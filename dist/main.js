/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/scripts/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeFunction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeFunction.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectWithoutProperties.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var objectWithoutPropertiesLoose = __webpack_require__(/*! ./objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__(/*! ./iterableToArray */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/wrapNativeSuper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeFunction = __webpack_require__(/*! ./isNativeFunction */ "./node_modules/@babel/runtime/helpers/isNativeFunction.js");

var construct = __webpack_require__(/*! ./construct */ "./node_modules/@babel/runtime/helpers/construct.js");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");

/***/ }),

/***/ "./node_modules/base-64/base64.js":
/*!****************************************!*\
  !*** ./node_modules/base-64/base64.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */
;

(function (root) {
  // Detect free variables `exports`.
  var freeExports =  true && exports; // Detect free variable `module`.

  var freeModule =  true && module && module.exports == freeExports && module; // Detect free variable `global`, from Node.js or Browserified code, and use
  // it as `root`.

  var freeGlobal = typeof global == 'object' && global;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
    root = freeGlobal;
  }
  /*--------------------------------------------------------------------------*/


  var InvalidCharacterError = function (message) {
    this.message = message;
  };

  InvalidCharacterError.prototype = new Error();
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  var error = function (message) {
    // Note: the error messages used throughout this file match those used by
    // the native `atob`/`btoa` implementation in Chromium.
    throw new InvalidCharacterError(message);
  };

  var TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; // http://whatwg.org/html/common-microsyntaxes.html#space-character

  var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g; // `decode` is designed to be fully compatible with `atob` as described in the
  // HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob
  // The optimized base64-decoding algorithm used is based on @atk’s excellent
  // implementation. https://gist.github.com/atk/1020396

  var decode = function (input) {
    input = String(input).replace(REGEX_SPACE_CHARACTERS, '');
    var length = input.length;

    if (length % 4 == 0) {
      input = input.replace(/==?$/, '');
      length = input.length;
    }

    if (length % 4 == 1 || // http://whatwg.org/C#alphanumeric-ascii-characters
    /[^+a-zA-Z0-9/]/.test(input)) {
      error('Invalid character: the string to be decoded is not correctly encoded.');
    }

    var bitCounter = 0;
    var bitStorage;
    var buffer;
    var output = '';
    var position = -1;

    while (++position < length) {
      buffer = TABLE.indexOf(input.charAt(position));
      bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer; // Unless this is the first of a group of 4 characters…

      if (bitCounter++ % 4) {
        // …convert the first 8 bits to a single ASCII character.
        output += String.fromCharCode(0xFF & bitStorage >> (-2 * bitCounter & 6));
      }
    }

    return output;
  }; // `encode` is designed to be fully compatible with `btoa` as described in the
  // HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa


  var encode = function (input) {
    input = String(input);

    if (/[^\0-\xFF]/.test(input)) {
      // Note: no need to special-case astral symbols here, as surrogates are
      // matched, and the input is supposed to only contain ASCII anyway.
      error('The string to be encoded contains characters outside of the ' + 'Latin1 range.');
    }

    var padding = input.length % 3;
    var output = '';
    var position = -1;
    var a;
    var b;
    var c;
    var d;
    var buffer; // Make sure any padding is handled outside of the loop.

    var length = input.length - padding;

    while (++position < length) {
      // Read three bytes, i.e. 24 bits.
      a = input.charCodeAt(position) << 16;
      b = input.charCodeAt(++position) << 8;
      c = input.charCodeAt(++position);
      buffer = a + b + c; // Turn the 24 bits into four chunks of 6 bits each, and append the
      // matching character for each of them to the output.

      output += TABLE.charAt(buffer >> 18 & 0x3F) + TABLE.charAt(buffer >> 12 & 0x3F) + TABLE.charAt(buffer >> 6 & 0x3F) + TABLE.charAt(buffer & 0x3F);
    }

    if (padding == 2) {
      a = input.charCodeAt(position) << 8;
      b = input.charCodeAt(++position);
      buffer = a + b;
      output += TABLE.charAt(buffer >> 10) + TABLE.charAt(buffer >> 4 & 0x3F) + TABLE.charAt(buffer << 2 & 0x3F) + '=';
    } else if (padding == 1) {
      buffer = input.charCodeAt(position);
      output += TABLE.charAt(buffer >> 2) + TABLE.charAt(buffer << 4 & 0x3F) + '==';
    }

    return output;
  };

  var base64 = {
    'encode': encode,
    'decode': decode,
    'version': '0.1.0'
  }; // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return base64;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var key; }
})(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");

var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");

var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function () {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/clone/clone.js":
/*!*************************************!*\
  !*** ./node_modules/clone/clone.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var clone = function () {
  'use strict';

  function _instanceof(obj, type) {
    return type != null && obj instanceof type;
  }

  var nativeMap;

  try {
    nativeMap = Map;
  } catch (_) {
    // maybe a reference error because no `Map`. Give it a dummy value that no
    // value will ever be an instanceof.
    nativeMap = function () {};
  }

  var nativeSet;

  try {
    nativeSet = Set;
  } catch (_) {
    nativeSet = function () {};
  }

  var nativePromise;

  try {
    nativePromise = Promise;
  } catch (_) {
    nativePromise = function () {};
  }
  /**
   * Clones (copies) an Object using deep copying.
   *
   * This function supports circular references by default, but if you are certain
   * there are no circular references in your object, you can save some CPU time
   * by calling clone(obj, false).
   *
   * Caution: if `circular` is false and `parent` contains circular references,
   * your program may enter an infinite loop and crash.
   *
   * @param `parent` - the object to be cloned
   * @param `circular` - set to true if the object to be cloned may contain
   *    circular references. (optional - true by default)
   * @param `depth` - set to a number if the object is only to be cloned to
   *    a particular depth. (optional - defaults to Infinity)
   * @param `prototype` - sets the prototype to be used when cloning an object.
   *    (optional - defaults to parent prototype).
   * @param `includeNonEnumerable` - set to true if the non-enumerable properties
   *    should be cloned as well. Non-enumerable properties on the prototype
   *    chain will be ignored. (optional - false by default)
  */


  function clone(parent, circular, depth, prototype, includeNonEnumerable) {
    if (typeof circular === 'object') {
      depth = circular.depth;
      prototype = circular.prototype;
      includeNonEnumerable = circular.includeNonEnumerable;
      circular = circular.circular;
    } // maintain two arrays for circular references, where corresponding parents
    // and children have the same index


    var allParents = [];
    var allChildren = [];
    var useBuffer = typeof Buffer != 'undefined';
    if (typeof circular == 'undefined') circular = true;
    if (typeof depth == 'undefined') depth = Infinity; // recurse this function so we don't reset allParents and allChildren

    function _clone(parent, depth) {
      // cloning null always returns null
      if (parent === null) return null;
      if (depth === 0) return parent;
      var child;
      var proto;

      if (typeof parent != 'object') {
        return parent;
      }

      if (_instanceof(parent, nativeMap)) {
        child = new nativeMap();
      } else if (_instanceof(parent, nativeSet)) {
        child = new nativeSet();
      } else if (_instanceof(parent, nativePromise)) {
        child = new nativePromise(function (resolve, reject) {
          parent.then(function (value) {
            resolve(_clone(value, depth - 1));
          }, function (err) {
            reject(_clone(err, depth - 1));
          });
        });
      } else if (clone.__isArray(parent)) {
        child = [];
      } else if (clone.__isRegExp(parent)) {
        child = new RegExp(parent.source, __getRegExpFlags(parent));
        if (parent.lastIndex) child.lastIndex = parent.lastIndex;
      } else if (clone.__isDate(parent)) {
        child = new Date(parent.getTime());
      } else if (useBuffer && Buffer.isBuffer(parent)) {
        child = new Buffer(parent.length);
        parent.copy(child);
        return child;
      } else if (_instanceof(parent, Error)) {
        child = Object.create(parent);
      } else {
        if (typeof prototype == 'undefined') {
          proto = Object.getPrototypeOf(parent);
          child = Object.create(proto);
        } else {
          child = Object.create(prototype);
          proto = prototype;
        }
      }

      if (circular) {
        var index = allParents.indexOf(parent);

        if (index != -1) {
          return allChildren[index];
        }

        allParents.push(parent);
        allChildren.push(child);
      }

      if (_instanceof(parent, nativeMap)) {
        parent.forEach(function (value, key) {
          var keyChild = _clone(key, depth - 1);

          var valueChild = _clone(value, depth - 1);

          child.set(keyChild, valueChild);
        });
      }

      if (_instanceof(parent, nativeSet)) {
        parent.forEach(function (value) {
          var entryChild = _clone(value, depth - 1);

          child.add(entryChild);
        });
      }

      for (var i in parent) {
        var attrs;

        if (proto) {
          attrs = Object.getOwnPropertyDescriptor(proto, i);
        }

        if (attrs && attrs.set == null) {
          continue;
        }

        child[i] = _clone(parent[i], depth - 1);
      }

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(parent);

        for (var i = 0; i < symbols.length; i++) {
          // Don't need to worry about cloning a symbol because it is a primitive,
          // like a number or string.
          var symbol = symbols[i];
          var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);

          if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
            continue;
          }

          child[symbol] = _clone(parent[symbol], depth - 1);

          if (!descriptor.enumerable) {
            Object.defineProperty(child, symbol, {
              enumerable: false
            });
          }
        }
      }

      if (includeNonEnumerable) {
        var allPropertyNames = Object.getOwnPropertyNames(parent);

        for (var i = 0; i < allPropertyNames.length; i++) {
          var propertyName = allPropertyNames[i];
          var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);

          if (descriptor && descriptor.enumerable) {
            continue;
          }

          child[propertyName] = _clone(parent[propertyName], depth - 1);
          Object.defineProperty(child, propertyName, {
            enumerable: false
          });
        }
      }

      return child;
    }

    return _clone(parent, depth);
  }
  /**
   * Simple flat clone using prototype, accepts only objects, usefull for property
   * override on FLAT configuration object (no nested props).
   *
   * USE WITH CAUTION! This may not behave as you wish if you do not know how this
   * works.
   */


  clone.clonePrototype = function clonePrototype(parent) {
    if (parent === null) return null;

    var c = function () {};

    c.prototype = parent;
    return new c();
  }; // private utility functions


  function __objToStr(o) {
    return Object.prototype.toString.call(o);
  }

  clone.__objToStr = __objToStr;

  function __isDate(o) {
    return typeof o === 'object' && __objToStr(o) === '[object Date]';
  }

  clone.__isDate = __isDate;

  function __isArray(o) {
    return typeof o === 'object' && __objToStr(o) === '[object Array]';
  }

  clone.__isArray = __isArray;

  function __isRegExp(o) {
    return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
  }

  clone.__isRegExp = __isRegExp;

  function __getRegExpFlags(re) {
    var flags = '';
    if (re.global) flags += 'g';
    if (re.ignoreCase) flags += 'i';
    if (re.multiline) flags += 'm';
    return flags;
  }

  clone.__getRegExpFlags = __getRegExpFlags;
  return clone;
}();

if ( true && module.exports) {
  module.exports = clone;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ "./node_modules/jsan/index.js":
/*!************************************!*\
  !*** ./node_modules/jsan/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib */ "./node_modules/jsan/lib/index.js");

/***/ }),

/***/ "./node_modules/jsan/lib/cycle.js":
/*!****************************************!*\
  !*** ./node_modules/jsan/lib/cycle.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pathGetter = __webpack_require__(/*! ./path-getter */ "./node_modules/jsan/lib/path-getter.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/jsan/lib/utils.js");

var WMap = typeof WeakMap !== 'undefined' ? WeakMap : function () {
  var keys = [];
  var values = [];
  return {
    set: function (key, value) {
      keys.push(key);
      values.push(value);
    },
    get: function (key) {
      for (var i = 0; i < keys.length; i++) {
        if (keys[i] === key) {
          return values[i];
        }
      }
    }
  };
}; // Based on https://github.com/douglascrockford/JSON-js/blob/master/cycle.js

exports.decycle = function decycle(object, options, replacer) {
  'use strict';

  var map = new WMap();
  var noCircularOption = !Object.prototype.hasOwnProperty.call(options, 'circular');
  var withRefs = options.refs !== false;
  return function derez(_value, path, key) {
    // The derez recurses through the object, producing the deep copy.
    var i, // The loop counter
    name, // Property name
    nu; // The new object or array
    // typeof null === 'object', so go on if this value is really an object but not
    // one of the weird builtin objects.

    var value = typeof replacer === 'function' ? replacer(key || '', _value) : _value;

    if (options.date && value instanceof Date) {
      return {
        $jsan: 'd' + value.getTime()
      };
    }

    if (options.regex && value instanceof RegExp) {
      return {
        $jsan: 'r' + utils.getRegexFlags(value) + ',' + value.source
      };
    }

    if (options['function'] && typeof value === 'function') {
      return {
        $jsan: 'f' + utils.stringifyFunction(value, options['function'])
      };
    }

    if (options['nan'] && typeof value === 'number' && isNaN(value)) {
      return {
        $jsan: 'n'
      };
    }

    if (options['infinity']) {
      if (Number.POSITIVE_INFINITY === value) return {
        $jsan: 'i'
      };
      if (Number.NEGATIVE_INFINITY === value) return {
        $jsan: 'y'
      };
    }

    if (options['undefined'] && value === undefined) {
      return {
        $jsan: 'u'
      };
    }

    if (options['error'] && value instanceof Error) {
      return {
        $jsan: 'e' + value.message
      };
    }

    if (options['symbol'] && typeof value === 'symbol') {
      var symbolKey = Symbol.keyFor(value);

      if (symbolKey !== undefined) {
        return {
          $jsan: 'g' + symbolKey
        };
      } // 'Symbol(foo)'.slice(7, -1) === 'foo'


      return {
        $jsan: 's' + value.toString().slice(7, -1)
      };
    }

    if (options['map'] && typeof Map === 'function' && value instanceof Map && typeof Array.from === 'function') {
      return {
        $jsan: 'm' + JSON.stringify(decycle(Array.from(value), options, replacer))
      };
    }

    if (options['set'] && typeof Set === 'function' && value instanceof Set && typeof Array.from === 'function') {
      return {
        $jsan: 'l' + JSON.stringify(decycle(Array.from(value), options, replacer))
      };
    }

    if (value && typeof value.toJSON === 'function') {
      try {
        value = value.toJSON(key);
      } catch (error) {
        var keyString = key || '$';
        return "toJSON failed for '" + (map.get(value) || keyString) + "'";
      }
    }

    if (typeof value === 'object' && value !== null && !(value instanceof Boolean) && !(value instanceof Date) && !(value instanceof Number) && !(value instanceof RegExp) && !(value instanceof String) && !(typeof value === 'symbol') && !(value instanceof Error)) {
      // If the value is an object or array, look to see if we have already
      // encountered it. If so, return a $ref/path object.
      if (typeof value === 'object') {
        var foundPath = map.get(value);

        if (foundPath) {
          if (noCircularOption && withRefs) {
            return {
              $jsan: foundPath
            };
          }

          if (path.indexOf(foundPath) === 0) {
            if (!noCircularOption) {
              return typeof options.circular === 'function' ? options.circular(value, path, foundPath) : options.circular;
            }

            return {
              $jsan: foundPath
            };
          }

          if (withRefs) return {
            $jsan: foundPath
          };
        }

        map.set(value, path);
      } // If it is an array, replicate the array.


      if (Object.prototype.toString.apply(value) === '[object Array]') {
        nu = [];

        for (i = 0; i < value.length; i += 1) {
          nu[i] = derez(value[i], path + '[' + i + ']', i);
        }
      } else {
        // If it is an object, replicate the object.
        nu = {};

        for (name in value) {
          if (Object.prototype.hasOwnProperty.call(value, name)) {
            var nextPath = /^\w+$/.test(name) ? '.' + name : '[' + JSON.stringify(name) + ']';
            nu[name] = name === '$jsan' ? [derez(value[name], path + nextPath)] : derez(value[name], path + nextPath, name);
          }
        }
      }

      return nu;
    }

    return value;
  }(object, '$');
};

exports.retrocycle = function retrocycle($) {
  'use strict';

  return function rez(value) {
    // The rez function walks recursively through the object looking for $jsan
    // properties. When it finds one that has a value that is a path, then it
    // replaces the $jsan object with a reference to the value that is found by
    // the path.
    var i, item, name, path;

    if (value && typeof value === 'object') {
      if (Object.prototype.toString.apply(value) === '[object Array]') {
        for (i = 0; i < value.length; i += 1) {
          item = value[i];

          if (item && typeof item === 'object') {
            if (item.$jsan) {
              value[i] = utils.restore(item.$jsan, $);
            } else {
              rez(item);
            }
          }
        }
      } else {
        for (name in value) {
          // base case passed raw object
          if (typeof value[name] === 'string' && name === '$jsan') {
            return utils.restore(value.$jsan, $);
            break;
          } else {
            if (name === '$jsan') {
              value[name] = value[name][0];
            }

            if (typeof value[name] === 'object') {
              item = value[name];

              if (item && typeof item === 'object') {
                if (item.$jsan) {
                  value[name] = utils.restore(item.$jsan, $);
                } else {
                  rez(item);
                }
              }
            }
          }
        }
      }
    }

    return value;
  }($);
};

/***/ }),

/***/ "./node_modules/jsan/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/jsan/lib/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cycle = __webpack_require__(/*! ./cycle */ "./node_modules/jsan/lib/cycle.js");

exports.stringify = function stringify(value, replacer, space, _options) {
  if (arguments.length < 4) {
    try {
      if (arguments.length === 1) {
        return JSON.stringify(value);
      } else {
        return JSON.stringify.apply(JSON, arguments);
      }
    } catch (e) {}
  }

  var options = _options || false;

  if (typeof options === 'boolean') {
    options = {
      'date': options,
      'function': options,
      'regex': options,
      'undefined': options,
      'error': options,
      'symbol': options,
      'map': options,
      'set': options,
      'nan': options,
      'infinity': options
    };
  }

  var decycled = cycle.decycle(value, options, replacer);

  if (arguments.length === 1) {
    return JSON.stringify(decycled);
  } else {
    // decycle already handles when replacer is a function.
    return JSON.stringify(decycled, Array.isArray(replacer) ? replacer : null, space);
  }
};

exports.parse = function parse(text, reviver) {
  var needsRetrocycle = /"\$jsan"/.test(text);
  var parsed;

  if (arguments.length === 1) {
    parsed = JSON.parse(text);
  } else {
    parsed = JSON.parse(text, reviver);
  }

  if (needsRetrocycle) {
    parsed = cycle.retrocycle(parsed);
  }

  return parsed;
};

/***/ }),

/***/ "./node_modules/jsan/lib/path-getter.js":
/*!**********************************************!*\
  !*** ./node_modules/jsan/lib/path-getter.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = pathGetter;

function pathGetter(obj, path) {
  if (path !== '$') {
    var paths = getPaths(path);

    for (var i = 0; i < paths.length; i++) {
      path = paths[i].toString().replace(/\\"/g, '"');
      if (typeof obj[path] === 'undefined' && i !== paths.length - 1) continue;
      obj = obj[path];
    }
  }

  return obj;
}

function getPaths(pathString) {
  var regex = /(?:\.(\w+))|(?:\[(\d+)\])|(?:\["((?:[^\\"]|\\.)*)"\])/g;
  var matches = [];
  var match;

  while (match = regex.exec(pathString)) {
    matches.push(match[1] || match[2] || match[3]);
  }

  return matches;
}

/***/ }),

/***/ "./node_modules/jsan/lib/utils.js":
/*!****************************************!*\
  !*** ./node_modules/jsan/lib/utils.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pathGetter = __webpack_require__(/*! ./path-getter */ "./node_modules/jsan/lib/path-getter.js");

var jsan = __webpack_require__(/*! ./ */ "./node_modules/jsan/lib/index.js");

exports.getRegexFlags = function getRegexFlags(regex) {
  var flags = '';
  if (regex.ignoreCase) flags += 'i';
  if (regex.global) flags += 'g';
  if (regex.multiline) flags += 'm';
  return flags;
};

exports.stringifyFunction = function stringifyFunction(fn, customToString) {
  if (typeof customToString === 'function') {
    return customToString(fn);
  }

  var str = fn.toString();
  var match = str.match(/^[^{]*{|^[^=]*=>/);
  var start = match ? match[0] : '<function> ';
  var end = str[str.length - 1] === '}' ? '}' : '';
  return start.replace(/\r\n|\n/g, ' ').replace(/\s+/g, ' ') + ' /* ... */ ' + end;
};

exports.restore = function restore(obj, root) {
  var type = obj[0];
  var rest = obj.slice(1);

  switch (type) {
    case '$':
      return pathGetter(root, obj);

    case 'r':
      var comma = rest.indexOf(',');
      var flags = rest.slice(0, comma);
      var source = rest.slice(comma + 1);
      return RegExp(source, flags);

    case 'd':
      return new Date(+rest);

    case 'f':
      var fn = function () {
        throw new Error("can't run jsan parsed function");
      };

      fn.toString = function () {
        return rest;
      };

      return fn;

    case 'u':
      return undefined;

    case 'e':
      var error = new Error(rest);
      error.stack = 'Stack is unavailable for jsan parsed errors';
      return error;

    case 's':
      return Symbol(rest);

    case 'g':
      return Symbol.for(rest);

    case 'm':
      return new Map(jsan.parse(rest));

    case 'l':
      return new Set(jsan.parse(rest));

    case 'n':
      return NaN;

    case 'i':
      return Infinity;

    case 'y':
      return -Infinity;

    default:
      console.warn('unknown type', obj);
      return obj;
  }
};

/***/ }),

/***/ "./node_modules/linked-list/_source/linked-list.js":
/*!*********************************************************!*\
  !*** ./node_modules/linked-list/_source/linked-list.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Constants.
 */

var errorMessage;
errorMessage = 'An argument without append, prepend, ' + 'or detach methods was given to `List';
/**
 * Creates a new List: A linked list is a bit like an Array, but
 * knows nothing about how many items are in it, and knows only about its
 * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,
 * &c.) knows which item comes before or after it (its more like the
 * implementation of the DOM in JavaScript).
 * @global
 * @private
 * @constructor
 * @class Represents an instance of List.
 */

function List()
/*items...*/
{
  if (arguments.length) {
    return List.from(arguments);
  }
}

var ListPrototype;
ListPrototype = List.prototype;
/**
 * Creates a new list from the arguments (each a list item) passed in.
 * @name List.of
 * @param {...ListItem} [items] - Zero or more items to attach.
 * @returns {list} - A new instance of List.
 */

List.of = function ()
/*items...*/
{
  return List.from.call(this, arguments);
};
/**
 * Creates a new list from the given array-like object (each a list item)
 * passed in.
 * @name List.from
 * @param {ListItem[]} [items] - The items to append.
 * @returns {list} - A new instance of List.
 */


List.from = function (items) {
  var list = new this(),
      length,
      iterator,
      item;

  if (items && (length = items.length)) {
    iterator = -1;

    while (++iterator < length) {
      item = items[iterator];

      if (item !== null && item !== undefined) {
        list.append(item);
      }
    }
  }

  return list;
};
/**
 * List#head
 * Default to `null`.
 */


ListPrototype.head = null;
/**
 * List#tail
 * Default to `null`.
 */

ListPrototype.tail = null;
/**
 * Returns the list's items as an array. This does *not* detach the items.
 * @name List#toArray
 * @returns {ListItem[]} - An array of (still attached) ListItems.
 */

ListPrototype.toArray = function () {
  var item = this.head,
      result = [];

  while (item) {
    result.push(item);
    item = item.next;
  }

  return result;
};
/**
 * Prepends the given item to the list: Item will be the new first item
 * (`head`).
 * @name List#prepend
 * @param {ListItem} item - The item to prepend.
 * @returns {ListItem} - An instance of ListItem (the given item).
 */


ListPrototype.prepend = function (item) {
  if (!item) {
    return false;
  }

  if (!item.append || !item.prepend || !item.detach) {
    throw new Error(errorMessage + '#prepend`.');
  }

  var self, head; // Cache self.

  self = this; // If self has a first item, defer prepend to the first items prepend
  // method, and return the result.

  head = self.head;

  if (head) {
    return head.prepend(item);
  } // ...otherwise, there is no `head` (or `tail`) item yet.
  // Detach the prependee.


  item.detach(); // Set the prependees parent list to reference self.

  item.list = self; // Set self's first item to the prependee, and return the item.

  self.head = item;
  return item;
};
/**
 * Appends the given item to the list: Item will be the new last item (`tail`)
 * if the list had a first item, and its first item (`head`) otherwise.
 * @name List#append
 * @param {ListItem} item - The item to append.
 * @returns {ListItem} - An instance of ListItem (the given item).
 */


ListPrototype.append = function (item) {
  if (!item) {
    return false;
  }

  if (!item.append || !item.prepend || !item.detach) {
    throw new Error(errorMessage + '#append`.');
  }

  var self, head, tail; // Cache self.

  self = this; // If self has a last item, defer appending to the last items append
  // method, and return the result.

  tail = self.tail;

  if (tail) {
    return tail.append(item);
  } // If self has a first item, defer appending to the first items append
  // method, and return the result.


  head = self.head;

  if (head) {
    return head.append(item);
  } // ...otherwise, there is no `tail` or `head` item yet.
  // Detach the appendee.


  item.detach(); // Set the appendees parent list to reference self.

  item.list = self; // Set self's first item to the appendee, and return the item.

  self.head = item;
  return item;
};
/**
 * Creates a new ListItem: A linked list item is a bit like DOM node:
 * It knows only about its "parent" (`list`), the item before it (`prev`),
 * and the item after it (`next`).
 * @global
 * @private
 * @constructor
 * @class Represents an instance of ListItem.
 */


function ListItem() {}

List.Item = ListItem;
var ListItemPrototype = ListItem.prototype;
ListItemPrototype.next = null;
ListItemPrototype.prev = null;
ListItemPrototype.list = null;
/**
 * Detaches the item operated on from its parent list.
 * @name ListItem#detach
 * @returns {ListItem} - The item operated on.
 */

ListItemPrototype.detach = function () {
  // Cache self, the parent list, and the previous and next items.
  var self = this,
      list = self.list,
      prev = self.prev,
      next = self.next; // If the item is already detached, return self.

  if (!list) {
    return self;
  } // If self is the last item in the parent list, link the lists last item
  // to the previous item.


  if (list.tail === self) {
    list.tail = prev;
  } // If self is the first item in the parent list, link the lists first item
  // to the next item.


  if (list.head === self) {
    list.head = next;
  } // If both the last and first items in the parent list are the same,
  // remove the link to the last item.


  if (list.tail === list.head) {
    list.tail = null;
  } // If a previous item exists, link its next item to selfs next item.


  if (prev) {
    prev.next = next;
  } // If a next item exists, link its previous item to selfs previous item.


  if (next) {
    next.prev = prev;
  } // Remove links from self to both the next and previous items, and to the
  // parent list.


  self.prev = self.next = self.list = null; // Return self.

  return self;
};
/**
 * Prepends the given item *before* the item operated on.
 * @name ListItem#prepend
 * @param {ListItem} item - The item to prepend.
 * @returns {ListItem} - The item operated on, or false when that item is not
 * attached.
 */


ListItemPrototype.prepend = function (item) {
  if (!item || !item.append || !item.prepend || !item.detach) {
    throw new Error(errorMessage + 'Item#prepend`.');
  } // Cache self, the parent list, and the previous item.


  var self = this,
      list = self.list,
      prev = self.prev; // If self is detached, return false.

  if (!list) {
    return false;
  } // Detach the prependee.


  item.detach(); // If self has a previous item...

  if (prev) {
    // ...link the prependees previous item, to selfs previous item.
    item.prev = prev; // ...link the previous items next item, to self.

    prev.next = item;
  } // Set the prependees next item to self.


  item.next = self; // Set the prependees parent list to selfs parent list.

  item.list = list; // Set the previous item of self to the prependee.

  self.prev = item; // If self is the first item in the parent list, link the lists first item
  // to the prependee.

  if (self === list.head) {
    list.head = item;
  } // If the the parent list has no last item, link the lists last item to
  // self.


  if (!list.tail) {
    list.tail = self;
  } // Return the prependee.


  return item;
};
/**
 * Appends the given item *after* the item operated on.
 * @name ListItem#append
 * @param {ListItem} item - The item to append.
 * @returns {ListItem} - The item operated on, or false when that item is not
 * attached.
 */


ListItemPrototype.append = function (item) {
  // If item is falsey, return false.
  if (!item || !item.append || !item.prepend || !item.detach) {
    throw new Error(errorMessage + 'Item#append`.');
  } // Cache self, the parent list, and the next item.


  var self = this,
      list = self.list,
      next = self.next; // If self is detached, return false.

  if (!list) {
    return false;
  } // Detach the appendee.


  item.detach(); // If self has a next item...

  if (next) {
    // ...link the appendees next item, to selfs next item.
    item.next = next; // ...link the next items previous item, to the appendee.

    next.prev = item;
  } // Set the appendees previous item to self.


  item.prev = self; // Set the appendees parent list to selfs parent list.

  item.list = list; // Set the next item of self to the appendee.

  self.next = item; // If the the parent list has no last item or if self is the parent lists
  // last item, link the lists last item to the appendee.

  if (self === list.tail || !list.tail) {
    list.tail = item;
  } // Return the appendee.


  return item;
};
/**
 * Expose `List`.
 */


module.exports = List;

/***/ }),

/***/ "./node_modules/linked-list/index.js":
/*!*******************************************!*\
  !*** ./node_modules/linked-list/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./_source/linked-list.js */ "./node_modules/linked-list/_source/linked-list.js");

/***/ }),

/***/ "./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js ***!
  \*********************************************************************/
/*! exports provided: addDisposer, addMiddleware, applyAction, applyPatch, applySnapshot, cast, castFlowReturn, castToReferenceSnapshot, castToSnapshot, clone, createActionTrackingMiddleware, createActionTrackingMiddleware2, decorate, destroy, detach, escapeJsonPath, flow, getChildType, getEnv, getIdentifier, getLivelinessChecking, getMembers, getNodeId, getParent, getParentOfType, getPath, getPathParts, getPropertyMembers, getRelativePath, getRoot, getRunningActionContext, getSnapshot, getType, hasParent, hasParentOfType, isActionContextChildOf, isActionContextThisOrChildOf, isAlive, isArrayType, isFrozenType, isIdentifierType, isLateType, isLiteralType, isMapType, isModelType, isOptionalType, isPrimitiveType, isProtected, isReferenceType, isRefinementType, isRoot, isStateTreeNode, isType, isUnionType, isValidReference, joinJsonPath, onAction, onPatch, onSnapshot, process, protect, recordActions, recordPatches, resolveIdentifier, resolvePath, setLivelinessChecking, setLivelynessChecking, splitJsonPath, toGenerator, toGeneratorFunction, tryReference, tryResolve, typecheck, types, unescapeJsonPath, unprotect, walk */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, setImmediate) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addDisposer", function() { return addDisposer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addMiddleware", function() { return addMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyAction", function() { return applyAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyPatch", function() { return applyPatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applySnapshot", function() { return applySnapshot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cast", function() { return cast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castFlowReturn", function() { return castFlowReturn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castToReferenceSnapshot", function() { return castToReferenceSnapshot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castToSnapshot", function() { return castToSnapshot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createActionTrackingMiddleware", function() { return createActionTrackingMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createActionTrackingMiddleware2", function() { return createActionTrackingMiddleware2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decorate", function() { return decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "destroy", function() { return destroy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "detach", function() { return detach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "escapeJsonPath", function() { return escapeJsonPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flow", function() { return flow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChildType", function() { return getChildType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnv", function() { return getEnv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIdentifier", function() { return getIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLivelinessChecking", function() { return getLivelinessChecking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMembers", function() { return getMembers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNodeId", function() { return getNodeId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParent", function() { return getParent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParentOfType", function() { return getParentOfType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPath", function() { return getPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPathParts", function() { return getPathParts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPropertyMembers", function() { return getPropertyMembers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRelativePath", function() { return getRelativePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRoot", function() { return getRoot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRunningActionContext", function() { return getRunningActionContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSnapshot", function() { return getSnapshot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getType", function() { return getType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasParent", function() { return hasParent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasParentOfType", function() { return hasParentOfType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isActionContextChildOf", function() { return isActionContextChildOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isActionContextThisOrChildOf", function() { return isActionContextThisOrChildOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAlive", function() { return isAlive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrayType", function() { return isArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFrozenType", function() { return isFrozenType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierType", function() { return isIdentifierType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLateType", function() { return isLateType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLiteralType", function() { return isLiteralType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMapType", function() { return isMapType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isModelType", function() { return isModelType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isOptionalType", function() { return isOptionalType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPrimitiveType", function() { return isPrimitiveType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isProtected", function() { return isProtected; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReferenceType", function() { return isReferenceType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isRefinementType", function() { return isRefinementType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isRoot", function() { return isRoot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isStateTreeNode", function() { return isStateTreeNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isType", function() { return isType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUnionType", function() { return isUnionType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidReference", function() { return isValidReference; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "joinJsonPath", function() { return joinJsonPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onAction", function() { return onAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onPatch", function() { return onPatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onSnapshot", function() { return onSnapshot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "process", function() { return process$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "protect", function() { return protect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recordActions", function() { return recordActions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recordPatches", function() { return recordPatches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveIdentifier", function() { return resolveIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return resolvePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLivelinessChecking", function() { return setLivelinessChecking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLivelynessChecking", function() { return setLivelynessChecking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitJsonPath", function() { return splitJsonPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toGenerator", function() { return toGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toGeneratorFunction", function() { return toGeneratorFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tryReference", function() { return tryReference; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tryResolve", function() { return tryResolve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typecheck", function() { return typecheck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "types", function() { return types; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unescapeJsonPath", function() { return unescapeJsonPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unprotect", function() { return unprotect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "walk", function() { return walk; });
/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mobx */ "./node_modules/mobx/dist/mobx.esm.js");

var livelinessChecking = "warn";
/**
 * Defines what MST should do when running into reads / writes to objects that have died.
 * By default it will print a warning.
 * Use the `"error"` option to easy debugging to see where the error was thrown and when the offending read / write took place
 *
 * @param mode `"warn"`, `"error"` or `"ignore"`
 */

function setLivelinessChecking(mode) {
  livelinessChecking = mode;
}
/**
 * Returns the current liveliness checking mode.
 *
 * @returns `"warn"`, `"error"` or `"ignore"`
 */


function getLivelinessChecking() {
  return livelinessChecking;
}
/**
 * @deprecated use setLivelinessChecking instead
 * @hidden
 *
 * Defines what MST should do when running into reads / writes to objects that have died.
 * By default it will print a warning.
 * Use the `"error"` option to easy debugging to see where the error was thrown and when the offending read / write took place
 *
 * @param mode `"warn"`, `"error"` or `"ignore"`
 */


function setLivelynessChecking(mode) {
  setLivelinessChecking(mode);
}
/**
 * @hidden
 */


var Hook;

(function (Hook) {
  Hook["afterCreate"] = "afterCreate";
  Hook["afterAttach"] = "afterAttach";
  Hook["afterCreationFinalization"] = "afterCreationFinalization";
  Hook["beforeDetach"] = "beforeDetach";
  Hook["beforeDestroy"] = "beforeDestroy";
})(Hook || (Hook = {}));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */


var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}

function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}
/**
 * Returns the _actual_ type of the given tree node. (Or throws)
 *
 * @param object
 * @returns
 */


function getType(object) {
  assertIsStateTreeNode(object, 1);
  return getStateTreeNode(object).type;
}
/**
 * Returns the _declared_ type of the given sub property of an object, array or map.
 * In the case of arrays and maps the property name is optional and will be ignored.
 *
 * Example:
 * ```ts
 * const Box = types.model({ x: 0, y: 0 })
 * const box = Box.create()
 *
 * console.log(getChildType(box, "x").name) // 'number'
 * ```
 *
 * @param object
 * @param propertyName
 * @returns
 */


function getChildType(object, propertyName) {
  assertIsStateTreeNode(object, 1);
  return getStateTreeNode(object).getChildType(propertyName);
}
/**
 * Registers a function that will be invoked for each mutation that is applied to the provided model instance, or to any of its children.
 * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details. onPatch events are emitted immediately and will not await the end of a transaction.
 * Patches can be used to deep observe a model tree.
 *
 * @param target the model instance from which to receive patches
 * @param callback the callback that is invoked for each patch. The reversePatch is a patch that would actually undo the emitted patch
 * @returns function to remove the listener
 */


function onPatch(target, callback) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  assertIsFunction(callback, 2);
  return getStateTreeNode(target).onPatch(callback);
}
/**
 * Registers a function that is invoked whenever a new snapshot for the given model instance is available.
 * The listener will only be fire at the end of the current MobX (trans)action.
 * See [snapshots](https://github.com/mobxjs/mobx-state-tree#snapshots) for more details.
 *
 * @param target
 * @param callback
 * @returns
 */


function onSnapshot(target, callback) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  assertIsFunction(callback, 2);
  return getStateTreeNode(target).onSnapshot(callback);
}
/**
 * Applies a JSON-patch to the given model instance or bails out if the patch couldn't be applied
 * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details.
 *
 * Can apply a single past, or an array of patches.
 *
 * @param target
 * @param patch
 * @returns
 */


function applyPatch(target, patch) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  assertArg(patch, function (p) {
    return typeof p === "object";
  }, "object or array", 2);
  getStateTreeNode(target).applyPatches(asArray(patch));
}
/**
 * Small abstraction around `onPatch` and `applyPatch`, attaches a patch listener to a tree and records all the patches.
 * Returns an recorder object with the following signature:
 *
 * Example:
 * ```ts
 * export interface IPatchRecorder {
 *      // the recorded patches
 *      patches: IJsonPatch[]
 *      // the inverse of the recorded patches
 *      inversePatches: IJsonPatch[]
 *      // true if currently recording
 *      recording: boolean
 *      // stop recording patches
 *      stop(): void
 *      // resume recording patches
 *      resume(): void
 *      // apply all the recorded patches on the given target (the original subject if omitted)
 *      replay(target?: IAnyStateTreeNode): void
 *      // reverse apply the recorded patches on the given target  (the original subject if omitted)
 *      // stops the recorder if not already stopped
 *      undo(): void
 * }
 * ```
 *
 * The optional filter function allows to skip recording certain patches.
 *
 * @param subject
 * @param filter
 * @returns
 */


function recordPatches(subject, filter) {
  // check all arguments
  assertIsStateTreeNode(subject, 1);
  var data = {
    patches: [],
    reversedInversePatches: []
  }; // we will generate the immutable copy of patches on demand for public consumption

  var publicData = {};
  var disposer;
  var recorder = {
    get recording() {
      return !!disposer;
    },

    get patches() {
      if (!publicData.patches) {
        publicData.patches = data.patches.slice();
      }

      return publicData.patches;
    },

    get reversedInversePatches() {
      if (!publicData.reversedInversePatches) {
        publicData.reversedInversePatches = data.reversedInversePatches.slice();
      }

      return publicData.reversedInversePatches;
    },

    get inversePatches() {
      if (!publicData.inversePatches) {
        publicData.inversePatches = data.reversedInversePatches.slice().reverse();
      }

      return publicData.inversePatches;
    },

    stop: function () {
      if (disposer) {
        disposer();
        disposer = undefined;
      }
    },
    resume: function () {
      if (disposer) return;
      disposer = onPatch(subject, function (patch, inversePatch) {
        // skip patches that are asked to be filtered if there's a filter in place
        if (filter && !filter(patch, inversePatch, getRunningActionContext())) {
          return;
        }

        data.patches.push(patch);
        data.reversedInversePatches.unshift(inversePatch); // mark immutable public patches as dirty

        publicData.patches = undefined;
        publicData.inversePatches = undefined;
        publicData.reversedInversePatches = undefined;
      });
    },
    replay: function (target) {
      applyPatch(target || subject, data.patches);
    },
    undo: function (target) {
      applyPatch(target || subject, data.reversedInversePatches);
    }
  };
  recorder.resume();
  return recorder;
}
/**
 * The inverse of `unprotect`.
 *
 * @param target
 */


function protect(target) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  var node = getStateTreeNode(target);
  if (!node.isRoot) throw fail$1("`protect` can only be invoked on root nodes");
  node.isProtectionEnabled = true;
}
/**
 * By default it is not allowed to directly modify a model. Models can only be modified through actions.
 * However, in some cases you don't care about the advantages (like replayability, traceability, etc) this yields.
 * For example because you are building a PoC or don't have any middleware attached to your tree.
 *
 * In that case you can disable this protection by calling `unprotect` on the root of your tree.
 *
 * Example:
 * ```ts
 * const Todo = types.model({
 *     done: false
 * }).actions(self => ({
 *     toggle() {
 *         self.done = !self.done
 *     }
 * }))
 *
 * const todo = Todo.create()
 * todo.done = true // throws!
 * todo.toggle() // OK
 * unprotect(todo)
 * todo.done = false // OK
 * ```
 */


function unprotect(target) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  var node = getStateTreeNode(target);
  if (!node.isRoot) throw fail$1("`unprotect` can only be invoked on root nodes");
  node.isProtectionEnabled = false;
}
/**
 * Returns true if the object is in protected mode, @see protect
 */


function isProtected(target) {
  return getStateTreeNode(target).isProtected;
}
/**
 * Applies a snapshot to a given model instances. Patch and snapshot listeners will be invoked as usual.
 *
 * @param target
 * @param snapshot
 * @returns
 */


function applySnapshot(target, snapshot) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  return getStateTreeNode(target).applySnapshot(snapshot);
}
/**
 * Calculates a snapshot from the given model instance. The snapshot will always reflect the latest state but use
 * structural sharing where possible. Doesn't require MobX transactions to be completed.
 *
 * @param target
 * @param applyPostProcess If true (the default) then postProcessSnapshot gets applied.
 * @returns
 */


function getSnapshot(target, applyPostProcess) {
  if (applyPostProcess === void 0) {
    applyPostProcess = true;
  } // check all arguments


  assertIsStateTreeNode(target, 1);
  var node = getStateTreeNode(target);
  if (applyPostProcess) return node.snapshot;
  return freeze(node.type.getSnapshot(node, false));
}
/**
 * Given a model instance, returns `true` if the object has a parent, that is, is part of another object, map or array.
 *
 * @param target
 * @param depth How far should we look upward? 1 by default.
 * @returns
 */


function hasParent(target, depth) {
  if (depth === void 0) {
    depth = 1;
  } // check all arguments


  assertIsStateTreeNode(target, 1);
  assertIsNumber(depth, 2, 0);
  var parent = getStateTreeNode(target).parent;

  while (parent) {
    if (--depth === 0) return true;
    parent = parent.parent;
  }

  return false;
}
/**
 * Returns the immediate parent of this object, or throws.
 *
 * Note that the immediate parent can be either an object, map or array, and
 * doesn't necessarily refer to the parent model.
 *
 * Please note that in child nodes access to the root is only possible
 * once the `afterAttach` hook has fired.
 *
 * @param target
 * @param depth How far should we look upward? 1 by default.
 * @returns
 */


function getParent(target, depth) {
  if (depth === void 0) {
    depth = 1;
  } // check all arguments


  assertIsStateTreeNode(target, 1);
  assertIsNumber(depth, 2, 0);
  var d = depth;
  var parent = getStateTreeNode(target).parent;

  while (parent) {
    if (--d === 0) return parent.storedValue;
    parent = parent.parent;
  }

  throw fail$1("Failed to find the parent of " + getStateTreeNode(target) + " at depth " + depth);
}
/**
 * Given a model instance, returns `true` if the object has a parent of given type, that is, is part of another object, map or array
 *
 * @param target
 * @param type
 * @returns
 */


function hasParentOfType(target, type) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  assertIsType(type, 2);
  var parent = getStateTreeNode(target).parent;

  while (parent) {
    if (type.is(parent.storedValue)) return true;
    parent = parent.parent;
  }

  return false;
}
/**
 * Returns the target's parent of a given type, or throws.
 *
 * @param target
 * @param type
 * @returns
 */


function getParentOfType(target, type) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  assertIsType(type, 2);
  var parent = getStateTreeNode(target).parent;

  while (parent) {
    if (type.is(parent.storedValue)) return parent.storedValue;
    parent = parent.parent;
  }

  throw fail$1("Failed to find the parent of " + getStateTreeNode(target) + " of a given type");
}
/**
 * Given an object in a model tree, returns the root object of that tree.
 *
 * Please note that in child nodes access to the root is only possible
 * once the `afterAttach` hook has fired.
 *
 * @param target
 * @returns
 */


function getRoot(target) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  return getStateTreeNode(target).root.storedValue;
}
/**
 * Returns the path of the given object in the model tree
 *
 * @param target
 * @returns
 */


function getPath(target) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  return getStateTreeNode(target).path;
}
/**
 * Returns the path of the given object as unescaped string array.
 *
 * @param target
 * @returns
 */


function getPathParts(target) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  return splitJsonPath(getStateTreeNode(target).path);
}
/**
 * Returns true if the given object is the root of a model tree.
 *
 * @param target
 * @returns
 */


function isRoot(target) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  return getStateTreeNode(target).isRoot;
}
/**
 * Resolves a path relatively to a given object.
 * Returns undefined if no value can be found.
 *
 * @param target
 * @param path escaped json path
 * @returns
 */


function resolvePath(target, path) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  assertIsString(path, 2);
  var node = resolveNodeByPath(getStateTreeNode(target), path);
  return node ? node.value : undefined;
}
/**
 * Resolves a model instance given a root target, the type and the identifier you are searching for.
 * Returns undefined if no value can be found.
 *
 * @param type
 * @param target
 * @param identifier
 * @returns
 */


function resolveIdentifier(type, target, identifier) {
  // check all arguments
  assertIsType(type, 1);
  assertIsStateTreeNode(target, 2);
  assertIsValidIdentifier(identifier, 3);
  var node = getStateTreeNode(target).root.identifierCache.resolve(type, normalizeIdentifier(identifier));
  return node ? node.value : undefined;
}
/**
 * Returns the identifier of the target node.
 * This is the *string normalized* identifier, which might not match the type of the identifier attribute
 *
 * @param target
 * @returns
 */


function getIdentifier(target) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  return getStateTreeNode(target).identifier;
}
/**
 * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns such reference if it the check passes,
 * else it returns undefined.
 *
 * @param getter Function to access the reference.
 * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.
 * @returns
 */


function tryReference(getter, checkIfAlive) {
  if (checkIfAlive === void 0) {
    checkIfAlive = true;
  }

  try {
    var node = getter();

    if (node === undefined || node === null) {
      return undefined;
    } else if (isStateTreeNode(node)) {
      if (!checkIfAlive) {
        return node;
      } else {
        return isAlive(node) ? node : undefined;
      }
    } else {
      throw fail$1("The reference to be checked is not one of node, null or undefined");
    }
  } catch (e) {
    if (e instanceof InvalidReferenceError) {
      return undefined;
    }

    throw e;
  }
}
/**
 * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns if the check passes or not.
 *
 * @param getter Function to access the reference.
 * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.
 * @returns
 */


function isValidReference(getter, checkIfAlive) {
  if (checkIfAlive === void 0) {
    checkIfAlive = true;
  }

  try {
    var node = getter();

    if (node === undefined || node === null) {
      return false;
    } else if (isStateTreeNode(node)) {
      return checkIfAlive ? isAlive(node) : true;
    } else {
      throw fail$1("The reference to be checked is not one of node, null or undefined");
    }
  } catch (e) {
    if (e instanceof InvalidReferenceError) {
      return false;
    }

    throw e;
  }
}
/**
 * Try to resolve a given path relative to a given node.
 *
 * @param target
 * @param path
 * @returns
 */


function tryResolve(target, path) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  assertIsString(path, 2);
  var node = resolveNodeByPath(getStateTreeNode(target), path, false);
  if (node === undefined) return undefined;

  try {
    return node.value;
  } catch (e) {
    // For what ever reason not resolvable (e.g. totally not existing path, or value that cannot be fetched)
    // see test / issue: 'try resolve doesn't work #686'
    return undefined;
  }
}
/**
 * Given two state tree nodes that are part of the same tree,
 * returns the shortest jsonpath needed to navigate from the one to the other
 *
 * @param base
 * @param target
 * @returns
 */


function getRelativePath(base, target) {
  // check all arguments
  assertIsStateTreeNode(base, 1);
  assertIsStateTreeNode(target, 2);
  return getRelativePathBetweenNodes(getStateTreeNode(base), getStateTreeNode(target));
}
/**
 * Returns a deep copy of the given state tree node as new tree.
 * Short hand for `snapshot(x) = getType(x).create(getSnapshot(x))`
 *
 * _Tip: clone will create a literal copy, including the same identifiers. To modify identifiers etc during cloning, don't use clone but take a snapshot of the tree, modify it, and create new instance_
 *
 * @param source
 * @param keepEnvironment indicates whether the clone should inherit the same environment (`true`, the default), or not have an environment (`false`). If an object is passed in as second argument, that will act as the environment for the cloned tree.
 * @returns
 */


function clone(source, keepEnvironment) {
  if (keepEnvironment === void 0) {
    keepEnvironment = true;
  } // check all arguments


  assertIsStateTreeNode(source, 1);
  var node = getStateTreeNode(source);
  return node.type.create(node.snapshot, keepEnvironment === true ? node.root.environment : keepEnvironment === false ? undefined : keepEnvironment); // it's an object or something else
}
/**
 * Removes a model element from the state tree, and let it live on as a new state tree
 */


function detach(target) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  getStateTreeNode(target).detach();
  return target;
}
/**
 * Removes a model element from the state tree, and mark it as end-of-life; the element should not be used anymore
 */


function destroy(target) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  var node = getStateTreeNode(target);
  if (node.isRoot) node.die();else node.parent.removeChild(node.subpath);
}
/**
 * Returns true if the given state tree node is not killed yet.
 * This means that the node is still a part of a tree, and that `destroy`
 * has not been called. If a node is not alive anymore, the only thing one can do with it
 * is requesting it's last path and snapshot
 *
 * @param target
 * @returns
 */


function isAlive(target) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  return getStateTreeNode(target).observableIsAlive;
}
/**
 * Use this utility to register a function that should be called whenever the
 * targeted state tree node is destroyed. This is a useful alternative to managing
 * cleanup methods yourself using the `beforeDestroy` hook.
 *
 * This methods returns the same disposer that was passed as argument.
 *
 * Example:
 * ```ts
 * const Todo = types.model({
 *   title: types.string
 * }).actions(self => ({
 *   afterCreate() {
 *     const autoSaveDisposer = reaction(
 *       () => getSnapshot(self),
 *       snapshot => sendSnapshotToServerSomehow(snapshot)
 *     )
 *     // stop sending updates to server if this
 *     // instance is destroyed
 *     addDisposer(self, autoSaveDisposer)
 *   }
 * }))
 * ```
 *
 * @param target
 * @param disposer
 * @returns The same disposer that was passed as argument
 */


function addDisposer(target, disposer) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  assertIsFunction(disposer, 2);
  var node = getStateTreeNode(target);
  node.addDisposer(disposer);
  return disposer;
}
/**
 * Returns the environment of the current state tree. For more info on environments,
 * see [Dependency injection](https://github.com/mobxjs/mobx-state-tree#dependency-injection)
 *
 * Please note that in child nodes access to the root is only possible
 * once the `afterAttach` hook has fired
 *
 * Returns an empty environment if the tree wasn't initialized with an environment
 *
 * @param target
 * @returns
 */


function getEnv(target) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  var node = getStateTreeNode(target);
  var env = node.root.environment;
  if (!env) return EMPTY_OBJECT;
  return env;
}
/**
 * Performs a depth first walk through a tree.
 */


function walk(target, processor) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  assertIsFunction(processor, 2);
  var node = getStateTreeNode(target); // tslint:disable-next-line:no_unused-variable

  node.getChildren().forEach(function (child) {
    if (isStateTreeNode(child.storedValue)) walk(child.storedValue, processor);
  });
  processor(node.storedValue);
}
/**
 * Returns a reflection of the model type properties and name for either a model type or model node.
 *
 * @param typeOrNode
 * @returns
 */


function getPropertyMembers(typeOrNode) {
  var type;

  if (isStateTreeNode(typeOrNode)) {
    type = getType(typeOrNode);
  } else {
    type = typeOrNode;
  }

  assertArg(type, function (t) {
    return isModelType(t);
  }, "model type or model instance", 1);
  return {
    name: type.name,
    properties: __assign({}, type.properties)
  };
}
/**
 * Returns a reflection of the model node, including name, properties, views, volatile and actions.
 *
 * @param target
 * @returns
 */


function getMembers(target) {
  var type = getStateTreeNode(target).type;

  var reflected = __assign(__assign({}, getPropertyMembers(type)), {
    actions: [],
    volatile: [],
    views: []
  });

  var props = Object.getOwnPropertyNames(target);
  props.forEach(function (key) {
    if (key in reflected.properties) return;
    var descriptor = Object.getOwnPropertyDescriptor(target, key);

    if (descriptor.get) {
      if (Object(mobx__WEBPACK_IMPORTED_MODULE_0__["isComputedProp"])(target, key)) reflected.views.push(key);else reflected.volatile.push(key);
      return;
    }

    if (descriptor.value._isMSTAction === true) reflected.actions.push(key);else if (Object(mobx__WEBPACK_IMPORTED_MODULE_0__["isObservableProp"])(target, key)) reflected.volatile.push(key);else reflected.views.push(key);
  });
  return reflected;
}
/**
 * Casts a node snapshot or instance type to an instance type so it can be assigned to a type instance.
 * Note that this is just a cast for the type system, this is, it won't actually convert a snapshot to an instance,
 * but just fool typescript into thinking so.
 * Either way, casting when outside an assignation operation won't compile.
 *
 * Example:
 * ```ts
 * const ModelA = types.model({
 *   n: types.number
 * }).actions(self => ({
 *   setN(aNumber: number) {
 *     self.n = aNumber
 *   }
 * }))
 *
 * const ModelB = types.model({
 *   innerModel: ModelA
 * }).actions(self => ({
 *   someAction() {
 *     // this will allow the compiler to assign a snapshot to the property
 *     self.innerModel = cast({ a: 5 })
 *   }
 * }))
 * ```
 *
 * @param snapshotOrInstance Snapshot or instance
 * @returns The same object casted as an instance
 */


function cast(snapshotOrInstance) {
  return snapshotOrInstance;
}
/**
 * Casts a node instance type to an snapshot type so it can be assigned to a type snapshot (e.g. to be used inside a create call).
 * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a snapshot,
 * but just fool typescript into thinking so.
 *
 * Example:
 * ```ts
 * const ModelA = types.model({
 *   n: types.number
 * }).actions(self => ({
 *   setN(aNumber: number) {
 *     self.n = aNumber
 *   }
 * }))
 *
 * const ModelB = types.model({
 *   innerModel: ModelA
 * })
 *
 * const a = ModelA.create({ n: 5 });
 * // this will allow the compiler to use a model as if it were a snapshot
 * const b = ModelB.create({ innerModel: castToSnapshot(a)})
 * ```
 *
 * @param snapshotOrInstance Snapshot or instance
 * @returns The same object casted as an input (creation) snapshot
 */


function castToSnapshot(snapshotOrInstance) {
  return snapshotOrInstance;
}
/**
 * Casts a node instance type to a reference snapshot type so it can be assigned to a refernence snapshot (e.g. to be used inside a create call).
 * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a refererence snapshot,
 * but just fool typescript into thinking so.
 *
 * Example:
 * ```ts
 * const ModelA = types.model({
 *   id: types.identifier,
 *   n: types.number
 * }).actions(self => ({
 *   setN(aNumber: number) {
 *     self.n = aNumber
 *   }
 * }))
 *
 * const ModelB = types.model({
 *   refA: types.reference(ModelA)
 * })
 *
 * const a = ModelA.create({ id: 'someId', n: 5 });
 * // this will allow the compiler to use a model as if it were a reference snapshot
 * const b = ModelB.create({ refA: castToReferenceSnapshot(a)})
 * ```
 *
 * @param instance Instance
 * @returns The same object casted as an reference snapshot (string or number)
 */


function castToReferenceSnapshot(instance) {
  return instance;
}
/**
 * Returns the unique node id (not to be confused with the instance identifier) for a
 * given instance.
 * This id is a number that is unique for each instance.
 *
 * @export
 * @param target
 * @returns
 */


function getNodeId(target) {
  assertIsStateTreeNode(target, 1);
  return getStateTreeNode(target).nodeId;
}
/**
 * @internal
 * @hidden
 */


var BaseNode =
/** @class */
function () {
  function BaseNode(type, parent, subpath, environment) {
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: type
    });
    Object.defineProperty(this, "environment", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: environment
    });
    Object.defineProperty(this, "_escapedSubpath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_subpath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_subpathUponDeath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_pathUponDeath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "storedValue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }); // usually the same type as the value, but not always (such as with references)

    Object.defineProperty(this, "aliveAtom", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_state", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: NodeLifeCycle.INITIALIZING
    });
    Object.defineProperty(this, "_hookSubscribers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_parent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "pathAtom", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.environment = environment;
    this.baseSetParent(parent, subpath);
  }

  Object.defineProperty(BaseNode.prototype, "subpath", {
    get: function () {
      return this._subpath;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseNode.prototype, "subpathUponDeath", {
    get: function () {
      return this._subpathUponDeath;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseNode.prototype, "pathUponDeath", {
    get: function () {
      return this._pathUponDeath;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseNode.prototype, "value", {
    get: function () {
      return this.type.getValue(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseNode.prototype, "state", {
    get: function () {
      return this._state;
    },
    set: function (val) {
      var wasAlive = this.isAlive;
      this._state = val;
      var isAlive = this.isAlive;

      if (this.aliveAtom && wasAlive !== isAlive) {
        this.aliveAtom.reportChanged();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseNode.prototype, "fireInternalHook", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (name) {
      if (this._hookSubscribers) {
        this._hookSubscribers.emit(name, this, name);
      }
    }
  });
  Object.defineProperty(BaseNode.prototype, "registerHook", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (hook, hookHandler) {
      if (!this._hookSubscribers) {
        this._hookSubscribers = new EventHandlers();
      }

      return this._hookSubscribers.register(hook, hookHandler);
    }
  });
  Object.defineProperty(BaseNode.prototype, "parent", {
    get: function () {
      return this._parent;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseNode.prototype, "baseSetParent", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath) {
      this._parent = parent;
      this._subpath = subpath;
      this._escapedSubpath = undefined; // regenerate when needed

      if (this.pathAtom) {
        this.pathAtom.reportChanged();
      }
    }
  });
  Object.defineProperty(BaseNode.prototype, "path", {
    /*
     * Returns (escaped) path representation as string
     */
    get: function () {
      return this.getEscapedPath(true);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseNode.prototype, "getEscapedPath", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (reportObserved) {
      if (reportObserved) {
        if (!this.pathAtom) {
          this.pathAtom = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["createAtom"])("path");
        }

        this.pathAtom.reportObserved();
      }

      if (!this.parent) return ""; // regenerate escaped subpath if needed

      if (this._escapedSubpath === undefined) {
        this._escapedSubpath = !this._subpath ? "" : escapeJsonPath(this._subpath);
      }

      return this.parent.getEscapedPath(reportObserved) + "/" + this._escapedSubpath;
    }
  });
  Object.defineProperty(BaseNode.prototype, "isRoot", {
    get: function () {
      return this.parent === null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseNode.prototype, "isAlive", {
    get: function () {
      return this.state !== NodeLifeCycle.DEAD;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseNode.prototype, "isDetaching", {
    get: function () {
      return this.state === NodeLifeCycle.DETACHING;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseNode.prototype, "observableIsAlive", {
    get: function () {
      if (!this.aliveAtom) {
        this.aliveAtom = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["createAtom"])("alive");
      }

      this.aliveAtom.reportObserved();
      return this.isAlive;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseNode.prototype, "baseFinalizeCreation", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (whenFinalized) {
      if (devMode()) {
        if (!this.isAlive) {
          // istanbul ignore next
          throw fail("assertion failed: cannot finalize the creation of a node that is already dead");
        }
      } // goal: afterCreate hooks runs depth-first. After attach runs parent first, so on afterAttach the parent has completed already


      if (this.state === NodeLifeCycle.CREATED) {
        if (this.parent) {
          if (this.parent.state !== NodeLifeCycle.FINALIZED) {
            // parent not ready yet, postpone
            return;
          }

          this.fireHook(Hook.afterAttach);
        }

        this.state = NodeLifeCycle.FINALIZED;

        if (whenFinalized) {
          whenFinalized();
        }
      }
    }
  });
  Object.defineProperty(BaseNode.prototype, "baseFinalizeDeath", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      if (this._hookSubscribers) {
        this._hookSubscribers.clearAll();
      }

      this._subpathUponDeath = this._subpath;
      this._pathUponDeath = this.getEscapedPath(false);
      this.baseSetParent(null, "");
      this.state = NodeLifeCycle.DEAD;
    }
  });
  Object.defineProperty(BaseNode.prototype, "baseAboutToDie", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      this.fireHook(Hook.beforeDestroy);
    }
  });
  return BaseNode;
}();
/**
 * @internal
 * @hidden
 */


var ScalarNode =
/** @class */
function (_super) {
  __extends(ScalarNode, _super);

  function ScalarNode(simpleType, parent, subpath, environment, initialSnapshot) {
    var _this = _super.call(this, simpleType, parent, subpath, environment) || this;

    try {
      _this.storedValue = simpleType.createNewInstance(initialSnapshot);
    } catch (e) {
      // short-cut to die the instance, to avoid the snapshot computed starting to throw...
      _this.state = NodeLifeCycle.DEAD;
      throw e;
    }

    _this.state = NodeLifeCycle.CREATED; // for scalar nodes there's no point in firing this event since it would fire on the constructor, before
    // anybody can actually register for/listen to it
    // this.fireHook(Hook.AfterCreate)

    _this.finalizeCreation();

    return _this;
  }

  Object.defineProperty(ScalarNode.prototype, "root", {
    get: function () {
      // future optimization: store root ref in the node and maintain it
      if (!this.parent) throw fail$1("This scalar node is not part of a tree");
      return this.parent.root;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScalarNode.prototype, "setParent", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (newParent, subpath) {
      var parentChanged = this.parent !== newParent;
      var subpathChanged = this.subpath !== subpath;

      if (!parentChanged && !subpathChanged) {
        return;
      }

      if (devMode()) {
        if (!subpath) {
          // istanbul ignore next
          throw fail$1("assertion failed: subpath expected");
        }

        if (!newParent) {
          // istanbul ignore next
          throw fail$1("assertion failed: parent expected");
        }

        if (parentChanged) {
          // istanbul ignore next
          throw fail$1("assertion failed: scalar nodes cannot change their parent");
        }
      }

      this.environment = undefined; // use parent's

      this.baseSetParent(this.parent, subpath);
    }
  });
  Object.defineProperty(ScalarNode.prototype, "snapshot", {
    get: function () {
      return freeze(this.getSnapshot());
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ScalarNode.prototype, "getSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this.type.getSnapshot(this);
    }
  });
  Object.defineProperty(ScalarNode.prototype, "toString", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      var path = (this.isAlive ? this.path : this.pathUponDeath) || "<root>";
      return this.type.name + "@" + path + (this.isAlive ? "" : " [dead]");
    }
  });
  Object.defineProperty(ScalarNode.prototype, "die", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      if (!this.isAlive || this.state === NodeLifeCycle.DETACHING) return;
      this.aboutToDie();
      this.finalizeDeath();
    }
  });
  Object.defineProperty(ScalarNode.prototype, "finalizeCreation", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      this.baseFinalizeCreation();
    }
  });
  Object.defineProperty(ScalarNode.prototype, "aboutToDie", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      this.baseAboutToDie();
    }
  });
  Object.defineProperty(ScalarNode.prototype, "finalizeDeath", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      this.baseFinalizeDeath();
    }
  });
  Object.defineProperty(ScalarNode.prototype, "fireHook", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (name) {
      this.fireInternalHook(name);
    }
  });
  return ScalarNode;
}(BaseNode);

ScalarNode.prototype.die = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["action"])(ScalarNode.prototype.die);
var nextNodeId = 1;
var snapshotReactionOptions = {
  onError: function (e) {
    throw e;
  }
};
/**
 * @internal
 * @hidden
 */

var ObjectNode =
/** @class */
function (_super) {
  __extends(ObjectNode, _super);

  function ObjectNode(complexType, parent, subpath, environment, initialValue) {
    var _this = _super.call(this, complexType, parent, subpath, environment) || this;

    Object.defineProperty(_this, "nodeId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ++nextNodeId
    });
    Object.defineProperty(_this, "identifierAttribute", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "identifier", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }); // Identifier is always normalized to string, even if the identifier property isn't

    Object.defineProperty(_this, "unnormalizedIdentifier", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "identifierCache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "isProtectionEnabled", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(_this, "middlewares", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "_applyPatches", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "_applySnapshot", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "_autoUnbox", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    }); // unboxing is disabled when reading child nodes

    Object.defineProperty(_this, "_isRunningAction", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    }); // only relevant for root

    Object.defineProperty(_this, "_hasSnapshotReaction", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(_this, "_observableInstanceState", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
      /* UNINITIALIZED */

    });
    Object.defineProperty(_this, "_childNodes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "_initialSnapshot", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "_cachedInitialSnapshot", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "_cachedInitialSnapshotCreated", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(_this, "_snapshotComputed", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "_snapshotUponDeath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }); // #region internal event handling

    Object.defineProperty(_this, "_internalEvents", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    _this._snapshotComputed = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["computed"])(function () {
      return freeze(_this.getSnapshot());
    });
    _this.unbox = _this.unbox.bind(_this);
    _this._initialSnapshot = freeze(initialValue);
    _this.identifierAttribute = complexType.identifierAttribute;

    if (!parent) {
      _this.identifierCache = new IdentifierCache();
    }

    _this._childNodes = complexType.initializeChildNodes(_this, _this._initialSnapshot); // identifier can not be changed during lifecycle of a node
    // so we safely can read it from initial snapshot

    _this.identifier = null;
    _this.unnormalizedIdentifier = null;

    if (_this.identifierAttribute && _this._initialSnapshot) {
      var id = _this._initialSnapshot[_this.identifierAttribute];

      if (id === undefined) {
        // try with the actual node if not (for optional identifiers)
        var childNode = _this._childNodes[_this.identifierAttribute];

        if (childNode) {
          id = childNode.value;
        }
      }

      if (typeof id !== "string" && typeof id !== "number") {
        throw fail$1("Instance identifier '" + _this.identifierAttribute + "' for type '" + _this.type.name + "' must be a string or a number");
      } // normalize internal identifier to string


      _this.identifier = normalizeIdentifier(id);
      _this.unnormalizedIdentifier = id;
    }

    if (!parent) {
      _this.identifierCache.addNodeToCache(_this);
    } else {
      parent.root.identifierCache.addNodeToCache(_this);
    }

    return _this;
  }

  Object.defineProperty(ObjectNode.prototype, "applyPatches", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (patches) {
      this.createObservableInstanceIfNeeded();

      this._applyPatches(patches);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "applySnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (snapshot) {
      this.createObservableInstanceIfNeeded();

      this._applySnapshot(snapshot);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "createObservableInstanceIfNeeded", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      if (this._observableInstanceState === 0
      /* UNINITIALIZED */
      ) {
          this.createObservableInstance();
        }
    }
  });
  Object.defineProperty(ObjectNode.prototype, "createObservableInstance", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      var e_1, _a;

      if (devMode()) {
        if (this.state !== NodeLifeCycle.INITIALIZING) {
          // istanbul ignore next
          throw fail$1("assertion failed: the creation of the observable instance must be done on the initializing phase");
        }
      }

      this._observableInstanceState = 1
      /* CREATING */
      ; // make sure the parent chain is created as well
      // array with parent chain from parent to child

      var parentChain = [];
      var parent = this.parent; // for performance reasons we never go back further than the most direct
      // uninitialized parent
      // this is done to avoid traversing the whole tree to the root when using
      // the same reference again

      while (parent && parent._observableInstanceState === 0
      /* UNINITIALIZED */
      ) {
        parentChain.unshift(parent);
        parent = parent.parent;
      }

      try {
        // initialize the uninitialized parent chain from parent to child
        for (var parentChain_1 = __values(parentChain), parentChain_1_1 = parentChain_1.next(); !parentChain_1_1.done; parentChain_1_1 = parentChain_1.next()) {
          var p = parentChain_1_1.value;
          p.createObservableInstanceIfNeeded();
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (parentChain_1_1 && !parentChain_1_1.done && (_a = parentChain_1.return)) _a.call(parentChain_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }

      var type = this.type;

      try {
        this.storedValue = type.createNewInstance(this._childNodes);
        this.preboot();
        this._isRunningAction = true;
        type.finalizeNewInstance(this, this.storedValue);
      } catch (e) {
        // short-cut to die the instance, to avoid the snapshot computed starting to throw...
        this.state = NodeLifeCycle.DEAD;
        throw e;
      } finally {
        this._isRunningAction = false;
      }

      this._observableInstanceState = 2
      /* CREATED */
      ;

      this._snapshotComputed.trackAndCompute();

      if (this.isRoot) this._addSnapshotReaction();
      this._childNodes = EMPTY_OBJECT;
      this.state = NodeLifeCycle.CREATED;
      this.fireHook(Hook.afterCreate);
      this.finalizeCreation();
    }
  });
  Object.defineProperty(ObjectNode.prototype, "root", {
    get: function () {
      var parent = this.parent;
      return parent ? parent.root : this;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ObjectNode.prototype, "clearParent", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      if (!this.parent) return; // detach if attached

      this.fireHook(Hook.beforeDetach);
      var previousState = this.state;
      this.state = NodeLifeCycle.DETACHING;
      var root = this.root;
      var newEnv = root.environment;
      var newIdCache = root.identifierCache.splitCache(this);

      try {
        this.parent.removeChild(this.subpath);
        this.baseSetParent(null, "");
        this.environment = newEnv;
        this.identifierCache = newIdCache;
      } finally {
        this.state = previousState;
      }
    }
  });
  Object.defineProperty(ObjectNode.prototype, "setParent", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (newParent, subpath) {
      var parentChanged = newParent !== this.parent;
      var subpathChanged = subpath !== this.subpath;

      if (!parentChanged && !subpathChanged) {
        return;
      }

      if (devMode()) {
        if (!subpath) {
          // istanbul ignore next
          throw fail$1("assertion failed: subpath expected");
        }

        if (!newParent) {
          // istanbul ignore next
          throw fail$1("assertion failed: new parent expected");
        }

        if (this.parent && parentChanged) {
          throw fail$1("A node cannot exists twice in the state tree. Failed to add " + this + " to path '" + newParent.path + "/" + subpath + "'.");
        }

        if (!this.parent && newParent.root === this) {
          throw fail$1("A state tree is not allowed to contain itself. Cannot assign " + this + " to path '" + newParent.path + "/" + subpath + "'");
        }

        if (!this.parent && !!this.environment && this.environment !== newParent.root.environment) {
          throw fail$1("A state tree cannot be made part of another state tree as long as their environments are different.");
        }
      }

      if (parentChanged) {
        // attach to new parent
        this.environment = undefined; // will use root's

        newParent.root.identifierCache.mergeCache(this);
        this.baseSetParent(newParent, subpath);
        this.fireHook(Hook.afterAttach);
      } else if (subpathChanged) {
        // moving to a new subpath on the same parent
        this.baseSetParent(this.parent, subpath);
      }
    }
  });
  Object.defineProperty(ObjectNode.prototype, "fireHook", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (name) {
      var _this = this;

      this.fireInternalHook(name);
      var fn = this.storedValue && typeof this.storedValue === "object" && this.storedValue[name];

      if (typeof fn === "function") {
        // we check for it to allow old mobx peer dependencies that don't have the method to work (even when still bugged)
        if (mobx__WEBPACK_IMPORTED_MODULE_0__["_allowStateChangesInsideComputed"]) {
          Object(mobx__WEBPACK_IMPORTED_MODULE_0__["_allowStateChangesInsideComputed"])(function () {
            fn.apply(_this.storedValue);
          });
        } else {
          fn.apply(this.storedValue);
        }
      }
    }
  });
  Object.defineProperty(ObjectNode.prototype, "snapshot", {
    // advantage of using computed for a snapshot is that nicely respects transactions etc.
    get: function () {
      return this._snapshotComputed.get();
    },
    enumerable: false,
    configurable: true
  }); // NOTE: we use this method to get snapshot without creating @computed overhead

  Object.defineProperty(ObjectNode.prototype, "getSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      if (!this.isAlive) return this._snapshotUponDeath;
      return this._observableInstanceState === 2
      /* CREATED */
      ? this._getActualSnapshot() : this._getCachedInitialSnapshot();
    }
  });
  Object.defineProperty(ObjectNode.prototype, "_getActualSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this.type.getSnapshot(this);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "_getCachedInitialSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      if (!this._cachedInitialSnapshotCreated) {
        var type = this.type;
        var childNodes = this._childNodes;
        var snapshot = this._initialSnapshot;
        this._cachedInitialSnapshot = type.processInitialSnapshot(childNodes, snapshot);
        this._cachedInitialSnapshotCreated = true;
      }

      return this._cachedInitialSnapshot;
    }
  });
  Object.defineProperty(ObjectNode.prototype, "isRunningAction", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      if (this._isRunningAction) return true;
      if (this.isRoot) return false;
      return this.parent.isRunningAction();
    }
  });
  Object.defineProperty(ObjectNode.prototype, "assertAlive", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (context) {
      var livelinessChecking = getLivelinessChecking();

      if (!this.isAlive && livelinessChecking !== "ignore") {
        var error = this._getAssertAliveError(context);

        switch (livelinessChecking) {
          case "error":
            throw fail$1(error);

          case "warn":
            warnError(error);
        }
      }
    }
  });
  Object.defineProperty(ObjectNode.prototype, "_getAssertAliveError", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (context) {
      var escapedPath = this.getEscapedPath(false) || this.pathUponDeath || "";
      var subpath = context.subpath && escapeJsonPath(context.subpath) || "";
      var actionContext = context.actionContext || getCurrentActionContext(); // try to use a real action context if possible since it includes the action name

      if (actionContext && actionContext.type !== "action" && actionContext.parentActionEvent) {
        actionContext = actionContext.parentActionEvent;
      }

      var actionFullPath = "";

      if (actionContext && actionContext.name != null) {
        // try to use the context, and if it not available use the node one
        var actionPath = actionContext && actionContext.context && getPath(actionContext.context) || escapedPath;
        actionFullPath = actionPath + "." + actionContext.name + "()";
      }

      return "You are trying to read or write to an object that is no longer part of a state tree. (Object type: '" + this.type.name + "', Path upon death: '" + escapedPath + "', Subpath: '" + subpath + "', Action: '" + actionFullPath + "'). Either detach nodes first, or don't use objects after removing / replacing them in the tree.";
    }
  });
  Object.defineProperty(ObjectNode.prototype, "getChildNode", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (subpath) {
      this.assertAlive({
        subpath: subpath
      });
      this._autoUnbox = false;

      try {
        return this._observableInstanceState === 2
        /* CREATED */
        ? this.type.getChildNode(this, subpath) : this._childNodes[subpath];
      } finally {
        this._autoUnbox = true;
      }
    }
  });
  Object.defineProperty(ObjectNode.prototype, "getChildren", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      this.assertAlive(EMPTY_OBJECT);
      this._autoUnbox = false;

      try {
        return this._observableInstanceState === 2
        /* CREATED */
        ? this.type.getChildren(this) : convertChildNodesToArray(this._childNodes);
      } finally {
        this._autoUnbox = true;
      }
    }
  });
  Object.defineProperty(ObjectNode.prototype, "getChildType", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (propertyName) {
      return this.type.getChildType(propertyName);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "isProtected", {
    get: function () {
      return this.root.isProtectionEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ObjectNode.prototype, "assertWritable", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (context) {
      this.assertAlive(context);

      if (!this.isRunningAction() && this.isProtected) {
        throw fail$1("Cannot modify '" + this + "', the object is protected and can only be modified by using an action.");
      }
    }
  });
  Object.defineProperty(ObjectNode.prototype, "removeChild", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (subpath) {
      this.type.removeChild(this, subpath);
    }
  }); // bound on the constructor

  Object.defineProperty(ObjectNode.prototype, "unbox", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (childNode) {
      if (!childNode) return childNode;
      this.assertAlive({
        subpath: childNode.subpath || childNode.subpathUponDeath
      });
      return this._autoUnbox ? childNode.value : childNode;
    }
  });
  Object.defineProperty(ObjectNode.prototype, "toString", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      var path = (this.isAlive ? this.path : this.pathUponDeath) || "<root>";
      var identifier = this.identifier ? "(id: " + this.identifier + ")" : "";
      return this.type.name + "@" + path + identifier + (this.isAlive ? "" : " [dead]");
    }
  });
  Object.defineProperty(ObjectNode.prototype, "finalizeCreation", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      var _this = this;

      this.baseFinalizeCreation(function () {
        var e_2, _a;

        try {
          for (var _b = __values(_this.getChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            child.finalizeCreation();
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_2) throw e_2.error;
          }
        }

        _this.fireInternalHook(Hook.afterCreationFinalization);
      });
    }
  });
  Object.defineProperty(ObjectNode.prototype, "detach", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      if (!this.isAlive) throw fail$1("Error while detaching, node is not alive.");
      this.clearParent();
    }
  });
  Object.defineProperty(ObjectNode.prototype, "preboot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      var self = this;
      this._applyPatches = createActionInvoker(this.storedValue, "@APPLY_PATCHES", function (patches) {
        patches.forEach(function (patch) {
          if (!patch.path) {
            self.type.applySnapshot(self, patch.value);
            return;
          }

          var parts = splitJsonPath(patch.path);
          var node = resolveNodeByPathParts(self, parts.slice(0, -1));
          node.applyPatchLocally(parts[parts.length - 1], patch);
        });
      });
      this._applySnapshot = createActionInvoker(this.storedValue, "@APPLY_SNAPSHOT", function (snapshot) {
        // if the snapshot is the same as the current one, avoid performing a reconcile
        if (snapshot === self.snapshot) return; // else, apply it by calling the type logic

        return self.type.applySnapshot(self, snapshot);
      });
      addHiddenFinalProp(this.storedValue, "$treenode", this);
      addHiddenFinalProp(this.storedValue, "toJSON", toJSON);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "die", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      if (!this.isAlive || this.state === NodeLifeCycle.DETACHING) return;
      this.aboutToDie();
      this.finalizeDeath();
    }
  });
  Object.defineProperty(ObjectNode.prototype, "aboutToDie", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      if (this._observableInstanceState === 0
      /* UNINITIALIZED */
      ) {
          return;
        }

      this.getChildren().forEach(function (node) {
        node.aboutToDie();
      }); // beforeDestroy should run before the disposers since else we could end up in a situation where
      // a disposer added with addDisposer at this stage (beforeDestroy) is actually never released

      this.baseAboutToDie();

      this._internalEventsEmit("dispose"
      /* Dispose */
      );

      this._internalEventsClear("dispose"
      /* Dispose */
      );
    }
  });
  Object.defineProperty(ObjectNode.prototype, "finalizeDeath", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      // invariant: not called directly but from "die"
      this.getChildren().forEach(function (node) {
        node.finalizeDeath();
      });
      this.root.identifierCache.notifyDied(this); // "kill" the computed prop and just store the last snapshot

      var snapshot = this.snapshot;
      this._snapshotUponDeath = snapshot;

      this._internalEventsClearAll();

      this.baseFinalizeDeath();
    }
  });
  Object.defineProperty(ObjectNode.prototype, "onSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (onChange) {
      this._addSnapshotReaction();

      return this._internalEventsRegister("snapshot"
      /* Snapshot */
      , onChange);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "emitSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (snapshot) {
      this._internalEventsEmit("snapshot"
      /* Snapshot */
      , snapshot);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "onPatch", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (handler) {
      return this._internalEventsRegister("patch"
      /* Patch */
      , handler);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "emitPatch", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (basePatch, source) {
      if (this._internalEventsHasSubscribers("patch"
      /* Patch */
      )) {
        var localizedPatch = extend({}, basePatch, {
          path: source.path.substr(this.path.length) + "/" + basePatch.path // calculate the relative path of the patch

        });

        var _a = __read(splitPatch(localizedPatch), 2),
            patch = _a[0],
            reversePatch = _a[1];

        this._internalEventsEmit("patch"
        /* Patch */
        , patch, reversePatch);
      }

      if (this.parent) this.parent.emitPatch(basePatch, source);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "hasDisposer", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (disposer) {
      return this._internalEventsHas("dispose"
      /* Dispose */
      , disposer);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "addDisposer", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (disposer) {
      if (!this.hasDisposer(disposer)) {
        this._internalEventsRegister("dispose"
        /* Dispose */
        , disposer, true);

        return;
      }

      throw fail$1("cannot add a disposer when it is already registered for execution");
    }
  });
  Object.defineProperty(ObjectNode.prototype, "removeDisposer", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (disposer) {
      if (!this._internalEventsHas("dispose"
      /* Dispose */
      , disposer)) {
        throw fail$1("cannot remove a disposer which was never registered for execution");
      }

      this._internalEventsUnregister("dispose"
      /* Dispose */
      , disposer);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "removeMiddleware", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (middleware) {
      if (this.middlewares) {
        var index = this.middlewares.indexOf(middleware);

        if (index >= 0) {
          this.middlewares.splice(index, 1);
        }
      }
    }
  });
  Object.defineProperty(ObjectNode.prototype, "addMiddleWare", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (handler, includeHooks) {
      var _this = this;

      if (includeHooks === void 0) {
        includeHooks = true;
      }

      var middleware = {
        handler: handler,
        includeHooks: includeHooks
      };
      if (!this.middlewares) this.middlewares = [middleware];else this.middlewares.push(middleware);
      return function () {
        _this.removeMiddleware(middleware);
      };
    }
  });
  Object.defineProperty(ObjectNode.prototype, "applyPatchLocally", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (subpath, patch) {
      this.assertWritable({
        subpath: subpath
      });
      this.createObservableInstanceIfNeeded();
      this.type.applyPatchLocally(this, subpath, patch);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "_addSnapshotReaction", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      var _this = this;

      if (!this._hasSnapshotReaction) {
        var snapshotDisposer = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["reaction"])(function () {
          return _this.snapshot;
        }, function (snapshot) {
          return _this.emitSnapshot(snapshot);
        }, snapshotReactionOptions);
        this.addDisposer(snapshotDisposer);
        this._hasSnapshotReaction = true;
      }
    }
  }); // we proxy the methods to avoid creating an EventHandlers instance when it is not needed

  Object.defineProperty(ObjectNode.prototype, "_internalEventsHasSubscribers", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (event) {
      return !!this._internalEvents && this._internalEvents.hasSubscribers(event);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "_internalEventsRegister", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (event, eventHandler, atTheBeginning) {
      if (atTheBeginning === void 0) {
        atTheBeginning = false;
      }

      if (!this._internalEvents) {
        this._internalEvents = new EventHandlers();
      }

      return this._internalEvents.register(event, eventHandler, atTheBeginning);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "_internalEventsHas", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (event, eventHandler) {
      return !!this._internalEvents && this._internalEvents.has(event, eventHandler);
    }
  });
  Object.defineProperty(ObjectNode.prototype, "_internalEventsUnregister", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (event, eventHandler) {
      if (this._internalEvents) {
        this._internalEvents.unregister(event, eventHandler);
      }
    }
  });
  Object.defineProperty(ObjectNode.prototype, "_internalEventsEmit", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (event) {
      var _a;

      var args = [];

      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }

      if (this._internalEvents) {
        (_a = this._internalEvents).emit.apply(_a, __spread([event], args));
      }
    }
  });
  Object.defineProperty(ObjectNode.prototype, "_internalEventsClear", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (event) {
      if (this._internalEvents) {
        this._internalEvents.clear(event);
      }
    }
  });
  Object.defineProperty(ObjectNode.prototype, "_internalEventsClearAll", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      if (this._internalEvents) {
        this._internalEvents.clearAll();
      }
    }
  });
  return ObjectNode;
}(BaseNode);

ObjectNode.prototype.createObservableInstance = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["action"])(ObjectNode.prototype.createObservableInstance);
ObjectNode.prototype.detach = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["action"])(ObjectNode.prototype.detach);
ObjectNode.prototype.die = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["action"])(ObjectNode.prototype.die);

var _a;
/**
 * @internal
 * @hidden
 */


var TypeFlags;

(function (TypeFlags) {
  TypeFlags[TypeFlags["String"] = 1] = "String";
  TypeFlags[TypeFlags["Number"] = 2] = "Number";
  TypeFlags[TypeFlags["Boolean"] = 4] = "Boolean";
  TypeFlags[TypeFlags["Date"] = 8] = "Date";
  TypeFlags[TypeFlags["Literal"] = 16] = "Literal";
  TypeFlags[TypeFlags["Array"] = 32] = "Array";
  TypeFlags[TypeFlags["Map"] = 64] = "Map";
  TypeFlags[TypeFlags["Object"] = 128] = "Object";
  TypeFlags[TypeFlags["Frozen"] = 256] = "Frozen";
  TypeFlags[TypeFlags["Optional"] = 512] = "Optional";
  TypeFlags[TypeFlags["Reference"] = 1024] = "Reference";
  TypeFlags[TypeFlags["Identifier"] = 2048] = "Identifier";
  TypeFlags[TypeFlags["Late"] = 4096] = "Late";
  TypeFlags[TypeFlags["Refinement"] = 8192] = "Refinement";
  TypeFlags[TypeFlags["Union"] = 16384] = "Union";
  TypeFlags[TypeFlags["Null"] = 32768] = "Null";
  TypeFlags[TypeFlags["Undefined"] = 65536] = "Undefined";
  TypeFlags[TypeFlags["Integer"] = 131072] = "Integer";
  TypeFlags[TypeFlags["Custom"] = 262144] = "Custom";
  TypeFlags[TypeFlags["SnapshotProcessor"] = 524288] = "SnapshotProcessor";
})(TypeFlags || (TypeFlags = {}));
/**
 * @internal
 * @hidden
 */


var cannotDetermineSubtype = "cannotDetermine";
/** @hidden */

var $type = Symbol("$type");
/**
 * A base type produces a MST node (Node in the state tree)
 *
 * @internal
 * @hidden
 */

var BaseType =
/** @class */
function () {
  function BaseType(name) {
    Object.defineProperty(this, _a, {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }); // these are just to make inner types avaialable to inherited classes

    Object.defineProperty(this, "C", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "S", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "T", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "N", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "isType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = name;
  }

  Object.defineProperty(BaseType.prototype, "create", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (snapshot, environment) {
      typecheckInternal(this, snapshot);
      return this.instantiate(null, "", environment, snapshot).value;
    }
  });
  Object.defineProperty(BaseType.prototype, "getSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, applyPostProcess) {
      // istanbul ignore next
      throw fail$1("unimplemented method");
    }
  });
  Object.defineProperty(BaseType.prototype, "isAssignableFrom", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (type) {
      return type === this;
    }
  });
  Object.defineProperty(BaseType.prototype, "validate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      var node = getStateTreeNodeSafe(value);

      if (node) {
        var valueType = getType(value);
        return this.isAssignableFrom(valueType) ? typeCheckSuccess() : typeCheckFailure(context, value); // it is tempting to compare snapshots, but in that case we should always clone on assignments...
      }

      return this.isValidSnapshot(value, context);
    }
  });
  Object.defineProperty(BaseType.prototype, "is", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (thing) {
      return this.validate(thing, [{
        path: "",
        type: this
      }]).length === 0;
    }
  });
  Object.defineProperty(BaseType.prototype, "Type", {
    get: function () {
      // istanbul ignore next
      throw fail$1("Factory.Type should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.Type`");
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseType.prototype, "TypeWithoutSTN", {
    get: function () {
      // istanbul ignore next
      throw fail$1("Factory.TypeWithoutSTN should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.TypeWithoutSTN`");
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseType.prototype, "SnapshotType", {
    get: function () {
      // istanbul ignore next
      throw fail$1("Factory.SnapshotType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.SnapshotType`");
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseType.prototype, "CreationType", {
    get: function () {
      // istanbul ignore next
      throw fail$1("Factory.CreationType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.CreationType`");
    },
    enumerable: false,
    configurable: true
  });
  return BaseType;
}();

_a = $type;
BaseType.prototype.create = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["action"])(BaseType.prototype.create);
/**
 * A complex type produces a MST node (Node in the state tree)
 *
 * @internal
 * @hidden
 */

var ComplexType =
/** @class */
function (_super) {
  __extends(ComplexType, _super);

  function ComplexType(name) {
    var _this = _super.call(this, name) || this;

    Object.defineProperty(_this, "identifierAttribute", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    return _this;
  }

  Object.defineProperty(ComplexType.prototype, "create", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (snapshot, environment) {
      if (snapshot === void 0) {
        snapshot = this.getDefaultSnapshot();
      }

      return _super.prototype.create.call(this, snapshot, environment);
    }
  });
  Object.defineProperty(ComplexType.prototype, "getValue", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      node.createObservableInstanceIfNeeded();
      return node.storedValue;
    }
  });
  Object.defineProperty(ComplexType.prototype, "tryToReconcileNode", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (current, newValue) {
      if (current.isDetaching) return false;

      if (current.snapshot === newValue) {
        // newValue is the current snapshot of the node, noop
        return true;
      }

      if (isStateTreeNode(newValue) && getStateTreeNode(newValue) === current) {
        // the current node is the same as the new one
        return true;
      }

      if (current.type === this && isMutable(newValue) && !isStateTreeNode(newValue) && (!current.identifierAttribute || current.identifier === normalizeIdentifier(newValue[current.identifierAttribute]))) {
        // the newValue has no node, so can be treated like a snapshot
        // we can reconcile
        current.applySnapshot(newValue);
        return true;
      }

      return false;
    }
  });
  Object.defineProperty(ComplexType.prototype, "reconcile", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (current, newValue, parent, subpath) {
      var nodeReconciled = this.tryToReconcileNode(current, newValue);

      if (nodeReconciled) {
        current.setParent(parent, subpath);
        return current;
      } // current node cannot be recycled in any way


      current.die(); // noop if detaching
      // attempt to reuse the new one

      if (isStateTreeNode(newValue) && this.isAssignableFrom(getType(newValue))) {
        // newValue is a Node as well, move it here..
        var newNode = getStateTreeNode(newValue);
        newNode.setParent(parent, subpath);
        return newNode;
      } // nothing to do, we have to create a new node


      return this.instantiate(parent, subpath, undefined, newValue);
    }
  });
  Object.defineProperty(ComplexType.prototype, "getSubTypes", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return null;
    }
  });
  return ComplexType;
}(BaseType);

ComplexType.prototype.create = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["action"])(ComplexType.prototype.create);
/**
 * @internal
 * @hidden
 */

var SimpleType =
/** @class */
function (_super) {
  __extends(SimpleType, _super);

  function SimpleType() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Object.defineProperty(SimpleType.prototype, "createNewInstance", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (snapshot) {
      return snapshot;
    }
  });
  Object.defineProperty(SimpleType.prototype, "getValue", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      // if we ever find a case where scalar nodes can be accessed without iterating through its parent
      // uncomment this to make sure the parent chain is created when this is accessed
      // if (node.parent) {
      //     node.parent.createObservableInstanceIfNeeded()
      // }
      return node.storedValue;
    }
  });
  Object.defineProperty(SimpleType.prototype, "getSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      return node.storedValue;
    }
  });
  Object.defineProperty(SimpleType.prototype, "reconcile", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (current, newValue, parent, subpath) {
      // reconcile only if type and value are still the same, and only if the node is not detaching
      if (!current.isDetaching && current.type === this && current.storedValue === newValue) {
        return current;
      }

      var res = this.instantiate(parent, subpath, undefined, newValue);
      current.die(); // noop if detaching

      return res;
    }
  });
  Object.defineProperty(SimpleType.prototype, "getSubTypes", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return null;
    }
  });
  return SimpleType;
}(BaseType);
/**
 * Returns if a given value represents a type.
 *
 * @param value Value to check.
 * @returns `true` if the value is a type.
 */


function isType(value) {
  return typeof value === "object" && value && value.isType === true;
}
/**
 * @internal
 * @hidden
 */


function assertIsType(type, argNumber) {
  assertArg(type, isType, "mobx-state-tree type", argNumber);
}

var runningActions = new Map();
/**
 * Note: Consider migrating to `createActionTrackingMiddleware2`, it is easier to use.
 *
 * Convenience utility to create action based middleware that supports async processes more easily.
 * All hooks are called for both synchronous and asynchronous actions. Except that either `onSuccess` or `onFail` is called
 *
 * The create middleware tracks the process of an action (assuming it passes the `filter`).
 * `onResume` can return any value, which will be passed as second argument to any other hook. This makes it possible to keep state during a process.
 *
 * See the `atomic` middleware for an example
 *
 * @param hooks
 * @returns
 */

function createActionTrackingMiddleware(hooks) {
  return function actionTrackingMiddleware(call, next, abort) {
    switch (call.type) {
      case "action":
        {
          if (!hooks.filter || hooks.filter(call) === true) {
            var context = hooks.onStart(call);
            hooks.onResume(call, context);
            runningActions.set(call.id, {
              call: call,
              context: context,
              async: false
            });

            try {
              var res = next(call);
              hooks.onSuspend(call, context);

              if (runningActions.get(call.id).async === false) {
                runningActions.delete(call.id);
                hooks.onSuccess(call, context, res);
              }

              return res;
            } catch (e) {
              runningActions.delete(call.id);
              hooks.onFail(call, context, e);
              throw e;
            }
          } else {
            return next(call);
          }
        }

      case "flow_spawn":
        {
          var root = runningActions.get(call.rootId);
          root.async = true;
          return next(call);
        }

      case "flow_resume":
      case "flow_resume_error":
        {
          var root = runningActions.get(call.rootId);
          hooks.onResume(call, root.context);

          try {
            return next(call);
          } finally {
            hooks.onSuspend(call, root.context);
          }
        }

      case "flow_throw":
        {
          var root = runningActions.get(call.rootId);
          runningActions.delete(call.rootId);
          hooks.onFail(call, root.context, call.args[0]);
          return next(call);
        }

      case "flow_return":
        {
          var root = runningActions.get(call.rootId);
          runningActions.delete(call.rootId);
          hooks.onSuccess(call, root.context, call.args[0]);
          return next(call);
        }
    }
  };
}

var RunningAction =
/** @class */
function () {
  function RunningAction(hooks, call) {
    Object.defineProperty(this, "hooks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: hooks
    });
    Object.defineProperty(this, "call", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: call
    });
    Object.defineProperty(this, "flowsPending", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "running", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });

    if (hooks) {
      hooks.onStart(call);
    }
  }

  Object.defineProperty(RunningAction.prototype, "finish", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (error) {
      if (this.running) {
        this.running = false;

        if (this.hooks) {
          this.hooks.onFinish(this.call, error);
        }
      }
    }
  });
  Object.defineProperty(RunningAction.prototype, "incFlowsPending", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      this.flowsPending++;
    }
  });
  Object.defineProperty(RunningAction.prototype, "decFlowsPending", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      this.flowsPending--;
    }
  });
  Object.defineProperty(RunningAction.prototype, "hasFlowsPending", {
    get: function () {
      return this.flowsPending > 0;
    },
    enumerable: false,
    configurable: true
  });
  return RunningAction;
}();
/**
 * Convenience utility to create action based middleware that supports async processes more easily.
 * The flow is like this:
 * - for each action: if filter passes -> `onStart` -> (inner actions recursively) -> `onFinish`
 *
 * Example: if we had an action `a` that called inside an action `b1`, then `b2` the flow would be:
 * - `filter(a)`
 * - `onStart(a)`
 *   - `filter(b1)`
 *   - `onStart(b1)`
 *   - `onFinish(b1)`
 *   - `filter(b2)`
 *   - `onStart(b2)`
 *   - `onFinish(b2)`
 * - `onFinish(a)`
 *
 * The flow is the same no matter if the actions are sync or async.
 *
 * See the `atomic` middleware for an example
 *
 * @param hooks
 * @returns
 */


function createActionTrackingMiddleware2(middlewareHooks) {
  var runningActions = new WeakMap();
  return function actionTrackingMiddleware(call, next) {
    // find parentRunningAction
    var parentRunningAction = call.parentActionEvent ? runningActions.get(call.parentActionEvent) : undefined;

    if (call.type === "action") {
      var newCall = __assign(__assign({}, call), {
        // make a shallow copy of the parent action env
        env: parentRunningAction && parentRunningAction.call.env,
        parentCall: parentRunningAction && parentRunningAction.call
      });

      var passesFilter = !middlewareHooks.filter || middlewareHooks.filter(newCall);
      var hooks = passesFilter ? middlewareHooks : undefined;
      var runningAction = new RunningAction(hooks, newCall);
      runningActions.set(call, runningAction);
      var res = void 0;

      try {
        res = next(call);
      } catch (e) {
        runningAction.finish(e);
        throw e;
      }

      if (!runningAction.hasFlowsPending) {
        // sync action finished
        runningAction.finish();
      }

      return res;
    } else {
      if (!parentRunningAction) {
        return next(call);
      }

      switch (call.type) {
        case "flow_spawn":
          {
            parentRunningAction.incFlowsPending();
            return next(call);
          }

        case "flow_resume":
        case "flow_resume_error":
          {
            return next(call);
          }

        case "flow_throw":
          {
            var error = call.args[0];

            try {
              return next(call);
            } finally {
              parentRunningAction.decFlowsPending();

              if (!parentRunningAction.hasFlowsPending) {
                parentRunningAction.finish(error);
              }
            }
          }

        case "flow_return":
          {
            try {
              return next(call);
            } finally {
              parentRunningAction.decFlowsPending();

              if (!parentRunningAction.hasFlowsPending) {
                parentRunningAction.finish();
              }
            }
          }
      }
    }
  };
}

function serializeArgument(node, actionName, index, arg) {
  if (arg instanceof Date) return {
    $MST_DATE: arg.getTime()
  };
  if (isPrimitive(arg)) return arg; // We should not serialize MST nodes, even if we can, because we don't know if the receiving party can handle a raw snapshot instead of an
  // MST type instance. So if one wants to serialize a MST node that was pass in, either explitly pass: 1: an id, 2: a (relative) path, 3: a snapshot

  if (isStateTreeNode(arg)) return serializeTheUnserializable("[MSTNode: " + getType(arg).name + "]");
  if (typeof arg === "function") return serializeTheUnserializable("[function]");
  if (typeof arg === "object" && !isPlainObject(arg) && !isArray(arg)) return serializeTheUnserializable("[object " + (arg && arg.constructor && arg.constructor.name || "Complex Object") + "]");

  try {
    // Check if serializable, cycle free etc...
    // MWE: there must be a better way....
    JSON.stringify(arg); // or throws

    return arg;
  } catch (e) {
    return serializeTheUnserializable("" + e);
  }
}

function deserializeArgument(adm, value) {
  if (value && typeof value === "object" && "$MST_DATE" in value) return new Date(value["$MST_DATE"]);
  return value;
}

function serializeTheUnserializable(baseType) {
  return {
    $MST_UNSERIALIZABLE: true,
    type: baseType
  };
}
/**
 * Applies an action or a series of actions in a single MobX transaction.
 * Does not return any value
 * Takes an action description as produced by the `onAction` middleware.
 *
 * @param target
 * @param actions
 */


function applyAction(target, actions) {
  // check all arguments
  assertIsStateTreeNode(target, 1);
  assertArg(actions, function (a) {
    return typeof a === "object";
  }, "object or array", 2);
  Object(mobx__WEBPACK_IMPORTED_MODULE_0__["runInAction"])(function () {
    asArray(actions).forEach(function (action) {
      return baseApplyAction(target, action);
    });
  });
}

function baseApplyAction(target, action) {
  var resolvedTarget = tryResolve(target, action.path || "");
  if (!resolvedTarget) throw fail$1("Invalid action path: " + (action.path || ""));
  var node = getStateTreeNode(resolvedTarget); // Reserved functions

  if (action.name === "@APPLY_PATCHES") {
    return applyPatch.call(null, resolvedTarget, action.args[0]);
  }

  if (action.name === "@APPLY_SNAPSHOT") {
    return applySnapshot.call(null, resolvedTarget, action.args[0]);
  }

  if (!(typeof resolvedTarget[action.name] === "function")) throw fail$1("Action '" + action.name + "' does not exist in '" + node.path + "'");
  return resolvedTarget[action.name].apply(resolvedTarget, action.args ? action.args.map(function (v) {
    return deserializeArgument(node, v);
  }) : []);
}
/**
 * Small abstraction around `onAction` and `applyAction`, attaches an action listener to a tree and records all the actions emitted.
 * Returns an recorder object with the following signature:
 *
 * Example:
 * ```ts
 * export interface IActionRecorder {
 *      // the recorded actions
 *      actions: ISerializedActionCall[]
 *      // true if currently recording
 *      recording: boolean
 *      // stop recording actions
 *      stop(): void
 *      // resume recording actions
 *      resume(): void
 *      // apply all the recorded actions on the given object
 *      replay(target: IAnyStateTreeNode): void
 * }
 * ```
 *
 * The optional filter function allows to skip recording certain actions.
 *
 * @param subject
 * @returns
 */


function recordActions(subject, filter) {
  // check all arguments
  assertIsStateTreeNode(subject, 1);
  var actions = [];

  var listener = function (call) {
    var recordThis = filter ? filter(call, getRunningActionContext()) : true;

    if (recordThis) {
      actions.push(call);
    }
  };

  var disposer;
  var recorder = {
    actions: actions,

    get recording() {
      return !!disposer;
    },

    stop: function () {
      if (disposer) {
        disposer();
        disposer = undefined;
      }
    },
    resume: function () {
      if (disposer) return;
      disposer = onAction(subject, listener);
    },
    replay: function (target) {
      applyAction(target, actions);
    }
  };
  recorder.resume();
  return recorder;
}
/**
 * Registers a function that will be invoked for each action that is called on the provided model instance, or to any of its children.
 * See [actions](https://github.com/mobxjs/mobx-state-tree#actions) for more details. onAction events are emitted only for the outermost called action in the stack.
 * Action can also be intercepted by middleware using addMiddleware to change the function call before it will be run.
 *
 * Not all action arguments might be serializable. For unserializable arguments, a struct like `{ $MST_UNSERIALIZABLE: true, type: "someType" }` will be generated.
 * MST Nodes are considered non-serializable as well (they could be serialized as there snapshot, but it is uncertain whether an replaying party will be able to handle such a non-instantiated snapshot).
 * Rather, when using `onAction` middleware, one should consider in passing arguments which are 1: an id, 2: a (relative) path, or 3: a snapshot. Instead of a real MST node.
 *
 * Example:
 * ```ts
 * const Todo = types.model({
 *   task: types.string
 * })
 *
 * const TodoStore = types.model({
 *   todos: types.array(Todo)
 * }).actions(self => ({
 *   add(todo) {
 *     self.todos.push(todo);
 *   }
 * }))
 *
 * const s = TodoStore.create({ todos: [] })
 *
 * let disposer = onAction(s, (call) => {
 *   console.log(call);
 * })
 *
 * s.add({ task: "Grab a coffee" })
 * // Logs: { name: "add", path: "", args: [{ task: "Grab a coffee" }] }
 * ```
 *
 * @param target
 * @param listener
 * @param attachAfter (default false) fires the listener *after* the action has executed instead of before.
 * @returns
 */


function onAction(target, listener, attachAfter) {
  if (attachAfter === void 0) {
    attachAfter = false;
  } // check all arguments


  assertIsStateTreeNode(target, 1);

  if (devMode()) {
    if (!isRoot(target)) warnError("Warning: Attaching onAction listeners to non root nodes is dangerous: No events will be emitted for actions initiated higher up in the tree.");
    if (!isProtected(target)) warnError("Warning: Attaching onAction listeners to non protected nodes is dangerous: No events will be emitted for direct modifications without action.");
  }

  return addMiddleware(target, function handler(rawCall, next) {
    if (rawCall.type === "action" && rawCall.id === rawCall.rootId) {
      var sourceNode_1 = getStateTreeNode(rawCall.context);
      var info = {
        name: rawCall.name,
        path: getRelativePathBetweenNodes(getStateTreeNode(target), sourceNode_1),
        args: rawCall.args.map(function (arg, index) {
          return serializeArgument(sourceNode_1, rawCall.name, index, arg);
        })
      };

      if (attachAfter) {
        var res = next(rawCall);
        listener(info);
        return res;
      } else {
        listener(info);
        return next(rawCall);
      }
    } else {
      return next(rawCall);
    }
  });
}

var nextActionId = 1;
var currentActionContext;
/**
 * @internal
 * @hidden
 */

function getCurrentActionContext() {
  return currentActionContext;
}
/**
 * @internal
 * @hidden
 */


function getNextActionId() {
  return nextActionId++;
} // TODO: optimize away entire action context if there is no middleware in tree?

/**
 * @internal
 * @hidden
 */


function runWithActionContext(context, fn) {
  var node = getStateTreeNode(context.context);

  if (context.type === "action") {
    node.assertAlive({
      actionContext: context
    });
  }

  var baseIsRunningAction = node._isRunningAction;
  node._isRunningAction = true;
  var previousContext = currentActionContext;
  currentActionContext = context;

  try {
    return runMiddleWares(node, context, fn);
  } finally {
    currentActionContext = previousContext;
    node._isRunningAction = baseIsRunningAction;
  }
}
/**
 * @internal
 * @hidden
 */


function getParentActionContext(parentContext) {
  if (!parentContext) return undefined;
  if (parentContext.type === "action") return parentContext;
  return parentContext.parentActionEvent;
}
/**
 * @internal
 * @hidden
 */


function createActionInvoker(target, name, fn) {
  var res = function () {
    var id = getNextActionId();
    var parentContext = currentActionContext;
    var parentActionContext = getParentActionContext(parentContext);
    return runWithActionContext({
      type: "action",
      name: name,
      id: id,
      args: argsToArray(arguments),
      context: target,
      tree: getRoot(target),
      rootId: parentContext ? parentContext.rootId : id,
      parentId: parentContext ? parentContext.id : 0,
      allParentIds: parentContext ? __spread(parentContext.allParentIds, [parentContext.id]) : [],
      parentEvent: parentContext,
      parentActionEvent: parentActionContext
    }, fn);
  };

  res._isMSTAction = true;
  return res;
}
/**
 * Middleware can be used to intercept any action is invoked on the subtree where it is attached.
 * If a tree is protected (by default), this means that any mutation of the tree will pass through your middleware.
 *
 * For more details, see the [middleware docs](concepts/middleware.md)
 *
 * @param target Node to apply the middleware to.
 * @param middleware Middleware to apply.
 * @returns A callable function to dispose the middleware.
 */


function addMiddleware(target, handler, includeHooks) {
  if (includeHooks === void 0) {
    includeHooks = true;
  }

  var node = getStateTreeNode(target);

  if (devMode()) {
    if (!node.isProtectionEnabled) {
      warnError("It is recommended to protect the state tree before attaching action middleware, as otherwise it cannot be guaranteed that all changes are passed through middleware. See `protect`");
    }
  }

  return node.addMiddleWare(handler, includeHooks);
}
/**
 * Binds middleware to a specific action.
 *
 * Example:
 * ```ts
 * type.actions(self => {
 *   function takeA____() {
 *       self.toilet.donate()
 *       self.wipe()
 *       self.wipe()
 *       self.toilet.flush()
 *   }
 *   return {
 *     takeA____: decorate(atomic, takeA____)
 *   }
 * })
 * ```
 *
 * @param handler
 * @param fn
 * @param includeHooks
 * @returns The original function
 */


function decorate(handler, fn, includeHooks) {
  if (includeHooks === void 0) {
    includeHooks = true;
  }

  var middleware = {
    handler: handler,
    includeHooks: includeHooks
  };
  fn.$mst_middleware = fn.$mst_middleware || [];
  fn.$mst_middleware.push(middleware);
  return fn;
}

var CollectedMiddlewares =
/** @class */
function () {
  function CollectedMiddlewares(node, fn) {
    Object.defineProperty(this, "arrayIndex", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "inArrayIndex", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "middlewares", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    }); // we just push middleware arrays into an array of arrays to avoid making copies

    if (fn.$mst_middleware) {
      this.middlewares.push(fn.$mst_middleware);
    }

    var n = node; // Find all middlewares. Optimization: cache this?

    while (n) {
      if (n.middlewares) this.middlewares.push(n.middlewares);
      n = n.parent;
    }
  }

  Object.defineProperty(CollectedMiddlewares.prototype, "isEmpty", {
    get: function () {
      return this.middlewares.length <= 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CollectedMiddlewares.prototype, "getNextMiddleware", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      var array = this.middlewares[this.arrayIndex];
      if (!array) return undefined;
      var item = array[this.inArrayIndex++];

      if (!item) {
        this.arrayIndex++;
        this.inArrayIndex = 0;
        return this.getNextMiddleware();
      }

      return item;
    }
  });
  return CollectedMiddlewares;
}();

function runMiddleWares(node, baseCall, originalFn) {
  var middlewares = new CollectedMiddlewares(node, originalFn); // Short circuit

  if (middlewares.isEmpty) return Object(mobx__WEBPACK_IMPORTED_MODULE_0__["action"])(originalFn).apply(null, baseCall.args);
  var result = null;

  function runNextMiddleware(call) {
    var middleware = middlewares.getNextMiddleware();
    var handler = middleware && middleware.handler;

    if (!handler) {
      return Object(mobx__WEBPACK_IMPORTED_MODULE_0__["action"])(originalFn).apply(null, call.args);
    } // skip hooks if asked to


    if (!middleware.includeHooks && Hook[call.name]) {
      return runNextMiddleware(call);
    }

    var nextInvoked = false;

    function next(call2, callback) {
      nextInvoked = true; // the result can contain
      // - the non manipulated return value from an action
      // - the non manipulated abort value
      // - one of the above but manipulated through the callback function

      result = runNextMiddleware(call2);

      if (callback) {
        result = callback(result);
      }
    }

    var abortInvoked = false;

    function abort(value) {
      abortInvoked = true; // overwrite the result
      // can be manipulated through middlewares earlier in the queue using the callback fn

      result = value;
    }

    handler(call, next, abort);

    if (devMode()) {
      if (!nextInvoked && !abortInvoked) {
        var node2 = getStateTreeNode(call.tree);
        throw fail$1("Neither the next() nor the abort() callback within the middleware " + handler.name + " for the action: \"" + call.name + "\" on the node: " + node2.type.name + " was invoked.");
      } else if (nextInvoked && abortInvoked) {
        var node2 = getStateTreeNode(call.tree);
        throw fail$1("The next() and abort() callback within the middleware " + handler.name + " for the action: \"" + call.name + "\" on the node: " + node2.type.name + " were invoked.");
      }
    }

    return result;
  }

  return runNextMiddleware(baseCall);
}
/**
 * Returns the currently executing MST action context, or undefined if none.
 */


function getRunningActionContext() {
  var current = getCurrentActionContext();

  while (current && current.type !== "action") {
    current = current.parentActionEvent;
  }

  return current;
}

function _isActionContextThisOrChildOf(actionContext, sameOrParent, includeSame) {
  var parentId = typeof sameOrParent === "number" ? sameOrParent : sameOrParent.id;
  var current = includeSame ? actionContext : actionContext.parentActionEvent;

  while (current) {
    if (current.id === parentId) {
      return true;
    }

    current = current.parentActionEvent;
  }

  return false;
}
/**
 * Returns if the given action context is a parent of this action context.
 */


function isActionContextChildOf(actionContext, parent) {
  return _isActionContextThisOrChildOf(actionContext, parent, false);
}
/**
 * Returns if the given action context is this or a parent of this action context.
 */


function isActionContextThisOrChildOf(actionContext, parentOrThis) {
  return _isActionContextThisOrChildOf(actionContext, parentOrThis, true);
}

function safeStringify(value) {
  try {
    return JSON.stringify(value);
  } catch (e) {
    // istanbul ignore next
    return "<Unserializable: " + e + ">";
  }
}
/**
 * @internal
 * @hidden
 */


function prettyPrintValue(value) {
  return typeof value === "function" ? "<function" + (value.name ? " " + value.name : "") + ">" : isStateTreeNode(value) ? "<" + value + ">" : "`" + safeStringify(value) + "`";
}

function shortenPrintValue(valueInString) {
  return valueInString.length < 280 ? valueInString : valueInString.substring(0, 272) + "......" + valueInString.substring(valueInString.length - 8);
}

function toErrorString(error) {
  var value = error.value;
  var type = error.context[error.context.length - 1].type;
  var fullPath = error.context.map(function (_a) {
    var path = _a.path;
    return path;
  }).filter(function (path) {
    return path.length > 0;
  }).join("/");
  var pathPrefix = fullPath.length > 0 ? "at path \"/" + fullPath + "\" " : "";
  var currentTypename = isStateTreeNode(value) ? "value of type " + getStateTreeNode(value).type.name + ":" : isPrimitive(value) ? "value" : "snapshot";
  var isSnapshotCompatible = type && isStateTreeNode(value) && type.is(getStateTreeNode(value).snapshot);
  return "" + pathPrefix + currentTypename + " " + prettyPrintValue(value) + " is not assignable " + (type ? "to type: `" + type.name + "`" : "") + (error.message ? " (" + error.message + ")" : "") + (type ? isPrimitiveType(type) || isPrimitive(value) ? "." : ", expected an instance of `" + type.name + "` or a snapshot like `" + type.describe() + "` instead." + (isSnapshotCompatible ? " (Note that a snapshot of the provided value is compatible with the targeted type)" : "") : ".");
}
/**
 * @internal
 * @hidden
 */


function getContextForPath(context, path, type) {
  return context.concat([{
    path: path,
    type: type
  }]);
}
/**
 * @internal
 * @hidden
 */


function typeCheckSuccess() {
  return EMPTY_ARRAY;
}
/**
 * @internal
 * @hidden
 */


function typeCheckFailure(context, value, message) {
  return [{
    context: context,
    value: value,
    message: message
  }];
}
/**
 * @internal
 * @hidden
 */


function flattenTypeErrors(errors) {
  return errors.reduce(function (a, i) {
    return a.concat(i);
  }, []);
} // TODO; doublecheck: typecheck should only needed to be invoked from: type.create and array / map / value.property will change

/**
 * @internal
 * @hidden
 */


function typecheckInternal(type, value) {
  // runs typeChecking if it is in dev-mode or through a process.env.ENABLE_TYPE_CHECK flag
  if (isTypeCheckingEnabled()) {
    typecheck(type, value);
  }
}
/**
 * Run's the typechecker for the given type on the given value, which can be a snapshot or an instance.
 * Throws if the given value is not according the provided type specification.
 * Use this if you need typechecks even in a production build (by default all automatic runtime type checks will be skipped in production builds)
 *
 * @param type Type to check against.
 * @param value Value to be checked, either a snapshot or an instance.
 */


function typecheck(type, value) {
  var errors = type.validate(value, [{
    path: "",
    type: type
  }]);

  if (errors.length > 0) {
    throw fail$1(validationErrorsToString(type, value, errors));
  }
}

function validationErrorsToString(type, value, errors) {
  if (errors.length === 0) {
    return undefined;
  }

  return "Error while converting " + shortenPrintValue(prettyPrintValue(value)) + " to `" + type.name + "`:\n\n    " + errors.map(toErrorString).join("\n    ");
}

var identifierCacheId = 0;
/**
 * @internal
 * @hidden
 */

var IdentifierCache =
/** @class */
function () {
  function IdentifierCache() {
    Object.defineProperty(this, "cacheId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: identifierCacheId++
    }); // n.b. in cache all identifiers are normalized to strings

    Object.defineProperty(this, "cache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: mobx__WEBPACK_IMPORTED_MODULE_0__["observable"].map()
    }); // last time the cache (array) for a given time changed
    // n.b. it is not really the time, but just an integer that gets increased after each modification to the array

    Object.defineProperty(this, "lastCacheModificationPerId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: mobx__WEBPACK_IMPORTED_MODULE_0__["observable"].map()
    });
  }

  Object.defineProperty(IdentifierCache.prototype, "updateLastCacheModificationPerId", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (identifier) {
      var lcm = this.lastCacheModificationPerId.get(identifier); // we start at 1 since 0 means no update since cache creation

      this.lastCacheModificationPerId.set(identifier, lcm === undefined ? 1 : lcm + 1);
    }
  });
  Object.defineProperty(IdentifierCache.prototype, "getLastCacheModificationPerId", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (identifier) {
      var modificationId = this.lastCacheModificationPerId.get(identifier) || 0;
      return this.cacheId + "-" + modificationId;
    }
  });
  Object.defineProperty(IdentifierCache.prototype, "addNodeToCache", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, lastCacheUpdate) {
      if (lastCacheUpdate === void 0) {
        lastCacheUpdate = true;
      }

      if (node.identifierAttribute) {
        var identifier = node.identifier;

        if (!this.cache.has(identifier)) {
          this.cache.set(identifier, mobx__WEBPACK_IMPORTED_MODULE_0__["observable"].array([], mobxShallow));
        }

        var set = this.cache.get(identifier);
        if (set.indexOf(node) !== -1) throw fail$1("Already registered");
        set.push(node);

        if (lastCacheUpdate) {
          this.updateLastCacheModificationPerId(identifier);
        }
      }
    }
  });
  Object.defineProperty(IdentifierCache.prototype, "mergeCache", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      var _this = this;

      Object(mobx__WEBPACK_IMPORTED_MODULE_0__["values"])(node.identifierCache.cache).forEach(function (nodes) {
        return nodes.forEach(function (child) {
          _this.addNodeToCache(child);
        });
      });
    }
  });
  Object.defineProperty(IdentifierCache.prototype, "notifyDied", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      if (node.identifierAttribute) {
        var id = node.identifier;
        var set = this.cache.get(id);

        if (set) {
          set.remove(node); // remove empty sets from cache

          if (!set.length) {
            this.cache.delete(id);
          }

          this.updateLastCacheModificationPerId(node.identifier);
        }
      }
    }
  });
  Object.defineProperty(IdentifierCache.prototype, "splitCache", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      var _this = this;

      var res = new IdentifierCache();
      var basePath = node.path;
      Object(mobx__WEBPACK_IMPORTED_MODULE_0__["entries"])(this.cache).forEach(function (_a) {
        var _b = __read(_a, 2),
            id = _b[0],
            nodes = _b[1];

        var modified = false;

        for (var i = nodes.length - 1; i >= 0; i--) {
          if (nodes[i].path.indexOf(basePath) === 0) {
            res.addNodeToCache(nodes[i], false); // no need to update lastUpdated since it is a whole new cache

            nodes.splice(i, 1);
            modified = true;
          }
        }

        if (modified) {
          _this.updateLastCacheModificationPerId(id);
        }
      });
      return res;
    }
  });
  Object.defineProperty(IdentifierCache.prototype, "has", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (type, identifier) {
      var set = this.cache.get(identifier);
      if (!set) return false;
      return set.some(function (candidate) {
        return type.isAssignableFrom(candidate.type);
      });
    }
  });
  Object.defineProperty(IdentifierCache.prototype, "resolve", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (type, identifier) {
      var set = this.cache.get(identifier);
      if (!set) return null;
      var matches = set.filter(function (candidate) {
        return type.isAssignableFrom(candidate.type);
      });

      switch (matches.length) {
        case 0:
          return null;

        case 1:
          return matches[0];

        default:
          throw fail$1("Cannot resolve a reference to type '" + type.name + "' with id: '" + identifier + "' unambigously, there are multiple candidates: " + matches.map(function (n) {
            return n.path;
          }).join(", "));
      }
    }
  });
  return IdentifierCache;
}();
/**
 * @internal
 * @hidden
 */


function createObjectNode(type, parent, subpath, environment, initialValue) {
  var existingNode = getStateTreeNodeSafe(initialValue);

  if (existingNode) {
    if (existingNode.parent) {
      // istanbul ignore next
      throw fail$1("Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '" + (parent ? parent.path : "") + "/" + subpath + "', but it lives already at '" + existingNode.path + "'");
    }

    if (parent) {
      existingNode.setParent(parent, subpath);
    } // else it already has no parent since it is a pre-requisite


    return existingNode;
  } // not a node, a snapshot


  return new ObjectNode(type, parent, subpath, environment, initialValue);
}
/**
 * @internal
 * @hidden
 */


function createScalarNode(type, parent, subpath, environment, initialValue) {
  return new ScalarNode(type, parent, subpath, environment, initialValue);
}
/**
 * @internal
 * @hidden
 */


function isNode(value) {
  return value instanceof ScalarNode || value instanceof ObjectNode;
}
/**
 * @internal
 * @hidden
 */


var NodeLifeCycle;

(function (NodeLifeCycle) {
  NodeLifeCycle[NodeLifeCycle["INITIALIZING"] = 0] = "INITIALIZING";
  NodeLifeCycle[NodeLifeCycle["CREATED"] = 1] = "CREATED";
  NodeLifeCycle[NodeLifeCycle["FINALIZED"] = 2] = "FINALIZED";
  NodeLifeCycle[NodeLifeCycle["DETACHING"] = 3] = "DETACHING";
  NodeLifeCycle[NodeLifeCycle["DEAD"] = 4] = "DEAD"; // no coming back from this one
})(NodeLifeCycle || (NodeLifeCycle = {}));
/**
 * Returns true if the given value is a node in a state tree.
 * More precisely, that is, if the value is an instance of a
 * `types.model`, `types.array` or `types.map`.
 *
 * @param value
 * @returns true if the value is a state tree node.
 */


function isStateTreeNode(value) {
  return !!(value && value.$treenode);
}
/**
 * @internal
 * @hidden
 */


function assertIsStateTreeNode(value, argNumber) {
  assertArg(value, isStateTreeNode, "mobx-state-tree node", argNumber);
}
/**
 * @internal
 * @hidden
 */


function getStateTreeNode(value) {
  if (!isStateTreeNode(value)) {
    // istanbul ignore next
    throw fail$1("Value " + value + " is no MST Node");
  }

  return value.$treenode;
}
/**
 * @internal
 * @hidden
 */


function getStateTreeNodeSafe(value) {
  return value && value.$treenode || null;
}
/**
 * @internal
 * @hidden
 */


function toJSON() {
  return getStateTreeNode(this).snapshot;
}

var doubleDot = function (_) {
  return "..";
};
/**
 * @internal
 * @hidden
 */


function getRelativePathBetweenNodes(base, target) {
  // PRE condition target is (a child of) base!
  if (base.root !== target.root) {
    throw fail$1("Cannot calculate relative path: objects '" + base + "' and '" + target + "' are not part of the same object tree");
  }

  var baseParts = splitJsonPath(base.path);
  var targetParts = splitJsonPath(target.path);
  var common = 0;

  for (; common < baseParts.length; common++) {
    if (baseParts[common] !== targetParts[common]) break;
  } // TODO: assert that no targetParts paths are "..", "." or ""!


  return baseParts.slice(common).map(doubleDot).join("/") + joinJsonPath(targetParts.slice(common));
}
/**
 * @internal
 * @hidden
 */


function resolveNodeByPath(base, path, failIfResolveFails) {
  if (failIfResolveFails === void 0) {
    failIfResolveFails = true;
  }

  return resolveNodeByPathParts(base, splitJsonPath(path), failIfResolveFails);
}
/**
 * @internal
 * @hidden
 */


function resolveNodeByPathParts(base, pathParts, failIfResolveFails) {
  if (failIfResolveFails === void 0) {
    failIfResolveFails = true;
  }

  var current = base;

  for (var i = 0; i < pathParts.length; i++) {
    var part = pathParts[i];

    if (part === "..") {
      current = current.parent;
      if (current) continue; // not everything has a parent
    } else if (part === ".") {
      continue;
    } else if (current) {
      if (current instanceof ScalarNode) {
        // check if the value of a scalar resolves to a state tree node (e.g. references)
        // then we can continue resolving...
        try {
          var value = current.value;

          if (isStateTreeNode(value)) {
            current = getStateTreeNode(value); // fall through
          }
        } catch (e) {
          if (!failIfResolveFails) {
            return undefined;
          }

          throw e;
        }
      }

      if (current instanceof ObjectNode) {
        var subType = current.getChildType(part);

        if (subType) {
          current = current.getChildNode(part);
          if (current) continue;
        }
      }
    }

    if (failIfResolveFails) throw fail$1("Could not resolve '" + part + "' in path '" + (joinJsonPath(pathParts.slice(0, i)) || "/") + "' while resolving '" + joinJsonPath(pathParts) + "'");else return undefined;
  }

  return current;
}
/**
 * @internal
 * @hidden
 */


function convertChildNodesToArray(childNodes) {
  if (!childNodes) return EMPTY_ARRAY;
  var keys = Object.keys(childNodes);
  if (!keys.length) return EMPTY_ARRAY;
  var result = new Array(keys.length);
  keys.forEach(function (key, index) {
    result[index] = childNodes[key];
  });
  return result;
} // based on: https://github.com/mobxjs/mobx-utils/blob/master/src/async-action.ts

/*
    All contents of this file are deprecated.

    The term `process` has been replaced with `flow` to avoid conflicts with the
    global `process` object.

    Refer to `flow.ts` for any further changes to this implementation.
*/


var DEPRECATION_MESSAGE = "See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information. " + "Note that the middleware event types starting with `process` now start with `flow`.";
/**
 * @hidden
 *
 * @deprecated has been renamed to `flow()`.
 * See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information.
 * Note that the middleware event types starting with `process` now start with `flow`.
 *
 * @returns {Promise}
 */

function process$1(asyncAction) {
  deprecated("process", "`process()` has been renamed to `flow()`. " + DEPRECATION_MESSAGE);
  return flow(asyncAction);
}

var plainObjectString = Object.toString();
/**
 * @internal
 * @hidden
 */

var EMPTY_ARRAY = Object.freeze([]);
/**
 * @internal
 * @hidden
 */

var EMPTY_OBJECT = Object.freeze({});
/**
 * @internal
 * @hidden
 */

var mobxShallow = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["_getGlobalState"])().useProxies ? {
  deep: false
} : {
  deep: false,
  proxy: false
};
Object.freeze(mobxShallow);
/**
 * @internal
 * @hidden
 */

function fail$1(message) {
  if (message === void 0) {
    message = "Illegal state";
  }

  return new Error("[mobx-state-tree] " + message);
}
/**
 * @internal
 * @hidden
 */


function identity(_) {
  return _;
}
/**
 * pollyfill (for IE) suggested in MDN:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
 * @internal
 * @hidden
 */


var isInteger = Number.isInteger || function (value) {
  return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};
/**
 * @internal
 * @hidden
 */


function isArray(val) {
  return Array.isArray(val) || Object(mobx__WEBPACK_IMPORTED_MODULE_0__["isObservableArray"])(val);
}
/**
 * @internal
 * @hidden
 */


function asArray(val) {
  if (!val) return EMPTY_ARRAY;
  if (isArray(val)) return val;
  return [val];
}
/**
 * @internal
 * @hidden
 */


function extend(a) {
  var b = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    b[_i - 1] = arguments[_i];
  }

  for (var i = 0; i < b.length; i++) {
    var current = b[i];

    for (var key in current) a[key] = current[key];
  }

  return a;
}
/**
 * @internal
 * @hidden
 */


function isPlainObject(value) {
  var _a;

  if (value === null || typeof value !== "object") return false;
  var proto = Object.getPrototypeOf(value);
  if (proto == null) return true;
  return ((_a = proto.constructor) === null || _a === void 0 ? void 0 : _a.toString()) === plainObjectString;
}
/**
 * @internal
 * @hidden
 */


function isMutable(value) {
  return value !== null && typeof value === "object" && !(value instanceof Date) && !(value instanceof RegExp);
}
/**
 * @internal
 * @hidden
 */


function isPrimitive(value, includeDate) {
  if (includeDate === void 0) {
    includeDate = true;
  }

  if (value === null || value === undefined) return true;
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || includeDate && value instanceof Date) return true;
  return false;
}
/**
 * @internal
 * @hidden
 * Freeze a value and return it (if not in production)
 */


function freeze(value) {
  if (!devMode()) return value;
  return isPrimitive(value) || Object(mobx__WEBPACK_IMPORTED_MODULE_0__["isObservableArray"])(value) ? value : Object.freeze(value);
}
/**
 * @internal
 * @hidden
 * Recursively freeze a value (if not in production)
 */


function deepFreeze(value) {
  if (!devMode()) return value;
  freeze(value);

  if (isPlainObject(value)) {
    Object.keys(value).forEach(function (propKey) {
      if (!isPrimitive(value[propKey]) && !Object.isFrozen(value[propKey])) {
        deepFreeze(value[propKey]);
      }
    });
  }

  return value;
}
/**
 * @internal
 * @hidden
 */


function isSerializable(value) {
  return typeof value !== "function";
}
/**
 * @internal
 * @hidden
 */


function addHiddenFinalProp(object, propName, value) {
  Object.defineProperty(object, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value: value
  });
}
/**
 * @internal
 * @hidden
 */


function addHiddenWritableProp(object, propName, value) {
  Object.defineProperty(object, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value: value
  });
}
/**
 * @internal
 * @hidden
 */


var EventHandler =
/** @class */
function () {
  function EventHandler() {
    Object.defineProperty(this, "handlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
  }

  Object.defineProperty(EventHandler.prototype, "hasSubscribers", {
    get: function () {
      return this.handlers.length > 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EventHandler.prototype, "register", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (fn, atTheBeginning) {
      var _this = this;

      if (atTheBeginning === void 0) {
        atTheBeginning = false;
      }

      if (atTheBeginning) {
        this.handlers.unshift(fn);
      } else {
        this.handlers.push(fn);
      }

      return function () {
        _this.unregister(fn);
      };
    }
  });
  Object.defineProperty(EventHandler.prototype, "has", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (fn) {
      return this.handlers.indexOf(fn) >= 0;
    }
  });
  Object.defineProperty(EventHandler.prototype, "unregister", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (fn) {
      var index = this.handlers.indexOf(fn);

      if (index >= 0) {
        this.handlers.splice(index, 1);
      }
    }
  });
  Object.defineProperty(EventHandler.prototype, "clear", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      this.handlers.length = 0;
    }
  });
  Object.defineProperty(EventHandler.prototype, "emit", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      } // make a copy just in case it changes


      var handlers = this.handlers.slice();
      handlers.forEach(function (f) {
        return f.apply(void 0, __spread(args));
      });
    }
  });
  return EventHandler;
}();
/**
 * @internal
 * @hidden
 */


var EventHandlers =
/** @class */
function () {
  function EventHandlers() {
    Object.defineProperty(this, "eventHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }

  Object.defineProperty(EventHandlers.prototype, "hasSubscribers", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (event) {
      var handler = this.eventHandlers && this.eventHandlers[event];
      return !!handler && handler.hasSubscribers;
    }
  });
  Object.defineProperty(EventHandlers.prototype, "register", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (event, fn, atTheBeginning) {
      if (atTheBeginning === void 0) {
        atTheBeginning = false;
      }

      if (!this.eventHandlers) {
        this.eventHandlers = {};
      }

      var handler = this.eventHandlers[event];

      if (!handler) {
        handler = this.eventHandlers[event] = new EventHandler();
      }

      return handler.register(fn, atTheBeginning);
    }
  });
  Object.defineProperty(EventHandlers.prototype, "has", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (event, fn) {
      var handler = this.eventHandlers && this.eventHandlers[event];
      return !!handler && handler.has(fn);
    }
  });
  Object.defineProperty(EventHandlers.prototype, "unregister", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (event, fn) {
      var handler = this.eventHandlers && this.eventHandlers[event];

      if (handler) {
        handler.unregister(fn);
      }
    }
  });
  Object.defineProperty(EventHandlers.prototype, "clear", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (event) {
      if (this.eventHandlers) {
        delete this.eventHandlers[event];
      }
    }
  });
  Object.defineProperty(EventHandlers.prototype, "clearAll", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      this.eventHandlers = undefined;
    }
  });
  Object.defineProperty(EventHandlers.prototype, "emit", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (event) {
      var _a;

      var args = [];

      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }

      var handler = this.eventHandlers && this.eventHandlers[event];

      if (handler) {
        (_a = handler).emit.apply(_a, __spread(args));
      }
    }
  });
  return EventHandlers;
}();
/**
 * @internal
 * @hidden
 */


function argsToArray(args) {
  var res = new Array(args.length);

  for (var i = 0; i < args.length; i++) res[i] = args[i];

  return res;
}
/**
 * @internal
 * @hidden
 */


function stringStartsWith(str, beginning) {
  return str.indexOf(beginning) === 0;
}
/**
 * @internal
 * @hidden
 */


var deprecated = function (id, message) {
  // skip if running production
  if (!devMode()) return; // warn if hasn't been warned before

  if (deprecated.ids && !deprecated.ids.hasOwnProperty(id)) {
    warnError("Deprecation warning: " + message);
  } // mark as warned to avoid duplicate warn message


  if (deprecated.ids) deprecated.ids[id] = true;
};

deprecated.ids = {};
/**
 * @internal
 * @hidden
 */

function warnError(msg) {
  console.warn(new Error("[mobx-state-tree] " + msg));
}
/**
 * @internal
 * @hidden
 */


function isTypeCheckingEnabled() {
  return devMode() || typeof process !== "undefined" && process.env && process.env.ENABLE_TYPE_CHECK === "true";
}
/**
 * @internal
 * @hidden
 */


function devMode() {
  return "development" !== "production";
}
/**
 * @internal
 * @hidden
 */


function assertArg(value, fn, typeName, argNumber) {
  if (devMode()) {
    if (!fn(value)) {
      // istanbul ignore next
      throw fail$1("expected " + typeName + " as argument " + asArray(argNumber).join(" or ") + ", got " + value + " instead");
    }
  }
}
/**
 * @internal
 * @hidden
 */


function assertIsFunction(value, argNumber) {
  assertArg(value, function (fn) {
    return typeof fn === "function";
  }, "function", argNumber);
}
/**
 * @internal
 * @hidden
 */


function assertIsNumber(value, argNumber, min, max) {
  assertArg(value, function (n) {
    return typeof n === "number";
  }, "number", argNumber);

  if (min !== undefined) {
    assertArg(value, function (n) {
      return n >= min;
    }, "number greater than " + min, argNumber);
  }

  if (max !== undefined) {
    assertArg(value, function (n) {
      return n <= max;
    }, "number lesser than " + max, argNumber);
  }
}
/**
 * @internal
 * @hidden
 */


function assertIsString(value, argNumber, canBeEmpty) {
  if (canBeEmpty === void 0) {
    canBeEmpty = true;
  }

  assertArg(value, function (s) {
    return typeof s === "string";
  }, "string", argNumber);

  if (!canBeEmpty) {
    assertArg(value, function (s) {
      return s !== "";
    }, "not empty string", argNumber);
  }
}
/**
 * @internal
 * @hidden
 */


function setImmediateWithFallback(fn) {
  if (typeof queueMicrotask === "function") {
    queueMicrotask(fn);
  } else if (typeof setImmediate === "function") {
    setImmediate(fn);
  } else {
    setTimeout(fn, 1);
  }
}
/**
 * See [asynchronous actions](concepts/async-actions.md).
 *
 * @returns The flow as a promise.
 */


function flow(generator) {
  return createFlowSpawner(generator.name, generator);
}
/**
 * @deprecated Not needed since TS3.6.
 * Used for TypeScript to make flows that return a promise return the actual promise result.
 *
 * @param val
 * @returns
 */


function castFlowReturn(val) {
  return val;
}
/**
 * @experimental
 * experimental api - might change on minor/patch releases
 *
 * Convert a promise-returning function to a generator-returning one.
 * This is intended to allow for usage of `yield*` in async actions to
 * retain the promise return type.
 *
 * Example:
 * ```ts
 * function getDataAsync(input: string): Promise<number> { ... }
 * const getDataGen = toGeneratorFunction(getDataAsync);
 *
 * const someModel.actions(self => ({
 *   someAction: flow(function*() {
 *     // value is typed as number
 *     const value = yield* getDataGen("input value");
 *     ...
 *   })
 * }))
 * ```
 */


function toGeneratorFunction(p) {
  return function () {
    var _i;

    var args = [];

    for (_i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    return __generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          return [4
          /*yield*/
          , p.apply(void 0, __spread(args))];

        case 1:
          return [2
          /*return*/
          , _a.sent()];
      }
    });
  };
}
/**
 * @experimental
 * experimental api - might change on minor/patch releases
 *
 * Convert a promise to a generator yielding that promise
 * This is intended to allow for usage of `yield*` in async actions to
 * retain the promise return type.
 *
 * Example:
 * ```ts
 * function getDataAsync(input: string): Promise<number> { ... }
 *
 * const someModel.actions(self => ({
 *   someAction: flow(function*() {
 *     // value is typed as number
 *     const value = yield* toGenerator(getDataAsync("input value"));
 *     ...
 *   })
 * }))
 * ```
 */


function toGenerator(p) {
  return __generator(this, function (_a) {
    switch (_a.label) {
      case 0:
        return [4
        /*yield*/
        , p];

      case 1:
        return [2
        /*return*/
        , _a.sent()];
    }
  });
}
/**
 * @internal
 * @hidden
 */


function createFlowSpawner(name, generator) {
  var spawner = function flowSpawner() {
    // Implementation based on https://github.com/tj/co/blob/master/index.js
    var runId = getNextActionId();
    var parentContext = getCurrentActionContext();

    if (!parentContext) {
      throw fail$1("a mst flow must always have a parent context");
    }

    var parentActionContext = getParentActionContext(parentContext);

    if (!parentActionContext) {
      throw fail$1("a mst flow must always have a parent action context");
    }

    var contextBase = {
      name: name,
      id: runId,
      tree: parentContext.tree,
      context: parentContext.context,
      parentId: parentContext.id,
      allParentIds: __spread(parentContext.allParentIds, [parentContext.id]),
      rootId: parentContext.rootId,
      parentEvent: parentContext,
      parentActionEvent: parentActionContext
    };
    var args = arguments;

    function wrap(fn, type, arg) {
      fn.$mst_middleware = spawner.$mst_middleware; // pick up any middleware attached to the flow

      runWithActionContext(__assign(__assign({}, contextBase), {
        type: type,
        args: [arg]
      }), fn);
    }

    return new Promise(function (resolve, reject) {
      var gen;

      var init = function asyncActionInit() {
        gen = generator.apply(null, arguments);
        onFulfilled(undefined); // kick off the flow
      };

      init.$mst_middleware = spawner.$mst_middleware;
      runWithActionContext(__assign(__assign({}, contextBase), {
        type: "flow_spawn",
        args: argsToArray(args)
      }), init);

      function onFulfilled(res) {
        var ret;

        try {
          // prettier-ignore
          wrap(function (r) {
            ret = gen.next(r);
          }, "flow_resume", res);
        } catch (e) {
          // prettier-ignore
          setImmediateWithFallback(function () {
            wrap(function (r) {
              reject(e);
            }, "flow_throw", e);
          });
          return;
        }

        next(ret);
        return;
      }

      function onRejected(err) {
        var ret;

        try {
          // prettier-ignore
          wrap(function (r) {
            ret = gen.throw(r);
          }, "flow_resume_error", err); // or yieldError?
        } catch (e) {
          // prettier-ignore
          setImmediateWithFallback(function () {
            wrap(function (r) {
              reject(e);
            }, "flow_throw", e);
          });
          return;
        }

        next(ret);
      }

      function next(ret) {
        if (ret.done) {
          // prettier-ignore
          setImmediateWithFallback(function () {
            wrap(function (r) {
              resolve(r);
            }, "flow_return", ret.value);
          });
          return;
        } // TODO: support more type of values? See https://github.com/tj/co/blob/249bbdc72da24ae44076afd716349d2089b31c4c/index.js#L100


        if (!ret.value || typeof ret.value.then !== "function") {
          // istanbul ignore next
          throw fail$1("Only promises can be yielded to `async`, got: " + ret);
        }

        return ret.value.then(onFulfilled, onRejected);
      }
    });
  };

  return spawner;
}
/**
 * @internal
 * @hidden
 */


function splitPatch(patch) {
  if (!("oldValue" in patch)) throw fail$1("Patches without `oldValue` field cannot be inversed");
  return [stripPatch(patch), invertPatch(patch)];
}
/**
 * @internal
 * @hidden
 */


function stripPatch(patch) {
  // strips `oldvalue` information from the patch, so that it becomes a patch conform the json-patch spec
  // this removes the ability to undo the patch
  switch (patch.op) {
    case "add":
      return {
        op: "add",
        path: patch.path,
        value: patch.value
      };

    case "remove":
      return {
        op: "remove",
        path: patch.path
      };

    case "replace":
      return {
        op: "replace",
        path: patch.path,
        value: patch.value
      };
  }
}

function invertPatch(patch) {
  switch (patch.op) {
    case "add":
      return {
        op: "remove",
        path: patch.path
      };

    case "remove":
      return {
        op: "add",
        path: patch.path,
        value: patch.oldValue
      };

    case "replace":
      return {
        op: "replace",
        path: patch.path,
        value: patch.oldValue
      };
  }
}
/**
 * Simple simple check to check it is a number.
 */


function isNumber(x) {
  return typeof x === "number";
}
/**
 * Escape slashes and backslashes.
 *
 * http://tools.ietf.org/html/rfc6901
 */


function escapeJsonPath(path) {
  if (isNumber(path) === true) {
    return "" + path;
  }

  if (path.indexOf("/") === -1 && path.indexOf("~") === -1) return path;
  return path.replace(/~/g, "~0").replace(/\//g, "~1");
}
/**
 * Unescape slashes and backslashes.
 */


function unescapeJsonPath(path) {
  return path.replace(/~1/g, "/").replace(/~0/g, "~");
}
/**
 * Generates a json-path compliant json path from path parts.
 *
 * @param path
 * @returns
 */


function joinJsonPath(path) {
  // `/` refers to property with an empty name, while `` refers to root itself!
  if (path.length === 0) return "";

  var getPathStr = function (p) {
    return p.map(escapeJsonPath).join("/");
  };

  if (path[0] === "." || path[0] === "..") {
    // relative
    return getPathStr(path);
  } else {
    // absolute
    return "/" + getPathStr(path);
  }
}
/**
 * Splits and decodes a json path into several parts.
 *
 * @param path
 * @returns
 */


function splitJsonPath(path) {
  // `/` refers to property with an empty name, while `` refers to root itself!
  var parts = path.split("/").map(unescapeJsonPath);
  var valid = path === "" || path === "." || path === ".." || stringStartsWith(path, "/") || stringStartsWith(path, "./") || stringStartsWith(path, "../");

  if (!valid) {
    throw fail$1("a json path must be either rooted, empty or relative, but got '" + path + "'");
  } // '/a/b/c' -> ["a", "b", "c"]
  // '../../b/c' -> ["..", "..", "b", "c"]
  // '' -> []
  // '/' -> ['']
  // './a' -> [".", "a"]
  // /./a' -> [".", "a"] equivalent to './a'


  if (parts[0] === "") {
    parts.shift();
  }

  return parts;
}

var SnapshotProcessor =
/** @class */
function (_super) {
  __extends(SnapshotProcessor, _super);

  function SnapshotProcessor(_subtype, _processors, name) {
    var _this = _super.call(this, name || _subtype.name) || this;

    Object.defineProperty(_this, "_subtype", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _subtype
    });
    Object.defineProperty(_this, "_processors", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _processors
    });
    return _this;
  }

  Object.defineProperty(SnapshotProcessor.prototype, "flags", {
    get: function () {
      return this._subtype.flags | TypeFlags.SnapshotProcessor;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SnapshotProcessor.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return "snapshotProcessor(" + this._subtype.describe() + ")";
    }
  });
  Object.defineProperty(SnapshotProcessor.prototype, "preProcessSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (sn) {
      if (this._processors.preProcessor) {
        return this._processors.preProcessor.call(null, sn);
      }

      return sn;
    }
  });
  Object.defineProperty(SnapshotProcessor.prototype, "postProcessSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (sn) {
      if (this._processors.postProcessor) {
        return this._processors.postProcessor.call(null, sn);
      }

      return sn;
    }
  });
  Object.defineProperty(SnapshotProcessor.prototype, "_fixNode", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      var _this = this; // the node has to use these methods rather than the original type ones


      proxyNodeTypeMethods(node.type, this, "create");
      var oldGetSnapshot = node.getSnapshot;

      node.getSnapshot = function () {
        return _this.postProcessSnapshot(oldGetSnapshot.call(node));
      };
    }
  });
  Object.defineProperty(SnapshotProcessor.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, initialValue) {
      var processedInitialValue = isStateTreeNode(initialValue) ? initialValue : this.preProcessSnapshot(initialValue);

      var node = this._subtype.instantiate(parent, subpath, environment, processedInitialValue);

      this._fixNode(node);

      return node;
    }
  });
  Object.defineProperty(SnapshotProcessor.prototype, "reconcile", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (current, newValue, parent, subpath) {
      var node = this._subtype.reconcile(current, isStateTreeNode(newValue) ? newValue : this.preProcessSnapshot(newValue), parent, subpath);

      if (node !== current) {
        this._fixNode(node);
      }

      return node;
    }
  });
  Object.defineProperty(SnapshotProcessor.prototype, "getSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, applyPostProcess) {
      if (applyPostProcess === void 0) {
        applyPostProcess = true;
      }

      var sn = this._subtype.getSnapshot(node);

      return applyPostProcess ? this.postProcessSnapshot(sn) : sn;
    }
  });
  Object.defineProperty(SnapshotProcessor.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      var processedSn = this.preProcessSnapshot(value);
      return this._subtype.validate(processedSn, context);
    }
  });
  Object.defineProperty(SnapshotProcessor.prototype, "getSubTypes", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this._subtype;
    }
  });
  Object.defineProperty(SnapshotProcessor.prototype, "is", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (thing) {
      var value = isType(thing) ? this._subtype : isStateTreeNode(thing) ? getSnapshot(thing, false) : this.preProcessSnapshot(thing);
      return this._subtype.validate(value, [{
        path: "",
        type: this._subtype
      }]).length === 0;
    }
  });
  Object.defineProperty(SnapshotProcessor.prototype, "isAssignableFrom", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (type) {
      return this._subtype.isAssignableFrom(type);
    }
  });
  return SnapshotProcessor;
}(BaseType);

function proxyNodeTypeMethods(nodeType, snapshotProcessorType) {
  var e_1, _a;

  var methods = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    methods[_i - 2] = arguments[_i];
  }

  try {
    for (var methods_1 = __values(methods), methods_1_1 = methods_1.next(); !methods_1_1.done; methods_1_1 = methods_1.next()) {
      var method = methods_1_1.value;
      nodeType[method] = snapshotProcessorType[method].bind(snapshotProcessorType);
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (methods_1_1 && !methods_1_1.done && (_a = methods_1.return)) _a.call(methods_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
}
/**
 * `types.snapshotProcessor` - Runs a pre/post snapshot processor before/after serializing a given type.
 *
 * Example:
 * ```ts
 * const Todo1 = types.model({ text: types.string })
 * // in the backend the text type must be null when empty
 * interface BackendTodo {
 *     text: string | null
 * }
 * const Todo2 = types.snapshotProcessor(Todo1, {
 *     // from snapshot to instance
 *     preProcessor(sn: BackendTodo) {
 *         return {
 *             text: sn.text || "";
 *         }
 *     },
 *     // from instance to snapshot
 *     postProcessor(sn): BackendTodo {
 *         return {
 *             text: !sn.text ? null : sn.text
 *         }
 *     }
 * })
 * ```
 *
 * @param type Type to run the processors over.
 * @param processors Processors to run.
 * @param name Type name, or undefined to inherit the inner type one.
 * @returns
 */


function snapshotProcessor(type, processors, name) {
  assertIsType(type, 1);

  if (devMode()) {
    if (processors.postProcessor && typeof processors.postProcessor !== "function") {
      // istanbul ignore next
      throw fail("postSnapshotProcessor must be a function");
    }

    if (processors.preProcessor && typeof processors.preProcessor !== "function") {
      // istanbul ignore next
      throw fail("preSnapshotProcessor must be a function");
    }
  }

  return new SnapshotProcessor(type, processors, name);
}

var needsIdentifierError = "Map.put can only be used to store complex values that have an identifier type attribute";

function tryCollectModelTypes(type, modelTypes) {
  var e_1, _a;

  var subtypes = type.getSubTypes();

  if (subtypes === cannotDetermineSubtype) {
    return false;
  }

  if (subtypes) {
    var subtypesArray = asArray(subtypes);

    try {
      for (var subtypesArray_1 = __values(subtypesArray), subtypesArray_1_1 = subtypesArray_1.next(); !subtypesArray_1_1.done; subtypesArray_1_1 = subtypesArray_1.next()) {
        var subtype = subtypesArray_1_1.value;
        if (!tryCollectModelTypes(subtype, modelTypes)) return false;
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (subtypesArray_1_1 && !subtypesArray_1_1.done && (_a = subtypesArray_1.return)) _a.call(subtypesArray_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  }

  if (type instanceof ModelType) {
    modelTypes.push(type);
  }

  return true;
}
/**
 * @internal
 * @hidden
 */


var MapIdentifierMode;

(function (MapIdentifierMode) {
  MapIdentifierMode[MapIdentifierMode["UNKNOWN"] = 0] = "UNKNOWN";
  MapIdentifierMode[MapIdentifierMode["YES"] = 1] = "YES";
  MapIdentifierMode[MapIdentifierMode["NO"] = 2] = "NO";
})(MapIdentifierMode || (MapIdentifierMode = {}));

var MSTMap =
/** @class */
function (_super) {
  __extends(MSTMap, _super);

  function MSTMap(initialData) {
    return _super.call(this, initialData, mobx__WEBPACK_IMPORTED_MODULE_0__["observable"].ref.enhancer) || this;
  }

  Object.defineProperty(MSTMap.prototype, "get", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (key) {
      // maybe this is over-enthousiastic? normalize numeric keys to strings
      return _super.prototype.get.call(this, "" + key);
    }
  });
  Object.defineProperty(MSTMap.prototype, "has", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (key) {
      return _super.prototype.has.call(this, "" + key);
    }
  });
  Object.defineProperty(MSTMap.prototype, "delete", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (key) {
      return _super.prototype.delete.call(this, "" + key);
    }
  });
  Object.defineProperty(MSTMap.prototype, "set", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (key, value) {
      return _super.prototype.set.call(this, "" + key, value);
    }
  });
  Object.defineProperty(MSTMap.prototype, "put", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value) {
      if (!value) throw fail$1("Map.put cannot be used to set empty values");

      if (isStateTreeNode(value)) {
        var node = getStateTreeNode(value);

        if (devMode()) {
          if (!node.identifierAttribute) {
            throw fail$1(needsIdentifierError);
          }
        }

        if (node.identifier === null) {
          throw fail$1(needsIdentifierError);
        }

        this.set(node.identifier, value);
        return value;
      } else if (!isMutable(value)) {
        throw fail$1("Map.put can only be used to store complex values");
      } else {
        var mapNode = getStateTreeNode(this);
        var mapType = mapNode.type;

        if (mapType.identifierMode !== MapIdentifierMode.YES) {
          throw fail$1(needsIdentifierError);
        }

        var idAttr = mapType.mapIdentifierAttribute;
        var id = value[idAttr];

        if (!isValidIdentifier(id)) {
          // try again but this time after creating a node for the value
          // since it might be an optional identifier
          var newNode = this.put(mapType.getChildType().create(value, mapNode.environment));
          return this.put(getSnapshot(newNode));
        }

        var key = normalizeIdentifier(id);
        this.set(key, value);
        return this.get(key);
      }
    }
  });
  return MSTMap;
}(mobx__WEBPACK_IMPORTED_MODULE_0__["ObservableMap"]);
/**
 * @internal
 * @hidden
 */


var MapType =
/** @class */
function (_super) {
  __extends(MapType, _super);

  function MapType(name, _subType, hookInitializers) {
    if (hookInitializers === void 0) {
      hookInitializers = [];
    }

    var _this = _super.call(this, name) || this;

    Object.defineProperty(_this, "_subType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _subType
    });
    Object.defineProperty(_this, "identifierMode", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: MapIdentifierMode.UNKNOWN
    });
    Object.defineProperty(_this, "mapIdentifierAttribute", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(_this, "flags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: TypeFlags.Map
    });
    Object.defineProperty(_this, "hookInitializers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });

    _this._determineIdentifierMode();

    _this.hookInitializers = hookInitializers;
    return _this;
  }

  Object.defineProperty(MapType.prototype, "hooks", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (hooks) {
      var hookInitializers = this.hookInitializers.length > 0 ? this.hookInitializers.concat(hooks) : [hooks];
      return new MapType(this.name, this._subType, hookInitializers);
    }
  });
  Object.defineProperty(MapType.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, initialValue) {
      this._determineIdentifierMode();

      return createObjectNode(this, parent, subpath, environment, initialValue);
    }
  });
  Object.defineProperty(MapType.prototype, "_determineIdentifierMode", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      if (this.identifierMode !== MapIdentifierMode.UNKNOWN) {
        return;
      }

      var modelTypes = [];

      if (tryCollectModelTypes(this._subType, modelTypes)) {
        var identifierAttribute_1 = undefined;
        modelTypes.forEach(function (type) {
          if (type.identifierAttribute) {
            if (identifierAttribute_1 && identifierAttribute_1 !== type.identifierAttribute) {
              throw fail$1("The objects in a map should all have the same identifier attribute, expected '" + identifierAttribute_1 + "', but child of type '" + type.name + "' declared attribute '" + type.identifierAttribute + "' as identifier");
            }

            identifierAttribute_1 = type.identifierAttribute;
          }
        });

        if (identifierAttribute_1) {
          this.identifierMode = MapIdentifierMode.YES;
          this.mapIdentifierAttribute = identifierAttribute_1;
        } else {
          this.identifierMode = MapIdentifierMode.NO;
        }
      }
    }
  });
  Object.defineProperty(MapType.prototype, "initializeChildNodes", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (objNode, initialSnapshot) {
      if (initialSnapshot === void 0) {
        initialSnapshot = {};
      }

      var subType = objNode.type._subType;
      var result = {};
      Object.keys(initialSnapshot).forEach(function (name) {
        result[name] = subType.instantiate(objNode, name, undefined, initialSnapshot[name]);
      });
      return result;
    }
  });
  Object.defineProperty(MapType.prototype, "createNewInstance", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (childNodes) {
      return new MSTMap(childNodes);
    }
  });
  Object.defineProperty(MapType.prototype, "finalizeNewInstance", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, instance) {
      Object(mobx__WEBPACK_IMPORTED_MODULE_0__["_interceptReads"])(instance, node.unbox);

      var type = node.type;
      type.hookInitializers.forEach(function (initializer) {
        var hooks = initializer(instance);
        Object.keys(hooks).forEach(function (name) {
          var hook = hooks[name];
          var actionInvoker = createActionInvoker(instance, name, hook);
          (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);
        });
      });
      Object(mobx__WEBPACK_IMPORTED_MODULE_0__["intercept"])(instance, this.willChange);
      Object(mobx__WEBPACK_IMPORTED_MODULE_0__["observe"])(instance, this.didChange);
    }
  });
  Object.defineProperty(MapType.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return "Map<string, " + this._subType.describe() + ">";
    }
  });
  Object.defineProperty(MapType.prototype, "getChildren", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      // return (node.storedValue as ObservableMap<any>).values()
      return Object(mobx__WEBPACK_IMPORTED_MODULE_0__["values"])(node.storedValue);
    }
  });
  Object.defineProperty(MapType.prototype, "getChildNode", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, key) {
      var childNode = node.storedValue.get("" + key);
      if (!childNode) throw fail$1("Not a child " + key);
      return childNode;
    }
  });
  Object.defineProperty(MapType.prototype, "willChange", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (change) {
      var node = getStateTreeNode(change.object);
      var key = change.name;
      node.assertWritable({
        subpath: key
      });
      var mapType = node.type;
      var subType = mapType._subType;

      switch (change.type) {
        case "update":
          {
            var newValue = change.newValue;
            var oldValue = change.object.get(key);
            if (newValue === oldValue) return null;
            typecheckInternal(subType, newValue);
            change.newValue = subType.reconcile(node.getChildNode(key), change.newValue, node, key);
            mapType.processIdentifier(key, change.newValue);
          }
          break;

        case "add":
          {
            typecheckInternal(subType, change.newValue);
            change.newValue = subType.instantiate(node, key, undefined, change.newValue);
            mapType.processIdentifier(key, change.newValue);
          }
          break;
      }

      return change;
    }
  });
  Object.defineProperty(MapType.prototype, "processIdentifier", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (expected, node) {
      if (this.identifierMode === MapIdentifierMode.YES && node instanceof ObjectNode) {
        var identifier = node.identifier;
        if (identifier !== expected) throw fail$1("A map of objects containing an identifier should always store the object under their own identifier. Trying to store key '" + identifier + "', but expected: '" + expected + "'");
      }
    }
  });
  Object.defineProperty(MapType.prototype, "getSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      var res = {};
      node.getChildren().forEach(function (childNode) {
        res[childNode.subpath] = childNode.snapshot;
      });
      return res;
    }
  });
  Object.defineProperty(MapType.prototype, "processInitialSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (childNodes) {
      var processed = {};
      Object.keys(childNodes).forEach(function (key) {
        processed[key] = childNodes[key].getSnapshot();
      });
      return processed;
    }
  });
  Object.defineProperty(MapType.prototype, "didChange", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (change) {
      var node = getStateTreeNode(change.object);

      switch (change.type) {
        case "update":
          return void node.emitPatch({
            op: "replace",
            path: escapeJsonPath(change.name),
            value: change.newValue.snapshot,
            oldValue: change.oldValue ? change.oldValue.snapshot : undefined
          }, node);

        case "add":
          return void node.emitPatch({
            op: "add",
            path: escapeJsonPath(change.name),
            value: change.newValue.snapshot,
            oldValue: undefined
          }, node);

        case "delete":
          // a node got deleted, get the old snapshot and make the node die
          var oldSnapshot = change.oldValue.snapshot;
          change.oldValue.die(); // emit the patch

          return void node.emitPatch({
            op: "remove",
            path: escapeJsonPath(change.name),
            oldValue: oldSnapshot
          }, node);
      }
    }
  });
  Object.defineProperty(MapType.prototype, "applyPatchLocally", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, subpath, patch) {
      var target = node.storedValue;

      switch (patch.op) {
        case "add":
        case "replace":
          target.set(subpath, patch.value);
          break;

        case "remove":
          target.delete(subpath);
          break;
      }
    }
  });
  Object.defineProperty(MapType.prototype, "applySnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, snapshot) {
      typecheckInternal(this, snapshot);
      var target = node.storedValue;
      var currentKeys = {};
      Array.from(target.keys()).forEach(function (key) {
        currentKeys[key] = false;
      });

      if (snapshot) {
        // Don't use target.replace, as it will throw away all existing items first
        for (var key in snapshot) {
          target.set(key, snapshot[key]);
          currentKeys["" + key] = true;
        }
      }

      Object.keys(currentKeys).forEach(function (key) {
        if (currentKeys[key] === false) target.delete(key);
      });
    }
  });
  Object.defineProperty(MapType.prototype, "getChildType", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this._subType;
    }
  });
  Object.defineProperty(MapType.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      var _this = this;

      if (!isPlainObject(value)) {
        return typeCheckFailure(context, value, "Value is not a plain object");
      }

      return flattenTypeErrors(Object.keys(value).map(function (path) {
        return _this._subType.validate(value[path], getContextForPath(context, path, _this._subType));
      }));
    }
  });
  Object.defineProperty(MapType.prototype, "getDefaultSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return EMPTY_OBJECT;
    }
  });
  Object.defineProperty(MapType.prototype, "removeChild", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, subpath) {
      node.storedValue.delete(subpath);
    }
  });
  return MapType;
}(ComplexType);

MapType.prototype.applySnapshot = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["action"])(MapType.prototype.applySnapshot);
/**
 * `types.map` - Creates a key based collection type who's children are all of a uniform declared type.
 * If the type stored in a map has an identifier, it is mandatory to store the child under that identifier in the map.
 *
 * This type will always produce [observable maps](https://mobx.js.org/refguide/map.html)
 *
 * Example:
 * ```ts
 * const Todo = types.model({
 *   id: types.identifier,
 *   task: types.string
 * })
 *
 * const TodoStore = types.model({
 *   todos: types.map(Todo)
 * })
 *
 * const s = TodoStore.create({ todos: {} })
 * unprotect(s)
 * s.todos.set(17, { task: "Grab coffee", id: 17 })
 * s.todos.put({ task: "Grab cookie", id: 18 }) // put will infer key from the identifier
 * console.log(s.todos.get(17).task) // prints: "Grab coffee"
 * ```
 *
 * @param subtype
 * @returns
 */

function map(subtype) {
  return new MapType("map<string, " + subtype.name + ">", subtype);
}
/**
 * Returns if a given value represents a map type.
 *
 * @param type
 * @returns `true` if it is a map type.
 */


function isMapType(type) {
  return isType(type) && (type.flags & TypeFlags.Map) > 0;
}
/**
 * @internal
 * @hidden
 */


var ArrayType =
/** @class */
function (_super) {
  __extends(ArrayType, _super);

  function ArrayType(name, _subType, hookInitializers) {
    if (hookInitializers === void 0) {
      hookInitializers = [];
    }

    var _this = _super.call(this, name) || this;

    Object.defineProperty(_this, "_subType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _subType
    });
    Object.defineProperty(_this, "flags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: TypeFlags.Array
    });
    Object.defineProperty(_this, "hookInitializers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    _this.hookInitializers = hookInitializers;
    return _this;
  }

  Object.defineProperty(ArrayType.prototype, "hooks", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (hooks) {
      var hookInitializers = this.hookInitializers.length > 0 ? this.hookInitializers.concat(hooks) : [hooks];
      return new ArrayType(this.name, this._subType, hookInitializers);
    }
  });
  Object.defineProperty(ArrayType.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, initialValue) {
      return createObjectNode(this, parent, subpath, environment, initialValue);
    }
  });
  Object.defineProperty(ArrayType.prototype, "initializeChildNodes", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (objNode, snapshot) {
      if (snapshot === void 0) {
        snapshot = [];
      }

      var subType = objNode.type._subType;
      var result = {};
      snapshot.forEach(function (item, index) {
        var subpath = "" + index;
        result[subpath] = subType.instantiate(objNode, subpath, undefined, item);
      });
      return result;
    }
  });
  Object.defineProperty(ArrayType.prototype, "createNewInstance", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (childNodes) {
      return mobx__WEBPACK_IMPORTED_MODULE_0__["observable"].array(convertChildNodesToArray(childNodes), mobxShallow);
    }
  });
  Object.defineProperty(ArrayType.prototype, "finalizeNewInstance", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, instance) {
      Object(mobx__WEBPACK_IMPORTED_MODULE_0__["_getAdministration"])(instance).dehancer = node.unbox;
      var type = node.type;
      type.hookInitializers.forEach(function (initializer) {
        var hooks = initializer(instance);
        Object.keys(hooks).forEach(function (name) {
          var hook = hooks[name];
          var actionInvoker = createActionInvoker(instance, name, hook);
          (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);
        });
      });
      Object(mobx__WEBPACK_IMPORTED_MODULE_0__["intercept"])(instance, this.willChange);
      Object(mobx__WEBPACK_IMPORTED_MODULE_0__["observe"])(instance, this.didChange);
    }
  });
  Object.defineProperty(ArrayType.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this._subType.describe() + "[]";
    }
  });
  Object.defineProperty(ArrayType.prototype, "getChildren", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      return node.storedValue.slice();
    }
  });
  Object.defineProperty(ArrayType.prototype, "getChildNode", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, key) {
      var index = Number(key);
      if (index < node.storedValue.length) return node.storedValue[index];
      throw fail$1("Not a child: " + key);
    }
  });
  Object.defineProperty(ArrayType.prototype, "willChange", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (change) {
      var node = getStateTreeNode(change.object);
      node.assertWritable({
        subpath: "" + change.index
      });
      var subType = node.type._subType;
      var childNodes = node.getChildren();

      switch (change.type) {
        case "update":
          {
            if (change.newValue === change.object[change.index]) return null;
            var updatedNodes = reconcileArrayChildren(node, subType, [childNodes[change.index]], [change.newValue], [change.index]);

            if (!updatedNodes) {
              return null;
            }

            change.newValue = updatedNodes[0];
          }
          break;

        case "splice":
          {
            var index_1 = change.index,
                removedCount = change.removedCount,
                added = change.added;
            var addedNodes = reconcileArrayChildren(node, subType, childNodes.slice(index_1, index_1 + removedCount), added, added.map(function (_, i) {
              return index_1 + i;
            }));

            if (!addedNodes) {
              return null;
            }

            change.added = addedNodes; // update paths of remaining items

            for (var i = index_1 + removedCount; i < childNodes.length; i++) {
              childNodes[i].setParent(node, "" + (i + added.length - removedCount));
            }
          }
          break;
      }

      return change;
    }
  });
  Object.defineProperty(ArrayType.prototype, "getSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      return node.getChildren().map(function (childNode) {
        return childNode.snapshot;
      });
    }
  });
  Object.defineProperty(ArrayType.prototype, "processInitialSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (childNodes) {
      var processed = [];
      Object.keys(childNodes).forEach(function (key) {
        processed.push(childNodes[key].getSnapshot());
      });
      return processed;
    }
  });
  Object.defineProperty(ArrayType.prototype, "didChange", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (change) {
      var node = getStateTreeNode(change.object);

      switch (change.type) {
        case "update":
          return void node.emitPatch({
            op: "replace",
            path: "" + change.index,
            value: change.newValue.snapshot,
            oldValue: change.oldValue ? change.oldValue.snapshot : undefined
          }, node);

        case "splice":
          for (var i = change.removedCount - 1; i >= 0; i--) node.emitPatch({
            op: "remove",
            path: "" + (change.index + i),
            oldValue: change.removed[i].snapshot
          }, node);

          for (var i = 0; i < change.addedCount; i++) node.emitPatch({
            op: "add",
            path: "" + (change.index + i),
            value: node.getChildNode("" + (change.index + i)).snapshot,
            oldValue: undefined
          }, node);

          return;
      }
    }
  });
  Object.defineProperty(ArrayType.prototype, "applyPatchLocally", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, subpath, patch) {
      var target = node.storedValue;
      var index = subpath === "-" ? target.length : Number(subpath);

      switch (patch.op) {
        case "replace":
          target[index] = patch.value;
          break;

        case "add":
          target.splice(index, 0, patch.value);
          break;

        case "remove":
          target.splice(index, 1);
          break;
      }
    }
  });
  Object.defineProperty(ArrayType.prototype, "applySnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, snapshot) {
      typecheckInternal(this, snapshot);
      var target = node.storedValue;
      target.replace(snapshot);
    }
  });
  Object.defineProperty(ArrayType.prototype, "getChildType", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this._subType;
    }
  });
  Object.defineProperty(ArrayType.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      var _this = this;

      if (!isArray(value)) {
        return typeCheckFailure(context, value, "Value is not an array");
      }

      return flattenTypeErrors(value.map(function (item, index) {
        return _this._subType.validate(item, getContextForPath(context, "" + index, _this._subType));
      }));
    }
  });
  Object.defineProperty(ArrayType.prototype, "getDefaultSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return EMPTY_ARRAY;
    }
  });
  Object.defineProperty(ArrayType.prototype, "removeChild", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, subpath) {
      node.storedValue.splice(Number(subpath), 1);
    }
  });
  return ArrayType;
}(ComplexType);

ArrayType.prototype.applySnapshot = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["action"])(ArrayType.prototype.applySnapshot);
/**
 * `types.array` - Creates an index based collection type who's children are all of a uniform declared type.
 *
 * This type will always produce [observable arrays](https://mobx.js.org/refguide/array.html)
 *
 * Example:
 * ```ts
 * const Todo = types.model({
 *   task: types.string
 * })
 *
 * const TodoStore = types.model({
 *   todos: types.array(Todo)
 * })
 *
 * const s = TodoStore.create({ todos: [] })
 * unprotect(s) // needed to allow modifying outside of an action
 * s.todos.push({ task: "Grab coffee" })
 * console.log(s.todos[0]) // prints: "Grab coffee"
 * ```
 *
 * @param subtype
 * @returns
 */

function array(subtype) {
  assertIsType(subtype, 1);
  return new ArrayType(subtype.name + "[]", subtype);
}

function reconcileArrayChildren(parent, childType, oldNodes, newValues, newPaths) {
  var nothingChanged = true;

  for (var i = 0;; i++) {
    var hasNewNode = i <= newValues.length - 1;
    var oldNode = oldNodes[i];
    var newValue = hasNewNode ? newValues[i] : undefined;
    var newPath = "" + newPaths[i]; // for some reason, instead of newValue we got a node, fallback to the storedValue
    // TODO: https://github.com/mobxjs/mobx-state-tree/issues/340#issuecomment-325581681

    if (isNode(newValue)) newValue = newValue.storedValue;

    if (!oldNode && !hasNewNode) {
      // both are empty, end
      break;
    } else if (!hasNewNode) {
      // new one does not exists
      nothingChanged = false;
      oldNodes.splice(i, 1);

      if (oldNode instanceof ObjectNode) {
        // since it is going to be returned by pop/splice/shift better create it before killing it
        // so it doesn't end up in an undead state
        oldNode.createObservableInstanceIfNeeded();
      }

      oldNode.die();
      i--;
    } else if (!oldNode) {
      // there is no old node, create it
      // check if already belongs to the same parent. if so, avoid pushing item in. only swapping can occur.
      if (isStateTreeNode(newValue) && getStateTreeNode(newValue).parent === parent) {
        // this node is owned by this parent, but not in the reconcilable set, so it must be double
        throw fail$1("Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '" + parent.path + "/" + newPath + "', but it lives already at '" + getStateTreeNode(newValue).path + "'");
      }

      nothingChanged = false;
      var newNode = valueAsNode(childType, parent, newPath, newValue);
      oldNodes.splice(i, 0, newNode);
    } else if (areSame(oldNode, newValue)) {
      // both are the same, reconcile
      oldNodes[i] = valueAsNode(childType, parent, newPath, newValue, oldNode);
    } else {
      // nothing to do, try to reorder
      var oldMatch = undefined; // find a possible candidate to reuse

      for (var j = i; j < oldNodes.length; j++) {
        if (areSame(oldNodes[j], newValue)) {
          oldMatch = oldNodes.splice(j, 1)[0];
          break;
        }
      }

      nothingChanged = false;
      var newNode = valueAsNode(childType, parent, newPath, newValue, oldMatch);
      oldNodes.splice(i, 0, newNode);
    }
  }

  return nothingChanged ? null : oldNodes;
}
/**
 * Convert a value to a node at given parent and subpath. Attempts to reuse old node if possible and given.
 */


function valueAsNode(childType, parent, subpath, newValue, oldNode) {
  // ensure the value is valid-ish
  typecheckInternal(childType, newValue);

  function getNewNode() {
    // the new value has a MST node
    if (isStateTreeNode(newValue)) {
      var childNode = getStateTreeNode(newValue);
      childNode.assertAlive(EMPTY_OBJECT); // the node lives here

      if (childNode.parent !== null && childNode.parent === parent) {
        childNode.setParent(parent, subpath);
        return childNode;
      }
    } // there is old node and new one is a value/snapshot


    if (oldNode) {
      return childType.reconcile(oldNode, newValue, parent, subpath);
    } // nothing to do, create from scratch


    return childType.instantiate(parent, subpath, undefined, newValue);
  }

  var newNode = getNewNode();

  if (oldNode && oldNode !== newNode) {
    if (oldNode instanceof ObjectNode) {
      // since it is going to be returned by pop/splice/shift better create it before killing it
      // so it doesn't end up in an undead state
      oldNode.createObservableInstanceIfNeeded();
    }

    oldNode.die();
  }

  return newNode;
}
/**
 * Check if a node holds a value.
 */


function areSame(oldNode, newValue) {
  // never consider dead old nodes for reconciliation
  if (!oldNode.isAlive) {
    return false;
  } // the new value has the same node


  if (isStateTreeNode(newValue)) {
    var newNode = getStateTreeNode(newValue);
    return newNode.isAlive && newNode === oldNode;
  } // the provided value is the snapshot of the old node


  if (oldNode.snapshot === newValue) {
    return true;
  } // new value is a snapshot with the correct identifier


  return oldNode instanceof ObjectNode && oldNode.identifier !== null && oldNode.identifierAttribute && isPlainObject(newValue) && oldNode.identifier === normalizeIdentifier(newValue[oldNode.identifierAttribute]) && oldNode.type.is(newValue);
}
/**
 * Returns if a given value represents an array type.
 *
 * @param type
 * @returns `true` if the type is an array type.
 */


function isArrayType(type) {
  return isType(type) && (type.flags & TypeFlags.Array) > 0;
}

var PRE_PROCESS_SNAPSHOT = "preProcessSnapshot";
var POST_PROCESS_SNAPSHOT = "postProcessSnapshot";

function objectTypeToString() {
  return getStateTreeNode(this).toString();
}

var defaultObjectOptions = {
  name: "AnonymousModel",
  properties: {},
  initializers: EMPTY_ARRAY
};

function toPropertiesObject(declaredProps) {
  // loop through properties and ensures that all items are types
  return Object.keys(declaredProps).reduce(function (props, key) {
    var _a, _b, _c; // warn if user intended a HOOK


    if (key in Hook) throw fail$1("Hook '" + key + "' was defined as property. Hooks should be defined as part of the actions"); // the user intended to use a view

    var descriptor = Object.getOwnPropertyDescriptor(props, key);

    if ("get" in descriptor) {
      throw fail$1("Getters are not supported as properties. Please use views instead");
    } // undefined and null are not valid


    var value = descriptor.value;

    if (value === null || value === undefined) {
      throw fail$1("The default value of an attribute cannot be null or undefined as the type cannot be inferred. Did you mean `types.maybe(someType)`?"); // its a primitive, convert to its type
    } else if (isPrimitive(value)) {
      return Object.assign({}, props, (_a = {}, _a[key] = optional(getPrimitiveFactoryFromValue(value), value), _a)); // map defaults to empty object automatically for models
    } else if (value instanceof MapType) {
      return Object.assign({}, props, (_b = {}, _b[key] = optional(value, {}), _b));
    } else if (value instanceof ArrayType) {
      return Object.assign({}, props, (_c = {}, _c[key] = optional(value, []), _c)); // its already a type
    } else if (isType(value)) {
      return props; // its a function, maybe the user wanted a view?
    } else if (devMode() && typeof value === "function") {
      throw fail$1("Invalid type definition for property '" + key + "', it looks like you passed a function. Did you forget to invoke it, or did you intend to declare a view / action?"); // no other complex values
    } else if (devMode() && typeof value === "object") {
      throw fail$1("Invalid type definition for property '" + key + "', it looks like you passed an object. Try passing another model type or a types.frozen."); // WTF did you pass in mate?
    } else {
      throw fail$1("Invalid type definition for property '" + key + "', cannot infer a type from a value like '" + value + "' (" + typeof value + ")");
    }
  }, declaredProps);
}
/**
 * @internal
 * @hidden
 */


var ModelType =
/** @class */
function (_super) {
  __extends(ModelType, _super);

  function ModelType(opts) {
    var _this = _super.call(this, opts.name || defaultObjectOptions.name) || this;

    Object.defineProperty(_this, "flags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: TypeFlags.Object
    });
    /*
     * The original object definition
     */

    Object.defineProperty(_this, "initializers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "properties", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "preProcessor", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "postProcessor", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "propertyNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "named", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: function (name) {
        return _this.cloneAndEnhance({
          name: name
        });
      }
    });
    Object.defineProperty(_this, "props", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: function (properties) {
        return _this.cloneAndEnhance({
          properties: properties
        });
      }
    });
    Object.defineProperty(_this, "preProcessSnapshot", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: function (preProcessor) {
        var currentPreprocessor = _this.preProcessor;
        if (!currentPreprocessor) return _this.cloneAndEnhance({
          preProcessor: preProcessor
        });else return _this.cloneAndEnhance({
          preProcessor: function (snapshot) {
            return currentPreprocessor(preProcessor(snapshot));
          }
        });
      }
    });
    Object.defineProperty(_this, "postProcessSnapshot", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: function (postProcessor) {
        var currentPostprocessor = _this.postProcessor;
        if (!currentPostprocessor) return _this.cloneAndEnhance({
          postProcessor: postProcessor
        });else return _this.cloneAndEnhance({
          postProcessor: function (snapshot) {
            return postProcessor(currentPostprocessor(snapshot));
          }
        });
      }
    });
    Object.assign(_this, defaultObjectOptions, opts); // ensures that any default value gets converted to its related type

    _this.properties = toPropertiesObject(_this.properties);
    freeze(_this.properties); // make sure nobody messes with it

    _this.propertyNames = Object.keys(_this.properties);
    _this.identifierAttribute = _this._getIdentifierAttribute();
    return _this;
  }

  Object.defineProperty(ModelType.prototype, "_getIdentifierAttribute", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      var identifierAttribute = undefined;
      this.forAllProps(function (propName, propType) {
        if (propType.flags & TypeFlags.Identifier) {
          if (identifierAttribute) throw fail$1("Cannot define property '" + propName + "' as object identifier, property '" + identifierAttribute + "' is already defined as identifier property");
          identifierAttribute = propName;
        }
      });
      return identifierAttribute;
    }
  });
  Object.defineProperty(ModelType.prototype, "cloneAndEnhance", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (opts) {
      return new ModelType({
        name: opts.name || this.name,
        properties: Object.assign({}, this.properties, opts.properties),
        initializers: this.initializers.concat(opts.initializers || []),
        preProcessor: opts.preProcessor || this.preProcessor,
        postProcessor: opts.postProcessor || this.postProcessor
      });
    }
  });
  Object.defineProperty(ModelType.prototype, "actions", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (fn) {
      var _this = this;

      var actionInitializer = function (self) {
        _this.instantiateActions(self, fn(self));

        return self;
      };

      return this.cloneAndEnhance({
        initializers: [actionInitializer]
      });
    }
  });
  Object.defineProperty(ModelType.prototype, "instantiateActions", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (self, actions) {
      // check if return is correct
      if (!isPlainObject(actions)) throw fail$1("actions initializer should return a plain object containing actions"); // bind actions to the object created

      Object.keys(actions).forEach(function (name) {
        // warn if preprocessor was given
        if (name === PRE_PROCESS_SNAPSHOT) throw fail$1("Cannot define action '" + PRE_PROCESS_SNAPSHOT + "', it should be defined using 'type.preProcessSnapshot(fn)' instead"); // warn if postprocessor was given

        if (name === POST_PROCESS_SNAPSHOT) throw fail$1("Cannot define action '" + POST_PROCESS_SNAPSHOT + "', it should be defined using 'type.postProcessSnapshot(fn)' instead");
        var action2 = actions[name]; // apply hook composition

        var baseAction = self[name];

        if (name in Hook && baseAction) {
          var specializedAction_1 = action2;

          action2 = function () {
            baseAction.apply(null, arguments);
            specializedAction_1.apply(null, arguments);
          };
        } // the goal of this is to make sure actions using "this" can call themselves,
        // while still allowing the middlewares to register them


        var middlewares = action2.$mst_middleware; // make sure middlewares are not lost

        var boundAction = action2.bind(actions);
        boundAction.$mst_middleware = middlewares;
        var actionInvoker = createActionInvoker(self, name, boundAction);
        actions[name] = actionInvoker;
        (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, name, actionInvoker);
      });
    }
  });
  Object.defineProperty(ModelType.prototype, "volatile", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (fn) {
      var _this = this;

      if (typeof fn !== "function") {
        throw fail$1("You passed an " + typeof fn + " to volatile state as an argument, when function is expected");
      }

      var stateInitializer = function (self) {
        _this.instantiateVolatileState(self, fn(self));

        return self;
      };

      return this.cloneAndEnhance({
        initializers: [stateInitializer]
      });
    }
  });
  Object.defineProperty(ModelType.prototype, "instantiateVolatileState", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (self, state) {
      // check views return
      if (!isPlainObject(state)) throw fail$1("volatile state initializer should return a plain object containing state");
      Object(mobx__WEBPACK_IMPORTED_MODULE_0__["set"])(self, state);
    }
  });
  Object.defineProperty(ModelType.prototype, "extend", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (fn) {
      var _this = this;

      var initializer = function (self) {
        var _a = fn(self),
            actions = _a.actions,
            views = _a.views,
            state = _a.state,
            rest = __rest(_a, ["actions", "views", "state"]);

        for (var key in rest) throw fail$1("The `extend` function should return an object with a subset of the fields 'actions', 'views' and 'state'. Found invalid key '" + key + "'");

        if (state) _this.instantiateVolatileState(self, state);
        if (views) _this.instantiateViews(self, views);
        if (actions) _this.instantiateActions(self, actions);
        return self;
      };

      return this.cloneAndEnhance({
        initializers: [initializer]
      });
    }
  });
  Object.defineProperty(ModelType.prototype, "views", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (fn) {
      var _this = this;

      var viewInitializer = function (self) {
        _this.instantiateViews(self, fn(self));

        return self;
      };

      return this.cloneAndEnhance({
        initializers: [viewInitializer]
      });
    }
  });
  Object.defineProperty(ModelType.prototype, "instantiateViews", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (self, views) {
      // check views return
      if (!isPlainObject(views)) throw fail$1("views initializer should return a plain object containing views");
      Object.keys(views).forEach(function (key) {
        var _a; // is this a computed property?


        var descriptor = Object.getOwnPropertyDescriptor(views, key);

        if ("get" in descriptor) {
          if (Object(mobx__WEBPACK_IMPORTED_MODULE_0__["isComputedProp"])(self, key)) {
            var computedValue = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["_getAdministration"])(self, key); // TODO: mobx currently does not allow redefining computes yet, pending #1121
            // FIXME: this binds to the internals of mobx!


            computedValue.derivation = descriptor.get;
            computedValue.scope = self;
            if (descriptor.set) computedValue.setter = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["action"])(computedValue.name + "-setter", descriptor.set);
          } else {
            Object.defineProperty(self, key, descriptor);
            Object(mobx__WEBPACK_IMPORTED_MODULE_0__["makeObservable"])(self, (_a = {}, _a[key] = mobx__WEBPACK_IMPORTED_MODULE_0__["computed"], _a));
          }
        } else if (typeof descriptor.value === "function") {
          (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, key, descriptor.value);
        } else {
          throw fail$1("A view member should either be a function or getter based property");
        }
      });
    }
  });
  Object.defineProperty(ModelType.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, initialValue) {
      var value = isStateTreeNode(initialValue) ? initialValue : this.applySnapshotPreProcessor(initialValue);
      return createObjectNode(this, parent, subpath, environment, value); // Optimization: record all prop- view- and action names after first construction, and generate an optimal base class
      // that pre-reserves all these fields for fast object-member lookups
    }
  });
  Object.defineProperty(ModelType.prototype, "initializeChildNodes", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (objNode, initialSnapshot) {
      if (initialSnapshot === void 0) {
        initialSnapshot = {};
      }

      var type = objNode.type;
      var result = {};
      type.forAllProps(function (name, childType) {
        result[name] = childType.instantiate(objNode, name, undefined, initialSnapshot[name]);
      });
      return result;
    }
  });
  Object.defineProperty(ModelType.prototype, "createNewInstance", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (childNodes) {
      return mobx__WEBPACK_IMPORTED_MODULE_0__["observable"].object(childNodes, EMPTY_OBJECT, mobxShallow);
    }
  });
  Object.defineProperty(ModelType.prototype, "finalizeNewInstance", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, instance) {
      addHiddenFinalProp(instance, "toString", objectTypeToString);
      this.forAllProps(function (name) {
        Object(mobx__WEBPACK_IMPORTED_MODULE_0__["_interceptReads"])(instance, name, node.unbox);
      });
      this.initializers.reduce(function (self, fn) {
        return fn(self);
      }, instance);
      Object(mobx__WEBPACK_IMPORTED_MODULE_0__["intercept"])(instance, this.willChange);
      Object(mobx__WEBPACK_IMPORTED_MODULE_0__["observe"])(instance, this.didChange);
    }
  });
  Object.defineProperty(ModelType.prototype, "willChange", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (chg) {
      // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop
      var change = chg;
      var node = getStateTreeNode(change.object);
      var subpath = change.name;
      node.assertWritable({
        subpath: subpath
      });
      var childType = node.type.properties[subpath]; // only properties are typed, state are stored as-is references

      if (childType) {
        typecheckInternal(childType, change.newValue);
        change.newValue = childType.reconcile(node.getChildNode(subpath), change.newValue, node, subpath);
      }

      return change;
    }
  });
  Object.defineProperty(ModelType.prototype, "didChange", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (chg) {
      // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop
      var change = chg;
      var childNode = getStateTreeNode(change.object);
      var childType = childNode.type.properties[change.name];

      if (!childType) {
        // don't emit patches for volatile state
        return;
      }

      var oldChildValue = change.oldValue ? change.oldValue.snapshot : undefined;
      childNode.emitPatch({
        op: "replace",
        path: escapeJsonPath(change.name),
        value: change.newValue.snapshot,
        oldValue: oldChildValue
      }, childNode);
    }
  });
  Object.defineProperty(ModelType.prototype, "getChildren", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      var _this = this;

      var res = [];
      this.forAllProps(function (name) {
        res.push(_this.getChildNode(node, name));
      });
      return res;
    }
  });
  Object.defineProperty(ModelType.prototype, "getChildNode", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, key) {
      if (!(key in this.properties)) throw fail$1("Not a value property: " + key);

      var adm = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["_getAdministration"])(node.storedValue, key);

      var childNode = adm.raw();
      if (!childNode) throw fail$1("Node not available for property " + key);
      return childNode;
    }
  });
  Object.defineProperty(ModelType.prototype, "getSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, applyPostProcess) {
      var _this = this;

      if (applyPostProcess === void 0) {
        applyPostProcess = true;
      }

      var res = {};
      this.forAllProps(function (name, type) {
        Object(mobx__WEBPACK_IMPORTED_MODULE_0__["getAtom"])(node.storedValue, name).reportObserved();
        res[name] = _this.getChildNode(node, name).snapshot;
      });

      if (applyPostProcess) {
        return this.applySnapshotPostProcessor(res);
      }

      return res;
    }
  });
  Object.defineProperty(ModelType.prototype, "processInitialSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (childNodes) {
      var processed = {};
      Object.keys(childNodes).forEach(function (key) {
        processed[key] = childNodes[key].getSnapshot();
      });
      return this.applySnapshotPostProcessor(processed);
    }
  });
  Object.defineProperty(ModelType.prototype, "applyPatchLocally", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, subpath, patch) {
      if (!(patch.op === "replace" || patch.op === "add")) {
        throw fail$1("object does not support operation " + patch.op);
      }

      node.storedValue[subpath] = patch.value;
    }
  });
  Object.defineProperty(ModelType.prototype, "applySnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, snapshot) {
      var preProcessedSnapshot = this.applySnapshotPreProcessor(snapshot);
      typecheckInternal(this, preProcessedSnapshot);
      this.forAllProps(function (name) {
        node.storedValue[name] = preProcessedSnapshot[name];
      });
    }
  });
  Object.defineProperty(ModelType.prototype, "applySnapshotPreProcessor", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (snapshot) {
      var processor = this.preProcessor;
      return processor ? processor.call(null, snapshot) : snapshot;
    }
  });
  Object.defineProperty(ModelType.prototype, "applySnapshotPostProcessor", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (snapshot) {
      var postProcessor = this.postProcessor;
      if (postProcessor) return postProcessor.call(null, snapshot);
      return snapshot;
    }
  });
  Object.defineProperty(ModelType.prototype, "getChildType", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (propertyName) {
      assertIsString(propertyName, 1);
      return this.properties[propertyName];
    }
  });
  Object.defineProperty(ModelType.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      var _this = this;

      var snapshot = this.applySnapshotPreProcessor(value);

      if (!isPlainObject(snapshot)) {
        return typeCheckFailure(context, snapshot, "Value is not a plain object");
      }

      return flattenTypeErrors(this.propertyNames.map(function (key) {
        return _this.properties[key].validate(snapshot[key], getContextForPath(context, key, _this.properties[key]));
      }));
    }
  });
  Object.defineProperty(ModelType.prototype, "forAllProps", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (fn) {
      var _this = this;

      this.propertyNames.forEach(function (key) {
        return fn(key, _this.properties[key]);
      });
    }
  });
  Object.defineProperty(ModelType.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      var _this = this; // optimization: cache


      return "{ " + this.propertyNames.map(function (key) {
        return key + ": " + _this.properties[key].describe();
      }).join("; ") + " }";
    }
  });
  Object.defineProperty(ModelType.prototype, "getDefaultSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return EMPTY_OBJECT;
    }
  });
  Object.defineProperty(ModelType.prototype, "removeChild", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node, subpath) {
      node.storedValue[subpath] = undefined;
    }
  });
  return ModelType;
}(ComplexType);

ModelType.prototype.applySnapshot = Object(mobx__WEBPACK_IMPORTED_MODULE_0__["action"])(ModelType.prototype.applySnapshot);
/**
 * `types.model` - Creates a new model type by providing a name, properties, volatile state and actions.
 *
 * See the [model type](/concepts/trees#creating-models) description or the [getting started](intro/getting-started.md#getting-started-1) tutorial.
 */

function model() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  var name = typeof args[0] === "string" ? args.shift() : "AnonymousModel";
  var properties = args.shift() || {};
  return new ModelType({
    name: name,
    properties: properties
  });
}
/**
 * `types.compose` - Composes a new model from one or more existing model types.
 * This method can be invoked in two forms:
 * Given 2 or more model types, the types are composed into a new Type.
 * Given first parameter as a string and 2 or more model types,
 * the types are composed into a new Type with the given name
 */


function compose() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  } // TODO: just join the base type names if no name is provided


  var hasTypename = typeof args[0] === "string";
  var typeName = hasTypename ? args[0] : "AnonymousModel";

  if (hasTypename) {
    args.shift();
  } // check all parameters


  if (devMode()) {
    args.forEach(function (type, i) {
      assertArg(type, isModelType, "mobx-state-tree model type", hasTypename ? i + 2 : i + 1);
    });
  }

  return args.reduce(function (prev, cur) {
    return prev.cloneAndEnhance({
      name: prev.name + "_" + cur.name,
      properties: cur.properties,
      initializers: cur.initializers,
      preProcessor: function (snapshot) {
        return cur.applySnapshotPreProcessor(prev.applySnapshotPreProcessor(snapshot));
      },
      postProcessor: function (snapshot) {
        return cur.applySnapshotPostProcessor(prev.applySnapshotPostProcessor(snapshot));
      }
    });
  }).named(typeName);
}
/**
 * Returns if a given value represents a model type.
 *
 * @param type
 * @returns
 */


function isModelType(type) {
  return isType(type) && (type.flags & TypeFlags.Object) > 0;
} // TODO: implement CoreType using types.custom ?

/**
 * @internal
 * @hidden
 */


var CoreType =
/** @class */
function (_super) {
  __extends(CoreType, _super);

  function CoreType(name, flags, checker, initializer) {
    if (initializer === void 0) {
      initializer = identity;
    }

    var _this = _super.call(this, name) || this;

    Object.defineProperty(_this, "flags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: flags
    });
    Object.defineProperty(_this, "checker", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: checker
    });
    Object.defineProperty(_this, "initializer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: initializer
    });
    _this.flags = flags;
    return _this;
  }

  Object.defineProperty(CoreType.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this.name;
    }
  });
  Object.defineProperty(CoreType.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, initialValue) {
      return createScalarNode(this, parent, subpath, environment, initialValue);
    }
  });
  Object.defineProperty(CoreType.prototype, "createNewInstance", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (snapshot) {
      return this.initializer(snapshot);
    }
  });
  Object.defineProperty(CoreType.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      if (isPrimitive(value) && this.checker(value)) {
        return typeCheckSuccess();
      }

      var typeName = this.name === "Date" ? "Date or a unix milliseconds timestamp" : this.name;
      return typeCheckFailure(context, value, "Value is not a " + typeName);
    }
  });
  return CoreType;
}(SimpleType);
/**
 * `types.string` - Creates a type that can only contain a string value.
 * This type is used for string values by default
 *
 * Example:
 * ```ts
 * const Person = types.model({
 *   firstName: types.string,
 *   lastName: "Doe"
 * })
 * ```
 */
// tslint:disable-next-line:variable-name


var string = new CoreType("string", TypeFlags.String, function (v) {
  return typeof v === "string";
});
/**
 * `types.number` - Creates a type that can only contain a numeric value.
 * This type is used for numeric values by default
 *
 * Example:
 * ```ts
 * const Vector = types.model({
 *   x: types.number,
 *   y: 1.5
 * })
 * ```
 */
// tslint:disable-next-line:variable-name

var number = new CoreType("number", TypeFlags.Number, function (v) {
  return typeof v === "number";
});
/**
 * `types.integer` - Creates a type that can only contain an integer value.
 * This type is used for integer values by default
 *
 * Example:
 * ```ts
 * const Size = types.model({
 *   width: types.integer,
 *   height: 10
 * })
 * ```
 */
// tslint:disable-next-line:variable-name

var integer = new CoreType("integer", TypeFlags.Integer, function (v) {
  return isInteger(v);
});
/**
 * `types.boolean` - Creates a type that can only contain a boolean value.
 * This type is used for boolean values by default
 *
 * Example:
 * ```ts
 * const Thing = types.model({
 *   isCool: types.boolean,
 *   isAwesome: false
 * })
 * ```
 */
// tslint:disable-next-line:variable-name

var boolean = new CoreType("boolean", TypeFlags.Boolean, function (v) {
  return typeof v === "boolean";
});
/**
 * `types.null` - The type of the value `null`
 */

var nullType = new CoreType("null", TypeFlags.Null, function (v) {
  return v === null;
});
/**
 * `types.undefined` - The type of the value `undefined`
 */

var undefinedType = new CoreType("undefined", TypeFlags.Undefined, function (v) {
  return v === undefined;
});

var _DatePrimitive = new CoreType("Date", TypeFlags.Date, function (v) {
  return typeof v === "number" || v instanceof Date;
}, function (v) {
  return v instanceof Date ? v : new Date(v);
});

_DatePrimitive.getSnapshot = function (node) {
  return node.storedValue.getTime();
};
/**
 * `types.Date` - Creates a type that can only contain a javascript Date value.
 *
 * Example:
 * ```ts
 * const LogLine = types.model({
 *   timestamp: types.Date,
 * })
 *
 * LogLine.create({ timestamp: new Date() })
 * ```
 */


var DatePrimitive = _DatePrimitive;
/**
 * @internal
 * @hidden
 */

function getPrimitiveFactoryFromValue(value) {
  switch (typeof value) {
    case "string":
      return string;

    case "number":
      return number;
    // In the future, isInteger(value) ? integer : number would be interesting, but would be too breaking for now

    case "boolean":
      return boolean;

    case "object":
      if (value instanceof Date) return DatePrimitive;
  }

  throw fail$1("Cannot determine primitive type from value " + value);
}
/**
 * Returns if a given value represents a primitive type.
 *
 * @param type
 * @returns
 */


function isPrimitiveType(type) {
  return isType(type) && (type.flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.Integer | TypeFlags.Boolean | TypeFlags.Date)) > 0;
}
/**
 * @internal
 * @hidden
 */


var Literal =
/** @class */
function (_super) {
  __extends(Literal, _super);

  function Literal(value) {
    var _this = _super.call(this, JSON.stringify(value)) || this;

    Object.defineProperty(_this, "value", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "flags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: TypeFlags.Literal
    });
    _this.value = value;
    return _this;
  }

  Object.defineProperty(Literal.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, initialValue) {
      return createScalarNode(this, parent, subpath, environment, initialValue);
    }
  });
  Object.defineProperty(Literal.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return JSON.stringify(this.value);
    }
  });
  Object.defineProperty(Literal.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      if (isPrimitive(value) && value === this.value) {
        return typeCheckSuccess();
      }

      return typeCheckFailure(context, value, "Value is not a literal " + JSON.stringify(this.value));
    }
  });
  return Literal;
}(SimpleType);
/**
 * `types.literal` - The literal type will return a type that will match only the exact given type.
 * The given value must be a primitive, in order to be serialized to a snapshot correctly.
 * You can use literal to match exact strings for example the exact male or female string.
 *
 * Example:
 * ```ts
 * const Person = types.model({
 *     name: types.string,
 *     gender: types.union(types.literal('male'), types.literal('female'))
 * })
 * ```
 *
 * @param value The value to use in the strict equal check
 * @returns
 */


function literal(value) {
  // check that the given value is a primitive
  assertArg(value, isPrimitive, "primitive", 1);
  return new Literal(value);
}
/**
 * Returns if a given value represents a literal type.
 *
 * @param type
 * @returns
 */


function isLiteralType(type) {
  return isType(type) && (type.flags & TypeFlags.Literal) > 0;
}

var Refinement =
/** @class */
function (_super) {
  __extends(Refinement, _super);

  function Refinement(name, _subtype, _predicate, _message) {
    var _this = _super.call(this, name) || this;

    Object.defineProperty(_this, "_subtype", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _subtype
    });
    Object.defineProperty(_this, "_predicate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _predicate
    });
    Object.defineProperty(_this, "_message", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _message
    });
    return _this;
  }

  Object.defineProperty(Refinement.prototype, "flags", {
    get: function () {
      return this._subtype.flags | TypeFlags.Refinement;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Refinement.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this.name;
    }
  });
  Object.defineProperty(Refinement.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, initialValue) {
      // create the child type
      return this._subtype.instantiate(parent, subpath, environment, initialValue);
    }
  });
  Object.defineProperty(Refinement.prototype, "isAssignableFrom", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (type) {
      return this._subtype.isAssignableFrom(type);
    }
  });
  Object.defineProperty(Refinement.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      var subtypeErrors = this._subtype.validate(value, context);

      if (subtypeErrors.length > 0) return subtypeErrors;
      var snapshot = isStateTreeNode(value) ? getStateTreeNode(value).snapshot : value;

      if (!this._predicate(snapshot)) {
        return typeCheckFailure(context, value, this._message(value));
      }

      return typeCheckSuccess();
    }
  });
  Object.defineProperty(Refinement.prototype, "reconcile", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (current, newValue, parent, subpath) {
      return this._subtype.reconcile(current, newValue, parent, subpath);
    }
  });
  Object.defineProperty(Refinement.prototype, "getSubTypes", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this._subtype;
    }
  });
  return Refinement;
}(BaseType);
/**
 * `types.refinement` - Creates a type that is more specific than the base type, e.g. `types.refinement(types.string, value => value.length > 5)` to create a type of strings that can only be longer then 5.
 *
 * @param name
 * @param type
 * @param predicate
 * @returns
 */


function refinement() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  var name = typeof args[0] === "string" ? args.shift() : isType(args[0]) ? args[0].name : null;
  var type = args[0];
  var predicate = args[1];
  var message = args[2] ? args[2] : function (v) {
    return "Value does not respect the refinement predicate";
  }; // ensures all parameters are correct

  assertIsType(type, [1, 2]);
  assertIsString(name, 1);
  assertIsFunction(predicate, [2, 3]);
  assertIsFunction(message, [3, 4]);
  return new Refinement(name, type, predicate, message);
}
/**
 * Returns if a given value is a refinement type.
 *
 * @param type
 * @returns
 */


function isRefinementType(type) {
  return (type.flags & TypeFlags.Refinement) > 0;
}
/**
 * `types.enumeration` - Can be used to create an string based enumeration.
 * (note: this methods is just sugar for a union of string literals)
 *
 * Example:
 * ```ts
 * const TrafficLight = types.model({
 *   color: types.enumeration("Color", ["Red", "Orange", "Green"])
 * })
 * ```
 *
 * @param name descriptive name of the enumeration (optional)
 * @param options possible values this enumeration can have
 * @returns
 */


function enumeration(name, options) {
  var realOptions = typeof name === "string" ? options : name; // check all options

  if (devMode()) {
    realOptions.forEach(function (option, i) {
      assertIsString(option, i + 1);
    });
  }

  var type = union.apply(void 0, __spread(realOptions.map(function (option) {
    return literal("" + option);
  })));
  if (typeof name === "string") type.name = name;
  return type;
}
/**
 * @internal
 * @hidden
 */


var Union =
/** @class */
function (_super) {
  __extends(Union, _super);

  function Union(name, _types, options) {
    var _this = _super.call(this, name) || this;

    Object.defineProperty(_this, "_types", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _types
    });
    Object.defineProperty(_this, "_dispatcher", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(_this, "_eager", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    options = __assign({
      eager: true,
      dispatcher: undefined
    }, options);
    _this._dispatcher = options.dispatcher;
    if (!options.eager) _this._eager = false;
    return _this;
  }

  Object.defineProperty(Union.prototype, "flags", {
    get: function () {
      var result = TypeFlags.Union;

      this._types.forEach(function (type) {
        result |= type.flags;
      });

      return result;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Union.prototype, "isAssignableFrom", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (type) {
      return this._types.some(function (subType) {
        return subType.isAssignableFrom(type);
      });
    }
  });
  Object.defineProperty(Union.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return "(" + this._types.map(function (factory) {
        return factory.describe();
      }).join(" | ") + ")";
    }
  });
  Object.defineProperty(Union.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, initialValue) {
      var type = this.determineType(initialValue, undefined);
      if (!type) throw fail$1("No matching type for union " + this.describe()); // can happen in prod builds

      return type.instantiate(parent, subpath, environment, initialValue);
    }
  });
  Object.defineProperty(Union.prototype, "reconcile", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (current, newValue, parent, subpath) {
      var type = this.determineType(newValue, current.type);
      if (!type) throw fail$1("No matching type for union " + this.describe()); // can happen in prod builds

      return type.reconcile(current, newValue, parent, subpath);
    }
  });
  Object.defineProperty(Union.prototype, "determineType", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, reconcileCurrentType) {
      // try the dispatcher, if defined
      if (this._dispatcher) {
        return this._dispatcher(value);
      } // find the most accomodating type
      // if we are using reconciliation try the current node type first (fix for #1045)


      if (reconcileCurrentType) {
        if (reconcileCurrentType.is(value)) {
          return reconcileCurrentType;
        }

        return this._types.filter(function (t) {
          return t !== reconcileCurrentType;
        }).find(function (type) {
          return type.is(value);
        });
      } else {
        return this._types.find(function (type) {
          return type.is(value);
        });
      }
    }
  });
  Object.defineProperty(Union.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      if (this._dispatcher) {
        return this._dispatcher(value).validate(value, context);
      }

      var allErrors = [];
      var applicableTypes = 0;

      for (var i = 0; i < this._types.length; i++) {
        var type = this._types[i];
        var errors = type.validate(value, context);

        if (errors.length === 0) {
          if (this._eager) return typeCheckSuccess();else applicableTypes++;
        } else {
          allErrors.push(errors);
        }
      }

      if (applicableTypes === 1) return typeCheckSuccess();
      return typeCheckFailure(context, value, "No type is applicable for the union").concat(flattenTypeErrors(allErrors));
    }
  });
  Object.defineProperty(Union.prototype, "getSubTypes", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this._types;
    }
  });
  return Union;
}(BaseType);
/**
 * `types.union` - Create a union of multiple types. If the correct type cannot be inferred unambiguously from a snapshot, provide a dispatcher function of the form `(snapshot) => Type`.
 *
 * @param optionsOrType
 * @param otherTypes
 * @returns
 */


function union(optionsOrType) {
  var otherTypes = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    otherTypes[_i - 1] = arguments[_i];
  }

  var options = isType(optionsOrType) ? undefined : optionsOrType;
  var types = isType(optionsOrType) ? __spread([optionsOrType], otherTypes) : otherTypes;
  var name = "(" + types.map(function (type) {
    return type.name;
  }).join(" | ") + ")"; // check all options

  if (devMode()) {
    if (options) {
      assertArg(options, function (o) {
        return isPlainObject(o);
      }, "object { eager?: boolean, dispatcher?: Function }", 1);
    }

    types.forEach(function (type, i) {
      assertIsType(type, options ? i + 2 : i + 1);
    });
  }

  return new Union(name, types, options);
}
/**
 * Returns if a given value represents a union type.
 *
 * @param type
 * @returns
 */


function isUnionType(type) {
  return (type.flags & TypeFlags.Union) > 0;
}
/**
 * @hidden
 * @internal
 */


var OptionalValue =
/** @class */
function (_super) {
  __extends(OptionalValue, _super);

  function OptionalValue(_subtype, _defaultValue, optionalValues) {
    var _this = _super.call(this, _subtype.name) || this;

    Object.defineProperty(_this, "_subtype", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _subtype
    });
    Object.defineProperty(_this, "_defaultValue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _defaultValue
    });
    Object.defineProperty(_this, "optionalValues", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: optionalValues
    });
    return _this;
  }

  Object.defineProperty(OptionalValue.prototype, "flags", {
    get: function () {
      return this._subtype.flags | TypeFlags.Optional;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(OptionalValue.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this._subtype.describe() + "?";
    }
  });
  Object.defineProperty(OptionalValue.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, initialValue) {
      if (this.optionalValues.indexOf(initialValue) >= 0) {
        var defaultInstanceOrSnapshot = this.getDefaultInstanceOrSnapshot();
        return this._subtype.instantiate(parent, subpath, environment, defaultInstanceOrSnapshot);
      }

      return this._subtype.instantiate(parent, subpath, environment, initialValue);
    }
  });
  Object.defineProperty(OptionalValue.prototype, "reconcile", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (current, newValue, parent, subpath) {
      return this._subtype.reconcile(current, this.optionalValues.indexOf(newValue) < 0 && this._subtype.is(newValue) ? newValue : this.getDefaultInstanceOrSnapshot(), parent, subpath);
    }
  });
  Object.defineProperty(OptionalValue.prototype, "getDefaultInstanceOrSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      var defaultInstanceOrSnapshot = typeof this._defaultValue === "function" ? this._defaultValue() : this._defaultValue; // while static values are already snapshots and checked on types.optional
      // generator functions must always be rechecked just in case

      if (typeof this._defaultValue === "function") {
        typecheckInternal(this, defaultInstanceOrSnapshot);
      }

      return defaultInstanceOrSnapshot;
    }
  });
  Object.defineProperty(OptionalValue.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      // defaulted values can be skipped
      if (this.optionalValues.indexOf(value) >= 0) {
        return typeCheckSuccess();
      } // bounce validation to the sub-type


      return this._subtype.validate(value, context);
    }
  });
  Object.defineProperty(OptionalValue.prototype, "isAssignableFrom", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (type) {
      return this._subtype.isAssignableFrom(type);
    }
  });
  Object.defineProperty(OptionalValue.prototype, "getSubTypes", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this._subtype;
    }
  });
  return OptionalValue;
}(BaseType);

function checkOptionalPreconditions(type, defaultValueOrFunction) {
  // make sure we never pass direct instances
  if (typeof defaultValueOrFunction !== "function" && isStateTreeNode(defaultValueOrFunction)) {
    throw fail$1("default value cannot be an instance, pass a snapshot or a function that creates an instance/snapshot instead");
  }

  assertIsType(type, 1);

  if (devMode()) {
    // we only check default values if they are passed directly
    // if they are generator functions they will be checked once they are generated
    // we don't check generator function results here to avoid generating a node just for type-checking purposes
    // which might generate side-effects
    if (typeof defaultValueOrFunction !== "function") {
      typecheckInternal(type, defaultValueOrFunction);
    }
  }
}
/**
 * `types.optional` - Can be used to create a property with a default value.
 *
 * Depending on the third argument (`optionalValues`) there are two ways of operation:
 * - If the argument is not provided, then if a value is not provided in the snapshot (`undefined` or missing),
 *   it will default to the provided `defaultValue`
 * - If the argument is provided, then if the value in the snapshot matches one of the optional values inside the array then it will
 *   default to the provided `defaultValue`. Additionally, if one of the optional values inside the array is `undefined` then a missing
 *   property is also valid.
 *
 *   Note that it is also possible to include values of the same type as the intended subtype as optional values,
 *   in this case the optional value will be transformed into the `defaultValue` (e.g. `types.optional(types.string, "unnamed", [undefined, ""])`
 *   will transform the snapshot values `undefined` (and therefore missing) and empty strings into the string `"unnamed"` when it gets
 *   instantiated).
 *
 * If `defaultValue` is a function, the function will be invoked for every new instance.
 * Applying a snapshot in which the optional value is one of the optional values (or `undefined`/_not_ present if none are provided) causes the
 * value to be reset.
 *
 * Example:
 * ```ts
 * const Todo = types.model({
 *   title: types.string,
 *   subtitle1: types.optional(types.string, "", [null]),
 *   subtitle2: types.optional(types.string, "", [null, undefined]),
 *   done: types.optional(types.boolean, false),
 *   created: types.optional(types.Date, () => new Date()),
 * })
 *
 * // if done is missing / undefined it will become false
 * // if created is missing / undefined it will get a freshly generated timestamp
 * // if subtitle1 is null it will default to "", but it cannot be missing or undefined
 * // if subtitle2 is null or undefined it will default to ""; since it can be undefined it can also be missing
 * const todo = Todo.create({ title: "Get coffee", subtitle1: null })
 * ```
 *
 * @param type
 * @param defaultValueOrFunction
 * @param optionalValues an optional array with zero or more primitive values (string, number, boolean, null or undefined)
 *                       that will be converted into the default. `[ undefined ]` is assumed when none is provided
 * @returns
 */


function optional(type, defaultValueOrFunction, optionalValues) {
  checkOptionalPreconditions(type, defaultValueOrFunction);
  return new OptionalValue(type, defaultValueOrFunction, optionalValues ? optionalValues : undefinedAsOptionalValues);
}

var undefinedAsOptionalValues = [undefined];
/**
 * Returns if a value represents an optional type.
 *
 * @template IT
 * @param type
 * @returns
 */

function isOptionalType(type) {
  return isType(type) && (type.flags & TypeFlags.Optional) > 0;
}

var optionalUndefinedType = optional(undefinedType, undefined);
var optionalNullType = optional(nullType, null);
/**
 * `types.maybe` - Maybe will make a type nullable, and also optional.
 * The value `undefined` will be used to represent nullability.
 *
 * @param type
 * @returns
 */

function maybe(type) {
  assertIsType(type, 1);
  return union(type, optionalUndefinedType);
}
/**
 * `types.maybeNull` - Maybe will make a type nullable, and also optional.
 * The value `null` will be used to represent no value.
 *
 * @param type
 * @returns
 */


function maybeNull(type) {
  assertIsType(type, 1);
  return union(type, optionalNullType);
}

var Late =
/** @class */
function (_super) {
  __extends(Late, _super);

  function Late(name, _definition) {
    var _this = _super.call(this, name) || this;

    Object.defineProperty(_this, "_definition", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _definition
    });
    Object.defineProperty(_this, "_subType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    return _this;
  }

  Object.defineProperty(Late.prototype, "flags", {
    get: function () {
      return (this._subType ? this._subType.flags : 0) | TypeFlags.Late;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Late.prototype, "getSubType", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (mustSucceed) {
      if (!this._subType) {
        var t = undefined;

        try {
          t = this._definition();
        } catch (e) {
          if (e instanceof ReferenceError) // can happen in strict ES5 code when a definition is self refering
            t = undefined;else throw e;
        }

        if (mustSucceed && t === undefined) throw fail$1("Late type seems to be used too early, the definition (still) returns undefined");

        if (t) {
          if (devMode() && !isType(t)) throw fail$1("Failed to determine subtype, make sure types.late returns a type definition.");
          this._subType = t;
        }
      }

      return this._subType;
    }
  });
  Object.defineProperty(Late.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, initialValue) {
      return this.getSubType(true).instantiate(parent, subpath, environment, initialValue);
    }
  });
  Object.defineProperty(Late.prototype, "reconcile", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (current, newValue, parent, subpath) {
      return this.getSubType(true).reconcile(current, newValue, parent, subpath);
    }
  });
  Object.defineProperty(Late.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      var t = this.getSubType(false);
      return t ? t.name : "<uknown late type>";
    }
  });
  Object.defineProperty(Late.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      var t = this.getSubType(false);

      if (!t) {
        // See #916; the variable the definition closure is pointing to wasn't defined yet, so can't be evaluted yet here
        return typeCheckSuccess();
      }

      return t.validate(value, context);
    }
  });
  Object.defineProperty(Late.prototype, "isAssignableFrom", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (type) {
      var t = this.getSubType(false);
      return t ? t.isAssignableFrom(type) : false;
    }
  });
  Object.defineProperty(Late.prototype, "getSubTypes", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      var subtype = this.getSubType(false);
      return subtype ? subtype : cannotDetermineSubtype;
    }
  });
  return Late;
}(BaseType);
/**
 * `types.late` - Defines a type that gets implemented later. This is useful when you have to deal with circular dependencies.
 * Please notice that when defining circular dependencies TypeScript isn't smart enough to inference them.
 *
 * Example:
 * ```ts
 *   // TypeScript isn't smart enough to infer self referencing types.
 *  const Node = types.model({
 *       children: types.array(types.late((): IAnyModelType => Node)) // then typecast each array element to Instance<typeof Node>
 *  })
 * ```
 *
 * @param name The name to use for the type that will be returned.
 * @param type A function that returns the type that will be defined.
 * @returns
 */


function late(nameOrType, maybeType) {
  var name = typeof nameOrType === "string" ? nameOrType : "late(" + nameOrType.toString() + ")";
  var type = typeof nameOrType === "string" ? maybeType : nameOrType; // checks that the type is actually a late type

  if (devMode()) {
    if (!(typeof type === "function" && type.length === 0)) throw fail$1("Invalid late type, expected a function with zero arguments that returns a type, got: " + type);
  }

  return new Late(name, type);
}
/**
 * Returns if a given value represents a late type.
 *
 * @param type
 * @returns
 */


function isLateType(type) {
  return isType(type) && (type.flags & TypeFlags.Late) > 0;
}
/**
 * @internal
 * @hidden
 */


var Frozen =
/** @class */
function (_super) {
  __extends(Frozen, _super);

  function Frozen(subType) {
    var _this = _super.call(this, subType ? "frozen(" + subType.name + ")" : "frozen") || this;

    Object.defineProperty(_this, "subType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: subType
    });
    Object.defineProperty(_this, "flags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: TypeFlags.Frozen
    });
    return _this;
  }

  Object.defineProperty(Frozen.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return "<any immutable value>";
    }
  });
  Object.defineProperty(Frozen.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, value) {
      // create the node
      return createScalarNode(this, parent, subpath, environment, deepFreeze(value));
    }
  });
  Object.defineProperty(Frozen.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      if (!isSerializable(value)) {
        return typeCheckFailure(context, value, "Value is not serializable and cannot be frozen");
      }

      if (this.subType) return this.subType.validate(value, context);
      return typeCheckSuccess();
    }
  });
  return Frozen;
}(SimpleType);

var untypedFrozenInstance = new Frozen();
/**
 * `types.frozen` - Frozen can be used to store any value that is serializable in itself (that is valid JSON).
 * Frozen values need to be immutable or treated as if immutable. They need be serializable as well.
 * Values stored in frozen will snapshotted as-is by MST, and internal changes will not be tracked.
 *
 * This is useful to store complex, but immutable values like vectors etc. It can form a powerful bridge to parts of your application that should be immutable, or that assume data to be immutable.
 *
 * Note: if you want to store free-form state that is mutable, or not serializeable, consider using volatile state instead.
 *
 * Frozen properties can be defined in three different ways
 * 1. `types.frozen(SubType)` - provide a valid MST type and frozen will check if the provided data conforms the snapshot for that type
 * 2. `types.frozen({ someDefaultValue: true})` - provide a primitive value, object or array, and MST will infer the type from that object, and also make it the default value for the field
 * 3. `types.frozen<TypeScriptType>()` - provide a typescript type, to help in strongly typing the field (design time only)
 *
 * Example:
 * ```ts
 * const GameCharacter = types.model({
 *   name: string,
 *   location: types.frozen({ x: 0, y: 0})
 * })
 *
 * const hero = GameCharacter.create({
 *   name: "Mario",
 *   location: { x: 7, y: 4 }
 * })
 *
 * hero.location = { x: 10, y: 2 } // OK
 * hero.location.x = 7 // Not ok!
 * ```
 *
 * ```ts
 * type Point = { x: number, y: number }
 *    const Mouse = types.model({
 *         loc: types.frozen<Point>()
 *    })
 * ```
 *
 * @param defaultValueOrType
 * @returns
 */

function frozen(arg) {
  if (arguments.length === 0) return untypedFrozenInstance;else if (isType(arg)) return new Frozen(arg);else return optional(untypedFrozenInstance, arg);
}
/**
 * Returns if a given value represents a frozen type.
 *
 * @param type
 * @returns
 */


function isFrozenType(type) {
  return isType(type) && (type.flags & TypeFlags.Frozen) > 0;
}

function getInvalidationCause(hook) {
  switch (hook) {
    case Hook.beforeDestroy:
      return "destroy";

    case Hook.beforeDetach:
      return "detach";

    default:
      return undefined;
  }
}

var StoredReference =
/** @class */
function () {
  function StoredReference(value, targetType) {
    Object.defineProperty(this, "targetType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: targetType
    });
    Object.defineProperty(this, "identifier", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "node", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "resolvedReference", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });

    if (isValidIdentifier(value)) {
      this.identifier = value;
    } else if (isStateTreeNode(value)) {
      var targetNode = getStateTreeNode(value);
      if (!targetNode.identifierAttribute) throw fail$1("Can only store references with a defined identifier attribute.");
      var id = targetNode.unnormalizedIdentifier;

      if (id === null || id === undefined) {
        throw fail$1("Can only store references to tree nodes with a defined identifier.");
      }

      this.identifier = id;
    } else {
      throw fail$1("Can only store references to tree nodes or identifiers, got: '" + value + "'");
    }
  }

  Object.defineProperty(StoredReference.prototype, "updateResolvedReference", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      var normalizedId = normalizeIdentifier(this.identifier);
      var root = node.root;
      var lastCacheModification = root.identifierCache.getLastCacheModificationPerId(normalizedId);

      if (!this.resolvedReference || this.resolvedReference.lastCacheModification !== lastCacheModification) {
        var targetType = this.targetType; // reference was initialized with the identifier of the target

        var target = root.identifierCache.resolve(targetType, normalizedId);

        if (!target) {
          throw new InvalidReferenceError("[mobx-state-tree] Failed to resolve reference '" + this.identifier + "' to type '" + this.targetType.name + "' (from node: " + node.path + ")");
        }

        this.resolvedReference = {
          node: target,
          lastCacheModification: lastCacheModification
        };
      }
    }
  });
  Object.defineProperty(StoredReference.prototype, "resolvedValue", {
    get: function () {
      this.updateResolvedReference(this.node);
      return this.resolvedReference.node.value;
    },
    enumerable: false,
    configurable: true
  });
  return StoredReference;
}();
/**
 * @internal
 * @hidden
 */


var InvalidReferenceError =
/** @class */
function (_super) {
  __extends(InvalidReferenceError, _super);

  function InvalidReferenceError(m) {
    var _this = _super.call(this, m) || this;

    Object.setPrototypeOf(_this, InvalidReferenceError.prototype);
    return _this;
  }

  return InvalidReferenceError;
}(Error);
/**
 * @internal
 * @hidden
 */


var BaseReferenceType =
/** @class */
function (_super) {
  __extends(BaseReferenceType, _super);

  function BaseReferenceType(targetType, onInvalidated) {
    var _this = _super.call(this, "reference(" + targetType.name + ")") || this;

    Object.defineProperty(_this, "targetType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: targetType
    });
    Object.defineProperty(_this, "onInvalidated", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: onInvalidated
    });
    Object.defineProperty(_this, "flags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: TypeFlags.Reference
    });
    return _this;
  }

  Object.defineProperty(BaseReferenceType.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this.name;
    }
  });
  Object.defineProperty(BaseReferenceType.prototype, "isAssignableFrom", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (type) {
      return this.targetType.isAssignableFrom(type);
    }
  });
  Object.defineProperty(BaseReferenceType.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      return isValidIdentifier(value) ? typeCheckSuccess() : typeCheckFailure(context, value, "Value is not a valid identifier, which is a string or a number");
    }
  });
  Object.defineProperty(BaseReferenceType.prototype, "fireInvalidated", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (cause, storedRefNode, referenceId, refTargetNode) {
      // to actually invalidate a reference we need an alive parent,
      // since it is a scalar value (immutable-ish) and we need to change it
      // from the parent
      var storedRefParentNode = storedRefNode.parent;

      if (!storedRefParentNode || !storedRefParentNode.isAlive) {
        return;
      }

      var storedRefParentValue = storedRefParentNode.storedValue;

      if (!storedRefParentValue) {
        return;
      }

      this.onInvalidated({
        cause: cause,
        parent: storedRefParentValue,
        invalidTarget: refTargetNode ? refTargetNode.storedValue : undefined,
        invalidId: referenceId,
        replaceRef: function (newRef) {
          applyPatch(storedRefNode.root.storedValue, {
            op: "replace",
            value: newRef,
            path: storedRefNode.path
          });
        },
        removeRef: function () {
          if (isModelType(storedRefParentNode.type)) {
            this.replaceRef(undefined);
          } else {
            applyPatch(storedRefNode.root.storedValue, {
              op: "remove",
              path: storedRefNode.path
            });
          }
        }
      });
    }
  });
  Object.defineProperty(BaseReferenceType.prototype, "addTargetNodeWatcher", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (storedRefNode, referenceId) {
      var _this = this; // this will make sure the target node becomes created


      var refTargetValue = this.getValue(storedRefNode);

      if (!refTargetValue) {
        return undefined;
      }

      var refTargetNode = getStateTreeNode(refTargetValue);

      var hookHandler = function (_, refTargetNodeHook) {
        var cause = getInvalidationCause(refTargetNodeHook);

        if (!cause) {
          return;
        }

        _this.fireInvalidated(cause, storedRefNode, referenceId, refTargetNode);
      };

      var refTargetDetachHookDisposer = refTargetNode.registerHook(Hook.beforeDetach, hookHandler);
      var refTargetDestroyHookDisposer = refTargetNode.registerHook(Hook.beforeDestroy, hookHandler);
      return function () {
        refTargetDetachHookDisposer();
        refTargetDestroyHookDisposer();
      };
    }
  });
  Object.defineProperty(BaseReferenceType.prototype, "watchTargetNodeForInvalidations", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (storedRefNode, identifier, customGetSet) {
      var _this = this;

      if (!this.onInvalidated) {
        return;
      }

      var onRefTargetDestroyedHookDisposer; // get rid of the watcher hook when the stored ref node is destroyed
      // detached is ignored since scalar nodes (where the reference resides) cannot be detached

      storedRefNode.registerHook(Hook.beforeDestroy, function () {
        if (onRefTargetDestroyedHookDisposer) {
          onRefTargetDestroyedHookDisposer();
        }
      });

      var startWatching = function (sync) {
        // re-create hook in case the stored ref gets reattached
        if (onRefTargetDestroyedHookDisposer) {
          onRefTargetDestroyedHookDisposer();
        } // make sure the target node is actually there and initialized


        var storedRefParentNode = storedRefNode.parent;
        var storedRefParentValue = storedRefParentNode && storedRefParentNode.storedValue;

        if (storedRefParentNode && storedRefParentNode.isAlive && storedRefParentValue) {
          var refTargetNodeExists = void 0;

          if (customGetSet) {
            refTargetNodeExists = !!customGetSet.get(identifier, storedRefParentValue);
          } else {
            refTargetNodeExists = storedRefNode.root.identifierCache.has(_this.targetType, normalizeIdentifier(identifier));
          }

          if (!refTargetNodeExists) {
            // we cannot change the reference in sync mode
            // since we are in the middle of a reconciliation/instantiation and the change would be overwritten
            // for those cases just let the wrong reference be assigned and fail upon usage
            // (like current references do)
            // this means that effectively this code will only run when it is created from a snapshot
            if (!sync) {
              _this.fireInvalidated("invalidSnapshotReference", storedRefNode, identifier, null);
            }
          } else {
            onRefTargetDestroyedHookDisposer = _this.addTargetNodeWatcher(storedRefNode, identifier);
          }
        }
      };

      if (storedRefNode.state === NodeLifeCycle.FINALIZED) {
        // already attached, so the whole tree is ready
        startWatching(true);
      } else {
        if (!storedRefNode.isRoot) {
          // start watching once the whole tree is ready
          storedRefNode.root.registerHook(Hook.afterCreationFinalization, function () {
            // make sure to attach it so it can start listening
            if (storedRefNode.parent) {
              storedRefNode.parent.createObservableInstanceIfNeeded();
            }
          });
        } // start watching once the node is attached somewhere / parent changes


        storedRefNode.registerHook(Hook.afterAttach, function () {
          startWatching(false);
        });
      }
    }
  });
  return BaseReferenceType;
}(SimpleType);
/**
 * @internal
 * @hidden
 */


var IdentifierReferenceType =
/** @class */
function (_super) {
  __extends(IdentifierReferenceType, _super);

  function IdentifierReferenceType(targetType, onInvalidated) {
    return _super.call(this, targetType, onInvalidated) || this;
  }

  Object.defineProperty(IdentifierReferenceType.prototype, "getValue", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (storedRefNode) {
      if (!storedRefNode.isAlive) return undefined;
      var storedRef = storedRefNode.storedValue;
      return storedRef.resolvedValue;
    }
  });
  Object.defineProperty(IdentifierReferenceType.prototype, "getSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (storedRefNode) {
      var ref = storedRefNode.storedValue;
      return ref.identifier;
    }
  });
  Object.defineProperty(IdentifierReferenceType.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, initialValue) {
      var identifier = isStateTreeNode(initialValue) ? getIdentifier(initialValue) : initialValue;
      var storedRef = new StoredReference(initialValue, this.targetType);
      var storedRefNode = createScalarNode(this, parent, subpath, environment, storedRef);
      storedRef.node = storedRefNode;
      this.watchTargetNodeForInvalidations(storedRefNode, identifier, undefined);
      return storedRefNode;
    }
  });
  Object.defineProperty(IdentifierReferenceType.prototype, "reconcile", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (current, newValue, parent, subpath) {
      if (!current.isDetaching && current.type === this) {
        var compareByValue = isStateTreeNode(newValue);
        var ref = current.storedValue;

        if (!compareByValue && ref.identifier === newValue || compareByValue && ref.resolvedValue === newValue) {
          current.setParent(parent, subpath);
          return current;
        }
      }

      var newNode = this.instantiate(parent, subpath, undefined, newValue);
      current.die(); // noop if detaching

      return newNode;
    }
  });
  return IdentifierReferenceType;
}(BaseReferenceType);
/**
 * @internal
 * @hidden
 */


var CustomReferenceType =
/** @class */
function (_super) {
  __extends(CustomReferenceType, _super);

  function CustomReferenceType(targetType, options, onInvalidated) {
    var _this = _super.call(this, targetType, onInvalidated) || this;

    Object.defineProperty(_this, "options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: options
    });
    return _this;
  }

  Object.defineProperty(CustomReferenceType.prototype, "getValue", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (storedRefNode) {
      if (!storedRefNode.isAlive) return undefined;
      var referencedNode = this.options.get(storedRefNode.storedValue, storedRefNode.parent ? storedRefNode.parent.storedValue : null);
      return referencedNode;
    }
  });
  Object.defineProperty(CustomReferenceType.prototype, "getSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (storedRefNode) {
      return storedRefNode.storedValue;
    }
  });
  Object.defineProperty(CustomReferenceType.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, newValue) {
      var identifier = isStateTreeNode(newValue) ? this.options.set(newValue, parent ? parent.storedValue : null) : newValue;
      var storedRefNode = createScalarNode(this, parent, subpath, environment, identifier);
      this.watchTargetNodeForInvalidations(storedRefNode, identifier, this.options);
      return storedRefNode;
    }
  });
  Object.defineProperty(CustomReferenceType.prototype, "reconcile", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (current, newValue, parent, subpath) {
      var newIdentifier = isStateTreeNode(newValue) ? this.options.set(newValue, current ? current.storedValue : null) : newValue;

      if (!current.isDetaching && current.type === this && current.storedValue === newIdentifier) {
        current.setParent(parent, subpath);
        return current;
      }

      var newNode = this.instantiate(parent, subpath, undefined, newIdentifier);
      current.die(); // noop if detaching

      return newNode;
    }
  });
  return CustomReferenceType;
}(BaseReferenceType);
/**
 * `types.reference` - Creates a reference to another type, which should have defined an identifier.
 * See also the [reference and identifiers](https://github.com/mobxjs/mobx-state-tree#references-and-identifiers) section.
 */


function reference(subType, options) {
  assertIsType(subType, 1);

  if (devMode()) {
    if (arguments.length === 2 && typeof arguments[1] === "string") {
      // istanbul ignore next
      throw fail$1("References with base path are no longer supported. Please remove the base path.");
    }
  }

  var getSetOptions = options ? options : undefined;
  var onInvalidated = options ? options.onInvalidated : undefined;

  if (getSetOptions && (getSetOptions.get || getSetOptions.set)) {
    if (devMode()) {
      if (!getSetOptions.get || !getSetOptions.set) {
        throw fail$1("reference options must either contain both a 'get' and a 'set' method or none of them");
      }
    }

    return new CustomReferenceType(subType, {
      get: getSetOptions.get,
      set: getSetOptions.set
    }, onInvalidated);
  } else {
    return new IdentifierReferenceType(subType, onInvalidated);
  }
}
/**
 * Returns if a given value represents a reference type.
 *
 * @param type
 * @returns
 */


function isReferenceType(type) {
  return (type.flags & TypeFlags.Reference) > 0;
}
/**
 * `types.safeReference` - A safe reference is like a standard reference, except that it accepts the undefined value by default
 * and automatically sets itself to undefined (when the parent is a model) / removes itself from arrays and maps
 * when the reference it is pointing to gets detached/destroyed.
 *
 * The optional options parameter object accepts a parameter named `acceptsUndefined`, which is set to true by default, so it is suitable
 * for model properties.
 * When used inside collections (arrays/maps), it is recommended to set this option to false so it can't take undefined as value,
 * which is usually the desired in those cases.
 * Additionally, the optional options parameter object accepts a parameter named `onInvalidated`, which will be called when the reference target node that the reference is pointing to is about to be detached/destroyed
 *
 * Strictly speaking it is a `types.maybe(types.reference(X))` (when `acceptsUndefined` is set to true, the default) and
 * `types.reference(X)` (when `acceptsUndefined` is set to false), both of them with a customized `onInvalidated` option.
 *
 * @param subType
 * @param options
 * @returns
 */


function safeReference(subType, options) {
  var refType = reference(subType, __assign(__assign({}, options), {
    onInvalidated: function (ev) {
      if (options && options.onInvalidated) {
        options.onInvalidated(ev);
      }

      ev.removeRef();
    }
  }));

  if (options && options.acceptsUndefined === false) {
    return refType;
  } else {
    return maybe(refType);
  }
}

var BaseIdentifierType =
/** @class */
function (_super) {
  __extends(BaseIdentifierType, _super);

  function BaseIdentifierType(name, validType) {
    var _this = _super.call(this, name) || this;

    Object.defineProperty(_this, "validType", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: validType
    });
    Object.defineProperty(_this, "flags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: TypeFlags.Identifier
    });
    return _this;
  }

  Object.defineProperty(BaseIdentifierType.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, initialValue) {
      if (!parent || !(parent.type instanceof ModelType)) throw fail$1("Identifier types can only be instantiated as direct child of a model type");
      return createScalarNode(this, parent, subpath, environment, initialValue);
    }
  });
  Object.defineProperty(BaseIdentifierType.prototype, "reconcile", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (current, newValue, parent, subpath) {
      // we don't consider detaching here since identifier are scalar nodes, and scalar nodes cannot be detached
      if (current.storedValue !== newValue) throw fail$1("Tried to change identifier from '" + current.storedValue + "' to '" + newValue + "'. Changing identifiers is not allowed.");
      current.setParent(parent, subpath);
      return current;
    }
  });
  Object.defineProperty(BaseIdentifierType.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      if (typeof value !== this.validType) {
        return typeCheckFailure(context, value, "Value is not a valid " + this.describe() + ", expected a " + this.validType);
      }

      return typeCheckSuccess();
    }
  });
  return BaseIdentifierType;
}(SimpleType);
/**
 * @internal
 * @hidden
 */


var IdentifierType =
/** @class */
function (_super) {
  __extends(IdentifierType, _super);

  function IdentifierType() {
    var _this = _super.call(this, "identifier", "string") || this;

    Object.defineProperty(_this, "flags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: TypeFlags.Identifier
    });
    return _this;
  }

  Object.defineProperty(IdentifierType.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return "identifier";
    }
  });
  return IdentifierType;
}(BaseIdentifierType);
/**
 * @internal
 * @hidden
 */


var IdentifierNumberType =
/** @class */
function (_super) {
  __extends(IdentifierNumberType, _super);

  function IdentifierNumberType() {
    return _super.call(this, "identifierNumber", "number") || this;
  }

  Object.defineProperty(IdentifierNumberType.prototype, "getSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      return node.storedValue;
    }
  });
  Object.defineProperty(IdentifierNumberType.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return "identifierNumber";
    }
  });
  return IdentifierNumberType;
}(BaseIdentifierType);
/**
 * `types.identifier` - Identifiers are used to make references, lifecycle events and reconciling works.
 * Inside a state tree, for each type can exist only one instance for each given identifier.
 * For example there couldn't be 2 instances of user with id 1. If you need more, consider using references.
 * Identifier can be used only as type property of a model.
 * This type accepts as parameter the value type of the identifier field that can be either string or number.
 *
 * Example:
 * ```ts
 *  const Todo = types.model("Todo", {
 *      id: types.identifier,
 *      title: types.string
 *  })
 * ```
 *
 * @returns
 */


var identifier = new IdentifierType();
/**
 * `types.identifierNumber` - Similar to `types.identifier`. This one will serialize from / to a number when applying snapshots
 *
 * Example:
 * ```ts
 *  const Todo = types.model("Todo", {
 *      id: types.identifierNumber,
 *      title: types.string
 *  })
 * ```
 *
 * @returns
 */

var identifierNumber = new IdentifierNumberType();
/**
 * Returns if a given value represents an identifier type.
 *
 * @param type
 * @returns
 */

function isIdentifierType(type) {
  return isType(type) && (type.flags & TypeFlags.Identifier) > 0;
}
/**
 * @internal
 * @hidden
 */


function normalizeIdentifier(id) {
  return "" + id;
}
/**
 * @internal
 * @hidden
 */


function isValidIdentifier(id) {
  return typeof id === "string" || typeof id === "number";
}
/**
 * @internal
 * @hidden
 */


function assertIsValidIdentifier(id, argNumber) {
  assertArg(id, isValidIdentifier, "string or number (identifier)", argNumber);
}
/**
 * `types.custom` - Creates a custom type. Custom types can be used for arbitrary immutable values, that have a serializable representation. For example, to create your own Date representation, Decimal type etc.
 *
 * The signature of the options is:
 * ```ts
 * export interface CustomTypeOptions<S, T> {
 *     // Friendly name
 *     name: string
 *     // given a serialized value and environment, how to turn it into the target type
 *     fromSnapshot(snapshot: S, env: any): T
 *     // return the serialization of the current value
 *     toSnapshot(value: T): S
 *     // if true, this is a converted value, if false, it's a snapshot
 *     isTargetType(value: T | S): value is T
 *     // a non empty string is assumed to be a validation error
 *     getValidationMessage?(snapshot: S): string
 * }
 * ```
 *
 * Example:
 * ```ts
 * const DecimalPrimitive = types.custom<string, Decimal>({
 *     name: "Decimal",
 *     fromSnapshot(value: string) {
 *         return new Decimal(value)
 *     },
 *     toSnapshot(value: Decimal) {
 *         return value.toString()
 *     },
 *     isTargetType(value: string | Decimal): boolean {
 *         return value instanceof Decimal
 *     },
 *     getValidationMessage(value: string): string {
 *         if (/^-?\d+\.\d+$/.test(value)) return "" // OK
 *         return `'${value}' doesn't look like a valid decimal number`
 *     }
 * })
 *
 * const Wallet = types.model({
 *     balance: DecimalPrimitive
 * })
 * ```
 *
 * @param options
 * @returns
 */


function custom(options) {
  return new CustomType(options);
}
/**
 * @internal
 * @hidden
 */


var CustomType =
/** @class */
function (_super) {
  __extends(CustomType, _super);

  function CustomType(options) {
    var _this = _super.call(this, options.name) || this;

    Object.defineProperty(_this, "options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: options
    });
    Object.defineProperty(_this, "flags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: TypeFlags.Custom
    });
    return _this;
  }

  Object.defineProperty(CustomType.prototype, "describe", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function () {
      return this.name;
    }
  });
  Object.defineProperty(CustomType.prototype, "isValidSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (value, context) {
      if (this.options.isTargetType(value)) return typeCheckSuccess();
      var typeError = this.options.getValidationMessage(value);

      if (typeError) {
        return typeCheckFailure(context, value, "Invalid value for type '" + this.name + "': " + typeError);
      }

      return typeCheckSuccess();
    }
  });
  Object.defineProperty(CustomType.prototype, "getSnapshot", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (node) {
      return this.options.toSnapshot(node.storedValue);
    }
  });
  Object.defineProperty(CustomType.prototype, "instantiate", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (parent, subpath, environment, initialValue) {
      var valueToStore = this.options.isTargetType(initialValue) ? initialValue : this.options.fromSnapshot(initialValue, parent && parent.root.environment);
      return createScalarNode(this, parent, subpath, environment, valueToStore);
    }
  });
  Object.defineProperty(CustomType.prototype, "reconcile", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (current, value, parent, subpath) {
      var isSnapshot = !this.options.isTargetType(value); // in theory customs use scalar nodes which cannot be detached, but still...

      if (!current.isDetaching) {
        var unchanged = current.type === this && (isSnapshot ? value === current.snapshot : value === current.storedValue);

        if (unchanged) {
          current.setParent(parent, subpath);
          return current;
        }
      }

      var valueToStore = isSnapshot ? this.options.fromSnapshot(value, parent.root.environment) : value;
      var newNode = this.instantiate(parent, subpath, undefined, valueToStore);
      current.die(); // noop if detaching

      return newNode;
    }
  });
  return CustomType;
}(SimpleType); // we import the types to re-export them inside types.


var types = {
  enumeration: enumeration,
  model: model,
  compose: compose,
  custom: custom,
  reference: reference,
  safeReference: safeReference,
  union: union,
  optional: optional,
  literal: literal,
  maybe: maybe,
  maybeNull: maybeNull,
  refinement: refinement,
  string: string,
  boolean: boolean,
  number: number,
  integer: integer,
  Date: DatePrimitive,
  map: map,
  array: array,
  frozen: frozen,
  identifier: identifier,
  identifierNumber: identifierNumber,
  late: late,
  undefined: undefinedType,
  null: nullType,
  snapshotProcessor: snapshotProcessor
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/mobx/dist/mobx.esm.js":
/*!********************************************!*\
  !*** ./node_modules/mobx/dist/mobx.esm.js ***!
  \********************************************/
/*! exports provided: $mobx, FlowCancellationError, ObservableMap, ObservableSet, Reaction, _allowStateChanges, _allowStateChangesInsideComputed, _allowStateReadsEnd, _allowStateReadsStart, _autoAction, _endAction, _getAdministration, _getGlobalState, _interceptReads, _isComputingDerivation, _resetGlobalState, _startAction, action, autorun, comparer, computed, configure, createAtom, entries, extendObservable, flow, flowResult, get, getAtom, getDebugName, getDependencyTree, getObserverTree, has, intercept, isAction, isBoxedObservable, isComputed, isComputedProp, isFlowCancellationError, isObservable, isObservableArray, isObservableMap, isObservableObject, isObservableProp, isObservableSet, keys, makeAutoObservable, makeObservable, observable, observe, onBecomeObserved, onBecomeUnobserved, onReactionError, override, reaction, remove, runInAction, set, spy, toJS, trace, transaction, untracked, values, when */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$mobx", function() { return $mobx; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlowCancellationError", function() { return FlowCancellationError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObservableMap", function() { return ObservableMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObservableSet", function() { return ObservableSet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reaction", function() { return Reaction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_allowStateChanges", function() { return allowStateChanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_allowStateChangesInsideComputed", function() { return runInAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_allowStateReadsEnd", function() { return allowStateReadsEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_allowStateReadsStart", function() { return allowStateReadsStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_autoAction", function() { return autoAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_endAction", function() { return _endAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getAdministration", function() { return getAdministration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getGlobalState", function() { return getGlobalState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_interceptReads", function() { return interceptReads; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isComputingDerivation", function() { return isComputingDerivation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_resetGlobalState", function() { return resetGlobalState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_startAction", function() { return _startAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "action", function() { return action; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autorun", function() { return autorun; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "comparer", function() { return comparer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computed", function() { return computed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "configure", function() { return configure; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createAtom", function() { return createAtom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "entries", function() { return entries; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendObservable", function() { return extendObservable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flow", function() { return flow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flowResult", function() { return flowResult; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAtom", function() { return getAtom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDebugName", function() { return getDebugName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDependencyTree", function() { return getDependencyTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getObserverTree", function() { return getObserverTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "has", function() { return has; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intercept", function() { return intercept; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAction", function() { return isAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBoxedObservable", function() { return isObservableValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isComputed", function() { return isComputed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isComputedProp", function() { return isComputedProp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFlowCancellationError", function() { return isFlowCancellationError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObservable", function() { return isObservable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObservableArray", function() { return isObservableArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObservableMap", function() { return isObservableMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObservableObject", function() { return isObservableObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObservableProp", function() { return isObservableProp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObservableSet", function() { return isObservableSet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return keys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeAutoObservable", function() { return makeAutoObservable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeObservable", function() { return makeObservable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observable", function() { return observable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "observe", function() { return observe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onBecomeObserved", function() { return onBecomeObserved; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onBecomeUnobserved", function() { return onBecomeUnobserved; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onReactionError", function() { return onReactionError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "override", function() { return override; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reaction", function() { return reaction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "runInAction", function() { return runInAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spy", function() { return spy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toJS", function() { return toJS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trace", function() { return trace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transaction", function() { return transaction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "untracked", function() { return untracked; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "values", function() { return values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "when", function() { return when; });
var niceErrors = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function _(annotationType, key) {
    return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
  },
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function _(index, length) {
    return "[mobx.array] Index out of bounds, " + index + " is larger than " + length;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function _(other) {
    return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
  },
  20: function _(other) {
    return "Cannot initialize map from " + other;
  },
  21: function _(dataStructure) {
    return "Cannot convert to map from '" + dataStructure + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function _(thing) {
    return "Cannot obtain administration from " + thing;
  },
  25: function _(property, name) {
    return "the entry '" + property + "' does not exist in the observable map '" + name + "'";
  },
  26: "please specify a property",
  27: function _(property, name) {
    return "no observable property '" + property.toString() + "' found on the observable object '" + name + "'";
  },
  28: function _(thing) {
    return "Cannot obtain atom from " + thing;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function _(name, derivation) {
    return "Cycle detected in computation " + name + ": " + derivation;
  },
  33: function _(name) {
    return "The setter of computed value '" + name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function _(name) {
    return "[ComputedValue '" + name + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function _(method) {
    return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
  }
};
var errors =  true ? niceErrors : undefined;

function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  if (true) {
    var e = typeof error === "string" ? error : errors[error];
    if (typeof e === "function") e = e.apply(null, args);
    throw new Error("[MobX] " + e);
  }

  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
}

var mockGlobal = {};

function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }

  if (typeof window !== "undefined") {
    return window;
  }

  if (typeof global !== "undefined") {
    return global;
  }

  if (typeof self !== "undefined") {
    return self;
  }

  return mockGlobal;
}

var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = /*#__PURE__*/Object.toString();

function assertProxies() {
  if (!hasProxy) {
    die( true ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : undefined);
  }
}

function warnAboutProxyRequirement(msg) {
  if ( true && globalState.verifyProxies) {
    die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + msg);
  }
}

function getNextId() {
  return ++globalState.mobxGuid;
}
/**
 * Makes sure that the provided function is invoked at most once.
 */


function once(func) {
  var invoked = false;
  return function () {
    if (invoked) return;
    invoked = true;
    return func.apply(this, arguments);
  };
}

var noop = function noop() {};

function isFunction(fn) {
  return typeof fn === "function";
}

function isStringish(value) {
  var t = typeof value;

  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }

  return false;
}

function isObject(value) {
  return value !== null && typeof value === "object";
}

function isPlainObject(value) {
  var _proto$constructor;

  if (!isObject(value)) return false;
  var proto = Object.getPrototypeOf(value);
  if (proto == null) return true;
  return ((_proto$constructor = proto.constructor) == null ? void 0 : _proto$constructor.toString()) === plainObjectString;
} // https://stackoverflow.com/a/37865170


function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) return false;
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) return true;
  return false;
}

function addHiddenProp(object, propName, value) {
  defineProperty(object, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value: value
  });
}

function addHiddenFinalProp(object, propName, value) {
  defineProperty(object, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value: value
  });
}

function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function (x) {
    return isObject(x) && x[propName] === true;
  };
}

function isES6Map(thing) {
  return thing instanceof Map;
}

function isES6Set(thing) {
  return thing instanceof Set;
}

var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
/**
 * Returns the following: own enumerable keys and symbols.
 */

function getPlainObjectKeys(object) {
  var keys = Object.keys(object); // Not supported in IE, so there are not going to be symbol props anyway...

  if (!hasGetOwnPropertySymbols) return keys;
  var symbols = Object.getOwnPropertySymbols(object);
  if (!symbols.length) return keys;
  return [].concat(keys, symbols.filter(function (s) {
    return objectPrototype.propertyIsEnumerable.call(object, s);
  }));
} // From Immer utils
// Returns all own keys, including non-enumerable and symbolic


var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function (obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} :
/* istanbul ignore next */
Object.getOwnPropertyNames;

function stringifyKey(key) {
  if (typeof key === "string") return key;
  if (typeof key === "symbol") return key.toString();
  return new String(key).toString();
}

function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}

function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
} // From Immer utils


var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
  var res = {}; // Note: without polyfill for ownKeys, symbols won't be picked up

  ownKeys(target).forEach(function (key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var storedAnnotationsSymbol = /*#__PURE__*/Symbol("mobx-stored-annotations");
/**
 * Creates a function that acts as
 * - decorator
 * - annotation object
 */

function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    storeAnnotation(target, property, annotation);
  }

  return Object.assign(decorator, annotation);
}
/**
 * Stores annotation to prototype,
 * so it can be inspected later by `makeObservable` called from constructor
 */


function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
  } // @override must override something


  if ( true && isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    die("'" + fieldName + "' is decorated with 'override', " + "but no such decorated member was found on prototype.");
  } // Cannot re-decorate


  assertNotDecorated(prototype, annotation, key); // Ignore override

  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}

function assertNotDecorated(prototype, annotation, key) {
  if ( true && !isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed." + "\nUse '@override' decorator for methods overriden by subclass.");
  }
}
/**
 * Collects annotations from prototypes and stores them on target (instance)
 */


function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    if ( true && !target[storedAnnotationsSymbol]) {
      die("No annotations were passed to makeObservable, but no decorated members have been found either");
    } // We need a copy as we will remove annotation from the list once it's applied.


    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
  }

  return target[storedAnnotationsSymbol];
}

var $mobx = /*#__PURE__*/Symbol("mobx administration");

var Atom = /*#__PURE__*/function () {
  // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed

  /**
   * Create a new atom. For debugging purposes it is recommended to give it a name.
   * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
   */
  function Atom(name_) {
    if (name_ === void 0) {
      name_ =  true ? "Atom@" + getNextId() : undefined;
    }

    this.name_ = void 0;
    this.isPendingUnobservation_ = false;
    this.isBeingObserved_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
  } // onBecomeObservedListeners


  var _proto = Atom.prototype;

  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function (listener) {
        return listener();
      });
    }
  };

  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function (listener) {
        return listener();
      });
    }
  }
  /**
   * Invoke this method to notify mobx that your atom has been used somehow.
   * Returns true if there is currently a reactive context.
   */
  ;

  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  }
  /**
   * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
   */
  ;

  _proto.reportChanged = function reportChanged() {
    startBatch();
    propagateChanged(this);
    endBatch();
  };

  _proto.toString = function toString() {
    return this.name_;
  };

  return Atom;
}();

var isAtom = /*#__PURE__*/createInstanceofPredicate("Atom", Atom);

function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }

  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }

  var atom = new Atom(name); // default `noop` listener will not initialize the hook Set

  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }

  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }

  return atom;
}

function identityComparer(a, b) {
  return a === b;
}

function structuralComparer(a, b) {
  return deepEqual(a, b);
}

function shallowComparer(a, b) {
  return deepEqual(a, b, 1);
}

function defaultComparer(a, b) {
  return Object.is(a, b);
}

var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};

function deepEnhancer(v, _, name) {
  // it is an observable already, done
  if (isObservable(v)) return v; // something that can be converted and mutated?

  if (Array.isArray(v)) return observable.array(v, {
    name: name
  });
  if (isPlainObject(v)) return observable.object(v, undefined, {
    name: name
  });
  if (isES6Map(v)) return observable.map(v, {
    name: name
  });
  if (isES6Set(v)) return observable.set(v, {
    name: name
  });
  return v;
}

function shallowEnhancer(v, _, name) {
  if (v === undefined || v === null) return v;
  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) return v;
  if (Array.isArray(v)) return observable.array(v, {
    name: name,
    deep: false
  });
  if (isPlainObject(v)) return observable.object(v, undefined, {
    name: name,
    deep: false
  });
  if (isES6Map(v)) return observable.map(v, {
    name: name,
    deep: false
  });
  if (isES6Set(v)) return observable.set(v, {
    name: name,
    deep: false
  });
  if (true) die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}

function referenceEnhancer(newValue) {
  // never turn into an observable
  return newValue;
}

function refStructEnhancer(v, oldValue) {
  if ( true && isObservable(v)) die("observable.struct should not be used with observable values");
  if (deepEqual(v, oldValue)) return oldValue;
  return v;
}

var OVERRIDE = "override";
var override = /*#__PURE__*/createDecoratorAnnotation({
  annotationType_: OVERRIDE,
  make_: make_,
  extend_: extend_
});

function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}

function make_(adm, key) {
  // Must not be plain object
  if ( true && adm.isPlainObject_) {
    die("Cannot apply '" + this.annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + this.annotationType_ + "' cannot be used on plain objects."));
  } // Must override something


  if ( true && !hasProp(adm.appliedAnnotations_, key)) {
    die("'" + adm.name_ + "." + key.toString() + "' is annotated with '" + this.annotationType_ + "', " + "but no such annotated member was found on prototype.");
  }
}

function extend_(adm, key, descriptor, proxyTrap) {
  die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}

function createActionAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$1,
    extend_: extend_$1
  };
}

function make_$1(adm, key) {
  var _this$options_$bound, _this$options_, _adm$target_$storedAn;

  var annotated = false;
  var source = adm.target_;
  var bound = (_this$options_$bound = (_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) != null ? _this$options_$bound : false;

  while (source && source !== objectPrototype) {
    var descriptor = getDescriptor(source, key);

    if (descriptor) {
      // Instance or bound
      // Keep first because the operation can be intercepted
      // and we don't want to end up with partially annotated proto chain
      if (source === adm.target_ || bound) {
        var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
        var definePropertyOutcome = adm.defineProperty_(key, actionDescriptor);

        if (!definePropertyOutcome) {
          // Intercepted
          return;
        }

        annotated = true; // Don't annotate protos if bound

        if (bound) {
          break;
        }
      } // Prototype


      if (source !== adm.target_) {
        if (isAction(descriptor.value)) {
          // A prototype could have been annotated already by other constructor,
          // rest of the proto chain must be annotated already
          annotated = true;
          break;
        }

        var _actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);

        defineProperty(source, key, _actionDescriptor);
        annotated = true;
      }
    }

    source = Object.getPrototypeOf(source);
  }

  if (annotated) {
    recordAnnotationApplied(adm, this, key);
  } else if (!((_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? void 0 : _adm$target_$storedAn[key])) {
    // Throw on missing key, except for decorators:
    // Decorator annotations are collected from whole prototype chain.
    // When called from super() some props may not exist yet.
    // However we don't have to worry about missing prop,
    // because the decorator must have been applied to something.
    die(1, this.annotationType_, adm.name_ + "." + key.toString());
  }
}

function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}

function assertActionDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;

  if ( true && !isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
  }
}

function createActionDescriptor(adm, annotation, key, descriptor, // provides ability to disable safeDescriptors for prototypes
safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3;

  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }

  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;

  if ((_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.bound) {
    var _adm$proxy_;

    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }

  return {
    value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}

function createFlowAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$2,
    extend_: extend_$2
  };
}

function make_$2(adm, key) {
  var _adm$target_$storedAn;

  var annotated = false;
  var source = adm.target_;

  while (source && source !== objectPrototype) {
    var descriptor = getDescriptor(source, key);

    if (descriptor) {
      if (source !== adm.target_) {
        // Prototype
        if (isFlow(descriptor.value)) {
          // A prototype could have been annotated already by other constructor,
          // rest of the proto chain must be annotated already
          annotated = true;
          break;
        }

        var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false);
        defineProperty(source, key, flowDescriptor);
      } else {
        var _flowDescriptor = createFlowDescriptor(adm, this, key, descriptor);

        var definePropertyOutcome = adm.defineProperty_(key, _flowDescriptor);

        if (!definePropertyOutcome) {
          // Intercepted
          return;
        }
      }

      annotated = true;
    }

    source = Object.getPrototypeOf(source);
  }

  if (annotated) {
    recordAnnotationApplied(adm, this, key);
  } else if (!((_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? void 0 : _adm$target_$storedAn[key])) {
    // Throw on missing key, except for decorators:
    // Decorator annotations are collected from whole prototype chain.
    // When called from super() some props may not exist yet.
    // However we don't have to worry about missing prop,
    // because the decorator must have been applied to something.
    die(1, this.annotationType_, adm.name_ + "." + key.toString());
  }
}

function extend_$2(adm, key, descriptor, proxyTrap) {
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}

function assertFlowDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;

  if ( true && !isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
  }
}

function createFlowDescriptor(adm, annotation, key, descriptor, // provides ability to disable safeDescriptors for prototypes
safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }

  assertFlowDescriptor(adm, annotation, key, descriptor);
  return {
    value: flow(descriptor.value),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}

function createComputedAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$3,
    extend_: extend_$3
  };
}

function make_$3(adm, key) {
  var _adm$target_$storedAn;

  var source = adm.target_;

  while (source && source !== objectPrototype) {
    var descriptor = getDescriptor(source, key);

    if (descriptor) {
      assertComputedDescriptor(adm, this, key, descriptor);
      var definePropertyOutcome = adm.defineComputedProperty_(key, _extends({}, this.options_, {
        get: descriptor.get,
        set: descriptor.set
      }));

      if (!definePropertyOutcome) {
        // Intercepted
        return;
      }

      recordAnnotationApplied(adm, this, key);
      return;
    }

    source = Object.getPrototypeOf(source);
  }

  if (!((_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? void 0 : _adm$target_$storedAn[key])) {
    // Throw on missing key, except for decorators:
    // Decorator annotations are collected from whole prototype chain.
    // When called from super() some props may not exist yet.
    // However we don't have to worry about missing prop,
    // because the decorator must have been applied to something.
    die(1, this.annotationType_, adm.name_ + "." + key.toString());
  }
}

function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}

function assertComputedDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var get = _ref2.get;

  if ( true && !get) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
  }
}

function createObservableAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$4,
    extend_: extend_$4
  };
}

function make_$4(adm, key) {
  var _adm$target_$storedAn;

  var source = adm.target_; // Copy props from proto as well, see test:
  // "decorate should work with Object.create"

  while (source && source !== objectPrototype) {
    var descriptor = getDescriptor(source, key);

    if (descriptor) {
      var _this$options_$enhanc, _this$options_;

      assertObservableDescriptor(adm, this, key, descriptor);
      var definePropertyOutcome = adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer);

      if (!definePropertyOutcome) {
        // Intercepted
        return;
      }

      recordAnnotationApplied(adm, this, key);
      return;
    }

    source = Object.getPrototypeOf(source);
  }

  if (!((_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? void 0 : _adm$target_$storedAn[key])) {
    // Throw on missing key, except for decorators:
    // Decorator annotations are collected from whole prototype chain.
    // When called from super() some props may not exist yet.
    // However we don't have to worry about missing prop,
    // because the decorator must have been applied to something.
    die(1, this.annotationType_, adm.name_ + "." + key.toString());
  }
}

function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc2, _this$options_2;

  assertObservableDescriptor(adm, this, key, descriptor);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc2 = (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.enhancer) != null ? _this$options_$enhanc2 : deepEnhancer, proxyTrap);
}

function assertObservableDescriptor(adm, _ref, key, descriptor) {
  var annotationType_ = _ref.annotationType_;

  if ( true && !("value" in descriptor)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
  }
} // in the majority of cases


var defaultCreateObservableOptions = {
  deep: true,
  name: undefined,
  defaultDecorator: undefined,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);

function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}

var observableAnnotation = /*#__PURE__*/createObservableAnnotation("observable");
var observableRefAnnotation = /*#__PURE__*/createObservableAnnotation("observable.ref", {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = /*#__PURE__*/createObservableAnnotation("observable.shallow", {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = /*#__PURE__*/createObservableAnnotation("observable.struct", {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = /*#__PURE__*/createDecoratorAnnotation(observableAnnotation);

function getEnhancerFromOptions(options) {
  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
}

function getAnnotationFromOptions(options) {
  return options ? options.deep === true ? observableAnnotation : options.deep === false ? observableRefAnnotation : options.defaultDecorator : undefined;
}

function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;

  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
/**
 * Turns an object, array or function into a reactive structure.
 * @param v the value which should become observable.
 */


function createObservable(v, arg2, arg3) {
  // @observable someProp;
  if (isStringish(arg2)) {
    storeAnnotation(v, arg2, observableAnnotation);
    return;
  } // already observable - ignore


  if (isObservable(v)) return v; // plain object

  if (isPlainObject(v)) return observable.object(v, arg2, arg3); // Array

  if (Array.isArray(v)) return observable.array(v, arg2); // Map

  if (isES6Map(v)) return observable.map(v, arg2); // Set

  if (isES6Set(v)) return observable.set(v, arg2); // other object - ignore

  if (typeof v === "object" && v !== null) return v; // anything else

  return observable.box(v, arg2);
}

Object.assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
  },
  array: function array(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
  },
  map: function map(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
  },
  set: function set(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
  },
  object: function object(props, decorators, options) {
    return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
  },
  ref: /*#__PURE__*/createDecoratorAnnotation(observableRefAnnotation),
  shallow: /*#__PURE__*/createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /*#__PURE__*/createDecoratorAnnotation(observableStructAnnotation)
}; // eslint-disable-next-line

var observable = /*#__PURE__*/assign(createObservable, observableFactories);
var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED);
var computedStructAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
/**
 * Decorator for class properties: @computed get value() { return expr; }.
 * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
 */

var computed = function computed(arg1, arg2) {
  if (isStringish(arg2)) {
    // @computed
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }

  if (isPlainObject(arg1)) {
    // @computed({ options })
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  } // computed(expr, options?)


  if (true) {
    if (!isFunction(arg1)) die("First argument to `computed` should be an expression.");
    if (isFunction(arg2)) die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
  }

  var opts = isPlainObject(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  /* for generated name */

  return new ComputedValue(opts);
};

Object.assign(computed, computedAnnotation);
computed.struct = /*#__PURE__*/createDecoratorAnnotation(computedStructAnnotation);

var _getDescriptor$config, _getDescriptor; // mobx versions


var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /*#__PURE__*/getDescriptor(function () {}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false; // we can safely recycle this object

var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};

function createAction(actionName, fn, autoAction, ref) {
  if (autoAction === void 0) {
    autoAction = false;
  }

  if (true) {
    if (!isFunction(fn)) die("`action` can only be invoked on functions");
    if (typeof actionName !== "string" || !actionName) die("actions should have valid names, got: '" + actionName + "'");
  }

  function res() {
    return executeAction(actionName, autoAction, fn, ref || this, arguments);
  }

  res.isMobxAction = true;

  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    Object.defineProperty(res, "name", tmpNameDescriptor);
  }

  return res;
}

function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);

  try {
    return fn.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}

function _startAction(actionName, canRunAsDerivation, // true for autoAction
scope, args) {
  var notifySpy_ =  true && isSpyEnabled() && !!actionName;
  var startTime_ = 0;

  if ( true && notifySpy_) {
    startTime_ = Date.now();
    var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: actionName,
      object: scope,
      arguments: flattenedArgs
    });
  }

  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges; // by default preserve previous allow

  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }

  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_: prevDerivation_,
    prevAllowStateChanges_: prevAllowStateChanges_,
    prevAllowStateReads_: prevAllowStateReads_,
    notifySpy_: notifySpy_,
    startTime_: startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}

function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }

  currentActionId = runInfo.parentActionId_;

  if (runInfo.error_ !== undefined) {
    globalState.suppressReactionErrors = true;
  }

  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) untrackedEnd(runInfo.prevDerivation_);

  if ( true && runInfo.notifySpy_) {
    spyReportEnd({
      time: Date.now() - runInfo.startTime_
    });
  }

  globalState.suppressReactionErrors = false;
}

function allowStateChanges(allowStateChanges, func) {
  var prev = allowStateChangesStart(allowStateChanges);

  try {
    return func();
  } finally {
    allowStateChangesEnd(prev);
  }
}

function allowStateChangesStart(allowStateChanges) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges;
  return prev;
}

function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}

var _Symbol$toPrimitive;

var CREATE = "create";
_Symbol$toPrimitive = Symbol.toPrimitive;

var ObservableValue = /*#__PURE__*/function (_Atom) {
  _inheritsLoose(ObservableValue, _Atom);

  function ObservableValue(value, enhancer, name_, notifySpy, equals) {
    var _this;

    if (name_ === void 0) {
      name_ =  true ? "ObservableValue@" + getNextId() : undefined;
    }

    if (notifySpy === void 0) {
      notifySpy = true;
    }

    if (equals === void 0) {
      equals = comparer["default"];
    }

    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, undefined, name_);

    if ( true && notifySpy && isSpyEnabled()) {
      // only notify spy if this is a stand-alone observable
      spyReport({
        type: CREATE,
        object: _assertThisInitialized(_this),
        observableKind: "value",
        debugObjectName: _this.name_,
        newValue: "" + _this.value_
      });
    }

    return _this;
  }

  var _proto = ObservableValue.prototype;

  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== undefined) return this.dehancer(value);
    return value;
  };

  _proto.set = function set(newValue) {
    var oldValue = this.value_;
    newValue = this.prepareNewValue_(newValue);

    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();

      if ( true && notifySpy) {
        spyReportStart({
          type: UPDATE,
          object: this,
          observableKind: "value",
          debugObjectName: this.name_,
          newValue: newValue,
          oldValue: oldValue
        });
      }

      this.setNewValue_(newValue);
      if ( true && notifySpy) spyReportEnd();
    }
  };

  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    checkIfStateModificationsAreAllowed(this);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue: newValue
      });
      if (!change) return globalState.UNCHANGED;
      newValue = change.newValue;
    } // apply modifier


    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };

  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();

    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue: newValue,
        oldValue: oldValue
      });
    }
  };

  _proto.get = function get() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately) listener({
      observableKind: "value",
      debugObjectName: this.name_,
      object: this,
      type: UPDATE,
      newValue: this.value_,
      oldValue: undefined
    });
    return registerListener(this, listener);
  };

  _proto.raw = function raw() {
    // used by MST ot get undehanced value
    return this.value_;
  };

  _proto.toJSON = function toJSON() {
    return this.get();
  };

  _proto.toString = function toString() {
    return this.name_ + "[" + this.value_ + "]";
  };

  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };

  _proto[_Symbol$toPrimitive] = function () {
    return this.valueOf();
  };

  return ObservableValue;
}(Atom);

var isObservableValue = /*#__PURE__*/createInstanceofPredicate("ObservableValue", ObservableValue);

var _Symbol$toPrimitive$1;
/**
 * A node in the state dependency root that observes other nodes, and can be observed itself.
 *
 * ComputedValue will remember the result of the computation for the duration of the batch, or
 * while being observed.
 *
 * During this time it will recompute only when one of its direct dependencies changed,
 * but only when it is being accessed with `ComputedValue.get()`.
 *
 * Implementation description:
 * 1. First time it's being accessed it will compute and remember result
 *    give back remembered result until 2. happens
 * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
 * 3. When it's being accessed, recompute if any shallow dependency changed.
 *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
 *    go to step 2. either way
 *
 * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
 */


_Symbol$toPrimitive$1 = Symbol.toPrimitive;

var ComputedValue = /*#__PURE__*/function () {
  // nodes we are looking at. Our value depends on these nodes
  // during tracking it's an array with new observed observers
  // to check for cycles
  // N.B: unminified as it is used by MST

  /**
   * Create a new computed value based on a function expression.
   *
   * The `name` property is for debug purposes only.
   *
   * The `equals` property specifies the comparer function to use to determine if a newly produced
   * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
   * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.
   * Structural comparison can be convenient if you always produce a new aggregated object and
   * don't want to notify observers if it is structurally the same.
   * This is useful for working with vectors, mouse coordinates etc.
   */
  function ComputedValue(options) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.isBeingObserved_ = false;
    this.isPendingUnobservation_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.isComputing_ = false;
    this.isRunningSetter_ = false;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options.get) die(31);
    this.derivation = options.get;
    this.name_ = options.name || ( true ? "ComputedValue@" + getNextId() : undefined);

    if (options.set) {
      this.setter_ = createAction( true ? this.name_ + "-setter" : undefined, options.set);
    }

    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options.context;
    this.requiresReaction_ = !!options.requiresReaction;
    this.keepAlive_ = !!options.keepAlive;
  }

  var _proto = ComputedValue.prototype;

  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };

  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function (listener) {
        return listener();
      });
    }
  };

  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function (listener) {
        return listener();
      });
    }
  }
  /**
   * Returns the current value of this computed value.
   * Will evaluate its computation first if needed.
   */
  ;

  _proto.get = function get() {
    if (this.isComputing_) die(32, this.name_, this.derivation);

    if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch(); // See perf test 'computed memoization'

        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);

      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext) globalState.trackingContext = this;
        if (this.trackAndCompute()) propagateChangeConfirmed(this);
        globalState.trackingContext = prevTrackingContext;
      }
    }

    var result = this.value_;
    if (isCaughtException(result)) throw result.cause;
    return result;
  };

  _proto.set = function set(value) {
    if (this.setter_) {
      if (this.isRunningSetter_) die(33, this.name_);
      this.isRunningSetter_ = true;

      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter_ = false;
      }
    } else die(34, this.name_);
  };

  _proto.trackAndCompute = function trackAndCompute() {
    // N.B: unminified as it is used by MST
    var oldValue = this.value_;
    var wasSuspended =
    /* see #1208 */
    this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;
    var newValue = this.computeValue_(true);

    if ( true && isSpyEnabled()) {
      spyReport({
        observableKind: "computed",
        debugObjectName: this.name_,
        object: this.scope_,
        type: "update",
        oldValue: this.value_,
        newValue: newValue
      });
    }

    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);

    if (changed) {
      this.value_ = newValue;
    }

    return changed;
  };

  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing_ = true; // don't allow state changes during computation

    var prev = allowStateChangesStart(false);
    var res;

    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e) {
          res = new CaughtException(e);
        }
      }
    }

    allowStateChangesEnd(prev);
    this.isComputing_ = false;
    return res;
  };

  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = undefined; // don't hold on to computed value!
    }
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;

    var firstTime = true;
    var prevValue = undefined;
    return autorun(function () {
      // TODO: why is this in a different place than the spyReport() function? in all other observables it's called in the same place
      var newValue = _this.get();

      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue: newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }

      firstTime = false;
      prevValue = newValue;
    });
  };

  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
    if (false) {}

    if (this.requiresReaction_ === true) {
      die("[mobx] Computed value " + this.name_ + " is read outside a reactive context");
    }

    if (this.isTracing_ !== TraceMode.NONE) {
      console.log("[mobx.trace] '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute");
    }

    if (globalState.computedRequiresReaction) {
      console.warn("[mobx] Computed value " + this.name_ + " is being read outside a reactive context. Doing a full recompute");
    }
  };

  _proto.toString = function toString() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };

  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };

  _proto[_Symbol$toPrimitive$1] = function () {
    return this.valueOf();
  };

  return ComputedValue;
}();

var isComputedValue = /*#__PURE__*/createInstanceofPredicate("ComputedValue", ComputedValue);
var IDerivationState_;

(function (IDerivationState_) {
  // before being run or (outside batch and not being observed)
  // at this point derivation is not holding any data about dependency tree
  IDerivationState_[IDerivationState_["NOT_TRACKING_"] = -1] = "NOT_TRACKING_"; // no shallow dependency changed since last computation
  // won't recalculate derivation
  // this is what makes mobx fast

  IDerivationState_[IDerivationState_["UP_TO_DATE_"] = 0] = "UP_TO_DATE_"; // some deep dependency changed, but don't know if shallow dependency changed
  // will require to check first if UP_TO_DATE or POSSIBLY_STALE
  // currently only ComputedValue will propagate POSSIBLY_STALE
  //
  // having this state is second big optimization:
  // don't have to recompute on every dependency change, but only when it's needed

  IDerivationState_[IDerivationState_["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_"; // A shallow dependency has changed since last computation and the derivation
  // will need to recompute when it's needed next.

  IDerivationState_[IDerivationState_["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));

var TraceMode;

(function (TraceMode) {
  TraceMode[TraceMode["NONE"] = 0] = "NONE";
  TraceMode[TraceMode["LOG"] = 1] = "LOG";
  TraceMode[TraceMode["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));

var CaughtException = function CaughtException(cause) {
  this.cause = void 0;
  this.cause = cause; // Empty
};

function isCaughtException(e) {
  return e instanceof CaughtException;
}
/**
 * Finds out whether any dependency of the derivation has actually changed.
 * If dependenciesState is 1 then it will recalculate dependencies,
 * if any dependency changed it will propagate it by changing dependenciesState to 2.
 *
 * By iterating over the dependencies in the same order that they were reported and
 * stopping on the first change, all the recalculations are only called for ComputedValues
 * that will be tracked by derivation. That is because we assume that if the first x
 * dependencies of the derivation doesn't change then the derivation should run the same way
 * up until accessing x-th dependency.
 */


function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;

    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;

    case IDerivationState_.POSSIBLY_STALE_:
      {
        // state propagation can occur outside of action/reactive context #2195
        var prevAllowStateReads = allowStateReadsStart(true);
        var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.

        var obs = derivation.observing_,
            l = obs.length;

        for (var i = 0; i < l; i++) {
          var obj = obs[i];

          if (isComputedValue(obj)) {
            if (globalState.disableErrorBoundaries) {
              obj.get();
            } else {
              try {
                obj.get();
              } catch (e) {
                // we are not interested in the value *or* exception at this moment, but if there is one, notify all
                untrackedEnd(prevUntracked);
                allowStateReadsEnd(prevAllowStateReads);
                return true;
              }
            } // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.
            // and `derivation` is an observer of `obj`
            // invariantShouldCompute(derivation)


            if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
        }

        changeDependenciesStateTo0(derivation);
        untrackedEnd(prevUntracked);
        allowStateReadsEnd(prevAllowStateReads);
        return false;
      }
  }
}

function isComputingDerivation() {
  return globalState.trackingDerivation !== null; // filter out actions inside computations
}

function checkIfStateModificationsAreAllowed(atom) {
  if (false) {}

  var hasObservers = atom.observers_.size > 0; // Should not be possible to change observed state outside strict mode, except during initialization, see #563

  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "always")) console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
}

function checkIfStateReadsAreAllowed(observable) {
  if ( true && !globalState.allowStateReads && globalState.observableRequiresReaction) {
    console.warn("[mobx] Observable " + observable.name_ + " being read outside a reactive context");
  }
}
/**
 * Executes the provided function `f` and tracks which observables are being accessed.
 * The tracking information is stored on the `derivation` object and the derivation is registered
 * as observer of any of the accessed observables.
 */


function trackDerivedFunction(derivation, f, context) {
  var prevAllowStateReads = allowStateReadsStart(true); // pre allocate array allocation + room for variation in deps
  // array will be trimmed by bindDependencies

  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(derivation.observing_.length + 100);
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;

  if (globalState.disableErrorBoundaries === true) {
    result = f.call(context);
  } else {
    try {
      result = f.call(context);
    } catch (e) {
      result = new CaughtException(e);
    }
  }

  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  warnAboutDerivationWithoutDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}

function warnAboutDerivationWithoutDependencies(derivation) {
  if (false) {}
  if (derivation.observing_.length !== 0) return;

  if (globalState.reactionRequiresObservable || derivation.requiresObservable_) {
    console.warn("[mobx] Derivation " + derivation.name_ + " is created/updated without reading any observable value");
  }
}
/**
 * diffs newObserving with observing.
 * update observing to be newObserving with unique observables
 * notify observers that become observed/unobserved
 */


function bindDependencies(derivation) {
  // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_; // Go through all new observables and check diffValue: (this list can contain duplicates):
  //   0: first occurrence, change to 1 and keep it
  //   1: extra occurrence, drop it

  var i0 = 0,
      l = derivation.unboundDepsCount_;

  for (var i = 0; i < l; i++) {
    var dep = observing[i];

    if (dep.diffValue_ === 0) {
      dep.diffValue_ = 1;
      if (i0 !== i) observing[i0] = dep;
      i0++;
    } // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
    // not hitting the condition


    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }

  observing.length = i0;
  derivation.newObserving_ = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)
  // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
  //   0: it's not in new observables, unobserve it
  //   1: it keeps being observed, don't want to notify it. change to 0

  l = prevObserving.length;

  while (l--) {
    var _dep = prevObserving[l];

    if (_dep.diffValue_ === 0) {
      removeObserver(_dep, derivation);
    }

    _dep.diffValue_ = 0;
  } // Go through all new observables and check diffValue: (now it should be unique)
  //   0: it was set to 0 in last loop. don't need to do anything.
  //   1: it wasn't observed, let's observe it. set back to 0


  while (i0--) {
    var _dep2 = observing[i0];

    if (_dep2.diffValue_ === 1) {
      _dep2.diffValue_ = 0;
      addObserver(_dep2, derivation);
    }
  } // Some new observed derivations may become stale during this derivation computation
  // so they have had no chance to propagate staleness (#916)


  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}

function clearObserving(derivation) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i = obs.length;

  while (i--) {
    removeObserver(obs[i], derivation);
  }

  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}

function untracked(action) {
  var prev = untrackedStart();

  try {
    return action();
  } finally {
    untrackedEnd(prev);
  }
}

function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}

function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}

function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}

function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
/**
 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
 *
 */


function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) return;
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i = obs.length;

  while (i--) {
    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
/**
 * These values will persist if global state is reset
 */


var persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"];

var MobXGlobals = function MobXGlobals() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
};

var canMergeGlobalState = true;
var isolateCalled = false;

var globalState = /*#__PURE__*/function () {
  var global = /*#__PURE__*/getGlobal();
  if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals) canMergeGlobalState = false;
  if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version) canMergeGlobalState = false;

  if (!canMergeGlobalState) {
    setTimeout(function () {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global.__mobxGlobals) {
    global.__mobxInstanceCount += 1;
    if (!global.__mobxGlobals.UNCHANGED) global.__mobxGlobals.UNCHANGED = {}; // make merge backward compatible

    return global.__mobxGlobals;
  } else {
    global.__mobxInstanceCount = 1;
    return global.__mobxGlobals = /*#__PURE__*/new MobXGlobals();
  }
}();

function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) die(36);
  isolateCalled = true;

  if (canMergeGlobalState) {
    var global = getGlobal();
    if (--global.__mobxInstanceCount === 0) global.__mobxGlobals = undefined;
    globalState = new MobXGlobals();
  }
}

function getGlobalState() {
  return globalState;
}
/**
 * For testing purposes only; this will break the internal state of existing observables,
 * but can be used to get back at a stable state after throwing errors
 */


function resetGlobalState() {
  var defaultGlobals = new MobXGlobals();

  for (var key in defaultGlobals) {
    if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];
  }

  globalState.allowStateChanges = !globalState.enforceActions;
}

function hasObservers(observable) {
  return observable.observers_ && observable.observers_.size > 0;
}

function getObservers(observable) {
  return observable.observers_;
} // function invariantObservers(observable: IObservable) {
//     const list = observable.observers
//     const map = observable.observersIndexes
//     const l = list.length
//     for (let i = 0; i < l; i++) {
//         const id = list[i].__mapid
//         if (i) {
//             invariant(map[id] === i, "INTERNAL ERROR maps derivation.__mapid to index in list") // for performance
//         } else {
//             invariant(!(id in map), "INTERNAL ERROR observer on index 0 shouldn't be held in map.") // for performance
//         }
//     }
//     invariant(
//         list.length === 0 || Object.keys(map).length === list.length - 1,
//         "INTERNAL ERROR there is no junk in map"
//     )
// }


function addObserver(observable, node) {
  // invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");
  // invariantObservers(observable);
  observable.observers_.add(node);
  if (observable.lowestObserverState_ > node.dependenciesState_) observable.lowestObserverState_ = node.dependenciesState_; // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR didn't add node");
}

function removeObserver(observable, node) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");
  // invariantObservers(observable);
  observable.observers_["delete"](node);

  if (observable.observers_.size === 0) {
    // deleting last observer
    queueForUnobservation(observable);
  } // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR remove already removed node2");

}

function queueForUnobservation(observable) {
  if (observable.isPendingUnobservation_ === false) {
    // invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");
    observable.isPendingUnobservation_ = true;
    globalState.pendingUnobservations.push(observable);
  }
}
/**
 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
 * During a batch `onBecomeUnobserved` will be called at most once per observable.
 * Avoids unnecessary recalculations.
 */


function startBatch() {
  globalState.inBatch++;
}

function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions(); // the batch is actually about to finish, all unobserving should happen here.

    var list = globalState.pendingUnobservations;

    for (var i = 0; i < list.length; i++) {
      var observable = list[i];
      observable.isPendingUnobservation_ = false;

      if (observable.observers_.size === 0) {
        if (observable.isBeingObserved_) {
          // if this observable had reactive observers, trigger the hooks
          observable.isBeingObserved_ = false;
          observable.onBUO();
        }

        if (observable instanceof ComputedValue) {
          // computed values are automatically teared down when the last observer leaves
          // this process happens recursively, this computed might be the last observabe of another, etc..
          observable.suspend_();
        }
      }
    }

    globalState.pendingUnobservations = [];
  }
}

function reportObserved(observable) {
  checkIfStateReadsAreAllowed(observable);
  var derivation = globalState.trackingDerivation;

  if (derivation !== null) {
    /**
     * Simple optimization, give each derivation run an unique id (runId)
     * Check if last time this observable was accessed the same runId is used
     * if this is the case, the relation is already known
     */
    if (derivation.runId_ !== observable.lastAccessedBy_) {
      observable.lastAccessedBy_ = derivation.runId_; // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...

      derivation.newObserving_[derivation.unboundDepsCount_++] = observable;

      if (!observable.isBeingObserved_ && globalState.trackingContext) {
        observable.isBeingObserved_ = true;
        observable.onBO();
      }
    }

    return true;
  } else if (observable.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable);
  }

  return false;
} // function invariantLOS(observable: IObservable, msg: string) {
//     // it's expensive so better not run it in produciton. but temporarily helpful for testing
//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)
//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`
//     throw new Error(
//         "lowestObserverState is wrong for " +
//             msg +
//             " because " +
//             min +
//             " < " +
//             observable.lowestObserverState
//     )
// }

/**
 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
 * It will propagate changes to observers from previous run
 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
 * Hopefully self reruning autoruns aren't a feature people should depend on
 * Also most basic use cases should be ok
 */
// Called by Atom when its value changes


function propagateChanged(observable) {
  // invariantLOS(observable, "changed start");
  if (observable.lowestObserverState_ === IDerivationState_.STALE_) return;
  observable.lowestObserverState_ = IDerivationState_.STALE_; // Ideally we use for..of here, but the downcompiled version is really slow...

  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      if ( true && d.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d, observable);
      }

      d.onBecomeStale_();
    }

    d.dependenciesState_ = IDerivationState_.STALE_;
  }); // invariantLOS(observable, "changed end");
} // Called by ComputedValue when it recalculate and its value changed


function propagateChangeConfirmed(observable) {
  // invariantLOS(observable, "confirmed start");
  if (observable.lowestObserverState_ === IDerivationState_.STALE_) return;
  observable.lowestObserverState_ = IDerivationState_.STALE_;
  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) d.dependenciesState_ = IDerivationState_.STALE_;else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ // this happens during computing of `d`, just keep lowestObserverState up to date.
    ) observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }); // invariantLOS(observable, "confirmed end");
} // Used by computed when its dependency changed, but we don't wan't to immediately recompute.


function propagateMaybeChanged(observable) {
  // invariantLOS(observable, "maybe start");
  if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) return;
  observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;

      if ( true && d.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d, observable);
      }

      d.onBecomeStale_();
    }
  }); // invariantLOS(observable, "maybe end");
}

function logTraceInfo(derivation, observable) {
  console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable.name_ + "'");

  if (derivation.isTracing_ === TraceMode.BREAK) {
    var lines = [];
    printDepTree(getDependencyTree(derivation), lines, 1); // prettier-ignore

    new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
}

function printDepTree(tree, lines, depth) {
  if (lines.length >= 1000) {
    lines.push("(and many more)");
    return;
  }

  lines.push("" + new Array(depth).join("\t") + tree.name); // MWE: not the fastest, but the easiest way :)

  if (tree.dependencies) tree.dependencies.forEach(function (child) {
    return printDepTree(child, lines, depth + 1);
  });
}

var Reaction = /*#__PURE__*/function () {
  // nodes we are looking at. Our value depends on these nodes
  function Reaction(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ =  true ? "Reaction@" + getNextId() : undefined;
    }

    if (requiresObservable_ === void 0) {
      requiresObservable_ = false;
    }

    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.isDisposed_ = false;
    this.isScheduled_ = false;
    this.isTrackPending_ = false;
    this.isRunning_ = false;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }

  var _proto = Reaction.prototype;

  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };

  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled_) {
      this.isScheduled_ = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };

  _proto.isScheduled = function isScheduled() {
    return this.isScheduled_;
  }
  /**
   * internal, use schedule() if you intend to kick off a reaction
   */
  ;

  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed_) {
      startBatch();
      this.isScheduled_ = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;

      if (shouldCompute(this)) {
        this.isTrackPending_ = true;

        try {
          this.onInvalidate_();

          if ( true && this.isTrackPending_ && isSpyEnabled()) {
            // onInvalidate didn't trigger track right away..
            spyReport({
              name: this.name_,
              type: "scheduled-reaction"
            });
          }
        } catch (e) {
          this.reportExceptionInDerivation_(e);
        }
      }

      globalState.trackingContext = prev;
      endBatch();
    }
  };

  _proto.track = function track(fn) {
    if (this.isDisposed_) {
      return; // console.warn("Reaction already disposed") // Note: Not a warning / error in mobx 4 either
    }

    startBatch();
    var notify = isSpyEnabled();
    var startTime;

    if ( true && notify) {
      startTime = Date.now();
      spyReportStart({
        name: this.name_,
        type: "reaction"
      });
    }

    this.isRunning_ = true;
    var prevReaction = globalState.trackingContext; // reactions could create reactions...

    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn, undefined);
    globalState.trackingContext = prevReaction;
    this.isRunning_ = false;
    this.isTrackPending_ = false;

    if (this.isDisposed_) {
      // disposed during last run. Clean up everything that was bound after the dispose call.
      clearObserving(this);
    }

    if (isCaughtException(result)) this.reportExceptionInDerivation_(result.cause);

    if ( true && notify) {
      spyReportEnd({
        time: Date.now() - startTime
      });
    }

    endBatch();
  };

  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;

    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }

    if (globalState.disableErrorBoundaries) throw error;
    var message =  true ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : undefined;

    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
      /** If debugging brought you here, please, read the above message :-). Tnx! */
    } else if (true) console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)"); // prettier-ignore


    if ( true && isSpyEnabled()) {
      spyReport({
        type: "error",
        name: this.name_,
        message: message,
        error: "" + error
      });
    }

    globalState.globalReactionErrorHandlers.forEach(function (f) {
      return f(error, _this);
    });
  };

  _proto.dispose = function dispose() {
    if (!this.isDisposed_) {
      this.isDisposed_ = true;

      if (!this.isRunning_) {
        // if disposed while running, clean up later. Maybe not optimal, but rare case
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };

  _proto.getDisposer_ = function getDisposer_() {
    var r = this.dispose.bind(this);
    r[$mobx] = this;
    return r;
  };

  _proto.toString = function toString() {
    return "Reaction[" + this.name_ + "]";
  };

  _proto.trace = function trace$1(enterBreakPoint) {
    if (enterBreakPoint === void 0) {
      enterBreakPoint = false;
    }

    trace(this, enterBreakPoint);
  };

  return Reaction;
}();

function onReactionError(handler) {
  globalState.globalReactionErrorHandlers.push(handler);
  return function () {
    var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
    if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);
  };
}
/**
 * Magic number alert!
 * Defines within how many times a reaction is allowed to re-trigger itself
 * until it is assumed that this is gonna be a never ending loop...
 */


var MAX_REACTION_ITERATIONS = 100;

var reactionScheduler = function reactionScheduler(f) {
  return f();
};

function runReactions() {
  // Trampolining, if runReactions are already running, new reactions will be picked up
  if (globalState.inBatch > 0 || globalState.isRunningReactions) return;
  reactionScheduler(runReactionsHelper);
}

function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0; // While running reactions, new reactions might be triggered.
  // Hence we work with two variables and check whether
  // we converge to no remaining reactions after a while.

  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error( true ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) : undefined);
      allReactions.splice(0); // clear reactions
    }

    var remainingReactions = allReactions.splice(0);

    for (var i = 0, l = remainingReactions.length; i < l; i++) {
      remainingReactions[i].runReaction_();
    }
  }

  globalState.isRunningReactions = false;
}

var isReaction = /*#__PURE__*/createInstanceofPredicate("Reaction", Reaction);

function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;

  reactionScheduler = function reactionScheduler(f) {
    return fn(function () {
      return baseScheduler(f);
    });
  };
}

function isSpyEnabled() {
  return  true && !!globalState.spyListeners.length;
}

function spyReport(event) {
  if (false) {} // dead code elimination can do the rest

  if (!globalState.spyListeners.length) return;
  var listeners = globalState.spyListeners;

  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](event);
  }
}

function spyReportStart(event) {
  if (false) {}

  var change = _extends({}, event, {
    spyReportStart: true
  });

  spyReport(change);
}

var END_EVENT = {
  type: "report-end",
  spyReportEnd: true
};

function spyReportEnd(change) {
  if (false) {}
  if (change) spyReport(_extends({}, change, {
    type: "report-end",
    spyReportEnd: true
  }));else spyReport(END_EVENT);
}

function spy(listener) {
  if (false) {} else {
    globalState.spyListeners.push(listener);
    return once(function () {
      globalState.spyListeners = globalState.spyListeners.filter(function (l) {
        return l !== listener;
      });
    });
  }
}

var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = /*#__PURE__*/createActionAnnotation(ACTION);
var actionBoundAnnotation = /*#__PURE__*/createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});

function createActionFactory(autoAction) {
  var res = function action(arg1, arg2) {
    // action(fn() {})
    if (isFunction(arg1)) return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction); // action("name", fn() {})

    if (isFunction(arg2)) return createAction(arg1, arg2, autoAction); // @action

    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation);
    } // action("name") & @action("name")


    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction
      }));
    }

    if (true) die("Invalid arguments for `action`");
  };

  return res;
}

var action = /*#__PURE__*/createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = /*#__PURE__*/createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /*#__PURE__*/createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /*#__PURE__*/createDecoratorAnnotation(autoActionBoundAnnotation);

function runInAction(fn) {
  return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined);
}

function isAction(thing) {
  return isFunction(thing) && thing.isMobxAction === true;
}
/**
 * Creates a named reactive view and keeps it alive, so that the view is always
 * updated if one of the dependencies changes, even when the view is not further used by something else.
 * @param view The reactive view
 * @returns disposer function, which can be used to stop the view from being updated in the future.
 */


function autorun(view, opts) {
  var _opts$name, _opts;

  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }

  if (true) {
    if (!isFunction(view)) die("Autorun expects a function as first argument");
    if (isAction(view)) die("Autorun does not accept actions since actions are untrackable");
  }

  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name :  true ? view.name || "Autorun@" + getNextId() : undefined;
  var runSync = !opts.scheduler && !opts.delay;
  var reaction;

  if (runSync) {
    // normal autorun
    reaction = new Reaction(name, function () {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts); // debounced autorun

    var isScheduled = false;
    reaction = new Reaction(name, function () {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function () {
          isScheduled = false;
          if (!reaction.isDisposed_) reaction.track(reactionRunner);
        });
      }
    }, opts.onError, opts.requiresObservable);
  }

  function reactionRunner() {
    view(reaction);
  }

  reaction.schedule_();
  return reaction.getDisposer_();
}

var run = function run(f) {
  return f();
};

function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function (f) {
    return setTimeout(f, opts.delay);
  } : run;
}

function reaction(expression, effect, opts) {
  var _opts$name2;

  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }

  if (true) {
    if (!isFunction(expression) || !isFunction(effect)) die("First and second argument to reaction should be functions");
    if (!isPlainObject(opts)) die("Third argument of reactions should be an object");
  }

  var name = (_opts$name2 = opts.name) != null ? _opts$name2 :  true ? "Reaction@" + getNextId() : undefined;
  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var oldValue = undefined; // only an issue with fireImmediately

  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
  var r = new Reaction(name, function () {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);

  function reactionRunner() {
    isScheduled = false;
    if (r.isDisposed_) return;
    var changed = false;
    r.track(function () {
      var nextValue = allowStateChanges(false, function () {
        return expression(r);
      });
      changed = firstTime || !equals(value, nextValue);
      oldValue = value;
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately) effectAction(value, oldValue, r);else if (!firstTime && changed) effectAction(value, oldValue, r);
    firstTime = false;
  }

  r.schedule_();
  return r.getDisposer_();
}

function wrapErrorHandler(errorHandler, baseFn) {
  return function () {
    try {
      return baseFn.apply(this, arguments);
    } catch (e) {
      errorHandler.call(this, e);
    }
  };
}

var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";

function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}

function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}

function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";

  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = new Set([cb]);
  }

  return function () {
    var hookListeners = atom[listenersKey];

    if (hookListeners) {
      hookListeners["delete"](cb);

      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}

var NEVER = "never";
var ALWAYS = "always";
var OBSERVED = "observed"; // const IF_AVAILABLE = "ifavailable"

function configure(options) {
  if (options.isolateGlobalState === true) {
    isolateGlobalState();
  }

  var useProxies = options.useProxies,
      enforceActions = options.enforceActions;

  if (useProxies !== undefined) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
  }

  if (useProxies === "ifavailable") globalState.verifyProxies = true;

  if (enforceActions !== undefined) {
    var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea;
    globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
  }

  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function (key) {
    if (key in options) globalState[key] = !!options[key];
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;

  if ( true && globalState.disableErrorBoundaries === true) {
    console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
  }

  if (options.reactionScheduler) {
    setReactionScheduler(options.reactionScheduler);
  }
}

function extendObservable(target, properties, annotations, options) {
  if (true) {
    if (arguments.length > 4) die("'extendObservable' expected 2-4 arguments");
    if (typeof target !== "object") die("'extendObservable' expects an object as first argument");
    if (isObservableMap(target)) die("'extendObservable' should not be used on maps, use map.merge instead");
    if (!isPlainObject(properties)) die("'extendObservabe' only accepts plain objects as second argument");
    if (isObservable(properties) || isObservable(annotations)) die("Extending an object with another observable (object) is not supported");
  } // Pull descriptors first, so we don't have to deal with props added by administration ($mobx)


  var descriptors = getOwnPropertyDescriptors(properties);
  var adm = asObservableObject(target, options)[$mobx];
  startBatch();

  try {
    ownKeys(descriptors).forEach(function (key) {
      adm.extend_(key, descriptors[key], // must pass "undefined" for { key: undefined }
      !annotations ? true : key in annotations ? annotations[key] : true);
    });
  } finally {
    endBatch();
  }

  return target;
}

function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}

function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0) result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  return result;
}

function getObserverTree(thing, property) {
  return nodeToObserverTree(getAtom(thing, property));
}

function nodeToObserverTree(node) {
  var result = {
    name: node.name_
  };
  if (hasObservers(node)) result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);
  return result;
}

function unique(list) {
  return Array.from(new Set(list));
}

var generatorId = 0;

function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}

FlowCancellationError.prototype = /*#__PURE__*/Object.create(Error.prototype);

function isFlowCancellationError(error) {
  return error instanceof FlowCancellationError;
}

var flowAnnotation = /*#__PURE__*/createFlowAnnotation("flow");
var flow = /*#__PURE__*/Object.assign(function flow(arg1, arg2) {
  // @flow
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  } // flow(fn)


  if ( true && arguments.length !== 1) die("Flow expects single argument with generator function");
  var generator = arg1;
  var name = generator.name || "<unnamed flow>"; // Implementation based on https://github.com/tj/co/blob/master/index.js

  var res = function res() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = undefined;
    var promise = new Promise(function (resolve, reject) {
      var stepId = 0;
      rejector = reject;

      function onFulfilled(res) {
        pendingPromise = undefined;
        var ret;

        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res);
        } catch (e) {
          return reject(e);
        }

        next(ret);
      }

      function onRejected(err) {
        pendingPromise = undefined;
        var ret;

        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e) {
          return reject(e);
        }

        next(ret);
      }

      function next(ret) {
        if (isFunction(ret == null ? void 0 : ret.then)) {
          // an async iterator
          ret.then(next, reject);
          return;
        }

        if (ret.done) return resolve(ret.value);
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }

      onFulfilled(undefined); // kick off the process
    });
    promise.cancel = action(name + " - runid: " + runId + " - cancel", function () {
      try {
        if (pendingPromise) cancelPromise(pendingPromise); // Finally block can return (or yield) stuff..

        var _res = gen["return"](undefined); // eat anything that promise would do, it's cancelled!


        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop, noop);
        cancelPromise(yieldedPromise); // maybe it can be cancelled :)
        // reject our original promise

        rejector(new FlowCancellationError());
      } catch (e) {
        rejector(e); // there could be a throwing finally block
      }
    });
    return promise;
  };

  res.isMobXFlow = true;
  return res;
}, flowAnnotation);

function cancelPromise(promise) {
  if (isFunction(promise.cancel)) promise.cancel();
}

function flowResult(result) {
  return result; // just tricking TypeScript :)
}

function isFlow(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}

function interceptReads(thing, propOrHandler, handler) {
  var target;

  if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
    target = getAdministration(thing);
  } else if (isObservableObject(thing)) {
    if ( true && !isStringish(propOrHandler)) return die("InterceptReads can only be used with a specific property, not with an object in general");
    target = getAdministration(thing, propOrHandler);
  } else if (true) {
    return die("Expected observable map, object or array as first array");
  }

  if ( true && target.dehancer !== undefined) return die("An intercept reader was already established");
  target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
  return function () {
    target.dehancer = undefined;
  };
}

function intercept(thing, propOrHandler, handler) {
  if (isFunction(handler)) return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);
}

function interceptInterceptable(thing, handler) {
  return getAdministration(thing).intercept_(handler);
}

function interceptProperty(thing, property, handler) {
  return getAdministration(thing, property).intercept_(handler);
}

function _isComputed(value, property) {
  if (property !== undefined) {
    if (isObservableObject(value) === false) return false;
    if (!value[$mobx].values_.has(property)) return false;
    var atom = getAtom(value, property);
    return isComputedValue(atom);
  }

  return isComputedValue(value);
}

function isComputed(value) {
  if ( true && arguments.length > 1) return die("isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property");
  return _isComputed(value);
}

function isComputedProp(value, propName) {
  if ( true && !isStringish(propName)) return die("isComputed expected a property name as second argument");
  return _isComputed(value, propName);
}

function _isObservable(value, property) {
  if (!value) return false;

  if (property !== undefined) {
    if ( true && (isObservableMap(value) || isObservableArray(value))) return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");

    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }

    return false;
  } // For first check, see #701


  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}

function isObservable(value) {
  if ( true && arguments.length !== 1) die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  return _isObservable(value);
}

function isObservableProp(value, propName) {
  if ( true && !isStringish(propName)) return die("expected a property name as second argument");
  return _isObservable(value, propName);
}

function keys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].keys_();
  }

  if (isObservableMap(obj) || isObservableSet(obj)) {
    return Array.from(obj.keys());
  }

  if (isObservableArray(obj)) {
    return obj.map(function (_, index) {
      return index;
    });
  }

  die(5);
}

function values(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return obj[key];
    });
  }

  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return obj.get(key);
    });
  }

  if (isObservableSet(obj)) {
    return Array.from(obj.values());
  }

  if (isObservableArray(obj)) {
    return obj.slice();
  }

  die(6);
}

function entries(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj[key]];
    });
  }

  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj.get(key)];
    });
  }

  if (isObservableSet(obj)) {
    return Array.from(obj.entries());
  }

  if (isObservableArray(obj)) {
    return obj.map(function (key, index) {
      return [index, key];
    });
  }

  die(7);
}

function set(obj, key, value) {
  if (arguments.length === 2 && !isObservableSet(obj)) {
    startBatch();
    var _values = key;

    try {
      for (var _key in _values) {
        set(obj, _key, _values[_key]);
      }
    } finally {
      endBatch();
    }

    return;
  }

  if (isObservableObject(obj)) {
    obj[$mobx].set_(key, value);
  } else if (isObservableMap(obj)) {
    obj.set(key, value);
  } else if (isObservableSet(obj)) {
    obj.add(key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") key = parseInt(key, 10);
    if (key < 0) die("Invalid index: '" + key + "'");
    startBatch();
    if (key >= obj.length) obj.length = key + 1;
    obj[key] = value;
    endBatch();
  } else die(8);
}

function remove(obj, key) {
  if (isObservableObject(obj)) {
    obj[$mobx].delete_(key);
  } else if (isObservableMap(obj)) {
    obj["delete"](key);
  } else if (isObservableSet(obj)) {
    obj["delete"](key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") key = parseInt(key, 10);
    obj.splice(key, 1);
  } else {
    die(9);
  }
}

function has(obj, key) {
  if (isObservableObject(obj)) {
    return obj[$mobx].has_(key);
  } else if (isObservableMap(obj)) {
    return obj.has(key);
  } else if (isObservableSet(obj)) {
    return obj.has(key);
  } else if (isObservableArray(obj)) {
    return key >= 0 && key < obj.length;
  }

  die(10);
}

function get(obj, key) {
  if (!has(obj, key)) return undefined;

  if (isObservableObject(obj)) {
    return obj[$mobx].get_(key);
  } else if (isObservableMap(obj)) {
    return obj.get(key);
  } else if (isObservableArray(obj)) {
    return obj[key];
  }

  die(11);
}

function observe(thing, propOrCb, cbOrFire, fireImmediately) {
  if (isFunction(cbOrFire)) return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);
}

function observeObservable(thing, listener, fireImmediately) {
  return getAdministration(thing).observe_(listener, fireImmediately);
}

function observeObservableProperty(thing, property, listener, fireImmediately) {
  return getAdministration(thing, property).observe_(listener, fireImmediately);
}

function cache(map, key, value) {
  map.set(key, value);
  return value;
}

function toJSHelper(source, __alreadySeen) {
  if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) return source;
  if (isObservableValue(source)) return toJSHelper(source.get(), __alreadySeen);

  if (__alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }

  if (isObservableArray(source)) {
    var res = cache(__alreadySeen, source, new Array(source.length));
    source.forEach(function (value, idx) {
      res[idx] = toJSHelper(value, __alreadySeen);
    });
    return res;
  }

  if (isObservableSet(source)) {
    var _res = cache(__alreadySeen, source, new Set());

    source.forEach(function (value) {
      _res.add(toJSHelper(value, __alreadySeen));
    });
    return _res;
  }

  if (isObservableMap(source)) {
    var _res2 = cache(__alreadySeen, source, new Map());

    source.forEach(function (value, key) {
      _res2.set(key, toJSHelper(value, __alreadySeen));
    });
    return _res2;
  } else {
    // must be observable object
    keys(source); // make sure keys are observed

    var _res3 = cache(__alreadySeen, source, {});

    getPlainObjectKeys(source).forEach(function (key) {
      _res3[key] = toJSHelper(source[key], __alreadySeen);
    });
    return _res3;
  }
}
/**
 * Basically, a deep clone, so that no reactive property will exist anymore.
 */


function toJS(source, options) {
  if ( true && options) die("toJS no longer supports options");
  return toJSHelper(source, new Map());
}

function trace() {
  if (false) {}
  var enterBreakPoint = false;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (typeof args[args.length - 1] === "boolean") enterBreakPoint = args.pop();
  var derivation = getAtomFromArgs(args);

  if (!derivation) {
    return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }

  if (derivation.isTracing_ === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
  }

  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}

function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;

    case 1:
      return getAtom(args[0]);

    case 2:
      return getAtom(args[0], args[1]);
  }
}
/**
 * During a transaction no views are updated until the end of the transaction.
 * The transaction will be run synchronously nonetheless.
 *
 * @param action a function that updates some reactive state
 * @returns any value that was returned by the 'action' parameter.
 */


function transaction(action, thisArg) {
  if (thisArg === void 0) {
    thisArg = undefined;
  }

  startBatch();

  try {
    return action.apply(thisArg);
  } finally {
    endBatch();
  }
}

function when(predicate, arg1, arg2) {
  if (arguments.length === 1 || arg1 && typeof arg1 === "object") return whenPromise(predicate, arg1);
  return _when(predicate, arg1, arg2 || {});
}

function _when(predicate, effect, opts) {
  var timeoutHandle;

  if (typeof opts.timeout === "number") {
    timeoutHandle = setTimeout(function () {
      if (!disposer[$mobx].isDisposed_) {
        disposer();
        var error = new Error("WHEN_TIMEOUT");
        if (opts.onError) opts.onError(error);else throw error;
      }
    }, opts.timeout);
  }

  opts.name =  true ? opts.name || "When@" + getNextId() : undefined;
  var effectAction = createAction( true ? opts.name + "-effect" : undefined, effect); // eslint-disable-next-line

  var disposer = autorun(function (r) {
    // predicate should not change state
    var cond = allowStateChanges(false, predicate);

    if (cond) {
      r.dispose();
      if (timeoutHandle) clearTimeout(timeoutHandle);
      effectAction();
    }
  }, opts);
  return disposer;
}

function whenPromise(predicate, opts) {
  if ( true && opts && opts.onError) return die("the options 'onError' and 'promise' cannot be combined");
  var cancel;
  var res = new Promise(function (resolve, reject) {
    var disposer = _when(predicate, resolve, _extends({}, opts, {
      onError: reject
    }));

    cancel = function cancel() {
      disposer();
      reject("WHEN_CANCELLED");
    };
  });
  res.cancel = cancel;
  return res;
}

function getAdm(target) {
  return target[$mobx];
} // Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,
// and skip either the internal values map, or the base object with its property descriptors!


var objectProxyTraps = {
  has: function has(target, name) {
    if ( true && globalState.trackingDerivation) warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
    return getAdm(target).has_(name);
  },
  get: function get(target, name) {
    return getAdm(target).get_(name);
  },
  set: function set(target, name, value) {
    var _getAdm$set_;

    if (!isStringish(name)) return false;

    if ( true && !getAdm(target).values_.has(name)) {
      warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
    } // null (intercepted) -> true (success)


    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name) {
    var _getAdm$delete_;

    if (true) {
      warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
    }

    if (!isStringish(name)) return false; // null (intercepted) -> true (success)

    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty(target, name, descriptor) {
    var _getAdm$definePropert;

    if (true) {
      warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
    } // null (intercepted) -> true (success)


    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys(target) {
    if ( true && globalState.trackingDerivation) warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use `keys` from 'mobx' instead.");
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};

function asDynamicObservableObject(target, options) {
  var _target$$mobx, _target$$mobx$proxy_;

  assertProxies();
  target = asObservableObject(target, options);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}

function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0;
}

function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function () {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) interceptors.splice(idx, 1);
  });
}

function interceptChange(interceptable, change) {
  var prevU = untrackedStart();

  try {
    // Interceptor can modify the array, copy it to avoid concurrent modification, see #1950
    var interceptors = [].concat(interceptable.interceptors_ || []);

    for (var i = 0, l = interceptors.length; i < l; i++) {
      change = interceptors[i](change);
      if (change && !change.type) die(14);
      if (!change) break;
    }

    return change;
  } finally {
    untrackedEnd(prevU);
  }
}

function hasListeners(listenable) {
  return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0;
}

function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function () {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) listeners.splice(idx, 1);
  });
}

function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) return;
  listeners = listeners.slice();

  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](change);
  }

  untrackedEnd(prevU);
}

function makeObservable(target, annotations, options) {
  var adm = asObservableObject(target, options)[$mobx];
  startBatch();

  try {
    var _annotations; // Default to decorators


    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target); // Annotate

    ownKeys(annotations).forEach(function (key) {
      return adm.make_(key, annotations[key]);
    });
  } finally {
    endBatch();
  }

  return target;
}

function makeAutoObservable(target, overrides, options) {
  if (true) {
    if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target))) die("'makeAutoObservable' can only be used for classes that don't have a superclass");
    if (isObservableObject(target)) die("makeAutoObservable can only be used on objects not already made observable");
  } // Optimization (avoids visiting protos)
  // assumes that annotation.make_/.extend_ works the same for plain objects


  if (isPlainObject(target)) {
    return extendObservable(target, target, overrides, options);
  }

  var adm = asObservableObject(target, options)[$mobx];
  startBatch();

  try {
    // Use cached inferred annotations if available (only in classes)
    if (target[inferredAnnotationsSymbol]) {
      target[inferredAnnotationsSymbol].forEach(function (value, key) {
        return adm.make_(key, value);
      });
    } else {
      var _ignoreKeys;

      var ignoreKeys = (_ignoreKeys = {}, _ignoreKeys[$mobx] = 1, _ignoreKeys[inferredAnnotationsSymbol] = 1, _ignoreKeys.constructor = 1, _ignoreKeys);

      var make = function make(key) {
        if (ignoreKeys[key]) return;
        ignoreKeys[key] = 1;
        adm.make_(key, // must pass "undefined" for { key: undefined }
        !overrides ? true : key in overrides ? overrides[key] : true);
      };

      var current = target;

      while (current && current !== objectPrototype) {
        ownKeys(current).forEach(make);
        current = Object.getPrototypeOf(current);
      }
    }
  } finally {
    endBatch();
  }

  return target;
}

var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859

var arrayTraps = {
  get: function get(target, name) {
    var adm = target[$mobx];
    if (name === $mobx) return adm;
    if (name === "length") return adm.getArrayLength_();

    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }

    if (hasProp(arrayExtensions, name)) {
      return arrayExtensions[name];
    }

    return target[name];
  },
  set: function set(target, name, value) {
    var adm = target[$mobx];

    if (name === "length") {
      adm.setArrayLength_(value);
    }

    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      // numeric string
      adm.set_(parseInt(name), value);
    }

    return true;
  },
  preventExtensions: function preventExtensions() {
    die(15);
  }
};

var ObservableArrayAdministration = /*#__PURE__*/function () {
  // this is the prop that gets proxied, so can't replace it!
  function ObservableArrayAdministration(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name =  true ? "ObservableArray@" + getNextId() : undefined;
    }

    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name);

    this.enhancer_ = function (newV, oldV) {
      return enhancer(newV, oldV,  true ? name + "[..]" : undefined);
    };
  }

  var _proto = ObservableArrayAdministration.prototype;

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) return this.dehancer(value);
    return value;
  };

  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== undefined && values.length > 0) return values.map(this.dehancer);
    return values;
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }

    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }

    return registerListener(this, listener);
  };

  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };

  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || newLength < 0) die("Out of range: " + newLength);
    var currentLength = this.values_.length;
    if (newLength === currentLength) return;else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);

      for (var i = 0; i < newLength - currentLength; i++) {
        newItems[i] = undefined;
      } // No Array.fill everywhere...


      this.spliceWithArray_(currentLength, 0, newItems);
    } else this.spliceWithArray_(newLength, currentLength - newLength);
  };

  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_) die(16);
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0) reserveArrayBuffer(oldLength + delta + 1);
  };

  _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {
    var _this = this;

    checkIfStateModificationsAreAllowed(this.atom_);
    var length = this.values_.length;
    if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);
    if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));
    if (newItems === undefined) newItems = EMPTY_ARRAY;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: index,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) return EMPTY_ARRAY;
      deleteCount = change.removedCount;
      newItems = change.added;
    }

    newItems = newItems.length === 0 ? newItems : newItems.map(function (v) {
      return _this.enhancer_(v, undefined);
    });

    if (this.legacyMode_ || "development" !== "production") {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length, lengthDelta); // checks if internal array wasn't modified
    }

    var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice_(index, newItems, res);
    return this.dehanceValues_(res);
  };

  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;

      return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index, index + deleteCount);
      var oldItems = this.values_.slice(index + deleteCount);
      this.values_.length = index + newItems.length - deleteCount;

      for (var i = 0; i < newItems.length; i++) {
        this.values_[index + i] = newItems[i];
      }

      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index + newItems.length + _i] = oldItems[_i];
      }

      return res;
    }
  };

  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: index,
      newValue: newValue,
      oldValue: oldValue
    } : null; // The reason why this is on right hand side here (and not above), is this way the uglifier will drop it, but it won't
    // cause any runtime overhead in development mode without NODE_ENV set, unless spying is enabled

    if ( true && notifySpy) spyReportStart(change);
    this.atom_.reportChanged();
    if (notify) notifyListeners(this, change);
    if ( true && notifySpy) spyReportEnd();
  };

  _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: index,
      removed: removed,
      added: added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    if ( true && notifySpy) spyReportStart(change);
    this.atom_.reportChanged(); // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe

    if (notify) notifyListeners(this, change);
    if ( true && notifySpy) spyReportEnd();
  };

  _proto.get_ = function get_(index) {
    if (index < this.values_.length) {
      this.atom_.reportObserved();
      return this.dehanceValue_(this.values_[index]);
    }

    console.warn( true ? "[mobx] Out of bounds read: " + index : undefined);
  };

  _proto.set_ = function set_(index, newValue) {
    var values = this.values_;

    if (index < values.length) {
      // update at index in range
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values[index];

      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          index: index,
          newValue: newValue
        });
        if (!change) return;
        newValue = change.newValue;
      }

      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;

      if (changed) {
        values[index] = newValue;
        this.notifyArrayChildUpdate_(index, newValue, oldValue);
      }
    } else if (index === values.length) {
      // add a new item
      this.spliceWithArray_(index, 0, [newValue]);
    } else {
      // out of bounds
      die(17, index, values.length);
    }
  };

  return ObservableArrayAdministration;
}();

function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name =  true ? "ObservableArray@" + getNextId() : undefined;
  }

  if (owned === void 0) {
    owned = false;
  }

  assertProxies();
  var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
  addHiddenFinalProp(adm.values_, $mobx, adm);
  var proxy = new Proxy(adm.values_, arrayTraps);
  adm.proxy_ = proxy;

  if (initialValues && initialValues.length) {
    var prev = allowStateChangesStart(true);
    adm.spliceWithArray_(0, 0, initialValues);
    allowStateChangesEnd(prev);
  }

  return proxy;
} // eslint-disable-next-line


var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  // Used by JSON.stringify
  toJSON: function toJSON() {
    return this.slice();
  },

  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function splice(index, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }

    var adm = this[$mobx];

    switch (arguments.length) {
      case 0:
        return [];

      case 1:
        return adm.spliceWithArray_(index);

      case 2:
        return adm.spliceWithArray_(index, deleteCount);
    }

    return adm.spliceWithArray_(index, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];

    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }

    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];

    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }

    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    // reverse by default mutates in place before returning the result
    // which makes it both a 'derivation' and a 'mutation'.
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }

    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    // sort by default mutates in place before returning the result
    // which goes against all good practices. Let's not change the array in place!
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }

    var copy = this.slice();
    copy.sort.apply(copy, arguments);
    this.replace(copy);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);

    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }

    return false;
  }
};
/**
 * Wrap function from prototype
 * Without this, everything works as well, but this works
 * faster as everything works on unproxied values
 */

addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc); // map

addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc); // reduce

addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);

function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
} // Report and delegate to dehanced array


function simpleFunc(funcName) {
  return function () {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
} // Make sure callbacks recieve correct array arg #2326


function mapLikeFunc(funcName) {
  return function (callback, thisArg) {
    var _this2 = this;

    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function (element, index) {
      return callback.call(thisArg, element, index, _this2);
    });
  };
} // Make sure callbacks recieve correct array arg #2326


function reduceLikeFunc(funcName) {
  return function () {
    var _this3 = this;

    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_); // #2432 - reduce behavior depends on arguments.length

    var callback = arguments[0];

    arguments[0] = function (accumulator, currentValue, index) {
      return callback(accumulator, currentValue, index, _this3);
    };

    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}

var isObservableArrayAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);

function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}

var _Symbol$iterator, _Symbol$toStringTag;

var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete"; // just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54
// But: https://github.com/mobxjs/mobx/issues/1556

_Symbol$iterator = Symbol.iterator;
_Symbol$toStringTag = Symbol.toStringTag;

var ObservableMap = /*#__PURE__*/function () {
  // hasMap, not hashMap >-).
  function ObservableMap(initialData, enhancer_, name_) {
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }

    if (name_ === void 0) {
      name_ =  true ? "ObservableMap@" + getNextId() : undefined;
    }

    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;

    if (!isFunction(Map)) {
      die(18);
    }

    this.keysAtom_ = createAtom( true ? this.name_ + ".keys()" : undefined);
    this.data_ = new Map();
    this.hasMap_ = new Map();
    this.merge(initialData);
  }

  var _proto = ObservableMap.prototype;

  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };

  _proto.has = function has(key) {
    var _this = this;

    if (!globalState.trackingDerivation) return this.has_(key);
    var entry = this.hasMap_.get(key);

    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer,  true ? this.name_ + "." + stringifyKey(key) + "?" : undefined, false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function () {
        return _this.hasMap_["delete"](key);
      });
    }

    return entry.get();
  };

  _proto.set = function set(key, value) {
    var hasKey = this.has_(key);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change) return this;
      value = change.newValue;
    }

    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }

    return this;
  };

  _proto["delete"] = function _delete(key) {
    var _this2 = this;

    checkIfStateModificationsAreAllowed(this.keysAtom_);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change) return false;
    }

    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);

      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;

      if ( true && notifySpy) spyReportStart(_change);
      transaction(function () {
        _this2.keysAtom_.reportChanged();

        _this2.updateHasMapEntry_(key, false);

        var observable = _this2.data_.get(key);

        observable.setNewValue_(undefined);

        _this2.data_["delete"](key);
      });
      if (notify) notifyListeners(this, _change);
      if ( true && notifySpy) spyReportEnd();
      return true;
    }

    return false;
  };

  _proto.updateHasMapEntry_ = function updateHasMapEntry_(key, value) {
    var entry = this.hasMap_.get(key);

    if (entry) {
      entry.setNewValue_(value);
    }
  };

  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable = this.data_.get(key);
    newValue = observable.prepareNewValue_(newValue);

    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable.value_,
        name: key,
        newValue: newValue
      } : null;
      if ( true && notifySpy) spyReportStart(change);
      observable.setNewValue_(newValue);
      if (notify) notifyListeners(this, change);
      if ( true && notifySpy) spyReportEnd();
    }
  };

  _proto.addValue_ = function addValue_(key, newValue) {
    var _this3 = this;

    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function () {
      var observable = new ObservableValue(newValue, _this3.enhancer_,  true ? _this3.name_ + "." + stringifyKey(key) : undefined, false);

      _this3.data_.set(key, observable);

      newValue = observable.value_; // value might have been changed

      _this3.updateHasMapEntry_(key, true);

      _this3.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue: newValue
    } : null;
    if ( true && notifySpy) spyReportStart(change);
    if (notify) notifyListeners(this, change);
    if ( true && notifySpy) spyReportEnd();
  };

  _proto.get = function get(key) {
    if (this.has(key)) return this.dehanceValue_(this.data_.get(key).get());
    return this.dehanceValue_(undefined);
  };

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }

    return value;
  };

  _proto.keys = function keys() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };

  _proto.values = function values() {
    var self = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next = keys.next(),
            done = _keys$next.done,
            value = _keys$next.value;

        return {
          done: done,
          value: done ? undefined : self.get(value)
        };
      }
    });
  };

  _proto.entries = function entries() {
    var self = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next2 = keys.next(),
            done = _keys$next2.done,
            value = _keys$next2.value;

        return {
          done: done,
          value: done ? undefined : [value, self.get(value)]
        };
      }
    });
  };

  _proto[_Symbol$iterator] = function () {
    return this.entries();
  };

  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          key = _step$value[0],
          value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  }
  /** Merge another object into this object, returns this. */
  ;

  _proto.merge = function merge(other) {
    var _this4 = this;

    if (isObservableMap(other)) {
      other = new Map(other);
    }

    transaction(function () {
      if (isPlainObject(other)) getPlainObjectKeys(other).forEach(function (key) {
        return _this4.set(key, other[key]);
      });else if (Array.isArray(other)) other.forEach(function (_ref) {
        var key = _ref[0],
            value = _ref[1];
        return _this4.set(key, value);
      });else if (isES6Map(other)) {
        if (other.constructor !== Map) die(19, other);
        other.forEach(function (value, key) {
          return _this4.set(key, value);
        });
      } else if (other !== null && other !== undefined) die(20, other);
    });
    return this;
  };

  _proto.clear = function clear() {
    var _this5 = this;

    transaction(function () {
      untracked(function () {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this5.keys()), _step2; !(_step2 = _iterator2()).done;) {
          var key = _step2.value;

          _this5["delete"](key);
        }
      });
    });
  };

  _proto.replace = function replace(values) {
    var _this6 = this; // Implementation requirements:
    // - respect ordering of replacement map
    // - allow interceptors to run and potentially prevent individual operations
    // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)
    // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)
    // - note that result map may differ from replacement map due to the interceptors


    transaction(function () {
      // Convert to map so we can do quick key lookups
      var replacementMap = convertToMap(values);
      var orderedData = new Map(); // Used for optimization

      var keysReportChangedCalled = false; // Delete keys that don't exist in replacement map
      // if the key deletion is prevented by interceptor
      // add entry at the beginning of the result map

      for (var _iterator3 = _createForOfIteratorHelperLoose(_this6.data_.keys()), _step3; !(_step3 = _iterator3()).done;) {
        var key = _step3.value; // Concurrently iterating/deleting keys
        // iterator should handle this correctly

        if (!replacementMap.has(key)) {
          var deleted = _this6["delete"](key); // Was the key removed?


          if (deleted) {
            // _keysAtom.reportChanged() was already called
            keysReportChangedCalled = true;
          } else {
            // Delete prevented by interceptor
            var value = _this6.data_.get(key);

            orderedData.set(key, value);
          }
        }
      } // Merge entries


      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done;) {
        var _step4$value = _step4.value,
            _key = _step4$value[0],
            _value = _step4$value[1]; // We will want to know whether a new key is added

        var keyExisted = _this6.data_.has(_key); // Add or update value


        _this6.set(_key, _value); // The addition could have been prevent by interceptor


        if (_this6.data_.has(_key)) {
          // The update could have been prevented by interceptor
          // and also we want to preserve existing values
          // so use value from _data map (instead of replacement map)
          var _value2 = _this6.data_.get(_key);

          orderedData.set(_key, _value2); // Was a new key added?

          if (!keyExisted) {
            // _keysAtom.reportChanged() was already called
            keysReportChangedCalled = true;
          }
        }
      } // Check for possible key order change


      if (!keysReportChangedCalled) {
        if (_this6.data_.size !== orderedData.size) {
          // If size differs, keys are definitely modified
          _this6.keysAtom_.reportChanged();
        } else {
          var iter1 = _this6.data_.keys();

          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();

          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this6.keysAtom_.reportChanged();

              break;
            }

            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      } // Use correctly ordered map


      _this6.data_ = orderedData;
    });
    return this;
  };

  _proto.toString = function toString() {
    return "[object ObservableMap]";
  };

  _proto.toJSON = function toJSON() {
    return Array.from(this);
  };
  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */


  _proto.observe_ = function observe_(listener, fireImmediately) {
    if ( true && fireImmediately === true) die("`observe` doesn't support fireImmediately=true in combination with maps.");
    return registerListener(this, listener);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _createClass(ObservableMap, [{
    key: "size",
    get: function get() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return "Map";
    }
  }]);

  return ObservableMap;
}(); // eslint-disable-next-line


var isObservableMap = /*#__PURE__*/createInstanceofPredicate("ObservableMap", ObservableMap);

function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map = new Map();

    for (var key in dataStructure) {
      map.set(key, dataStructure[key]);
    }

    return map;
  } else {
    return die(21, dataStructure);
  }
}

var _Symbol$iterator$1, _Symbol$toStringTag$1;

var ObservableSetMarker = {};
_Symbol$iterator$1 = Symbol.iterator;
_Symbol$toStringTag$1 = Symbol.toStringTag;

var ObservableSet = /*#__PURE__*/function () {
  function ObservableSet(initialData, enhancer, name_) {
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }

    if (name_ === void 0) {
      name_ =  true ? "ObservableSet@" + getNextId() : undefined;
    }

    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;

    if (!isFunction(Set)) {
      die(22);
    }

    this.atom_ = createAtom(this.name_);

    this.enhancer_ = function (newV, oldV) {
      return enhancer(newV, oldV, name_);
    };

    if (initialData) {
      this.replace(initialData);
    }
  }

  var _proto = ObservableSet.prototype;

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }

    return value;
  };

  _proto.clear = function clear() {
    var _this = this;

    transaction(function () {
      untracked(function () {
        for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done;) {
          var value = _step.value;

          _this["delete"](value);
        }
      });
    });
  };

  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done;) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };

  _proto.add = function add(value) {
    var _this2 = this;

    checkIfStateModificationsAreAllowed(this.atom_);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change) return this; // ideally, value = change.value would be done here, so that values can be
      // changed by interceptor. Same applies for other Set and Map api's.
    }

    if (!this.has(value)) {
      transaction(function () {
        _this2.data_.add(_this2.enhancer_(value, undefined));

        _this2.atom_.reportChanged();
      });
      var notifySpy =  true && isSpyEnabled();
      var notify = hasListeners(this);

      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;

      if (notifySpy && "development" !== "production") spyReportStart(_change);
      if (notify) notifyListeners(this, _change);
      if (notifySpy && "development" !== "production") spyReportEnd();
    }

    return this;
  };

  _proto["delete"] = function _delete(value) {
    var _this3 = this;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change) return false;
    }

    if (this.has(value)) {
      var notifySpy =  true && isSpyEnabled();
      var notify = hasListeners(this);

      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;

      if (notifySpy && "development" !== "production") spyReportStart(_change2);
      transaction(function () {
        _this3.atom_.reportChanged();

        _this3.data_["delete"](value);
      });
      if (notify) notifyListeners(this, _change2);
      if (notifySpy && "development" !== "production") spyReportEnd();
      return true;
    }

    return false;
  };

  _proto.has = function has(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };

  _proto.entries = function entries() {
    var nextIndex = 0;
    var keys = Array.from(this.keys());
    var values = Array.from(this.values());
    return makeIterable({
      next: function next() {
        var index = nextIndex;
        nextIndex += 1;
        return index < values.length ? {
          value: [keys[index], values[index]],
          done: false
        } : {
          done: true
        };
      }
    });
  };

  _proto.keys = function keys() {
    return this.values();
  };

  _proto.values = function values() {
    this.atom_.reportObserved();
    var self = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterable({
      next: function next() {
        return nextIndex < observableValues.length ? {
          value: self.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          done: true
        };
      }
    });
  };

  _proto.replace = function replace(other) {
    var _this4 = this;

    if (isObservableSet(other)) {
      other = new Set(other);
    }

    transaction(function () {
      if (Array.isArray(other)) {
        _this4.clear();

        other.forEach(function (value) {
          return _this4.add(value);
        });
      } else if (isES6Set(other)) {
        _this4.clear();

        other.forEach(function (value) {
          return _this4.add(value);
        });
      } else if (other !== null && other !== undefined) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    // ... 'fireImmediately' could also be true?
    if ( true && fireImmediately === true) die("`observe` doesn't support fireImmediately=true in combination with sets.");
    return registerListener(this, listener);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.toJSON = function toJSON() {
    return Array.from(this);
  };

  _proto.toString = function toString() {
    return "[object ObservableSet]";
  };

  _proto[_Symbol$iterator$1] = function () {
    return this.values();
  };

  _createClass(ObservableSet, [{
    key: "size",
    get: function get() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag$1,
    get: function get() {
      return "Set";
    }
  }]);

  return ObservableSet;
}(); // eslint-disable-next-line


var isObservableSet = /*#__PURE__*/createInstanceofPredicate("ObservableSet", ObservableSet);
var inferredAnnotationsSymbol = /*#__PURE__*/Symbol("mobx-inferred-annotations");
var descriptorCache = /*#__PURE__*/Object.create(null);
var REMOVE = "remove";

var ObservableObjectAdministration = /*#__PURE__*/function () {
  function ObservableObjectAdministration(target_, values_, name_, // Used anytime annotation is not explicitely provided
  defaultAnnotation_, // Bind automatically inferred actions?
  autoBind_) {
    if (values_ === void 0) {
      values_ = new Map();
    }

    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = observable;
    }

    if (autoBind_ === void 0) {
      autoBind_ = false;
    }

    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.autoBind_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.autoBind_ = autoBind_;
    this.keysAtom_ = new Atom( true ? this.name_ + ".keys" : undefined); // Optimization: we use this frequently

    this.isPlainObject_ = isPlainObject(this.target_);

    if ( true && !isAnnotation(this.defaultAnnotation_)) {
      die("defaultAnnotation must be valid annotation");
    }

    if ( true && typeof this.autoBind_ !== "boolean") {
      die("autoBind must be boolean");
    }

    if (true) {
      // Prepare structure for tracking which fields were already annotated
      this.appliedAnnotations_ = {};
    }
  }

  var _proto = ObservableObjectAdministration.prototype;

  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };

  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable = this.values_.get(key);

    if (observable instanceof ComputedValue) {
      observable.set(newValue);
      return true;
    } // intercept


    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: newValue
      });
      if (!change) return null;
      newValue = change.newValue;
    }

    newValue = observable.prepareNewValue_(newValue); // notify spy & observers

    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy =  true && isSpyEnabled();

      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable.value_,
        name: key,
        newValue: newValue
      } : null;

      if ( true && notifySpy) spyReportStart(_change);
      observable.setNewValue_(newValue);
      if (notify) notifyListeners(this, _change);
      if ( true && notifySpy) spyReportEnd();
    }

    return true;
  };

  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      // Key doesn't exist yet, subscribe for it in case it's added later
      this.has_(key);
    }

    return this.target_[key];
  }
  /**
   * @param {PropertyKey} key
   * @param {any} value
   * @param {Annotation|boolean} annotation true - infer from descriptor, false - copy as is
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    } // Don't use .has(key) - we care about own


    if (hasProp(this.target_, key)) {
      // Existing prop
      if (this.values_.has(key)) {
        // Observable (can be intercepted)
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        // Non-observable - proxy
        return Reflect.set(this.target_, key, value);
      } else {
        // Non-observable
        this.target_[key] = value;
        return true;
      }
    } else {
      // New prop
      return this.extend_(key, {
        value: value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  } // Trap for "in"
  ;

  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      // Skip key subscription outside derivation
      return key in this.target_;
    }

    this.pendingKeys_ || (this.pendingKeys_ = new Map());
    var entry = this.pendingKeys_.get(key);

    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer,  true ? this.name_ + "." + stringifyKey(key) + "?" : undefined, false);
      this.pendingKeys_.set(key, entry);
    }

    return entry.get();
  }
  /**
   * @param {PropertyKey} key
   * @param {Annotation|boolean} annotation true - infer from object or it's prototype, false - ignore
   */
  ;

  _proto.make_ = function make_(key, annotation) {
    if (annotation === true) {
      annotation = this.inferAnnotation_(key);
    }

    if (annotation === false) {
      return;
    }

    assertAnnotable(this, annotation, key);
    annotation.make_(this, key);
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {Annotation|boolean} annotation true - infer from descriptor, false - copy as is
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    if (annotation === true) {
      annotation = inferAnnotationFromDescriptor(descriptor, this.defaultAnnotation_, this.autoBind_);
    }

    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }

    assertAnnotable(this, annotation, key);
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);

    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }

    return outcome;
  };

  _proto.inferAnnotation_ = function inferAnnotation_(key) {
    var _this$target_$inferre; // Inherited is fine - annotation cannot differ in subclass


    var annotation = (_this$target_$inferre = this.target_[inferredAnnotationsSymbol]) == null ? void 0 : _this$target_$inferre.get(key);
    if (annotation) return annotation;
    var current = this.target_;

    while (current && current !== objectPrototype) {
      var descriptor = getDescriptor(current, key);

      if (descriptor) {
        annotation = inferAnnotationFromDescriptor(descriptor, this.defaultAnnotation_, this.autoBind_);
        break;
      }

      current = Object.getPrototypeOf(current);
    } // Not found (false means ignore)


    if (annotation === undefined) {
      die(1, "true", key);
    } // Cache the annotation.
    // Note we can do this only because annotation and field can't change.


    if (!this.isPlainObject_) {
      // We could also place it on furthest proto, shoudn't matter
      var closestProto = Object.getPrototypeOf(this.target_);

      if (!hasProp(closestProto, inferredAnnotationsSymbol)) {
        addHiddenProp(closestProto, inferredAnnotationsSymbol, new Map());
      }

      closestProto[inferredAnnotationsSymbol].set(key, annotation);
    }

    return annotation;
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change) return null;
        var newValue = change.newValue;

        if (descriptor.value !== newValue) {
          descriptor = _extends({}, descriptor, {
            value: newValue
          });
        }
      } // Define


      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      } // Notify


      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }

    return true;
  } // If original descriptor becomes relevant, move this to annotation directly
  ;

  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change) return null;
        value = change.newValue;
      }

      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      }; // Define

      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }

      var _observable = new ObservableValue(value, enhancer,  true ? this.name_ + "." + key.toString() : undefined, false);

      this.values_.set(key, _observable); // Notify (value possibly changed by ObservableValue)

      this.notifyPropertyAddition_(key, _observable.value_);
    } finally {
      endBatch();
    }

    return true;
  } // If original descriptor becomes relevant, move this to annotation directly
  ;

  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: undefined
        });
        if (!change) return null;
      }

      options.name || (options.name =  true ? this.name_ + "." + key.toString() : undefined);
      options.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      }; // Define

      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }

      this.values_.set(key, new ComputedValue(options)); // Notify

      this.notifyPropertyAddition_(key, undefined);
    } finally {
      endBatch();
    }

    return true;
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    } // No such prop


    if (!hasProp(this.target_, key)) {
      return true;
    } // Intercept


    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      }); // Cancelled

      if (!change) return null;
    } // Delete


    try {
      var _this$pendingKeys_, _this$pendingKeys_$ge;

      startBatch();
      var notify = hasListeners(this);
      var notifySpy =  true && isSpyEnabled();

      var _observable2 = this.values_.get(key); // Value needed for spies/listeners


      var value = undefined; // Optimization: don't pull the value unless we will need it

      if (!_observable2 && (notify || notifySpy)) {
        var _getDescriptor;

        value = (_getDescriptor = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor.value;
      } // delete prop (do first, may fail)


      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      } // Allow re-annotating this field


      if (true) {
        delete this.appliedAnnotations_[key];
      } // Clear observable


      if (_observable2) {
        this.values_["delete"](key); // for computed, value is undefined

        if (_observable2 instanceof ObservableValue) {
          value = _observable2.value_;
        } // Notify: autorun(() => obj[key]), see #1796


        propagateChanged(_observable2);
      } // Notify "keys/entries/values" observers


      this.keysAtom_.reportChanged(); // Notify "has" observers
      // "in" as it may still exist in proto

      (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_); // Notify spies/listeners

      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if ( true && notifySpy) spyReportStart(_change2);
        if (notify) notifyListeners(this, _change2);
        if ( true && notifySpy) spyReportEnd();
      }
    } finally {
      endBatch();
    }

    return true;
  }
  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */
  ;

  _proto.observe_ = function observe_(callback, fireImmediately) {
    if ( true && fireImmediately === true) die("`observe` doesn't support the fire immediately property for observable objects.");
    return registerListener(this, callback);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2, _this$pendingKeys_2$g;

    var notify = hasListeners(this);
    var notifySpy =  true && isSpyEnabled();

    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if ( true && notifySpy) spyReportStart(change);
      if (notify) notifyListeners(this, change);
      if ( true && notifySpy) spyReportEnd();
    }

    (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true); // Notify "keys/entries/values" observers

    this.keysAtom_.reportChanged();
  };

  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };

  _proto.keys_ = function keys_() {
    // Returns enumerable && own, but unfortunately keysAtom will report on ANY key change.
    // There is no way to distinguish between Object.keys(object) and Reflect.ownKeys(object) - both are handled by ownKeys trap.
    // We can either over-report in Object.keys(object) or under-report in Reflect.ownKeys(object)
    // We choose to over-report in Object.keys(object), because:
    // - typically it's used with simple data objects
    // - when symbolic/non-enumerable keys are relevant Reflect.ownKeys works as expected
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };

  return ObservableObjectAdministration;
}();

function asObservableObject(target, options) {
  var _options$name;

  if ( true && options && isObservableObject(target)) {
    die("Options can't be provided for already observable objects.");
  }

  if (hasProp(target, $mobx)) {
    if ( true && !(getAdministration(target) instanceof ObservableObjectAdministration)) {
      die("Cannot convert '" + getDebugName(target) + "' into observable object:" + "\nThe target is already observable of different type." + "\nExtending builtins is not supported.");
    }

    return target;
  }

  if ( true && !Object.isExtensible(target)) die("Cannot make the designated object observable; it is not extensible");
  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name :  true ? (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() : undefined;
  var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options), options == null ? void 0 : options.autoBind);
  addHiddenProp(target, $mobx, adm);
  return target;
}

var isObservableObjectAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);

function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}

function isObservableObject(thing) {
  if (isObject(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }

  return false;
}

function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;

  if (true) {
    adm.appliedAnnotations_[key] = annotation;
  } // Remove applied decorator annotation so we don't try to apply it again in subclass constructor


  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];
}

function assertAnnotable(adm, annotation, key) {
  // Valid annotation
  if ( true && !isAnnotation(annotation)) {
    die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
  }
  /*
  // Configurable, not sealed, not frozen
  // Possibly not needed, just a little better error then the one thrown by engine.
  // Cases where this would be useful the most (subclass field initializer) are not interceptable by this.
  if (__DEV__) {
      const configurable = getDescriptor(adm.target_, key)?.configurable
      const frozen = Object.isFrozen(adm.target_)
      const sealed = Object.isSealed(adm.target_)
      if (!configurable || frozen || sealed) {
          const fieldName = `${adm.name_}.${key.toString()}`
          const requestedAnnotationType = annotation.annotationType_
          let error = `Cannot apply '${requestedAnnotationType}' to '${fieldName}':`
          if (frozen) {
              error += `\nObject is frozen.`
          }
          if (sealed) {
              error += `\nObject is sealed.`
          }
          if (!configurable) {
              error += `\nproperty is not configurable.`
              // Mention only if caused by us to avoid confusion
              if (hasProp(adm.appliedAnnotations!, key)) {
                  error += `\nTo prevent accidental re-definition of a field by a subclass, `
                  error += `all annotated fields of non-plain objects (classes) are not configurable.`
              }
          }
          die(error)
      }
  }
  */
  // Not annotated


  if ( true && !isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {
    var fieldName = adm.name_ + "." + key.toString();
    var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed." + "\nUse 'override' annotation for methods overriden by subclass.");
  }
}
/**
 * This array buffer contains two lists of properties, so that all arrays
 * can recycle their property definitions, which significantly improves performance of creating
 * properties on the fly.
 */


var OBSERVABLE_ARRAY_BUFFER_SIZE = 0; // Typescript workaround to make sure ObservableArray extends Array

var StubArray = function StubArray() {};

function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== undefined) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}

inherit(StubArray, Array.prototype); // Weex proto freeze protection was here,
// but it is unclear why the hack is need as MobX never changed the prototype
// anyway, so removed it in V6

var LegacyObservableArray = /*#__PURE__*/function (_StubArray) {
  _inheritsLoose(LegacyObservableArray, _StubArray);

  function LegacyObservableArray(initialValues, enhancer, name, owned) {
    var _this;

    if (name === void 0) {
      name =  true ? "ObservableArray@" + getNextId() : undefined;
    }

    if (owned === void 0) {
      owned = false;
    }

    _this = _StubArray.call(this) || this;
    var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
    adm.proxy_ = _assertThisInitialized(_this);
    addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);

    if (initialValues && initialValues.length) {
      var prev = allowStateChangesStart(true); // @ts-ignore

      _this.spliceWithArray(0, 0, initialValues);

      allowStateChangesEnd(prev);
    }

    return _this;
  }

  var _proto = LegacyObservableArray.prototype;

  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();

    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }

    return Array.prototype.concat.apply(this.slice(), //@ts-ignore
    arrays.map(function (a) {
      return isObservableArray(a) ? a.slice() : a;
    }));
  };

  _proto[Symbol.iterator] = function () {
    var self = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        // @ts-ignore
        return nextIndex < self.length ? {
          value: self[nextIndex++],
          done: false
        } : {
          done: true,
          value: undefined
        };
      }
    });
  };

  _createClass(LegacyObservableArray, [{
    key: "length",
    get: function get() {
      return this[$mobx].getArrayLength_();
    },
    set: function set(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return "Array";
    }
  }]);

  return LegacyObservableArray;
}(StubArray);

Object.entries(arrayExtensions).forEach(function (_ref) {
  var prop = _ref[0],
      fn = _ref[1];
  if (prop !== "concat") addHiddenProp(LegacyObservableArray.prototype, prop, fn);
});

function createArrayEntryDescriptor(index) {
  return {
    enumerable: false,
    configurable: true,
    get: function get() {
      return this[$mobx].get_(index);
    },
    set: function set(value) {
      this[$mobx].set_(index, value);
    }
  };
}

function createArrayBufferItem(index) {
  defineProperty(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
}

function reserveArrayBuffer(max) {
  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {
      createArrayBufferItem(index);
    }

    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
  }
}

reserveArrayBuffer(1000);

function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}

function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== undefined) die(23);
      return thing[$mobx].atom_;
    }

    if (isObservableSet(thing)) {
      return thing[$mobx];
    }

    if (isObservableMap(thing)) {
      if (property === undefined) return thing.keysAtom_;
      var observable = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable) die(25, property, getDebugName(thing));
      return observable;
    }

    if (isObservableObject(thing)) {
      if (!property) return die(26);

      var _observable = thing[$mobx].values_.get(property);

      if (!_observable) die(27, property, getDebugName(thing));
      return _observable;
    }

    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction(thing)) {
    if (isReaction(thing[$mobx])) {
      // disposer function
      return thing[$mobx];
    }
  }

  die(28);
}

function getAdministration(thing, property) {
  if (!thing) die(29);
  if (property !== undefined) return getAdministration(getAtom(thing, property));
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;
  if (isObservableMap(thing) || isObservableSet(thing)) return thing;
  if (thing[$mobx]) return thing[$mobx];
  die(24, thing);
}

function getDebugName(thing, property) {
  var named;

  if (property !== undefined) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    // valid for arrays as well
    named = getAtom(thing);
  }

  return named.name_;
}

var toString = objectPrototype.toString;

function deepEqual(a, b, depth) {
  if (depth === void 0) {
    depth = -1;
  }

  return eq(a, b, depth);
} // Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289
// Internal recursive comparison function for `isEqual`.


function eq(a, b, depth, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) return a !== 0 || 1 / a === 1 / b; // `null` or `undefined` only equal to itself (strict comparison).

  if (a == null || b == null) return false; // `NaN`s are equivalent, but non-reflexive.

  if (a !== a) return b !== b; // Exhaust primitive checks

  var type = typeof a;
  if (!isFunction(type) && type !== "object" && typeof b != "object") return false; // Compare `[[Class]]` names.

  var className = toString.call(a);
  if (className !== toString.call(b)) return false;

  switch (className) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case "[object RegExp]": // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')

    case "[object String]":
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return "" + a === "" + b;

    case "[object Number]":
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values.

      return +a === 0 ? 1 / +a === 1 / b : +a === +b;

    case "[object Date]":
    case "[object Boolean]":
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;

    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);

    case "[object Map]":
    case "[object Set]":
      // Maps and Sets are unwrapped to arrays of entry-pairs, adding an incidental level.
      // Hide this extra level by increasing the depth.
      if (depth >= 0) {
        depth++;
      }

      break;
  } // Unwrap any wrapped objects.


  a = unwrap(a);
  b = unwrap(b);
  var areArrays = className === "[object Array]";

  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.

    var aCtor = a.constructor,
        bCtor = b.constructor;

    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
      return false;
    }
  }

  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  } // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.


  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;

  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) return bStack[length] === b;
  } // Add the first object to the stack of traversed objects.


  aStack.push(a);
  bStack.push(b); // Recursively compare objects and arrays.

  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties.

    while (length--) {
      if (!eq(a[length], b[length], depth - 1, aStack, bStack)) return false;
    }
  } else {
    // Deep compare objects.
    var keys = Object.keys(a);
    var key;
    length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality.

    if (Object.keys(b).length !== length) return false;

    while (length--) {
      // Deep compare each member
      key = keys[length];
      if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) return false;
    }
  } // Remove the first object from the stack of traversed objects.


  aStack.pop();
  bStack.pop();
  return true;
}

function unwrap(a) {
  if (isObservableArray(a)) return a.slice();
  if (isES6Map(a) || isObservableMap(a)) return Array.from(a.entries());
  if (isES6Set(a) || isObservableSet(a)) return Array.from(a.entries());
  return a;
}

function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return iterator;
}

function getSelf() {
  return this;
}
/**
 * Infers the best fitting annotation from property descriptor or false if the field shoudn't be annotated
 * - getter(+setter) -> computed
 * - setter w/o getter -> false (ignore)
 * - flow -> false (ignore)
 * - generator -> flow
 * - action -> false (ignore)
 * - function -> action (optionally bound)
 * - other -> defaultAnnotation
 */


function inferAnnotationFromDescriptor(desc, defaultAnnotation, autoBind) {
  if (desc.get) return computed;
  if (desc.set) return false; // ignore lone setter
  // If already wrapped in action/flow, don't do that another time, but assume it is already set up properly.

  return isFunction(desc.value) ? isGenerator(desc.value) ? isFlow(desc.value) ? false : flow : isAction(desc.value) ? false : autoBind ? autoAction.bound : autoAction : defaultAnnotation;
}

function isAnnotation(thing) {
  return (// Can be function
    thing instanceof Object && typeof thing.annotationType_ === "string" && isFunction(thing.make_) && isFunction(thing.extend_)
  );
}
/**
 * (c) Michel Weststrate 2015 - 2020
 * MIT Licensed
 *
 * Welcome to the mobx sources! To get an global overview of how MobX internally works,
 * this is a good place to start:
 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 *
 * Source folders:
 * ===============
 *
 * - api/     Most of the public static methods exposed by the module can be found here.
 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
 * - utils/   Utility stuff.
 *
 */


["Symbol", "Map", "Set", "Symbol"].forEach(function (m) {
  var g = getGlobal();

  if (typeof g[m] === "undefined") {
    die("MobX requires global '" + m + "' to be available or polyfilled");
  }
});

if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  // See: https://github.com/andykog/mobx-devtools/
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy: spy,
    extras: {
      getDebugName: getDebugName
    },
    $mobx: $mobx
  });
}


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/mst-middlewares/dist/mst-middlewares.module.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mst-middlewares/dist/mst-middlewares.module.js ***!
  \*********************************************************************/
/*! exports provided: TimeTraveller, UndoManager, actionLogger, asReduxStore, atomic, connectReduxDevtools, simpleActionLogger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeTraveller", function() { return TimeTraveller; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UndoManager", function() { return UndoManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "actionLogger", function() { return actionLogger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asReduxStore", function() { return asReduxStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atomic", function() { return atomic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "connectReduxDevtools", function() { return connectReduxDevtools; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "simpleActionLogger", function() { return simpleActionLogger; });
/* harmony import */ var mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mobx-state-tree */ "./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js");

var atomic = Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["createActionTrackingMiddleware2"])({
  filter: function (call) {
    // only call the methods above for actions that were not being recorded,
    // but do not call them for child acions (which inherit a copy of the env)
    if (call.env) {
      // already recording
      return false;
    }

    return true;
  },
  onStart: function (call) {
    var recorder = Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["recordPatches"])(call.tree, function (_patch, _inversePatch, actionContext) {
      // only record patches that were generated by this action or children of this action
      return !!actionContext && Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["isActionContextThisOrChildOf"])(actionContext, call.id);
    });
    recorder.resume();
    call.env = {
      recorder: recorder
    };
  },
  onFinish: function (call, error) {
    var recorder = call.env.recorder;
    call.env = undefined;
    recorder.stop();

    if (error !== undefined) {
      recorder.undo();
    }
  }
});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}

function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}
/**
 * Creates a tiny proxy around a MST tree that conforms to the redux store api.
 * This makes it possible to use MST inside a redux application.
 *
 * See the [redux-todomvc example](https://github.com/mobxjs/mobx-state-tree/blob/e9e804c8c43e1edde4aabbd52675544e2b3a905b/examples/redux-todomvc/src/index.js#L20) for more details.
 *
 * @export
 * @param {*} model
 * @param {...MiddleWare[]} middlewares
 * @returns {IReduxStore}
 */


var asReduxStore = function (model) {
  var middlewares = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    middlewares[_i - 1] = arguments[_i];
  }

  if (!Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["isStateTreeNode"])(model)) throw new Error("Expected model object");
  var store = {
    getState: function () {
      return Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getSnapshot"])(model);
    },
    dispatch: function (action) {
      runMiddleWare(action, runners.slice(), function (newAction) {
        return Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["applyAction"])(model, reduxActionToAction(newAction));
      });
    },
    subscribe: function (listener) {
      return Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["onSnapshot"])(model, listener);
    }
  };
  var runners = middlewares.map(function (mw) {
    return mw(store);
  });
  return store;
};

function reduxActionToAction(action) {
  var actionArgs = Object.assign({}, action);
  delete actionArgs.type;
  return {
    name: action.type,
    args: [actionArgs]
  };
}

function runMiddleWare(action, runners, next) {
  function n(retVal) {
    var f = runners.shift();
    if (f) f(n)(retVal);else next(retVal);
  }

  n(action);
}

function getActionContextNameAndTypePath(actionContext, logArgsNearName) {
  var name = actionContext.name;
  var targetTypePath = actionContext.targetTypePath;

  if (logArgsNearName) {
    var args = actionContext.callArgs.map(function (a) {
      return JSON.stringify(a);
    }).join(", ");

    if (args.length > 64) {
      args = args.slice(0, 64) + "...";
    }

    name += "(" + args + ")";
  }

  if (actionContext.runningAsync) {
    name += " (" + (actionContext.step !== undefined ? actionContext.step : "?") + ")";
  }

  if (actionContext.errored) {
    name += " -error thrown-";
  }

  if (actionContext.parent) {
    var ret = getActionContextNameAndTypePath(actionContext.parent, logArgsNearName);

    if (ret) {
      name = ret.name + " >>> " + name;
      targetTypePath = ret.targetTypePath + " >>> " + targetTypePath;
    }
  }

  return {
    name: name,
    targetTypePath: targetTypePath
  };
}

function getTypeName(node) {
  return Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getType"])(node).name || "(UnnamedType)";
}

function getTargetTypePath(node) {
  var current = node;
  var names = [];

  while (current) {
    names.unshift(getTypeName(current));
    current = Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["hasParent"])(current) ? Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getParent"])(current) : undefined;
  }

  return names;
}
/**
 * Connects a MST tree to the Redux devtools.
 * See this [example](https://github.com/mobxjs/mobx-state-tree/blob/e9e804c8c43e1edde4aabbd52675544e2b3a905b/examples/redux-todomvc/src/index.js#L21)
 * for a setup example.
 *
 * @export
 * @param {*} remoteDevDep
 * @param {IAnyStateTreeNode} model
 * @param {{
 *         logIdempotentActionSteps?: boolean
 *         logChildActions?: boolean
 *         logArgsNearName?: boolean
 *     }} [options]
 */


function connectReduxDevtools(remoteDevDep, model, options) {
  var opts = __assign({
    logIdempotentActionSteps: true,
    logChildActions: false,
    logArgsNearName: true
  }, options);

  var handlingMonitorAction = 0; // Connect to the monitor

  var remotedev = remoteDevDep.connectViaExtension({
    name: Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getType"])(model).name
  }); // Subscribe to change state (if need more than just logging)

  remotedev.subscribe(function (message) {
    if (message.type === "DISPATCH") {
      handleMonitorActions(remotedev, model, message);
    }
  });
  var initialState = Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getSnapshot"])(model);
  remotedev.init(initialState);
  var actionContexts = new Map();
  var changesMadeSetter = undefined;

  if (!opts.logIdempotentActionSteps) {
    Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["onPatch"])(model, function () {
      if (!handlingMonitorAction && changesMadeSetter) {
        changesMadeSetter();
      }
    });
  }

  Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["addMiddleware"])(model, actionMiddleware, false);

  function actionMiddleware(call, next) {
    if (handlingMonitorAction) {
      next(call);
      return;
    }

    var context; // find the context of the parent action (if any)

    for (var i = call.allParentIds.length - 1; i >= 0; i--) {
      var parentId = call.allParentIds[i];
      var foundContext = actionContexts.get(parentId);

      if (foundContext) {
        context = foundContext;
        break;
      }
    } // if it is an action we need to create a new action context
    // and also if there's no context (e.g. the middleware was connected in the middle of an action with a flow)


    if (call.type === "action" || !context) {
      var targetTypePath = getTargetTypePath(call.context).join("/");
      var parentContext = context;
      var path = call.context ? "root" + Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getPath"])(call.context) : "*unknown*";
      context = {
        // use a space rather than a dot so that the redux devtools move the actions to the next line if there's not enough space
        name: "[" + path + "] " + (call.name || "*unknownAction*"),
        targetTypePath: targetTypePath,
        id: call.id,
        runningAsync: false,
        errored: false,
        errorReported: false,
        step: call.type === "action" ? 0 : undefined,
        callArgs: [],
        changesMadeSetter: undefined
      };

      if (call.type === "action") {
        if (call.args) {
          context.callArgs = __spread(call.args);
        } // subaction, assign the parent action context


        if (call.parentId) {
          context.parent = parentContext;
        }

        actionContexts.set(call.id, context);
      }
    }

    var changesMade = false;

    context.changesMadeSetter = function () {
      changesMade = true;
    };

    var oldChangesMadeSetter = changesMadeSetter;
    changesMadeSetter = context.changesMadeSetter; // capture any errors and rethrow them later (after it is logged)

    var errorThrown;

    try {
      next(call);
    } catch (e) {
      errorThrown = e;
      context.errored = true;
    }

    changesMadeSetter = oldChangesMadeSetter;
    context.changesMadeSetter = undefined;
    var changedTheModel = opts.logIdempotentActionSteps ? true : changesMade;

    switch (call.type) {
      case "flow_spawn":
      case "flow_resume":
      case "flow_resume_error":
        // not errored since the promise error might be caught
        // when this events come we can be sure that this action is being run async, as well as its parent actions
        context.runningAsync = true;
        var parent = context.parent;

        while (parent) {
          parent.runningAsync = true;
          parent = parent.parent;
        }

        break;

      case "flow_throw":
        context.errored = true;
        break;
    } // only log if:
    // - it is a sync (never run async code) action
    // - a flow_resume
    // - a flow_throw that wasn't reported as an error before
    // we don't include other kinds since flow_spawn never contain state changes and flow_resume_error might be caught by and handled the parent


    var syncAction = call.type === "action" && !context.runningAsync;
    var log = syncAction || call.type === "flow_resume" || call.type === "flow_throw" && !context.errorReported; // do not log child actions if asked not to, but only for sync actions

    if (!opts.logChildActions && context.parent && !context.runningAsync) {
      log = false; // give the child action changes to the parent action

      if (changesMade && context.parent.changesMadeSetter) {
        context.parent.changesMadeSetter();
      }
    }

    if (log) {
      var logStep = function (logContext) {
        var sn = Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getSnapshot"])(model);
        var names = getActionContextNameAndTypePath(logContext, opts.logArgsNearName);
        var copy = {
          type: names.name,
          targetTypePath: names.targetTypePath,
          args: logContext.callArgs
        };
        remotedev.send(copy, sn); // we do it over the original context, not the log context, since the original context might throw but the original context might not

        if (context.errored) {
          context.errorReported = true;
        } // increase the step for logging purposes, as well as any parent steps (since child steps count as a parent step)


        if (context.step !== undefined) {
          context.step++;
        }

        var parent = context.parent;

        while (parent) {
          if (parent.step !== undefined) {
            parent.step++;
          }

          parent = parent.parent;
        }
      }; // if it is an async subaction we need to log it since it made a change, but we will log it as if it were the root


      var logAsRoot = context.parent && !opts.logChildActions;

      if (changedTheModel) {
        var logContext = context;

        if (logAsRoot) {
          while (logContext.parent) {
            logContext = logContext.parent;
          }
        }

        logStep(logContext);
      } else if (!logAsRoot && context.errored && !context.errorReported) {
        logStep(context);
      }
    } // once the action is totally finished remove it from the context list to avoid mem leaks


    if (call.type === "flow_return" || call.type === "flow_throw" || !context.runningAsync) {
      actionContexts.delete(context.id);
    } // rethrow previously captured excepton if needed


    if (errorThrown) {
      throw errorThrown;
    }
  }

  function handleMonitorActions(remotedev2, model2, message) {
    try {
      handlingMonitorAction++;

      switch (message.payload.type) {
        case "RESET":
          Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["applySnapshot"])(model2, initialState);
          return remotedev2.init(initialState);

        case "COMMIT":
          return remotedev2.init(Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getSnapshot"])(model2));

        case "ROLLBACK":
          return remotedev2.init(remoteDevDep.extractState(message));

        case "JUMP_TO_STATE":
        case "JUMP_TO_ACTION":
          Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["applySnapshot"])(model2, remoteDevDep.extractState(message));
          return;

        case "IMPORT_STATE":
          var nextLiftedState = message.payload.nextLiftedState;
          var computedStates = nextLiftedState.computedStates;
          Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["applySnapshot"])(model2, computedStates[computedStates.length - 1].state);
          remotedev2.send(null, nextLiftedState);
          return;

        default:
      }
    } finally {
      handlingMonitorAction--;
    }
  }
}

function simpleActionLogger(call, next) {
  if (call.type === "action" && call.parentId === 0) console.log("[MST] " + Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getPath"])(call.context) + "/" + call.name);
  return next(call);
}

function actionLogger(call, next) {
  var skip = call.type === "action" && call.parentId !== 0 || call.type === "flow_resume" || call.type === "flow_resume_error";
  if (!skip) console.log("[MST] #" + call.rootId + " " + call.type + " - " + Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getPath"])(call.context) + "/" + call.name);
  next(call);
}

var TimeTraveller = mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].model("TimeTraveller", {
  history: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].array(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].frozen()),
  undoIdx: -1,
  targetPath: ""
}).views(function (self) {
  return {
    get canUndo() {
      return self.undoIdx > 0;
    },

    get canRedo() {
      return self.undoIdx < self.history.length - 1;
    }

  };
}).actions(function (self) {
  var targetStore;
  var snapshotDisposer;
  var skipNextUndoState = false;
  return {
    addUndoState: function (todos) {
      if (skipNextUndoState) {
        // skip recording if this state was caused by undo / redo
        skipNextUndoState = false;
        return;
      }

      self.history.splice(self.undoIdx + 1);
      self.history.push(todos);
      self.undoIdx = self.history.length - 1;
    },
    afterCreate: function () {
      var _this = this;

      targetStore = self.targetPath ? Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["resolvePath"])(self, self.targetPath) : Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getEnv"])(self).targetStore;
      if (!targetStore) throw new Error("Failed to find target store for TimeTraveller. Please provide `targetPath` property, or a `targetStore` in the environment"); // TODO: check if targetStore doesn't contain self
      // if (contains(targetStore, self)) throw new Error("TimeTraveller shouldn't be recording itself. Please specify a sibling as taret, not some parent")
      // start listening to changes

      snapshotDisposer = Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["onSnapshot"])(targetStore, function (snapshot) {
        return _this.addUndoState(snapshot);
      }); // record an initial state if no known

      if (self.history.length === 0) {
        this.addUndoState(Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getSnapshot"])(targetStore));
      }
    },
    beforeDestroy: function () {
      snapshotDisposer();
    },
    undo: function () {
      self.undoIdx--;
      skipNextUndoState = true;
      Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["applySnapshot"])(targetStore, self.history[self.undoIdx]);
    },
    redo: function () {
      self.undoIdx++;
      skipNextUndoState = true;
      Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["applySnapshot"])(targetStore, self.history[self.undoIdx]);
    }
  };
});
var Entry = mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].model("UndoManagerEntry", {
  patches: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].frozen(),
  inversePatches: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].frozen()
});
var UndoManager = mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].model("UndoManager", {
  history: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].array(Entry),
  undoIdx: 0
}).views(function (self) {
  return {
    get undoLevels() {
      return self.undoIdx;
    },

    get redoLevels() {
      return self.history.length - self.undoIdx;
    },

    get canUndo() {
      return this.undoLevels > 0;
    },

    get canRedo() {
      return this.redoLevels > 0;
    }

  };
}).actions(function (self) {
  var targetStore;
  var recordingDisabled = 0;
  var groupRecorders = [];
  var undoRedoMiddleware = Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["createActionTrackingMiddleware2"])({
    filter: function (call) {
      if (call.env) {
        // already recording
        return false;
      }

      if (call.context === self) {
        // also skip actions over self
        return false;
      }

      return true;
    },
    onStart: function (call) {
      var recorder = Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["recordPatches"])(call.tree, function (_patch, _inversePatch, actionContext) {
        if (recordingDisabled) {
          return false;
        } // only record patches that were generated by this action or children of this action


        return !!actionContext && Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["isActionContextThisOrChildOf"])(actionContext, call.id);
      });
      recorder.resume();
      call.env = {
        recorder: recorder
      };
    },
    onFinish: function (call, error) {
      var recorder = call.env.recorder;
      call.env = undefined;
      recorder.stop();

      if (error === undefined) {
        if (groupRecorders.length > 0) {
          var groupRecorder = groupRecorders[groupRecorders.length - 1];
          groupRecorder.patches = groupRecorder.patches.concat(recorder.patches);
          groupRecorder.inversePatches = groupRecorder.inversePatches.concat(recorder.inversePatches);
        } else {
          self.addUndoState(recorder);
        }
      } else {
        recorder.undo();
      }
    }
  });

  var skipRecording = function (fn) {
    recordingDisabled++;

    try {
      return fn();
    } finally {
      recordingDisabled--;
    }
  };

  return {
    addUndoState: function (recorder) {
      this.withoutUndo(function () {
        if (recorder.patches.length === 0) {
          // skip recording if patches is empty
          return;
        }

        self.history.splice(self.undoIdx);
        self.history.push({
          patches: recorder.patches,
          inversePatches: recorder.inversePatches
        });
        var maxLength = Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getEnv"])(self).maxHistoryLength || Infinity;
        self.history.splice(0, self.history.length - maxLength);
        self.undoIdx = self.history.length;
      });
    },
    afterCreate: function () {
      var selfRoot = Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getRoot"])(self);
      targetStore = Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getEnv"])(self).targetStore || selfRoot;

      if (targetStore === self) {
        throw new Error("UndoManager should be created as part of a tree, or with `targetStore` in it's environment");
      }

      Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["addDisposer"])(self, Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["addMiddleware"])(targetStore, undoRedoMiddleware, false));
    },
    undo: Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["decorate"])(atomic, function () {
      skipRecording(function () {
        if (!self.canUndo) {
          throw new Error("undo not possible, nothing to undo");
        }

        Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["applyPatch"])(Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getRoot"])(targetStore), // n.b: reverse patches back to forth
        self.history[self.undoIdx - 1].inversePatches.slice().reverse());
        self.undoIdx--;
      });
    }),
    redo: Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["decorate"])(atomic, function () {
      skipRecording(function () {
        if (!self.canRedo) {
          throw new Error("redo not possible, nothing to redo");
        }

        Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["applyPatch"])(Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getRoot"])(targetStore), self.history[self.undoIdx].patches);
        self.undoIdx++;
      });
    }),
    withoutUndo: function (fn) {
      return skipRecording(fn);
    },
    withoutUndoFlow: function (generatorFn) {
      return Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["flow"])(function __withoutUndoFlow__() {
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              recordingDisabled++;
              _a.label = 1;

            case 1:
              _a.trys.push([1,, 3, 4]);

              return [5
              /*yield**/
              , __values(generatorFn())];

            case 2:
              return [2
              /*return*/
              , _a.sent()];

            case 3:
              recordingDisabled--;
              return [7
              /*endfinally*/
              ];

            case 4:
              return [2
              /*return*/
              ];
          }
        });
      });
    },
    startGroup: function (fn) {
      if (groupRecorders.length >= 1) {
        throw new Error("a previous startGroup is still running, did you forget to call stopGroup?");
      }

      groupRecorders.push({
        patches: [],
        inversePatches: []
      });
      return fn();
    },
    stopGroup: function () {
      var groupRecorder = groupRecorders.pop();

      if (!groupRecorder) {
        throw new Error("each call to stopGroup requires a previous call to startGroup, did you forget to call startGroup?");
      }

      this.addUndoState(groupRecorder);
    },
    clear: Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["decorate"])(atomic, function () {
      skipRecording(function () {
        self.history.clear();
        self.undoIdx = 0;
      });
    }),
    clearUndo: Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["decorate"])(atomic, function () {
      skipRecording(function () {
        self.history.splice(0, self.undoLevels);
        self.undoIdx = 0;
      });
    }),
    clearRedo: Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["decorate"])(atomic, function () {
      skipRecording(function () {
        self.history.splice(self.undoIdx, self.redoLevels);
      });
    })
  };
});


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var stringifyPrimitive = function (v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }

  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }

  return res;
};

/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
 true ? module.exports : undefined);

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),

/***/ "./node_modules/remotedev/lib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/remotedev/lib/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var defaultSocketOptions = exports.defaultSocketOptions = {
  secure: true,
  hostname: 'remotedev.io',
  port: 443,
  autoReconnect: true,
  autoReconnectOptions: {
    randomness: 60000
  }
};

/***/ }),

/***/ "./node_modules/remotedev/lib/devTools.js":
/*!************************************************!*\
  !*** ./node_modules/remotedev/lib/devTools.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.send = undefined;
exports.extractState = extractState;
exports.generateId = generateId;
exports.start = start;
exports.connect = connect;
exports.connectViaExtension = connectViaExtension;

var _jsan = __webpack_require__(/*! jsan */ "./node_modules/jsan/index.js");

var _socketclusterClient = __webpack_require__(/*! socketcluster-client */ "./node_modules/socketcluster-client/index.js");

var _socketclusterClient2 = _interopRequireDefault(_socketclusterClient);

var _rnHostDetect = __webpack_require__(/*! rn-host-detect */ "./node_modules/rn-host-detect/index.js");

var _rnHostDetect2 = _interopRequireDefault(_rnHostDetect);

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/remotedev/lib/constants.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var socket = undefined;
var channel = undefined;
var listeners = {};

function extractState(message) {
  if (!message || !message.state) return undefined;
  if (typeof message.state === 'string') return (0, _jsan.parse)(message.state);
  return message.state;
}

function generateId() {
  return Math.random().toString(36).substr(2);
}

function handleMessages(message) {
  if (!message.payload) message.payload = message.action;
  Object.keys(listeners).forEach(function (id) {
    if (message.instanceId && id !== message.instanceId) return;
    if (typeof listeners[id] === 'function') listeners[id](message);else listeners[id].forEach(function (fn) {
      fn(message);
    });
  });
}

function watch() {
  if (channel) return;
  socket.emit('login', 'master', function (err, channelName) {
    if (err) {
      console.log(err);
      return;
    }

    channel = socket.subscribe(channelName);
    channel.watch(handleMessages);
    socket.on(channelName, handleMessages);
  });
}

function connectToServer(options) {
  if (socket) return;
  var socketOptions = undefined;

  if (options.port) {
    socketOptions = {
      port: options.port,
      hostname: (0, _rnHostDetect2.default)(options.hostname || 'localhost'),
      secure: !!options.secure
    };
  } else socketOptions = _constants.defaultSocketOptions;

  socket = _socketclusterClient2.default.create(socketOptions);
  watch();
}

function start(options) {
  if (options) {
    if (options.port && !options.hostname) {
      options.hostname = 'localhost';
    }
  }

  connectToServer(options);
}

function transformAction(action, config) {
  if (action.action) return action;
  var liftedAction = {
    timestamp: Date.now()
  };

  if (action) {
    if (config.getActionType) liftedAction.action = config.getActionType(action);else {
      if (typeof action === 'string') liftedAction.action = {
        type: action
      };else if (!action.type) liftedAction.action = {
        type: 'update'
      };else liftedAction.action = action;
    }
  } else {
    liftedAction.action = {
      type: action
    };
  }

  return liftedAction;
}

function _send(action, state, options, type, instanceId) {
  start(options);
  setTimeout(function () {
    var message = {
      payload: state ? (0, _jsan.stringify)(state) : '',
      action: type === 'ACTION' ? (0, _jsan.stringify)(transformAction(action, options)) : action,
      type: type || 'ACTION',
      id: socket.id,
      instanceId: instanceId,
      name: options.name
    };
    socket.emit(socket.id ? 'log' : 'log-noid', message);
  }, 0);
}

exports.send = _send;

function connect() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var id = generateId(options.instanceId);
  start(options);
  return {
    init: function init(state, action) {
      _send(action || {}, state, options, 'INIT', id);
    },
    subscribe: function subscribe(listener) {
      if (!listener) return undefined;
      if (!listeners[id]) listeners[id] = [];
      listeners[id].push(listener);
      return function unsubscribe() {
        var index = listeners[id].indexOf(listener);
        listeners[id].splice(index, 1);
      };
    },
    unsubscribe: function unsubscribe() {
      delete listeners[id];
    },
    send: function send(action, payload) {
      if (action) {
        _send(action, payload, options, 'ACTION', id);
      } else {
        _send(undefined, payload, options, 'STATE', id);
      }
    },
    error: function error(payload) {
      socket.emit({
        type: 'ERROR',
        payload: payload,
        id: socket.id,
        instanceId: id
      });
    }
  };
}

function connectViaExtension(options) {
  if (options && options.remote || typeof window === 'undefined' || !window.__REDUX_DEVTOOLS_EXTENSION__) {
    return connect(options);
  }

  return window.__REDUX_DEVTOOLS_EXTENSION__.connect(options);
}

exports.default = {
  connect: connect,
  connectViaExtension: connectViaExtension,
  send: _send,
  extractState: extractState,
  generateId: generateId
};

/***/ }),

/***/ "./node_modules/remotedev/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/remotedev/lib/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./devTools */ "./node_modules/remotedev/lib/devTools.js");

/***/ }),

/***/ "./node_modules/rn-host-detect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/rn-host-detect/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * It only for Debug Remotely mode for Android
 * When __DEV__ === false, we can't use window.require('NativeModules')
 */

function getByRemoteConfig(hostname) {
  var remoteModuleConfig = typeof window !== 'undefined' && window.__fbBatchedBridgeConfig && window.__fbBatchedBridgeConfig.remoteModuleConfig;
  if (!Array.isArray(remoteModuleConfig) || hostname !== 'localhost' && hostname !== '127.0.0.1') return {
    hostname: hostname,
    passed: false
  };
  var result = hostname;
  var passed = false;
  remoteModuleConfig.some(function (config) {
    if (!config) return false;
    var name = config[0];
    var content = config[1];

    if ((name === 'AndroidConstants' || name === 'PlatformConstants') && content && content.ServerHost) {
      result = content.ServerHost.split(':')[0];
      passed = true;
      return true;
    }

    if (name === 'SourceCode' && content && content.scriptURL) {
      result = content.scriptURL.replace(/https?:\/\//, '').split(':')[0];
      passed = true;
      return true;
    }

    return false;
  });
  return {
    hostname: result,
    passed: passed
  };
}

function getByRNRequirePolyfill(hostname) {
  var originalWarn = console.warn;
  var NativeModules;
  var Constants;
  var SourceCode;

  if (typeof window === 'undefined' || !window.__DEV__ || typeof window.require !== 'function' || // RN >= 0.56
  // TODO: Get NativeModules for RN >= 0.56
  window.require.name === 'metroRequire') {
    return hostname;
  }

  console.warn = function () {
    if (arguments[0] && typeof arguments[0].indexOf == 'function' && arguments[0].indexOf("Requiring module 'NativeModules' by name") > -1) return;
    return originalWarn.apply(console, arguments);
  };

  try {
    NativeModules = window.require('NativeModules');
  } catch (e) {}

  console.warn = originalWarn;
  if (!NativeModules) return hostname;
  Constants = NativeModules.PlatformConstants || NativeModules.AndroidConstants;
  SourceCode = NativeModules.SourceCode;

  if (Constants && Constants.ServerHost) {
    return Constants.ServerHost.split(':')[0];
  } else if (SourceCode && SourceCode.scriptURL) {
    return SourceCode.scriptURL.replace(/https?:\/\//, '').split(':')[0];
  }

  return hostname;
}
/*
 * Get React Native server IP if hostname is `localhost`
 * On Android emulator, the IP of host is `10.0.2.2` (Genymotion: 10.0.3.2)
 */


module.exports = function (hostname) {
  // Check if it in React Native environment
  if (typeof __fbBatchedBridgeConfig !== 'object' || hostname !== 'localhost' && hostname !== '127.0.0.1') {
    return hostname;
  }

  var result = getByRemoteConfig(hostname); // Leave if get hostname by remote config successful

  if (result.passed) {
    return result.hostname;
  } // Otherwise, use RN's require polyfill


  return getByRNRequirePolyfill(hostname);
};

/***/ }),

/***/ "./node_modules/sc-channel/index.js":
/*!******************************************!*\
  !*** ./node_modules/sc-channel/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/sc-channel/node_modules/component-emitter/index.js");

var SCChannel = function (name, client, options) {
  var self = this;
  Emitter.call(this);
  this.PENDING = 'pending';
  this.SUBSCRIBED = 'subscribed';
  this.UNSUBSCRIBED = 'unsubscribed';
  this.name = name;
  this.state = this.UNSUBSCRIBED;
  this.client = client;
  this.options = options || {};
  this.setOptions(this.options);
};

SCChannel.prototype = Object.create(Emitter.prototype);

SCChannel.prototype.setOptions = function (options) {
  if (!options) {
    options = {};
  }

  this.waitForAuth = options.waitForAuth || false;
  this.batch = options.batch || false;

  if (options.data !== undefined) {
    this.data = options.data;
  }
};

SCChannel.prototype.getState = function () {
  return this.state;
};

SCChannel.prototype.subscribe = function (options) {
  this.client.subscribe(this.name, options);
};

SCChannel.prototype.unsubscribe = function () {
  this.client.unsubscribe(this.name);
};

SCChannel.prototype.isSubscribed = function (includePending) {
  return this.client.isSubscribed(this.name, includePending);
};

SCChannel.prototype.publish = function (data, callback) {
  this.client.publish(this.name, data, callback);
};

SCChannel.prototype.watch = function (handler) {
  this.client.watch(this.name, handler);
};

SCChannel.prototype.unwatch = function (handler) {
  this.client.unwatch(this.name, handler);
};

SCChannel.prototype.watchers = function () {
  return this.client.watchers(this.name);
};

SCChannel.prototype.destroy = function () {
  this.client.destroyChannel(this.name);
};

module.exports.SCChannel = SCChannel;

/***/ }),

/***/ "./node_modules/sc-channel/node_modules/component-emitter/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sc-channel/node_modules/component-emitter/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Expose `Emitter`.
 */
if (true) {
  module.exports = Emitter;
}
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */


function Emitter(obj) {
  if (obj) return mixin(obj);
}

;
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }

  return obj;
}
/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};
/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};
/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {}; // all

  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  } // specific event


  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this; // remove all handlers

  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  } // remove specific handler


  var cb;

  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];

    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  return this;
};
/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */


Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1),
      callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);

    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};
/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */


Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};
/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */


Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

/***/ }),

/***/ "./node_modules/sc-errors/decycle.js":
/*!*******************************************!*\
  !*** ./node_modules/sc-errors/decycle.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Based on https://github.com/dscape/cycle/blob/master/cycle.js
module.exports = function decycle(object) {
  // Make a deep copy of an object or array, assuring that there is at most
  // one instance of each object or array in the resulting structure. The
  // duplicate references (which might be forming cycles) are replaced with
  // an object of the form
  //      {$ref: PATH}
  // where the PATH is a JSONPath string that locates the first occurance.
  // So,
  //      var a = [];
  //      a[0] = a;
  //      return JSON.stringify(JSON.decycle(a));
  // produces the string '[{"$ref":"$"}]'.
  // JSONPath is used to locate the unique object. $ indicates the top level of
  // the object or array. [NUMBER] or [STRING] indicates a child member or
  // property.
  var objects = [],
      // Keep a reference to each unique object or array
  paths = []; // Keep the path to each unique object or array

  return function derez(value, path) {
    // The derez recurses through the object, producing the deep copy.
    var i, // The loop counter
    name, // Property name
    nu; // The new object or array
    // typeof null === 'object', so go on if this value is really an object but not
    // one of the weird builtin objects.

    if (typeof value === 'object' && value !== null && !(value instanceof Boolean) && !(value instanceof Date) && !(value instanceof Number) && !(value instanceof RegExp) && !(value instanceof String)) {
      // If the value is an object or array, look to see if we have already
      // encountered it. If so, return a $ref/path object. This is a hard way,
      // linear search that will get slower as the number of unique objects grows.
      for (i = 0; i < objects.length; i += 1) {
        if (objects[i] === value) {
          return {
            $ref: paths[i]
          };
        }
      } // Otherwise, accumulate the unique value and its path.


      objects.push(value);
      paths.push(path); // If it is an array, replicate the array.

      if (Object.prototype.toString.apply(value) === '[object Array]') {
        nu = [];

        for (i = 0; i < value.length; i += 1) {
          nu[i] = derez(value[i], path + '[' + i + ']');
        }
      } else {
        // If it is an object, replicate the object.
        nu = {};

        for (name in value) {
          if (Object.prototype.hasOwnProperty.call(value, name)) {
            nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');
          }
        }
      }

      return nu;
    }

    return value;
  }(object, '$');
};

/***/ }),

/***/ "./node_modules/sc-errors/index.js":
/*!*****************************************!*\
  !*** ./node_modules/sc-errors/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var decycle = __webpack_require__(/*! ./decycle */ "./node_modules/sc-errors/decycle.js");

var isStrict = function () {
  return !this;
}();

function AuthTokenExpiredError(message, expiry) {
  this.name = 'AuthTokenExpiredError';
  this.message = message;
  this.expiry = expiry;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

AuthTokenExpiredError.prototype = Object.create(Error.prototype);

function AuthTokenInvalidError(message) {
  this.name = 'AuthTokenInvalidError';
  this.message = message;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

AuthTokenInvalidError.prototype = Object.create(Error.prototype);

function AuthTokenNotBeforeError(message, date) {
  this.name = 'AuthTokenNotBeforeError';
  this.message = message;
  this.date = date;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

AuthTokenNotBeforeError.prototype = Object.create(Error.prototype); // For any other auth token error.

function AuthTokenError(message) {
  this.name = 'AuthTokenError';
  this.message = message;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

AuthTokenError.prototype = Object.create(Error.prototype);

function SilentMiddlewareBlockedError(message, type) {
  this.name = 'SilentMiddlewareBlockedError';
  this.message = message;
  this.type = type;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

SilentMiddlewareBlockedError.prototype = Object.create(Error.prototype);

function InvalidActionError(message) {
  this.name = 'InvalidActionError';
  this.message = message;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

InvalidActionError.prototype = Object.create(Error.prototype);

function InvalidArgumentsError(message) {
  this.name = 'InvalidArgumentsError';
  this.message = message;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

InvalidArgumentsError.prototype = Object.create(Error.prototype);

function InvalidOptionsError(message) {
  this.name = 'InvalidOptionsError';
  this.message = message;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

InvalidOptionsError.prototype = Object.create(Error.prototype);

function InvalidMessageError(message) {
  this.name = 'InvalidMessageError';
  this.message = message;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

InvalidMessageError.prototype = Object.create(Error.prototype);

function SocketProtocolError(message, code) {
  this.name = 'SocketProtocolError';
  this.message = message;
  this.code = code;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

SocketProtocolError.prototype = Object.create(Error.prototype);

function ServerProtocolError(message) {
  this.name = 'ServerProtocolError';
  this.message = message;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

ServerProtocolError.prototype = Object.create(Error.prototype);

function HTTPServerError(message) {
  this.name = 'HTTPServerError';
  this.message = message;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

HTTPServerError.prototype = Object.create(Error.prototype);

function ResourceLimitError(message) {
  this.name = 'ResourceLimitError';
  this.message = message;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

ResourceLimitError.prototype = Object.create(Error.prototype);

function TimeoutError(message) {
  this.name = 'TimeoutError';
  this.message = message;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

TimeoutError.prototype = Object.create(Error.prototype);

function BadConnectionError(message, type) {
  this.name = 'BadConnectionError';
  this.message = message;
  this.type = type;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

BadConnectionError.prototype = Object.create(Error.prototype);

function BrokerError(message) {
  this.name = 'BrokerError';
  this.message = message;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

BrokerError.prototype = Object.create(Error.prototype);

function ProcessExitError(message, code) {
  this.name = 'ProcessExitError';
  this.message = message;
  this.code = code;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

ProcessExitError.prototype = Object.create(Error.prototype);

function UnknownError(message) {
  this.name = 'UnknownError';
  this.message = message;

  if (Error.captureStackTrace && !isStrict) {
    Error.captureStackTrace(this, arguments.callee);
  } else {
    this.stack = new Error().stack;
  }
}

UnknownError.prototype = Object.create(Error.prototype); // Expose all error types.

module.exports = {
  AuthTokenExpiredError: AuthTokenExpiredError,
  AuthTokenInvalidError: AuthTokenInvalidError,
  AuthTokenNotBeforeError: AuthTokenNotBeforeError,
  AuthTokenError: AuthTokenError,
  SilentMiddlewareBlockedError: SilentMiddlewareBlockedError,
  InvalidActionError: InvalidActionError,
  InvalidArgumentsError: InvalidArgumentsError,
  InvalidOptionsError: InvalidOptionsError,
  InvalidMessageError: InvalidMessageError,
  SocketProtocolError: SocketProtocolError,
  ServerProtocolError: ServerProtocolError,
  HTTPServerError: HTTPServerError,
  ResourceLimitError: ResourceLimitError,
  TimeoutError: TimeoutError,
  BadConnectionError: BadConnectionError,
  BrokerError: BrokerError,
  ProcessExitError: ProcessExitError,
  UnknownError: UnknownError
};
module.exports.socketProtocolErrorStatuses = {
  1001: 'Socket was disconnected',
  1002: 'A WebSocket protocol error was encountered',
  1003: 'Server terminated socket because it received invalid data',
  1005: 'Socket closed without status code',
  1006: 'Socket hung up',
  1007: 'Message format was incorrect',
  1008: 'Encountered a policy violation',
  1009: 'Message was too big to process',
  1010: 'Client ended the connection because the server did not comply with extension requirements',
  1011: 'Server encountered an unexpected fatal condition',
  4000: 'Server ping timed out',
  4001: 'Client pong timed out',
  4002: 'Server failed to sign auth token',
  4003: 'Failed to complete handshake',
  4004: 'Client failed to save auth token',
  4005: 'Did not receive #handshake from client before timeout',
  4006: 'Failed to bind socket to message broker',
  4007: 'Client connection establishment timed out',
  4008: 'Server rejected handshake from client'
};
module.exports.socketProtocolIgnoreStatuses = {
  1000: 'Socket closed normally',
  1001: 'Socket hung up'
}; // Properties related to error domains cannot be serialized.

var unserializableErrorProperties = {
  domain: 1,
  domainEmitter: 1,
  domainThrown: 1
}; // Convert an error into a JSON-compatible type which can later be hydrated
// back to its *original* form.

module.exports.dehydrateError = function dehydrateError(error, includeStackTrace) {
  var dehydratedError;

  if (error && typeof error === 'object') {
    dehydratedError = {
      message: error.message
    };

    if (includeStackTrace) {
      dehydratedError.stack = error.stack;
    }

    for (var i in error) {
      if (!unserializableErrorProperties[i]) {
        dehydratedError[i] = error[i];
      }
    }
  } else if (typeof error === 'function') {
    dehydratedError = '[function ' + (error.name || 'anonymous') + ']';
  } else {
    dehydratedError = error;
  }

  return decycle(dehydratedError);
}; // Convert a dehydrated error back to its *original* form.


module.exports.hydrateError = function hydrateError(error) {
  var hydratedError = null;

  if (error != null) {
    if (typeof error === 'object') {
      hydratedError = new Error(error.message);

      for (var i in error) {
        if (error.hasOwnProperty(i)) {
          hydratedError[i] = error[i];
        }
      }
    } else {
      hydratedError = error;
    }
  }

  return hydratedError;
};

module.exports.decycle = decycle;

/***/ }),

/***/ "./node_modules/sc-formatter/index.js":
/*!********************************************!*\
  !*** ./node_modules/sc-formatter/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var validJSONStartRegex = /^[ \n\r\t]*[{\[]/;

var arrayBufferToBase64 = function (arraybuffer) {
  var bytes = new Uint8Array(arraybuffer);
  var len = bytes.length;
  var base64 = '';

  for (var i = 0; i < len; i += 3) {
    base64 += base64Chars[bytes[i] >> 2];
    base64 += base64Chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    base64 += base64Chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    base64 += base64Chars[bytes[i + 2] & 63];
  }

  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + '=';
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + '==';
  }

  return base64;
};

var binaryToBase64Replacer = function (key, value) {
  if (global.ArrayBuffer && value instanceof global.ArrayBuffer) {
    return {
      base64: true,
      data: arrayBufferToBase64(value)
    };
  } else if (global.Buffer) {
    if (value instanceof global.Buffer) {
      return {
        base64: true,
        data: value.toString('base64')
      };
    } // Some versions of Node.js convert Buffers to Objects before they are passed to
    // the replacer function - Because of this, we need to rehydrate Buffers
    // before we can convert them to base64 strings.


    if (value && value.type === 'Buffer' && Array.isArray(value.data)) {
      var rehydratedBuffer;

      if (global.Buffer.from) {
        rehydratedBuffer = global.Buffer.from(value.data);
      } else {
        rehydratedBuffer = new global.Buffer(value.data);
      }

      return {
        base64: true,
        data: rehydratedBuffer.toString('base64')
      };
    }
  }

  return value;
}; // Decode the data which was transmitted over the wire to a JavaScript Object in a format which SC understands.
// See encode function below for more details.


module.exports.decode = function (input) {
  if (input == null) {
    return null;
  } // Leave ping or pong message as is


  if (input === '#1' || input === '#2') {
    return input;
  }

  var message = input.toString(); // Performance optimization to detect invalid JSON packet sooner.

  if (!validJSONStartRegex.test(message)) {
    return message;
  }

  try {
    return JSON.parse(message);
  } catch (err) {}

  return message;
}; // Encode a raw JavaScript object (which is in the SC protocol format) into a format for
// transfering it over the wire. In this case, we just convert it into a simple JSON string.
// If you want to create your own custom codec, you can encode the object into any format
// (e.g. binary ArrayBuffer or string with any kind of compression) so long as your decode
// function is able to rehydrate that object back into its original JavaScript Object format
// (which adheres to the SC protocol).
// See https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md
// for details about the SC protocol.


module.exports.encode = function (object) {
  // Leave ping or pong message as is
  if (object === '#1' || object === '#2') {
    return object;
  }

  return JSON.stringify(object, binaryToBase64Replacer);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function (handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function (event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function (handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function (handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function (handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function (handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/socketcluster-client/index.js":
/*!****************************************************!*\
  !*** ./node_modules/socketcluster-client/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var SCClientSocket = __webpack_require__(/*! ./lib/scclientsocket */ "./node_modules/socketcluster-client/lib/scclientsocket.js");

var factory = __webpack_require__(/*! ./lib/factory */ "./node_modules/socketcluster-client/lib/factory.js");

module.exports.factory = factory;
module.exports.SCClientSocket = SCClientSocket;
module.exports.Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/socketcluster-client/node_modules/component-emitter/index.js");

module.exports.create = function (options) {
  return factory.create(options);
};

module.exports.connect = module.exports.create;

module.exports.destroy = function (socket) {
  return factory.destroy(socket);
};

module.exports.clients = factory.clients;
module.exports.version = '13.0.1';

/***/ }),

/***/ "./node_modules/socketcluster-client/lib/auth.js":
/*!*******************************************************!*\
  !*** ./node_modules/socketcluster-client/lib/auth.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var AuthEngine = function () {
  this._internalStorage = {};
  this.isLocalStorageEnabled = this._checkLocalStorageEnabled();
};

AuthEngine.prototype._checkLocalStorageEnabled = function () {
  var err;

  try {
    // Some browsers will throw an error here if localStorage is disabled.
    global.localStorage; // Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem
    // throw QuotaExceededError. We're going to detect this and avoid hard to debug edge cases.

    global.localStorage.setItem('__scLocalStorageTest', 1);
    global.localStorage.removeItem('__scLocalStorageTest');
  } catch (e) {
    err = e;
  }

  return !err;
};

AuthEngine.prototype.saveToken = function (name, token, options, callback) {
  if (this.isLocalStorageEnabled && global.localStorage) {
    global.localStorage.setItem(name, token);
  } else {
    this._internalStorage[name] = token;
  }

  callback && callback(null, token);
};

AuthEngine.prototype.removeToken = function (name, callback) {
  var token;
  this.loadToken(name, function (err, authToken) {
    token = authToken;
  });

  if (this.isLocalStorageEnabled && global.localStorage) {
    global.localStorage.removeItem(name);
  } else {
    delete this._internalStorage[name];
  }

  callback && callback(null, token);
};

AuthEngine.prototype.loadToken = function (name, callback) {
  var token;

  if (this.isLocalStorageEnabled && global.localStorage) {
    token = global.localStorage.getItem(name);
  } else {
    token = this._internalStorage[name] || null;
  }

  callback(null, token);
};

module.exports.AuthEngine = AuthEngine;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/socketcluster-client/lib/factory.js":
/*!**********************************************************!*\
  !*** ./node_modules/socketcluster-client/lib/factory.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var SCClientSocket = __webpack_require__(/*! ./scclientsocket */ "./node_modules/socketcluster-client/lib/scclientsocket.js");

var scErrors = __webpack_require__(/*! sc-errors */ "./node_modules/sc-errors/index.js");

var uuid = __webpack_require__(/*! uuid */ "./node_modules/socketcluster-client/node_modules/uuid/index.js");

var InvalidArgumentsError = scErrors.InvalidArgumentsError;
var _clients = {};

function getMultiplexId(options) {
  var protocolPrefix = options.secure ? 'https://' : 'http://';
  var queryString = '';

  if (options.query) {
    if (typeof options.query == 'string') {
      queryString = options.query;
    } else {
      var queryArray = [];
      var queryMap = options.query;

      for (var key in queryMap) {
        if (queryMap.hasOwnProperty(key)) {
          queryArray.push(key + '=' + queryMap[key]);
        }
      }

      if (queryArray.length) {
        queryString = '?' + queryArray.join('&');
      }
    }
  }

  var host;

  if (options.host) {
    host = options.host;
  } else {
    host = options.hostname + ':' + options.port;
  }

  return protocolPrefix + host + options.path + queryString;
}

function isUrlSecure() {
  return global.location && location.protocol == 'https:';
}

function getPort(options, isSecureDefault) {
  var isSecure = options.secure == null ? isSecureDefault : options.secure;
  return options.port || (global.location && location.port ? location.port : isSecure ? 443 : 80);
}

function create(options) {
  var self = this;
  options = options || {};

  if (options.host && !options.host.match(/[^:]+:\d{2,5}/)) {
    throw new InvalidArgumentsError('The host option should include both' + ' the hostname and the port number in the format "hostname:port"');
  }

  if (options.host && options.hostname) {
    throw new InvalidArgumentsError('The host option should already include' + ' the hostname and the port number in the format "hostname:port"' + ' - Because of this, you should never use host and hostname options together');
  }

  if (options.host && options.port) {
    throw new InvalidArgumentsError('The host option should already include' + ' the hostname and the port number in the format "hostname:port"' + ' - Because of this, you should never use host and port options together');
  }

  var isSecureDefault = isUrlSecure();
  var opts = {
    port: getPort(options, isSecureDefault),
    hostname: global.location && location.hostname || 'localhost',
    path: '/socketcluster/',
    secure: isSecureDefault,
    autoConnect: true,
    autoReconnect: true,
    autoSubscribeOnConnect: true,
    connectTimeout: 20000,
    ackTimeout: 10000,
    timestampRequests: false,
    timestampParam: 't',
    authEngine: null,
    authTokenName: 'socketCluster.authToken',
    binaryType: 'arraybuffer',
    multiplex: true,
    pubSubBatchDuration: null,
    cloneData: false
  };

  for (var i in options) {
    if (options.hasOwnProperty(i)) {
      opts[i] = options[i];
    }
  }

  opts.clientMap = _clients;

  if (opts.multiplex === false) {
    opts.clientId = uuid.v4();
    var socket = new SCClientSocket(opts);
    _clients[opts.clientId] = socket;
    return socket;
  }

  opts.clientId = getMultiplexId(opts);

  if (_clients[opts.clientId]) {
    if (opts.autoConnect) {
      _clients[opts.clientId].connect();
    }
  } else {
    _clients[opts.clientId] = new SCClientSocket(opts);
  }

  return _clients[opts.clientId];
}

function destroy(socket) {
  socket.destroy();
}

module.exports = {
  create: create,
  destroy: destroy,
  clients: _clients
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/socketcluster-client/lib/response.js":
/*!***********************************************************!*\
  !*** ./node_modules/socketcluster-client/lib/response.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var scErrors = __webpack_require__(/*! sc-errors */ "./node_modules/sc-errors/index.js");

var InvalidActionError = scErrors.InvalidActionError;

var Response = function (socket, id) {
  this.socket = socket;
  this.id = id;
  this.sent = false;
};

Response.prototype._respond = function (responseData) {
  if (this.sent) {
    throw new InvalidActionError('Response ' + this.id + ' has already been sent');
  } else {
    this.sent = true;
    this.socket.send(this.socket.encode(responseData));
  }
};

Response.prototype.end = function (data) {
  if (this.id) {
    var responseData = {
      rid: this.id
    };

    if (data !== undefined) {
      responseData.data = data;
    }

    this._respond(responseData);
  }
};

Response.prototype.error = function (error, data) {
  if (this.id) {
    var err = scErrors.dehydrateError(error);
    var responseData = {
      rid: this.id,
      error: err
    };

    if (data !== undefined) {
      responseData.data = data;
    }

    this._respond(responseData);
  }
};

Response.prototype.callback = function (error, data) {
  if (error) {
    this.error(error, data);
  } else {
    this.end(data);
  }
};

module.exports.Response = Response;

/***/ }),

/***/ "./node_modules/socketcluster-client/lib/scclientsocket.js":
/*!*****************************************************************!*\
  !*** ./node_modules/socketcluster-client/lib/scclientsocket.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, Buffer) {var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/socketcluster-client/node_modules/component-emitter/index.js");

var SCChannel = __webpack_require__(/*! sc-channel */ "./node_modules/sc-channel/index.js").SCChannel;

var Response = __webpack_require__(/*! ./response */ "./node_modules/socketcluster-client/lib/response.js").Response;

var AuthEngine = __webpack_require__(/*! ./auth */ "./node_modules/socketcluster-client/lib/auth.js").AuthEngine;

var formatter = __webpack_require__(/*! sc-formatter */ "./node_modules/sc-formatter/index.js");

var SCTransport = __webpack_require__(/*! ./sctransport */ "./node_modules/socketcluster-client/lib/sctransport.js").SCTransport;

var querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

var LinkedList = __webpack_require__(/*! linked-list */ "./node_modules/linked-list/index.js");

var base64 = __webpack_require__(/*! base-64 */ "./node_modules/base-64/base64.js");

var clone = __webpack_require__(/*! clone */ "./node_modules/clone/clone.js");

var scErrors = __webpack_require__(/*! sc-errors */ "./node_modules/sc-errors/index.js");

var InvalidArgumentsError = scErrors.InvalidArgumentsError;
var InvalidMessageError = scErrors.InvalidMessageError;
var InvalidActionError = scErrors.InvalidActionError;
var SocketProtocolError = scErrors.SocketProtocolError;
var TimeoutError = scErrors.TimeoutError;
var BadConnectionError = scErrors.BadConnectionError;
var isBrowser = typeof window != 'undefined';

var SCClientSocket = function (opts) {
  var self = this;
  Emitter.call(this);
  this.id = null;
  this.state = this.CLOSED;
  this.authState = this.UNAUTHENTICATED;
  this.signedAuthToken = null;
  this.authToken = null;
  this.pendingReconnect = false;
  this.pendingReconnectTimeout = null;
  this.preparingPendingSubscriptions = false;
  this.clientId = opts.clientId;
  this.connectTimeout = opts.connectTimeout;
  this.ackTimeout = opts.ackTimeout;
  this.channelPrefix = opts.channelPrefix || null;
  this.disconnectOnUnload = opts.disconnectOnUnload == null ? true : opts.disconnectOnUnload;
  this.authTokenName = opts.authTokenName; // pingTimeout will be ackTimeout at the start, but it will
  // be updated with values provided by the 'connect' event

  this.pingTimeout = this.ackTimeout;
  this.pingTimeoutDisabled = !!opts.pingTimeoutDisabled;
  this.active = true;
  this._clientMap = opts.clientMap || {};
  var maxTimeout = Math.pow(2, 31) - 1;

  var verifyDuration = function (propertyName) {
    if (self[propertyName] > maxTimeout) {
      throw new InvalidArgumentsError('The ' + propertyName + ' value provided exceeded the maximum amount allowed');
    }
  };

  verifyDuration('connectTimeout');
  verifyDuration('ackTimeout');
  this._localEvents = {
    'connect': 1,
    'connectAbort': 1,
    'close': 1,
    'disconnect': 1,
    'message': 1,
    'error': 1,
    'raw': 1,
    'kickOut': 1,
    'subscribe': 1,
    'unsubscribe': 1,
    'subscribeStateChange': 1,
    'authStateChange': 1,
    'authenticate': 1,
    'deauthenticate': 1,
    'removeAuthToken': 1,
    'subscribeRequest': 1
  };
  this.connectAttempts = 0;
  this._emitBuffer = new LinkedList();
  this.channels = {};
  this.options = opts;
  this._cid = 1;

  this.options.callIdGenerator = function () {
    return self._cid++;
  };

  if (this.options.autoReconnect) {
    if (this.options.autoReconnectOptions == null) {
      this.options.autoReconnectOptions = {};
    } // Add properties to the this.options.autoReconnectOptions object.
    // We assign the reference to a reconnectOptions variable to avoid repetition.


    var reconnectOptions = this.options.autoReconnectOptions;

    if (reconnectOptions.initialDelay == null) {
      reconnectOptions.initialDelay = 10000;
    }

    if (reconnectOptions.randomness == null) {
      reconnectOptions.randomness = 10000;
    }

    if (reconnectOptions.multiplier == null) {
      reconnectOptions.multiplier = 1.5;
    }

    if (reconnectOptions.maxDelay == null) {
      reconnectOptions.maxDelay = 60000;
    }
  }

  if (this.options.subscriptionRetryOptions == null) {
    this.options.subscriptionRetryOptions = {};
  }

  if (this.options.authEngine) {
    this.auth = this.options.authEngine;
  } else {
    this.auth = new AuthEngine();
  }

  if (this.options.codecEngine) {
    this.codec = this.options.codecEngine;
  } else {
    // Default codec engine
    this.codec = formatter;
  }

  this.options.path = this.options.path.replace(/\/$/, '') + '/';
  this.options.query = opts.query || {};

  if (typeof this.options.query == 'string') {
    this.options.query = querystring.parse(this.options.query);
  }

  this._channelEmitter = new Emitter();

  this._unloadHandler = function () {
    self.disconnect();
  };

  if (isBrowser && this.disconnectOnUnload && global.addEventListener) {
    global.addEventListener('beforeunload', this._unloadHandler, false);
  }

  this._clientMap[this.clientId] = this;

  if (this.options.autoConnect) {
    this.connect();
  }
};

SCClientSocket.prototype = Object.create(Emitter.prototype);
SCClientSocket.CONNECTING = SCClientSocket.prototype.CONNECTING = SCTransport.prototype.CONNECTING;
SCClientSocket.OPEN = SCClientSocket.prototype.OPEN = SCTransport.prototype.OPEN;
SCClientSocket.CLOSED = SCClientSocket.prototype.CLOSED = SCTransport.prototype.CLOSED;
SCClientSocket.AUTHENTICATED = SCClientSocket.prototype.AUTHENTICATED = 'authenticated';
SCClientSocket.UNAUTHENTICATED = SCClientSocket.prototype.UNAUTHENTICATED = 'unauthenticated';
SCClientSocket.PENDING = SCClientSocket.prototype.PENDING = 'pending';
SCClientSocket.ignoreStatuses = scErrors.socketProtocolIgnoreStatuses;
SCClientSocket.errorStatuses = scErrors.socketProtocolErrorStatuses;
SCClientSocket.prototype._privateEventHandlerMap = {
  '#publish': function (data) {
    var undecoratedChannelName = this._undecorateChannelName(data.channel);

    var isSubscribed = this.isSubscribed(undecoratedChannelName, true);

    if (isSubscribed) {
      this._channelEmitter.emit(undecoratedChannelName, data.data);
    }
  },
  '#kickOut': function (data) {
    var undecoratedChannelName = this._undecorateChannelName(data.channel);

    var channel = this.channels[undecoratedChannelName];

    if (channel) {
      Emitter.prototype.emit.call(this, 'kickOut', data.message, undecoratedChannelName);
      channel.emit('kickOut', data.message, undecoratedChannelName);

      this._triggerChannelUnsubscribe(channel);
    }
  },
  '#setAuthToken': function (data, response) {
    var self = this;

    if (data) {
      var triggerAuthenticate = function (err) {
        if (err) {
          // This is a non-fatal error, we don't want to close the connection
          // because of this but we do want to notify the server and throw an error
          // on the client.
          response.error(err);

          self._onSCError(err);
        } else {
          self._changeToAuthenticatedState(data.token);

          response.end();
        }
      };

      this.auth.saveToken(this.authTokenName, data.token, {}, triggerAuthenticate);
    } else {
      response.error(new InvalidMessageError('No token data provided by #setAuthToken event'));
    }
  },
  '#removeAuthToken': function (data, response) {
    var self = this;
    this.auth.removeToken(this.authTokenName, function (err, oldToken) {
      if (err) {
        // Non-fatal error - Do not close the connection
        response.error(err);

        self._onSCError(err);
      } else {
        Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);

        self._changeToUnauthenticatedStateAndClearTokens();

        response.end();
      }
    });
  },
  '#disconnect': function (data) {
    this.transport.close(data.code, data.data);
  }
};

SCClientSocket.prototype.getState = function () {
  return this.state;
};

SCClientSocket.prototype.getBytesReceived = function () {
  return this.transport.getBytesReceived();
};

SCClientSocket.prototype.deauthenticate = function (callback) {
  var self = this;
  this.auth.removeToken(this.authTokenName, function (err, oldToken) {
    if (err) {
      // Non-fatal error - Do not close the connection
      self._onSCError(err);
    } else {
      Emitter.prototype.emit.call(self, 'removeAuthToken', oldToken);

      if (self.state != self.CLOSED) {
        self.emit('#removeAuthToken');
      }

      self._changeToUnauthenticatedStateAndClearTokens();
    }

    callback && callback(err);
  });
};

SCClientSocket.prototype.connect = SCClientSocket.prototype.open = function () {
  var self = this;

  if (!this.active) {
    var error = new InvalidActionError('Cannot connect a destroyed client');

    this._onSCError(error);

    return;
  }

  if (this.state == this.CLOSED) {
    this.pendingReconnect = false;
    this.pendingReconnectTimeout = null;
    clearTimeout(this._reconnectTimeoutRef);
    this.state = this.CONNECTING;
    Emitter.prototype.emit.call(this, 'connecting');

    if (this.transport) {
      this.transport.off();
    }

    this.transport = new SCTransport(this.auth, this.codec, this.options);
    this.transport.on('open', function (status) {
      self.state = self.OPEN;

      self._onSCOpen(status);
    });
    this.transport.on('error', function (err) {
      self._onSCError(err);
    });
    this.transport.on('close', function (code, data) {
      self.state = self.CLOSED;

      self._onSCClose(code, data);
    });
    this.transport.on('openAbort', function (code, data) {
      self.state = self.CLOSED;

      self._onSCClose(code, data, true);
    });
    this.transport.on('event', function (event, data, res) {
      self._onSCEvent(event, data, res);
    });
  }
};

SCClientSocket.prototype.reconnect = function (code, data) {
  this.disconnect(code, data);
  this.connect();
};

SCClientSocket.prototype.disconnect = function (code, data) {
  code = code || 1000;

  if (typeof code != 'number') {
    throw new InvalidArgumentsError('If specified, the code argument must be a number');
  }

  if (this.state == this.OPEN || this.state == this.CONNECTING) {
    this.transport.close(code, data);
  } else {
    this.pendingReconnect = false;
    this.pendingReconnectTimeout = null;
    clearTimeout(this._reconnectTimeoutRef);
  }
};

SCClientSocket.prototype.destroy = function (code, data) {
  if (isBrowser && global.removeEventListener) {
    global.removeEventListener('beforeunload', this._unloadHandler, false);
  }

  this.active = false;
  this.disconnect(code, data);
  delete this._clientMap[this.clientId];
};

SCClientSocket.prototype._changeToUnauthenticatedStateAndClearTokens = function () {
  if (this.authState != this.UNAUTHENTICATED) {
    var oldState = this.authState;
    var oldSignedToken = this.signedAuthToken;
    this.authState = this.UNAUTHENTICATED;
    this.signedAuthToken = null;
    this.authToken = null;
    var stateChangeData = {
      oldState: oldState,
      newState: this.authState
    };
    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);
    Emitter.prototype.emit.call(this, 'deauthenticate', oldSignedToken);
  }
};

SCClientSocket.prototype._changeToAuthenticatedState = function (signedAuthToken) {
  this.signedAuthToken = signedAuthToken;
  this.authToken = this._extractAuthTokenData(signedAuthToken);

  if (this.authState != this.AUTHENTICATED) {
    var oldState = this.authState;
    this.authState = this.AUTHENTICATED;
    var stateChangeData = {
      oldState: oldState,
      newState: this.authState,
      signedAuthToken: signedAuthToken,
      authToken: this.authToken
    };

    if (!this.preparingPendingSubscriptions) {
      this.processPendingSubscriptions();
    }

    Emitter.prototype.emit.call(this, 'authStateChange', stateChangeData);
  }

  Emitter.prototype.emit.call(this, 'authenticate', signedAuthToken);
};

SCClientSocket.prototype.decodeBase64 = function (encodedString) {
  var decodedString;

  if (typeof Buffer == 'undefined') {
    if (global.atob) {
      decodedString = global.atob(encodedString);
    } else {
      decodedString = base64.decode(encodedString);
    }
  } else {
    var buffer = new Buffer(encodedString, 'base64');
    decodedString = buffer.toString('utf8');
  }

  return decodedString;
};

SCClientSocket.prototype.encodeBase64 = function (decodedString) {
  var encodedString;

  if (typeof Buffer == 'undefined') {
    if (global.btoa) {
      encodedString = global.btoa(decodedString);
    } else {
      encodedString = base64.encode(decodedString);
    }
  } else {
    var buffer = new Buffer(decodedString, 'utf8');
    encodedString = buffer.toString('base64');
  }

  return encodedString;
};

SCClientSocket.prototype._extractAuthTokenData = function (signedAuthToken) {
  var tokenParts = (signedAuthToken || '').split('.');
  var encodedTokenData = tokenParts[1];

  if (encodedTokenData != null) {
    var tokenData = encodedTokenData;

    try {
      tokenData = this.decodeBase64(tokenData);
      return JSON.parse(tokenData);
    } catch (e) {
      return tokenData;
    }
  }

  return null;
};

SCClientSocket.prototype.getAuthToken = function () {
  return this.authToken;
};

SCClientSocket.prototype.getSignedAuthToken = function () {
  return this.signedAuthToken;
}; // Perform client-initiated authentication by providing an encrypted token string.


SCClientSocket.prototype.authenticate = function (signedAuthToken, callback) {
  var self = this;
  this.emit('#authenticate', signedAuthToken, function (err, authStatus) {
    if (authStatus && authStatus.isAuthenticated != null) {
      // If authStatus is correctly formatted (has an isAuthenticated property),
      // then we will rehydrate the authError.
      if (authStatus.authError) {
        authStatus.authError = scErrors.hydrateError(authStatus.authError);
      }
    } else {
      // Some errors like BadConnectionError and TimeoutError will not pass a valid
      // authStatus object to the current function, so we need to create it ourselves.
      authStatus = {
        isAuthenticated: self.authState,
        authError: null
      };
    }

    if (err) {
      if (err.name != 'BadConnectionError' && err.name != 'TimeoutError') {
        // In case of a bad/closed connection or a timeout, we maintain the last
        // known auth state since those errors don't mean that the token is invalid.
        self._changeToUnauthenticatedStateAndClearTokens();
      }

      callback && callback(err, authStatus);
    } else {
      self.auth.saveToken(self.authTokenName, signedAuthToken, {}, function (err) {
        if (err) {
          self._onSCError(err);
        }

        if (authStatus.isAuthenticated) {
          self._changeToAuthenticatedState(signedAuthToken);
        } else {
          self._changeToUnauthenticatedStateAndClearTokens();
        }

        callback && callback(err, authStatus);
      });
    }
  });
};

SCClientSocket.prototype._tryReconnect = function (initialDelay) {
  var self = this;
  var exponent = this.connectAttempts++;
  var reconnectOptions = this.options.autoReconnectOptions;
  var timeout;

  if (initialDelay == null || exponent > 0) {
    var initialTimeout = Math.round(reconnectOptions.initialDelay + (reconnectOptions.randomness || 0) * Math.random());
    timeout = Math.round(initialTimeout * Math.pow(reconnectOptions.multiplier, exponent));
  } else {
    timeout = initialDelay;
  }

  if (timeout > reconnectOptions.maxDelay) {
    timeout = reconnectOptions.maxDelay;
  }

  clearTimeout(this._reconnectTimeoutRef);
  this.pendingReconnect = true;
  this.pendingReconnectTimeout = timeout;
  this._reconnectTimeoutRef = setTimeout(function () {
    self.connect();
  }, timeout);
};

SCClientSocket.prototype._onSCOpen = function (status) {
  var self = this;
  this.preparingPendingSubscriptions = true;

  if (status) {
    this.id = status.id;
    this.pingTimeout = status.pingTimeout;
    this.transport.pingTimeout = this.pingTimeout;

    if (status.isAuthenticated) {
      this._changeToAuthenticatedState(status.authToken);
    } else {
      this._changeToUnauthenticatedStateAndClearTokens();
    }
  } else {
    // This can happen if auth.loadToken (in sctransport.js) fails with
    // an error - This means that the signedAuthToken cannot be loaded by
    // the auth engine and therefore, we need to unauthenticate the client.
    this._changeToUnauthenticatedStateAndClearTokens();
  }

  this.connectAttempts = 0;

  if (this.options.autoSubscribeOnConnect) {
    this.processPendingSubscriptions();
  } // If the user invokes the callback while in autoSubscribeOnConnect mode, it
  // won't break anything.


  Emitter.prototype.emit.call(this, 'connect', status, function () {
    self.processPendingSubscriptions();
  });

  if (this.state == this.OPEN) {
    this._flushEmitBuffer();
  }
};

SCClientSocket.prototype._onSCError = function (err) {
  var self = this; // Throw error in different stack frame so that error handling
  // cannot interfere with a reconnect action.

  setTimeout(function () {
    if (self.listeners('error').length < 1) {
      throw err;
    } else {
      Emitter.prototype.emit.call(self, 'error', err);
    }
  }, 0);
};

SCClientSocket.prototype._suspendSubscriptions = function () {
  var channel, newState;

  for (var channelName in this.channels) {
    if (this.channels.hasOwnProperty(channelName)) {
      channel = this.channels[channelName];

      if (channel.state == channel.SUBSCRIBED || channel.state == channel.PENDING) {
        newState = channel.PENDING;
      } else {
        newState = channel.UNSUBSCRIBED;
      }

      this._triggerChannelUnsubscribe(channel, newState);
    }
  }
};

SCClientSocket.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {
  var currentNode = this._emitBuffer.head;
  var nextNode;

  while (currentNode) {
    nextNode = currentNode.next;
    var eventObject = currentNode.data;
    clearTimeout(eventObject.timeout);
    delete eventObject.timeout;
    currentNode.detach();
    currentNode = nextNode;
    var callback = eventObject.callback;

    if (callback) {
      delete eventObject.callback;
      var errorMessage = "Event '" + eventObject.event + "' was aborted due to a bad connection";
      var error = new BadConnectionError(errorMessage, failureType);
      callback.call(eventObject, error, eventObject);
    } // Cleanup any pending response callback in the transport layer too.


    if (eventObject.cid) {
      this.transport.cancelPendingResponse(eventObject.cid);
    }
  }
};

SCClientSocket.prototype._onSCClose = function (code, data, openAbort) {
  var self = this;
  this.id = null;

  if (this.transport) {
    this.transport.off();
  }

  this.pendingReconnect = false;
  this.pendingReconnectTimeout = null;
  clearTimeout(this._reconnectTimeoutRef);

  this._suspendSubscriptions();

  this._abortAllPendingEventsDueToBadConnection(openAbort ? 'connectAbort' : 'disconnect'); // Try to reconnect
  // on server ping timeout (4000)
  // or on client pong timeout (4001)
  // or on close without status (1005)
  // or on handshake failure (4003)
  // or on handshake rejection (4008)
  // or on socket hung up (1006)


  if (this.options.autoReconnect) {
    if (code == 4000 || code == 4001 || code == 1005) {
      // If there is a ping or pong timeout or socket closes without
      // status, don't wait before trying to reconnect - These could happen
      // if the client wakes up after a period of inactivity and in this case we
      // want to re-establish the connection as soon as possible.
      this._tryReconnect(0); // Codes 4500 and above will be treated as permanent disconnects.
      // Socket will not try to auto-reconnect.

    } else if (code != 1000 && code < 4500) {
      this._tryReconnect();
    }
  }

  if (openAbort) {
    Emitter.prototype.emit.call(self, 'connectAbort', code, data);
  } else {
    Emitter.prototype.emit.call(self, 'disconnect', code, data);
  }

  Emitter.prototype.emit.call(self, 'close', code, data);

  if (!SCClientSocket.ignoreStatuses[code]) {
    var closeMessage;

    if (data) {
      closeMessage = 'Socket connection closed with status code ' + code + ' and reason: ' + data;
    } else {
      closeMessage = 'Socket connection closed with status code ' + code;
    }

    var err = new SocketProtocolError(SCClientSocket.errorStatuses[code] || closeMessage, code);

    this._onSCError(err);
  }
};

SCClientSocket.prototype._onSCEvent = function (event, data, res) {
  var handler = this._privateEventHandlerMap[event];

  if (handler) {
    handler.call(this, data, res);
  } else {
    Emitter.prototype.emit.call(this, event, data, function () {
      res && res.callback.apply(res, arguments);
    });
  }
};

SCClientSocket.prototype.decode = function (message) {
  return this.transport.decode(message);
};

SCClientSocket.prototype.encode = function (object) {
  return this.transport.encode(object);
};

SCClientSocket.prototype._flushEmitBuffer = function () {
  var currentNode = this._emitBuffer.head;
  var nextNode;

  while (currentNode) {
    nextNode = currentNode.next;
    var eventObject = currentNode.data;
    currentNode.detach();
    this.transport.emitObject(eventObject);
    currentNode = nextNode;
  }
};

SCClientSocket.prototype._handleEventAckTimeout = function (eventObject, eventNode) {
  if (eventNode) {
    eventNode.detach();
  }

  delete eventObject.timeout;
  var callback = eventObject.callback;

  if (callback) {
    delete eventObject.callback;
    var error = new TimeoutError("Event response for '" + eventObject.event + "' timed out");
    callback.call(eventObject, error, eventObject);
  } // Cleanup any pending response callback in the transport layer too.


  if (eventObject.cid) {
    this.transport.cancelPendingResponse(eventObject.cid);
  }
};

SCClientSocket.prototype._emit = function (event, data, callback) {
  var self = this;

  if (this.state == this.CLOSED) {
    this.connect();
  }

  var eventObject = {
    event: event,
    callback: callback
  };
  var eventNode = new LinkedList.Item();

  if (this.options.cloneData) {
    eventObject.data = clone(data);
  } else {
    eventObject.data = data;
  }

  eventNode.data = eventObject;
  eventObject.timeout = setTimeout(function () {
    self._handleEventAckTimeout(eventObject, eventNode);
  }, this.ackTimeout);

  this._emitBuffer.append(eventNode);

  if (this.state == this.OPEN) {
    this._flushEmitBuffer();
  }
};

SCClientSocket.prototype.send = function (data) {
  this.transport.send(data);
};

SCClientSocket.prototype.emit = function (event, data, callback) {
  if (this._localEvents[event] == null) {
    this._emit(event, data, callback);
  } else if (event == 'error') {
    Emitter.prototype.emit.call(this, event, data);
  } else {
    var error = new InvalidActionError('The "' + event + '" event is reserved and cannot be emitted on a client socket');

    this._onSCError(error);
  }
};

SCClientSocket.prototype.publish = function (channelName, data, callback) {
  var pubData = {
    channel: this._decorateChannelName(channelName),
    data: data
  };
  this.emit('#publish', pubData, callback);
};

SCClientSocket.prototype._triggerChannelSubscribe = function (channel, subscriptionOptions) {
  var channelName = channel.name;

  if (channel.state != channel.SUBSCRIBED) {
    var oldState = channel.state;
    channel.state = channel.SUBSCRIBED;
    var stateChangeData = {
      channel: channelName,
      oldState: oldState,
      newState: channel.state,
      subscriptionOptions: subscriptionOptions
    };
    channel.emit('subscribeStateChange', stateChangeData);
    channel.emit('subscribe', channelName, subscriptionOptions);
    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);
    Emitter.prototype.emit.call(this, 'subscribe', channelName, subscriptionOptions);
  }
};

SCClientSocket.prototype._triggerChannelSubscribeFail = function (err, channel, subscriptionOptions) {
  var channelName = channel.name;
  var meetsAuthRequirements = !channel.waitForAuth || this.authState == this.AUTHENTICATED;

  if (channel.state != channel.UNSUBSCRIBED && meetsAuthRequirements) {
    channel.state = channel.UNSUBSCRIBED;
    channel.emit('subscribeFail', err, channelName, subscriptionOptions);
    Emitter.prototype.emit.call(this, 'subscribeFail', err, channelName, subscriptionOptions);
  }
}; // Cancel any pending subscribe callback


SCClientSocket.prototype._cancelPendingSubscribeCallback = function (channel) {
  if (channel._pendingSubscriptionCid != null) {
    this.transport.cancelPendingResponse(channel._pendingSubscriptionCid);
    delete channel._pendingSubscriptionCid;
  }
};

SCClientSocket.prototype._decorateChannelName = function (channelName) {
  if (this.channelPrefix) {
    channelName = this.channelPrefix + channelName;
  }

  return channelName;
};

SCClientSocket.prototype._undecorateChannelName = function (decoratedChannelName) {
  if (this.channelPrefix && decoratedChannelName.indexOf(this.channelPrefix) == 0) {
    return decoratedChannelName.replace(this.channelPrefix, '');
  }

  return decoratedChannelName;
};

SCClientSocket.prototype._trySubscribe = function (channel) {
  var self = this;
  var meetsAuthRequirements = !channel.waitForAuth || this.authState == this.AUTHENTICATED; // We can only ever have one pending subscribe action at any given time on a channel

  if (this.state == this.OPEN && !this.preparingPendingSubscriptions && channel._pendingSubscriptionCid == null && meetsAuthRequirements) {
    var options = {
      noTimeout: true
    };
    var subscriptionOptions = {
      channel: this._decorateChannelName(channel.name)
    };

    if (channel.waitForAuth) {
      options.waitForAuth = true;
      subscriptionOptions.waitForAuth = options.waitForAuth;
    }

    if (channel.data) {
      subscriptionOptions.data = channel.data;
    }

    if (channel.batch) {
      options.batch = true;
      subscriptionOptions.batch = true;
    }

    channel._pendingSubscriptionCid = this.transport.emit('#subscribe', subscriptionOptions, options, function (err) {
      delete channel._pendingSubscriptionCid;

      if (err) {
        self._triggerChannelSubscribeFail(err, channel, subscriptionOptions);
      } else {
        self._triggerChannelSubscribe(channel, subscriptionOptions);
      }
    });
    Emitter.prototype.emit.call(this, 'subscribeRequest', channel.name, subscriptionOptions);
  }
};

SCClientSocket.prototype.subscribe = function (channelName, options) {
  var channel = this.channels[channelName];

  if (!channel) {
    channel = new SCChannel(channelName, this, options);
    this.channels[channelName] = channel;
  } else if (options) {
    channel.setOptions(options);
  }

  if (channel.state == channel.UNSUBSCRIBED) {
    channel.state = channel.PENDING;

    this._trySubscribe(channel);
  }

  return channel;
};

SCClientSocket.prototype._triggerChannelUnsubscribe = function (channel, newState) {
  var channelName = channel.name;
  var oldState = channel.state;

  if (newState) {
    channel.state = newState;
  } else {
    channel.state = channel.UNSUBSCRIBED;
  }

  this._cancelPendingSubscribeCallback(channel);

  if (oldState == channel.SUBSCRIBED) {
    var stateChangeData = {
      channel: channelName,
      oldState: oldState,
      newState: channel.state
    };
    channel.emit('subscribeStateChange', stateChangeData);
    channel.emit('unsubscribe', channelName);
    Emitter.prototype.emit.call(this, 'subscribeStateChange', stateChangeData);
    Emitter.prototype.emit.call(this, 'unsubscribe', channelName);
  }
};

SCClientSocket.prototype._tryUnsubscribe = function (channel) {
  var self = this;

  if (this.state == this.OPEN) {
    var options = {
      noTimeout: true
    };

    if (channel.batch) {
      options.batch = true;
    } // If there is a pending subscribe action, cancel the callback


    this._cancelPendingSubscribeCallback(channel); // This operation cannot fail because the TCP protocol guarantees delivery
    // so long as the connection remains open. If the connection closes,
    // the server will automatically unsubscribe the client and thus complete
    // the operation on the server side.


    var decoratedChannelName = this._decorateChannelName(channel.name);

    this.transport.emit('#unsubscribe', decoratedChannelName, options);
  }
};

SCClientSocket.prototype.unsubscribe = function (channelName) {
  var channel = this.channels[channelName];

  if (channel) {
    if (channel.state != channel.UNSUBSCRIBED) {
      this._triggerChannelUnsubscribe(channel);

      this._tryUnsubscribe(channel);
    }
  }
};

SCClientSocket.prototype.channel = function (channelName, options) {
  var currentChannel = this.channels[channelName];

  if (!currentChannel) {
    currentChannel = new SCChannel(channelName, this, options);
    this.channels[channelName] = currentChannel;
  }

  return currentChannel;
};

SCClientSocket.prototype.destroyChannel = function (channelName) {
  var channel = this.channels[channelName];

  if (channel) {
    channel.unwatch();
    channel.unsubscribe();
    delete this.channels[channelName];
  }
};

SCClientSocket.prototype.subscriptions = function (includePending) {
  var subs = [];
  var channel, includeChannel;

  for (var channelName in this.channels) {
    if (this.channels.hasOwnProperty(channelName)) {
      channel = this.channels[channelName];

      if (includePending) {
        includeChannel = channel && (channel.state == channel.SUBSCRIBED || channel.state == channel.PENDING);
      } else {
        includeChannel = channel && channel.state == channel.SUBSCRIBED;
      }

      if (includeChannel) {
        subs.push(channelName);
      }
    }
  }

  return subs;
};

SCClientSocket.prototype.isSubscribed = function (channelName, includePending) {
  var channel = this.channels[channelName];

  if (includePending) {
    return !!channel && (channel.state == channel.SUBSCRIBED || channel.state == channel.PENDING);
  }

  return !!channel && channel.state == channel.SUBSCRIBED;
};

SCClientSocket.prototype.processPendingSubscriptions = function () {
  var self = this;
  this.preparingPendingSubscriptions = false;
  var pendingChannels = [];

  for (var i in this.channels) {
    if (this.channels.hasOwnProperty(i)) {
      var channel = this.channels[i];

      if (channel.state == channel.PENDING) {
        pendingChannels.push(channel);
      }
    }
  }

  pendingChannels.sort(function (a, b) {
    var ap = a.priority || 0;
    var bp = b.priority || 0;

    if (ap > bp) {
      return -1;
    }

    if (ap < bp) {
      return 1;
    }

    return 0;
  });
  pendingChannels.forEach(function (channel) {
    self._trySubscribe(channel);
  });
};

SCClientSocket.prototype.watch = function (channelName, handler) {
  if (typeof handler != 'function') {
    throw new InvalidArgumentsError('No handler function was provided');
  }

  this._channelEmitter.on(channelName, handler);
};

SCClientSocket.prototype.unwatch = function (channelName, handler) {
  if (handler) {
    this._channelEmitter.removeListener(channelName, handler);
  } else {
    this._channelEmitter.removeAllListeners(channelName);
  }
};

SCClientSocket.prototype.watchers = function (channelName) {
  return this._channelEmitter.listeners(channelName);
};

module.exports = SCClientSocket;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/socketcluster-client/lib/sctransport.js":
/*!**************************************************************!*\
  !*** ./node_modules/socketcluster-client/lib/sctransport.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/socketcluster-client/node_modules/component-emitter/index.js");

var Response = __webpack_require__(/*! ./response */ "./node_modules/socketcluster-client/lib/response.js").Response;

var querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

var WebSocket;
var createWebSocket;

if (global.WebSocket) {
  WebSocket = global.WebSocket;

  createWebSocket = function (uri, options) {
    return new WebSocket(uri);
  };
} else {
  WebSocket = __webpack_require__(/*! ws */ "./node_modules/socketcluster-client/lib/ws-browser.js");

  createWebSocket = function (uri, options) {
    return new WebSocket(uri, null, options);
  };
}

var scErrors = __webpack_require__(/*! sc-errors */ "./node_modules/sc-errors/index.js");

var TimeoutError = scErrors.TimeoutError;
var BadConnectionError = scErrors.BadConnectionError;

var SCTransport = function (authEngine, codecEngine, options) {
  var self = this;
  this.state = this.CLOSED;
  this.auth = authEngine;
  this.codec = codecEngine;
  this.options = options;
  this.connectTimeout = options.connectTimeout;
  this.pingTimeout = options.ackTimeout;
  this.pingTimeoutDisabled = !!options.pingTimeoutDisabled;
  this.callIdGenerator = options.callIdGenerator;
  this.authTokenName = options.authTokenName;
  this._pingTimeoutTicker = null;
  this._callbackMap = {};
  this._batchSendList = []; // Open the connection.

  this.state = this.CONNECTING;
  var uri = this.uri();
  var wsSocket = createWebSocket(uri, this.options);
  wsSocket.binaryType = this.options.binaryType;
  this.socket = wsSocket;

  wsSocket.onopen = function () {
    self._onOpen();
  };

  wsSocket.onclose = function (event) {
    var code;

    if (event.code == null) {
      // This is to handle an edge case in React Native whereby
      // event.code is undefined when the mobile device is locked.
      // TODO: This is not perfect since this condition could also apply to
      // an abnormal close (no close control frame) which would be a 1006.
      code = 1005;
    } else {
      code = event.code;
    }

    self._onClose(code, event.reason);
  };

  wsSocket.onmessage = function (message, flags) {
    self._onMessage(message.data);
  };

  wsSocket.onerror = function (error) {
    // The onclose event will be called automatically after the onerror event
    // if the socket is connected - Otherwise, if it's in the middle of
    // connecting, we want to close it manually with a 1006 - This is necessary
    // to prevent inconsistent behavior when running the client in Node.js
    // vs in a browser.
    if (self.state === self.CONNECTING) {
      self._onClose(1006);
    }
  };

  this._connectTimeoutRef = setTimeout(function () {
    self._onClose(4007);

    self.socket.close(4007);
  }, this.connectTimeout);
};

SCTransport.prototype = Object.create(Emitter.prototype);
SCTransport.CONNECTING = SCTransport.prototype.CONNECTING = 'connecting';
SCTransport.OPEN = SCTransport.prototype.OPEN = 'open';
SCTransport.CLOSED = SCTransport.prototype.CLOSED = 'closed';

SCTransport.prototype.uri = function () {
  var query = this.options.query || {};
  var schema = this.options.secure ? 'wss' : 'ws';

  if (this.options.timestampRequests) {
    query[this.options.timestampParam] = new Date().getTime();
  }

  query = querystring.encode(query);

  if (query.length) {
    query = '?' + query;
  }

  var host;

  if (this.options.host) {
    host = this.options.host;
  } else {
    var port = '';

    if (this.options.port && (schema == 'wss' && this.options.port != 443 || schema == 'ws' && this.options.port != 80)) {
      port = ':' + this.options.port;
    }

    host = this.options.hostname + port;
  }

  return schema + '://' + host + this.options.path + query;
};

SCTransport.prototype._onOpen = function () {
  var self = this;
  clearTimeout(this._connectTimeoutRef);

  this._resetPingTimeout();

  this._handshake(function (err, status) {
    if (err) {
      var statusCode;

      if (status && status.code) {
        statusCode = status.code;
      } else {
        statusCode = 4003;
      }

      self._onError(err);

      self._onClose(statusCode, err.toString());

      self.socket.close(statusCode);
    } else {
      self.state = self.OPEN;
      Emitter.prototype.emit.call(self, 'open', status);

      self._resetPingTimeout();
    }
  });
};

SCTransport.prototype._handshake = function (callback) {
  var self = this;
  this.auth.loadToken(this.authTokenName, function (err, token) {
    if (err) {
      callback(err);
    } else {
      // Don't wait for this.state to be 'open'.
      // The underlying WebSocket (this.socket) is already open.
      var options = {
        force: true
      };
      self.emit('#handshake', {
        authToken: token
      }, options, function (err, status) {
        if (status) {
          // Add the token which was used as part of authentication attempt
          // to the status object.
          status.authToken = token;

          if (status.authError) {
            status.authError = scErrors.hydrateError(status.authError);
          }
        }

        callback(err, status);
      });
    }
  });
};

SCTransport.prototype._abortAllPendingEventsDueToBadConnection = function (failureType) {
  for (var i in this._callbackMap) {
    if (this._callbackMap.hasOwnProperty(i)) {
      var eventObject = this._callbackMap[i];
      delete this._callbackMap[i];
      clearTimeout(eventObject.timeout);
      delete eventObject.timeout;
      var errorMessage = "Event '" + eventObject.event + "' was aborted due to a bad connection";
      var badConnectionError = new BadConnectionError(errorMessage, failureType);
      var callback = eventObject.callback;
      delete eventObject.callback;
      callback.call(eventObject, badConnectionError, eventObject);
    }
  }
};

SCTransport.prototype._onClose = function (code, data) {
  delete this.socket.onopen;
  delete this.socket.onclose;
  delete this.socket.onmessage;
  delete this.socket.onerror;
  clearTimeout(this._connectTimeoutRef);
  clearTimeout(this._pingTimeoutTicker);
  clearTimeout(this._batchTimeout);

  if (this.state == this.OPEN) {
    this.state = this.CLOSED;
    Emitter.prototype.emit.call(this, 'close', code, data);

    this._abortAllPendingEventsDueToBadConnection('disconnect');
  } else if (this.state == this.CONNECTING) {
    this.state = this.CLOSED;
    Emitter.prototype.emit.call(this, 'openAbort', code, data);

    this._abortAllPendingEventsDueToBadConnection('connectAbort');
  }
};

SCTransport.prototype._handleEventObject = function (obj, message) {
  if (obj && obj.event != null) {
    var response = new Response(this, obj.cid);
    Emitter.prototype.emit.call(this, 'event', obj.event, obj.data, response);
  } else if (obj && obj.rid != null) {
    var eventObject = this._callbackMap[obj.rid];

    if (eventObject) {
      clearTimeout(eventObject.timeout);
      delete eventObject.timeout;
      delete this._callbackMap[obj.rid];

      if (eventObject.callback) {
        var rehydratedError = scErrors.hydrateError(obj.error);
        eventObject.callback(rehydratedError, obj.data);
      }
    }
  } else {
    Emitter.prototype.emit.call(this, 'event', 'raw', message);
  }
};

SCTransport.prototype._onMessage = function (message) {
  Emitter.prototype.emit.call(this, 'event', 'message', message);
  var obj = this.decode(message); // If ping

  if (obj == '#1') {
    this._resetPingTimeout();

    if (this.socket.readyState == this.socket.OPEN) {
      this.sendObject('#2');
    }
  } else {
    if (Array.isArray(obj)) {
      var len = obj.length;

      for (var i = 0; i < len; i++) {
        this._handleEventObject(obj[i], message);
      }
    } else {
      this._handleEventObject(obj, message);
    }
  }
};

SCTransport.prototype._onError = function (err) {
  Emitter.prototype.emit.call(this, 'error', err);
};

SCTransport.prototype._resetPingTimeout = function () {
  if (this.pingTimeoutDisabled) {
    return;
  }

  var self = this;
  var now = new Date().getTime();
  clearTimeout(this._pingTimeoutTicker);
  this._pingTimeoutTicker = setTimeout(function () {
    self._onClose(4000);

    self.socket.close(4000);
  }, this.pingTimeout);
};

SCTransport.prototype.getBytesReceived = function () {
  return this.socket.bytesReceived;
};

SCTransport.prototype.close = function (code, data) {
  code = code || 1000;

  if (this.state == this.OPEN) {
    var packet = {
      code: code,
      data: data
    };
    this.emit('#disconnect', packet);

    this._onClose(code, data);

    this.socket.close(code);
  } else if (this.state == this.CONNECTING) {
    this._onClose(code, data);

    this.socket.close(code);
  }
};

SCTransport.prototype.emitObject = function (eventObject, options) {
  var simpleEventObject = {
    event: eventObject.event,
    data: eventObject.data
  };

  if (eventObject.callback) {
    simpleEventObject.cid = eventObject.cid = this.callIdGenerator();
    this._callbackMap[eventObject.cid] = eventObject;
  }

  this.sendObject(simpleEventObject, options);
  return eventObject.cid || null;
};

SCTransport.prototype._handleEventAckTimeout = function (eventObject) {
  if (eventObject.cid) {
    delete this._callbackMap[eventObject.cid];
  }

  delete eventObject.timeout;
  var callback = eventObject.callback;

  if (callback) {
    delete eventObject.callback;
    var error = new TimeoutError("Event response for '" + eventObject.event + "' timed out");
    callback.call(eventObject, error, eventObject);
  }
}; // The last two optional arguments (a and b) can be options and/or callback


SCTransport.prototype.emit = function (event, data, a, b) {
  var self = this;
  var callback, options;

  if (b) {
    options = a;
    callback = b;
  } else {
    if (a instanceof Function) {
      options = {};
      callback = a;
    } else {
      options = a;
    }
  }

  var eventObject = {
    event: event,
    data: data,
    callback: callback
  };

  if (callback && !options.noTimeout) {
    eventObject.timeout = setTimeout(function () {
      self._handleEventAckTimeout(eventObject);
    }, this.options.ackTimeout);
  }

  var cid = null;

  if (this.state == this.OPEN || options.force) {
    cid = this.emitObject(eventObject, options);
  }

  return cid;
};

SCTransport.prototype.cancelPendingResponse = function (cid) {
  delete this._callbackMap[cid];
};

SCTransport.prototype.decode = function (message) {
  return this.codec.decode(message);
};

SCTransport.prototype.encode = function (object) {
  return this.codec.encode(object);
};

SCTransport.prototype.send = function (data) {
  if (this.socket.readyState != this.socket.OPEN) {
    this._onClose(1005);
  } else {
    this.socket.send(data);
  }
};

SCTransport.prototype.serializeObject = function (object) {
  var str, formatError;

  try {
    str = this.encode(object);
  } catch (err) {
    formatError = err;

    this._onError(formatError);
  }

  if (!formatError) {
    return str;
  }

  return null;
};

SCTransport.prototype.sendObjectBatch = function (object) {
  var self = this;

  this._batchSendList.push(object);

  if (this._batchTimeout) {
    return;
  }

  this._batchTimeout = setTimeout(function () {
    delete self._batchTimeout;

    if (self._batchSendList.length) {
      var str = self.serializeObject(self._batchSendList);

      if (str != null) {
        self.send(str);
      }

      self._batchSendList = [];
    }
  }, this.options.pubSubBatchDuration || 0);
};

SCTransport.prototype.sendObjectSingle = function (object) {
  var str = this.serializeObject(object);

  if (str != null) {
    this.send(str);
  }
};

SCTransport.prototype.sendObject = function (object, options) {
  if (options && options.batch) {
    this.sendObjectBatch(object);
  } else {
    this.sendObjectSingle(object);
  }
};

module.exports.SCTransport = SCTransport;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/socketcluster-client/lib/ws-browser.js":
/*!*************************************************************!*\
  !*** ./node_modules/socketcluster-client/lib/ws-browser.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var global;

if (typeof WorkerGlobalScope !== 'undefined') {
  global = self;
} else {
  global = typeof window != 'undefined' && window || function () {
    return this;
  }();
}

var WebSocket = global.WebSocket || global.MozWebSocket;
/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object} opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;

  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }

  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;
module.exports = WebSocket ? ws : null;

/***/ }),

/***/ "./node_modules/socketcluster-client/node_modules/component-emitter/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/socketcluster-client/node_modules/component-emitter/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Expose `Emitter`.
 */
if (true) {
  module.exports = Emitter;
}
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */


function Emitter(obj) {
  if (obj) return mixin(obj);
}

;
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }

  return obj;
}
/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};
/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};
/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {}; // all

  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  } // specific event


  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this; // remove all handlers

  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  } // remove specific handler


  var cb;

  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];

    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  return this;
};
/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */


Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1),
      callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);

    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};
/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */


Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};
/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */


Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

/***/ }),

/***/ "./node_modules/socketcluster-client/node_modules/uuid/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/socketcluster-client/node_modules/uuid/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(/*! ./v1 */ "./node_modules/socketcluster-client/node_modules/uuid/v1.js");

var v4 = __webpack_require__(/*! ./v4 */ "./node_modules/socketcluster-client/node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
module.exports = uuid;

/***/ }),

/***/ "./node_modules/socketcluster-client/node_modules/uuid/lib/bytesToUuid.js":
/*!********************************************************************************!*\
  !*** ./node_modules/socketcluster-client/node_modules/uuid/lib/bytesToUuid.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;

/***/ }),

/***/ "./node_modules/socketcluster-client/node_modules/uuid/lib/rng-browser.js":
/*!********************************************************************************!*\
  !*** ./node_modules/socketcluster-client/node_modules/uuid/lib/rng-browser.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && msCrypto.getRandomValues.bind(msCrypto);

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

/***/ }),

/***/ "./node_modules/socketcluster-client/node_modules/uuid/v1.js":
/*!*******************************************************************!*\
  !*** ./node_modules/socketcluster-client/node_modules/uuid/v1.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/socketcluster-client/node_modules/uuid/lib/rng-browser.js");

var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/socketcluster-client/node_modules/uuid/lib/bytesToUuid.js"); // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html


var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/broofa/node-uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = rng();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;

/***/ }),

/***/ "./node_modules/socketcluster-client/node_modules/uuid/v4.js":
/*!*******************************************************************!*\
  !*** ./node_modules/socketcluster-client/node_modules/uuid/v4.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/socketcluster-client/node_modules/uuid/lib/rng-browser.js");

var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/socketcluster-client/node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }

  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js"); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ "./src/scripts/data/puzzle_01.js":
/*!***************************************!*\
  !*** ./src/scripts/data/puzzle_01.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shared_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/constants */ "./src/scripts/shared/constants.js");

/* harmony default export */ __webpack_exports__["default"] = ({
  id: 1,
  size: 9,
  difficulty: 'hard',
  operations: [_shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"], _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"], _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"], _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"]],
  cages: [{
    squares: [[0, 0], [1, 0]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 2
  }, {
    squares: [[0, 1], [1, 1]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 1
  }, {
    squares: [[0, 2], [1, 2]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 3
  }, {
    squares: [[0, 3], [1, 3]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 56
  }, {
    squares: [[0, 4], [0, 5]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 4
  }, {
    squares: [[0, 6], [1, 6]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 11
  }, {
    squares: [[0, 7], [0, 8]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 2
  }, {
    squares: [[1, 4], [2, 4]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 2
  }, {
    squares: [[1, 5], [2, 5]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 72
  }, {
    squares: [[2, 6], [3, 6]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 2
  }, {
    squares: [[1, 7], [2, 7], [3, 7]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 17
  }, {
    squares: [[1, 8], [2, 8]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 3
  }, {
    squares: [[2, 0], [2, 1]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 7
  }, {
    squares: [[2, 2], [2, 3]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 24
  }, {
    squares: [[3, 0], [4, 0]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 14
  }, {
    squares: [[3, 1], [4, 1]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 12
  }, {
    squares: [[3, 2], [3, 3]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 11
  }, {
    squares: [[3, 4], [3, 5]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 9
  }, {
    squares: [[3, 8], [4, 8]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 54
  }, {
    squares: [[4, 2], [5, 1], [5, 2]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 90
  }, {
    squares: [[4, 3], [4, 4]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 11
  }, {
    squares: [[4, 5], [5, 5]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 3
  }, {
    squares: [[4, 6], [4, 7], [5, 7]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 320
  }, {
    squares: [[5, 0], [6, 0], [6, 1]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 15
  }, {
    squares: [[5, 3], [5, 4], [6, 4]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 16
  }, {
    squares: [[5, 6], [6, 6]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 5
  }, {
    squares: [[5, 8], [6, 8]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 9
  }, {
    squares: [[6, 2], [6, 3]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 7
  }, {
    squares: [[6, 5], [7, 5]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 3
  }, {
    squares: [[6, 7], [7, 6], [7, 7], [7, 8]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 45
  }, {
    squares: [[7, 0], [8, 0]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 4
  }, {
    squares: [[7, 1], [7, 2]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 2
  }, {
    squares: [[7, 3], [7, 4]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 13
  }, {
    squares: [[8, 1], [8, 2]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 2
  }, {
    squares: [[8, 3], [8, 4]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 1
  }, {
    squares: [[8, 5], [8, 6]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 3
  }, {
    squares: [[8, 7], [8, 8]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 1
  }],
  solution: [[1, 7, 3, 8, 9, 5, 6, 2, 4], [2, 6, 9, 7, 3, 8, 5, 4, 1], [8, 1, 4, 6, 5, 9, 2, 7, 3], [5, 4, 8, 3, 2, 7, 1, 6, 9], [9, 3, 2, 4, 7, 1, 8, 5, 6], [6, 9, 5, 2, 1, 3, 4, 8, 7], [4, 5, 7, 1, 8, 6, 9, 3, 2], [7, 8, 6, 9, 4, 2, 3, 1, 5], [3, 2, 1, 5, 6, 4, 7, 9, 8]]
});

/***/ }),

/***/ "./src/scripts/data/puzzle_02.js":
/*!***************************************!*\
  !*** ./src/scripts/data/puzzle_02.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shared_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/constants */ "./src/scripts/shared/constants.js");

/* harmony default export */ __webpack_exports__["default"] = ({
  id: 2,
  size: 9,
  difficulty: 'hard',
  operations: [_shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"], _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"], _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"], _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"]],
  cages: [{
    squares: [[0, 0], [1, 0], [2, 0]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 15
  }, {
    squares: [[0, 1], [1, 1]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 2
  }, {
    squares: [[0, 2], [1, 2]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 2
  }, {
    squares: [[0, 3], [0, 4], [0, 5], [0, 6]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 25
  }, {
    squares: [[0, 7], [0, 8], [1, 8], [2, 8]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 320
  }, {
    squares: [[1, 3], [2, 3]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 11
  }, {
    squares: [[1, 4], [2, 4]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 5
  }, {
    squares: [[1, 5], [2, 5]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 1
  }, {
    squares: [[1, 6], [1, 7]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 3
  }, {
    squares: [[2, 1], [3, 1]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 45
  }, {
    squares: [[2, 2], [3, 2]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 42
  }, {
    squares: [[2, 6], [3, 6]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 2
  }, {
    squares: [[2, 7], [3, 7], [3, 8]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 14
  }, {
    squares: [[3, 0], [4, 0]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 14
  }, {
    squares: [[3, 3], [3, 4], [4, 4]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 80
  }, {
    squares: [[3, 5], [4, 5]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 5
  }, {
    squares: [[4, 1], [4, 2], [4, 3]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 12
  }, {
    squares: [[4, 6], [5, 6], [6, 6]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 14
  }, {
    squares: [[4, 7], [5, 7]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 45
  }, {
    squares: [[4, 8], [5, 8]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 2
  }, {
    squares: [[5, 0], [6, 0]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 2
  }, {
    squares: [[5, 1], [6, 1]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 13
  }, {
    squares: [[5, 2], [6, 2]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 1
  }, {
    squares: [[5, 3], [6, 3]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 1
  }, {
    squares: [[5, 4], [5, 5]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 14
  }, {
    squares: [[6, 4], [6, 5]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 6
  }, {
    squares: [[6, 7], [6, 8]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 5
  }, {
    squares: [[7, 0], [7, 1]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 11
  }, {
    squares: [[7, 2], [8, 2]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 3
  }, {
    squares: [[7, 3], [8, 3]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["MULTIPLY"],
    result: 28
  }, {
    squares: [[7, 4], [8, 4]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["DIVIDE"],
    result: 4
  }, {
    squares: [[7, 5], [8, 5]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ADD"],
    result: 11
  }, {
    squares: [[7, 6], [8, 6]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 3
  }, {
    squares: [[7, 7], [7, 8]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 1
  }, {
    squares: [[8, 0], [8, 1]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 5
  }, {
    squares: [[8, 7], [8, 8]],
    operation: _shared_constants__WEBPACK_IMPORTED_MODULE_0__["SUBTRACT"],
    result: 1
  }],
  solution: [[5, 4, 1, 3, 6, 7, 9, 2, 8], [1, 8, 2, 6, 3, 9, 4, 7, 5], [3, 9, 7, 5, 2, 8, 6, 1, 4], [7, 5, 6, 2, 8, 1, 3, 4, 9], [2, 3, 8, 1, 5, 4, 7, 9, 6], [8, 6, 4, 9, 7, 2, 1, 5, 3], [4, 7, 5, 8, 9, 3, 2, 6, 1], [9, 2, 3, 4, 1, 6, 5, 8, 7], [6, 1, 9, 7, 4, 5, 8, 3, 2]]
});

/***/ }),

/***/ "./src/scripts/data/puzzles.js":
/*!*************************************!*\
  !*** ./src/scripts/data/puzzles.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _puzzle_01_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./puzzle_01.js */ "./src/scripts/data/puzzle_01.js");
/* harmony import */ var _puzzle_02_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./puzzle_02.js */ "./src/scripts/data/puzzle_02.js");


/* harmony default export */ __webpack_exports__["default"] = ([_puzzle_01_js__WEBPACK_IMPORTED_MODULE_0__["default"], _puzzle_02_js__WEBPACK_IMPORTED_MODULE_1__["default"]]);

/***/ }),

/***/ "./src/scripts/dev.js":
/*!****************************!*\
  !*** ./src/scripts/dev.js ***!
  \****************************/
/*! exports provided: activateDevFlag, setupDev, devLog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "activateDevFlag", function() { return activateDevFlag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupDev", function() { return setupDev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "devLog", function() { return devLog; });
/* harmony import */ var remotedev__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! remotedev */ "./node_modules/remotedev/lib/index.js");
/* harmony import */ var remotedev__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(remotedev__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mobx-state-tree */ "./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js");
/* harmony import */ var mst_middlewares__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mst-middlewares */ "./node_modules/mst-middlewares/dist/mst-middlewares.module.js");
/* harmony import */ var _shared_lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/lru_cache */ "./src/scripts/shared/lru_cache.js");
/* harmony import */ var _shared_spotlight__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/spotlight */ "./src/scripts/shared/spotlight.js");






var devFlag = false;
var activateDevFlag = function activateDevFlag() {
  return devFlag = true;
};
var setupDev = function setupDev(game) {
  if (!devFlag) return;
  Object(mst_middlewares__WEBPACK_IMPORTED_MODULE_2__["connectReduxDevtools"])(remotedev__WEBPACK_IMPORTED_MODULE_0___default.a, game.gameStore);
  Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["unprotect"])(game.gameStore);
  setupPalette();
  window.gs = game.gameStore;
  window.lru = _shared_lru_cache__WEBPACK_IMPORTED_MODULE_3__["default"];
  window.getSnap = mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["getSnapshot"];
  window.applySnap = mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["applySnapshot"];
};
var devLog = function devLog() {
  var _console;

  if (!devFlag) return;

  (_console = console).log.apply(_console, arguments);
};

function setupPalette() {
  var COLORS = ['light-brick-1', 'light-brick-2', 'light-brick-3', 'light-brick-4', 'light-brick-5', 'light-brick-6', 'light-brick-7', 'brick-1', 'brick-2', 'violet-1', 'violet-2', 'violet-3', 'violet-4', 'light-ocean-1', 'light-ocean-2', 'light-ocean-2-transparent', 'light-ocean-2-semi-transparent', 'light-ocean-3', 'light-ocean-4', 'light-ocean-5', 'ocean-1', 'ocean-2', 'ocean-2-semi-translucent', 'grey-ocean-1', 'grey-ocean-2', 'grey-ocean-3', 'grey-ocean-4', 'grey-ocean-5', 'grey-ocean-6', 'green-1', 'green-1-transparent', 'green-2', 'green-3', 'green-4', 'cream-1', 'cream-2', 'cream-3', 'cream-4', 'cream-5', 'cream-6', 'cream-7', 'cream-8', 'cappuccino-1', 'cappuccino-2', 'cappuccino-3'];
  var togglePalette = document.createElement('button');
  togglePalette.innerText = 'Toggle Palette';
  var palette = document.createElement('section');
  palette.className = 'hidden';
  palette.id = 'color-palette';
  COLORS.forEach(function (color) {
    var colorDiv = document.createElement('div');
    colorDiv.className = "color-div ".concat(color);
    var colorLabel = document.createElement('span');
    colorLabel.className = "color-label";
    colorLabel.innerText = color;
    colorDiv.appendChild(colorLabel);
    palette.appendChild(colorDiv);
  });
  var testDiv = document.createElement('div');
  testDiv.className = "color-div brick-1";
  var colorLabel = document.createElement('span');
  colorLabel.className = "color-label";
  colorLabel.innerText = 'testDiv';
  testDiv.appendChild(colorLabel);
  palette.appendChild(testDiv);

  testDiv.onclick = function () {
    return testDiv.classList.toggle('test-color-div');
  };

  togglePalette.addEventListener('click', function () {
    palette.classList.toggle('hidden');
  });
  document.body.append(togglePalette, palette);
}

/***/ }),

/***/ "./src/scripts/index.js":
/*!******************************!*\
  !*** ./src/scripts/index.js ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles/index.scss */ "./src/styles/index.scss");
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_index_scss__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _setup_setup_env__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./setup/setup_env */ "./src/scripts/setup/setup_env.js");
/* harmony import */ var _setup_setup_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./setup/setup_dom */ "./src/scripts/setup/setup_dom.js");
/* harmony import */ var _setup_setup_game__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./setup/setup_game */ "./src/scripts/setup/setup_game.js");
/* harmony import */ var _dev__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dev */ "./src/scripts/dev.js");








if (true) {
  Object(_dev__WEBPACK_IMPORTED_MODULE_6__["activateDevFlag"])();
}

document.addEventListener('DOMContentLoaded', /*#__PURE__*/_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee() {
  var env, elements, gameStore;
  return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return Object(_setup_setup_env__WEBPACK_IMPORTED_MODULE_3__["getNewEnv"])();

        case 2:
          env = _context.sent;
          elements = Object(_setup_setup_dom__WEBPACK_IMPORTED_MODULE_4__["default"])(env);
          _context.next = 6;
          return Object(_setup_setup_game__WEBPACK_IMPORTED_MODULE_5__["default"])({
            env: env,
            elements: elements
          });

        case 6:
          gameStore = _context.sent;
          Object(_dev__WEBPACK_IMPORTED_MODULE_6__["setupDev"])({
            env: env,
            elements: elements,
            gameStore: gameStore
          });

        case 8:
        case "end":
          return _context.stop();
      }
    }
  }, _callee);
})));

/***/ }),

/***/ "./src/scripts/setup/listeners/click_listeners.js":
/*!********************************************************!*\
  !*** ./src/scripts/setup/listeners/click_listeners.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mountClickListeners; });
/* harmony import */ var _shared_dom_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/dom_util */ "./src/scripts/shared/dom_util.js");

function mountClickListeners(_ref) {
  var gameStore = _ref.gameStore,
      _ref$elements = _ref.elements,
      puzzleEle = _ref$elements.puzzleEle,
      infoEle = _ref$elements.infoEle;
  document.addEventListener('click', function (e) {
    if (!e.path.includes(puzzleEle) && !e.path.includes(infoEle)) {
      gameStore.clearFocus();
      gameStore.ui.clearSelectedSquares();
    }
  });
  puzzleEle.addEventListener('click', function (e) {
    var square = e.target.closest('.square');
    if (!square) return;
    var squareId = square.dataset.id;

    if (e.shiftKey) {
      gameStore.ui.selectThroughSquare(squareId);
    } else if (e.metaKey) {
      gameStore.ui.toggleSelectedSquare(squareId);
    } else {
      gameStore.selectSquareById(squareId);
    }
  });
}

/***/ }),

/***/ "./src/scripts/setup/listeners/keyboard_listeners.js":
/*!***********************************************************!*\
  !*** ./src/scripts/setup/listeners/keyboard_listeners.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mountKeyboardListeners; });
/* harmony import */ var _shared_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/constants */ "./src/scripts/shared/constants.js");
/* harmony import */ var _shared_general_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/general_util */ "./src/scripts/shared/general_util.js");


function mountKeyboardListeners(_ref) {
  var gameStore = _ref.gameStore;
  document.addEventListener('keydown', function (e) {
    if (!gameStore.ui.curSquare) return;
    Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_1__["stringSwitch"])(e.code, function (_ref2) {
      var _case = _ref2._case,
          _ensure = _ref2._ensure;

      _case(!e.metaKey, !e.ctrlKey, /^Alt/, function () {
        return gameStore.beginStaging();
      });

      _case(!e.altKey, e.ctrlKey, _shared_constants__WEBPACK_IMPORTED_MODULE_0__["NUM_REGEX"], function () {
        return gameStore.toggleFocusedSquarePossibility(Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_1__["getNumFromCode"])(e.code));
      });

      _case(!e.altKey, e.shiftKey, _shared_constants__WEBPACK_IMPORTED_MODULE_0__["NUM_REGEX"], function () {
        return gameStore.toggleFilterPossibility(Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_1__["getNumFromCode"])(e.code));
      });

      _case(!e.altKey, _shared_constants__WEBPACK_IMPORTED_MODULE_0__["NUM_REGEX"], function () {
        return gameStore.setFocusedSquare(Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_1__["getNumFromCode"])(e.code));
      });

      _case(e.altKey, _shared_constants__WEBPACK_IMPORTED_MODULE_0__["NUM_REGEX"], function () {
        return gameStore.toggleStagedPossibility(Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_1__["getNumFromCode"])(e.code));
      });

      _case(!e.altKey, !e.shiftKey, _shared_constants__WEBPACK_IMPORTED_MODULE_0__["ARROW_REGEX"], function () {
        return gameStore.selectSquareByDir(Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_1__["getDirFromCode"])(e.code));
      });

      _case(e.ctrlKey, ['Delete', 'Backspace'], function () {
        return gameStore.resetFocusedSquarePossibilities();
      });

      _case(e.shiftKey, ['Delete', 'Backspace'], function () {
        return gameStore.clearFilter();
      });

      _case(!e.altKey, ['Delete', 'Backspace'], function () {
        return gameStore.clearFocusedSquare();
      });

      _case(e.altKey, ['Delete', 'Backspace'], function () {
        return gameStore.clearStagedPossibilities();
      });

      _case(!e.altKey, e.shiftKey, _shared_constants__WEBPACK_IMPORTED_MODULE_0__["LEFT_OR_RIGHT_REGEX"], function () {
        return gameStore.ui.changeFilterModeByDir(Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_1__["getDirFromCode"])(e.code));
      });

      _case('KeyA', function () {
        return gameStore.ui.setFilterMode('and');
      });

      _case('KeyE', function () {
        return gameStore.ui.setFilterMode('not');
      });

      _case('KeyO', function () {
        return gameStore.ui.setFilterMode('or');
      });

      _ensure(function () {
        e.preventDefault();
      });
    });
  });
  document.addEventListener('keydown', function (e) {
    Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_1__["stringSwitch"])(e.code, function (_ref3) {
      var _case = _ref3._case,
          _ensure = _ref3._ensure;

      _case([e.metaKey, e.ctrlKey], 'KeyZ', function () {
        gameStore.undo();
      });

      _case([e.metaKey, e.ctrlKey], 'KeyY', function () {
        gameStore.redo();
      });

      _ensure(function () {
        e.preventDefault();
      });
    });
  });
  document.addEventListener('keyup', function (e) {
    if (e.key === 'Alt') {
      gameStore.stopStaging();
    }
  });
}

/***/ }),

/***/ "./src/scripts/setup/setup_dom.js":
/*!****************************************!*\
  !*** ./src/scripts/setup/setup_dom.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return setupDOM; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shared_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/constants */ "./src/scripts/shared/constants.js");
/* harmony import */ var _shared_general_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/general_util */ "./src/scripts/shared/general_util.js");
/* harmony import */ var _shared_dom_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/dom_util */ "./src/scripts/shared/dom_util.js");
/* harmony import */ var _views_header_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../views/header_view */ "./src/scripts/views/header_view.js");
/* harmony import */ var _views_options_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../views/options_view */ "./src/scripts/views/options_view.js");
/* harmony import */ var _views_info_collection_view__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../views/info_collection_view */ "./src/scripts/views/info_collection_view.js");
/* harmony import */ var _views_info_square_view__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../views/info_square_view */ "./src/scripts/views/info_square_view.js");
/* harmony import */ var _views_square_view__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../views/square_view */ "./src/scripts/views/square_view.js");
/* harmony import */ var _dev__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dev */ "./src/scripts/dev.js");










function setupDOM(_ref) {
  var globals = _ref.globals,
      templates = _ref.templates;
  setupOptions(templates);
  setupSquareTemplate(globals, templates);
  setupSquarePossibilities(globals, templates);
  setupFilterPossibilities(globals, templates);
  setupLabels(templates);
  setupIcons();
  setupLocalizations();
  return getElements();
}

function getElements() {
  return {
    puzzleEle: document.querySelector('.puzzle'),
    infoEle: document.querySelector('.info-box'),
    squareInfoEle: document.querySelector('.square-info'),
    collectionInfoEle: document.querySelector('.collection-info'),
    headerEle: document.querySelector('.header'),
    squareInfoEles: Object(_views_info_square_view__WEBPACK_IMPORTED_MODULE_7__["getSquareInfoElements"])(),
    collectionInfoEles: Object(_views_info_collection_view__WEBPACK_IMPORTED_MODULE_6__["getCollectionInfoElements"])(),
    headerEles: Object(_views_header_view__WEBPACK_IMPORTED_MODULE_4__["getHeaderElements"])(),
    optionsEles: Object(_views_options_view__WEBPACK_IMPORTED_MODULE_5__["getOptionsElements"])(),
    squareEle: _views_square_view__WEBPACK_IMPORTED_MODULE_8__["getSquareElement"],
    squareEles: _views_square_view__WEBPACK_IMPORTED_MODULE_8__["getSquareElementsFromId"]
  };
}

function setupIcons() {
  document.querySelectorAll('i').forEach(function (icon) {
    icon.className = _shared_constants__WEBPACK_IMPORTED_MODULE_1__["ICONS"][Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["kebabToCamel"])(icon.className)];
  });
}

function setupSquareTemplate(globals, templates) {
  var modelPossibility = templates.square.querySelector('.square_possibility');

  for (var i = 1; i <= globals.size; i++) {
    var possibility = modelPossibility.cloneNode(true);
    possibility.dataset.val = i;
    possibility.innerText = i;
    modelPossibility.before(possibility);
  }

  modelPossibility.remove();
}

function setupSquarePossibilities(globals, templates) {
  var squarePossibilities = new DocumentFragment();

  for (var i = 1; i <= globals.size; i++) {
    var possibility = templates.squareInfoPossibility.cloneNode(true);
    possibility.dataset.val = i;
    possibility.querySelector('.square-info_possibility-val').innerText = i;
    squarePossibilities.appendChild(possibility);
  }

  document.querySelector('.square-info').prepend(squarePossibilities);
}

function setupFilterPossibilities(globals, templates) {
  var filterPossibilities = new DocumentFragment();

  for (var i = 1; i <= globals.size; i++) {
    var possibility = templates.filterPossibility.cloneNode(true);
    possibility.dataset.val = i;
    possibility.querySelector('.filter-possibility_val').innerText = i;
    filterPossibilities.appendChild(possibility);
  }

  document.querySelector('.filter-possibilities').prepend(filterPossibilities);
}

function setupLocalizations() {
  var metaKey = window.navigator.platform.startsWith('Win') ? '⌃' : '⌘';
  document.querySelector('#header-undo .keyboard').innerText = "".concat(metaKey, "z");
  document.querySelector('#header-redo .keyboard').innerText = "".concat(metaKey, "y");
}

function setupLabels(templates) {
  document.querySelector('.info-box').prepend(createLabel(templates.infoLabel, {
    text: 'Square',
    id: 'square-label'
  }), createLabel(templates.infoLabel, {
    text: 'Cage',
    id: 'cage-label'
  }));
}

function createLabel(template, _ref2) {
  var text = _ref2.text,
      id = _ref2.id;
  var label = template.cloneNode(true);
  label.setAttribute('id', id);
  label.querySelector('text').textContent = text;
  return label;
}

function setupOptions(templates) {
  var _document$querySelect;

  var template = templates.option;
  var toggleTemplate = templates.optionToggle;
  var numTemplate = templates.optionNum;
  var optionsData = [{
    inputId: 'option-auto-block',
    inputTemplate: toggleTemplate,
    infoText: 'block contradictory moves',
    hoverText: "prevents you from entering a number that's eliminated as a possibility"
  }, {
    inputId: 'option-auto-elim',
    inputTemplate: toggleTemplate,
    infoText: 'auto-eliminate possibilities',
    hoverText: "when you enter a number, remove that number as a possibility from all the squares in the same row or column"
  }, {
    inputId: 'option-auto-elim-math-impossibilities',
    inputTemplate: toggleTemplate,
    infoText: 'auto-eliminate mathematical impossibilities',
    hoverText: "only certain combinations of numbers can mathematically appear in a cage; eliminate those that can't"
  }, {
    inputId: 'option-walkthrough',
    inputTemplate: toggleTemplate,
    infoText: 'always show walkthrough',
    hoverText: "always show the walkthrough upon refresh or revisiting this page"
  }, {
    inputId: 'option-max-possibilities',
    inputTemplate: numTemplate,
    infoText: 'max possibilities to display in square',
    hoverText: "don't display the possibilites in the square itself, unless you've narrowed it down to this number or less"
  }];
  var options = optionsData.map(function (data) {
    return createOption(template, data);
  });

  (_document$querySelect = document.querySelector('#header-options .header_dropdown')).append.apply(_document$querySelect, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(options));
}

function createOption(template, _ref3) {
  var infoText = _ref3.infoText,
      hoverText = _ref3.hoverText,
      inputTemplate = _ref3.inputTemplate,
      inputId = _ref3.inputId;
  var option = template.cloneNode(true);
  var input = inputTemplate.cloneNode(true);
  option.querySelector('.option_info-text').innerText = infoText;
  option.querySelector('.option_hover-text').innerText = hoverText;
  input.setAttribute('id', inputId);
  option.append(input);
  return option;
}

/***/ }),

/***/ "./src/scripts/setup/setup_env.js":
/*!****************************************!*\
  !*** ./src/scripts/setup/setup_env.js ***!
  \****************************************/
/*! exports provided: getNewEnv, resetEnv, getStaticEnv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNewEnv", function() { return getNewEnv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetEnv", function() { return resetEnv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStaticEnv", function() { return getStaticEnv; });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _shared_lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/lru_cache */ "./src/scripts/shared/lru_cache.js");
/* harmony import */ var _shared_dom_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/dom_util */ "./src/scripts/shared/dom_util.js");
/* harmony import */ var _data_puzzles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../data/puzzles */ "./src/scripts/data/puzzles.js");
/* harmony import */ var _views_header_view__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../views/header_view */ "./src/scripts/views/header_view.js");
/* harmony import */ var _views_options_view__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../views/options_view */ "./src/scripts/views/options_view.js");
/* harmony import */ var _views_info_collection_view__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../views/info_collection_view */ "./src/scripts/views/info_collection_view.js");
/* harmony import */ var _views_info_square_view__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../views/info_square_view */ "./src/scripts/views/info_square_view.js");
/* harmony import */ var _views_square_view__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../views/square_view */ "./src/scripts/views/square_view.js");
/* harmony import */ var _shared_general_util__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../shared/general_util */ "./src/scripts/shared/general_util.js");
/* harmony import */ var _shared_storage_util__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../shared/storage_util */ "./src/scripts/shared/storage_util.js");




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











function getNewEnv() {
  return _getNewEnv.apply(this, arguments);
}

function _getNewEnv() {
  _getNewEnv = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee() {
    var env, oldEnv;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            env = _objectSpread(_objectSpread({}, getStaticEnv()), getDefaultDynamicEnv());
            _context.prev = 1;
            _context.next = 4;
            return Object(_shared_storage_util__WEBPACK_IMPORTED_MODULE_12__["dbGet"])('env');

          case 4:
            oldEnv = _context.sent;
            console.log('here', oldEnv);
            return _context.abrupt("return", Object.assign(env, oldEnv));

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](1);
            console.log(_context.t0);
            return _context.abrupt("return", env);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 9]]);
  }));
  return _getNewEnv.apply(this, arguments);
}

function resetEnv(env) {
  return Object.assign(env, getDefaultDynamicEnv());
}
function getStaticEnv() {
  return {
    puzzles: _data_puzzles__WEBPACK_IMPORTED_MODULE_5__["default"],
    globals: {
      size: 9,
      mistakeTimeoutMs: 600
    },
    templates: {
      option: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('option-template'),
      optionToggle: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('option-toggle-template'),
      optionNum: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('option-num-template'),
      square: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('square-template'),
      combo: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('combo-template'),
      squareInfoPossibility: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('square-info_possibility-template'),
      filterPossibility: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('filter-possibility-template'),
      infoLabel: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('info-label-template'),
      spotlight: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('spotlight-template'),
      spotlightCaption: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('spotlight-caption-template'),
      puzzleCaptionContent: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('caption-content-puzzle-template'),
      cageCaptionContent: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('caption-content-cage-template'),
      infoCaptionContent: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('caption-content-info-template'),
      squareInfoCaptionContent: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('caption-content-square-info-template'),
      collectionInfoCaptionContent: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('caption-content-collection-info-template'),
      instructionsCaptionContent: Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_4__["getTemplateById"])('caption-content-instructions-template')
    }
  };
}

function getDefaultDynamicEnv() {
  return {
    snapshots: {},
    history: [],
    future: [],
    puzzleCache: new _shared_lru_cache__WEBPACK_IMPORTED_MODULE_3__["default"](50, 10 * 60 * 1000)
  };
}

/***/ }),

/***/ "./src/scripts/setup/setup_game.js":
/*!*****************************************!*\
  !*** ./src/scripts/setup/setup_game.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return setupGame; });
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _views_header_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../views/header_view */ "./src/scripts/views/header_view.js");
/* harmony import */ var _views_options_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../views/options_view */ "./src/scripts/views/options_view.js");
/* harmony import */ var _views_info_collection_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../views/info_collection_view */ "./src/scripts/views/info_collection_view.js");
/* harmony import */ var _views_info_square_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../views/info_square_view */ "./src/scripts/views/info_square_view.js");
/* harmony import */ var _listeners_keyboard_listeners__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./listeners/keyboard_listeners */ "./src/scripts/setup/listeners/keyboard_listeners.js");
/* harmony import */ var _listeners_click_listeners__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./listeners/click_listeners */ "./src/scripts/setup/listeners/click_listeners.js");
/* harmony import */ var _setup_puzzle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./setup_puzzle */ "./src/scripts/setup/setup_puzzle.js");
/* harmony import */ var _walkthrough__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./walkthrough */ "./src/scripts/setup/walkthrough.js");
/* harmony import */ var mobx_state_tree__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! mobx-state-tree */ "./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js");
/* harmony import */ var _store_game__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../store/game */ "./src/scripts/store/game.js");











 // const RESTORE_FLAG = window.localStorage.getItem('restoreFlag')

var RESTORE_FLAG = true;
function setupGame(_x) {
  return _setupGame.apply(this, arguments);
}

function _setupGame() {
  _setupGame = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee(_ref) {
    var env, elements, gameStore, game;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            env = _ref.env, elements = _ref.elements;
            _context.next = 3;
            return createGameStore(env);

          case 3:
            gameStore = _context.sent;
            game = {
              gameStore: gameStore,
              env: env,
              elements: elements
            };
            Object(_views_options_view__WEBPACK_IMPORTED_MODULE_3__["setupOptions"])(game);
            Object(_views_info_square_view__WEBPACK_IMPORTED_MODULE_5__["setupSquareInfo"])(game);
            Object(_views_info_collection_view__WEBPACK_IMPORTED_MODULE_4__["setupCollectionInfo"])(game);
            Object(_setup_puzzle__WEBPACK_IMPORTED_MODULE_8__["setupPuzzle"])(game);

            if (!(gameStore.storedSnapshot && gameStore.options.walkthrough)) {
              _context.next = 12;
              break;
            }

            _context.next = 12;
            return Object(_walkthrough__WEBPACK_IMPORTED_MODULE_9__["default"])(game);

          case 12:
            Object(_views_header_view__WEBPACK_IMPORTED_MODULE_2__["setupHeader"])(game);
            Object(_listeners_click_listeners__WEBPACK_IMPORTED_MODULE_7__["default"])(game);
            Object(_listeners_keyboard_listeners__WEBPACK_IMPORTED_MODULE_6__["default"])(game);

            if (!RESTORE_FLAG) {
              _context.next = 18;
              break;
            }

            _context.next = 18;
            return gameStore.applyStoredSnapshot();

          case 18:
            gameStore.attachHooks();
            return _context.abrupt("return", gameStore);

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _setupGame.apply(this, arguments);
}

function createGameStore(_x2) {
  return _createGameStore.apply(this, arguments);
}

function _createGameStore() {
  _createGameStore = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0___default()( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee2(env) {
    var gameStore;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            gameStore = _store_game__WEBPACK_IMPORTED_MODULE_11__["default"].create({}, env);

            if (!RESTORE_FLAG) {
              _context2.next = 6;
              break;
            }

            _context2.next = 4;
            return gameStore.resetToStoredSnapshot();

          case 4:
            _context2.next = 7;
            break;

          case 6:
            gameStore.initialize();

          case 7:
            return _context2.abrupt("return", gameStore);

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _createGameStore.apply(this, arguments);
}

/***/ }),

/***/ "./src/scripts/setup/setup_puzzle.js":
/*!*******************************************!*\
  !*** ./src/scripts/setup/setup_puzzle.js ***!
  \*******************************************/
/*! exports provided: newPuzzle, setupPuzzle, resetPuzzle, restorePuzzle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newPuzzle", function() { return newPuzzle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupPuzzle", function() { return setupPuzzle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetPuzzle", function() { return resetPuzzle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "restorePuzzle", function() { return restorePuzzle; });
/* harmony import */ var _setup_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setup_env */ "./src/scripts/setup/setup_env.js");
/* harmony import */ var _views_square_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../views/square_view */ "./src/scripts/views/square_view.js");


var disposerFunc;
function newPuzzle(game) {
  var _disposerFunc;

  (_disposerFunc = disposerFunc) === null || _disposerFunc === void 0 ? void 0 : _disposerFunc();
  game.gameStore.newPuzzle();
  Object(_setup_env__WEBPACK_IMPORTED_MODULE_0__["resetEnv"])(game.env);
  disposerFunc = Object(_views_square_view__WEBPACK_IMPORTED_MODULE_1__["setupSquares"])(game);
}
function setupPuzzle(game) {
  disposerFunc = Object(_views_square_view__WEBPACK_IMPORTED_MODULE_1__["setupSquares"])(game);
}
function resetPuzzle(game) {
  game.gameStore.resetPuzzle();
  Object(_setup_env__WEBPACK_IMPORTED_MODULE_0__["resetEnv"])(game.env);
}
function restorePuzzle(game) {
  var _disposerFunc2;

  (_disposerFunc2 = disposerFunc) === null || _disposerFunc2 === void 0 ? void 0 : _disposerFunc2();
  disposerFunc = Object(_views_square_view__WEBPACK_IMPORTED_MODULE_1__["setupSquares"])(game);
}

/***/ }),

/***/ "./src/scripts/setup/walkthrough.js":
/*!******************************************!*\
  !*** ./src/scripts/setup/walkthrough.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shared_dom_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/dom_util */ "./src/scripts/shared/dom_util.js");
/* harmony import */ var _shared_general_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/general_util */ "./src/scripts/shared/general_util.js");
/* harmony import */ var _shared_spotlight__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/spotlight */ "./src/scripts/shared/spotlight.js");




/* harmony default export */ __webpack_exports__["default"] = (function (_ref) {
  var gameStore = _ref.gameStore,
      env = _ref.env,
      elements = _ref.elements;
  var caption = env.templates.spotlightCaption.cloneNode(true);
  var svg = env.templates.spotlight.cloneNode(true);

  var cleanup = function cleanup() {};

  var steps = getSpotlights({
    gameStore: gameStore,
    env: env,
    elements: elements
  }).map(function (spotlight) {
    return function () {
      cleanup();

      var update = function update() {
        spotlight.updateSVG({
          element: svg,
          regenerate: true
        });
        spotlight.updateCaption({
          element: caption,
          regenerate: false
        });
      };

      if (spotlight.captionContent) {
        var _caption$querySelecto;

        (_caption$querySelecto = caption.querySelector('.caption-content')) === null || _caption$querySelecto === void 0 ? void 0 : _caption$querySelecto.remove();
        caption.prepend(spotlight.captionContent);
      }

      var cleanupShow = spotlight.onShow();
      window.addEventListener('resize', update);

      cleanup = function cleanup() {
        window.removeEventListener('resize', update);
        cleanupShow();
      }; // debugger


      update();
      appendIfRemoved(svg, caption);
    };
  });
  return new Promise(function (resolve) {
    var finish = function finish() {
      cleanup();
      svg.remove();
      caption.remove();
      document.removeEventListener('keydown', handleKeydown, true);
      resolve();
    };

    steps.push(finish);

    var _getCaptionElements = getCaptionElements(caption),
        nextBtn = _getCaptionElements.nextBtn,
        previousBtn = _getCaptionElements.previousBtn,
        finishBtn = _getCaptionElements.finishBtn;

    var curStep = 0;

    var next = function next() {
      return steps[++curStep]();
    };

    var prev = function prev() {
      if (curStep > 0) steps[--curStep]();
    };

    Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_1__["addNoFocusClickListener"])(nextBtn, next);
    Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_1__["addNoFocusClickListener"])(previousBtn, prev);
    Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_1__["addNoFocusClickListener"])(finishBtn, finish);

    function handleKeydown(e) {
      Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["stringSwitch"])(e.code, function (_ref2) {
        var _case = _ref2._case;

        _case('KeyN', next);

        _case('KeyP', prev);

        _case('KeyF', finish); // e.stopImmediatePropagation()

      });
    }

    document.addEventListener('keydown', handleKeydown, true);
    steps[curStep]();
  });
});

function getSpotlights(_ref3) {
  var gameStore = _ref3.gameStore,
      _ref3$env$templates = _ref3.env.templates,
      puzzleCaptionContent = _ref3$env$templates.puzzleCaptionContent,
      infoCaptionContent = _ref3$env$templates.infoCaptionContent,
      squareInfoCaptionContent = _ref3$env$templates.squareInfoCaptionContent,
      collectionInfoCaptionContent = _ref3$env$templates.collectionInfoCaptionContent,
      instructionsCaptionContent = _ref3$env$templates.instructionsCaptionContent,
      _ref3$elements = _ref3.elements,
      puzzleEle = _ref3$elements.puzzleEle,
      infoEle = _ref3$elements.infoEle,
      squareInfoEle = _ref3$elements.squareInfoEle,
      collectionInfoEle = _ref3$elements.collectionInfoEle,
      _ref3$elements$header = _ref3$elements.headerEles,
      instructionsButton = _ref3$elements$header.instructionsButton,
      instructionsDropdown = _ref3$elements$header.instructionsDropdown;
  var cageSquares = getCageSquares(gameStore);
  var squareEle = cageSquares[0];
  return [_shared_spotlight__WEBPACK_IMPORTED_MODULE_3__["default"].fromEle(puzzleEle, {
    padding: 5,
    borderRadius: 8,
    captionContent: puzzleCaptionContent.cloneNode(true)
  }), _shared_spotlight__WEBPACK_IMPORTED_MODULE_3__["default"].fromEle(infoEle, {
    padding: {
      default: 6,
      left: 8
    },
    borderRadius: 8,
    blur: 1.5,
    captionPosition: 'left',
    captionOffsetX: '-10px',
    captionOffsetY: '50px',
    captionContent: infoCaptionContent.cloneNode(true)
  }), _shared_spotlight__WEBPACK_IMPORTED_MODULE_3__["default"].fromEles([squareEle, squareInfoEle], {
    padding: [0, {
      default: 0,
      top: -10,
      bottom: -20
    }],
    borderRadius: 2,
    blur: 1,
    captionPosition: 'bottom',
    captionContent: squareInfoCaptionContent.cloneNode(true),
    onShow: function onShow() {
      gameStore.selectSquareById(squareEle.dataset.id);
      return function () {
        gameStore.clearFocus();
        gameStore.ui.clearSelectedSquares();
      };
    }
  }), _shared_spotlight__WEBPACK_IMPORTED_MODULE_3__["default"].fromEles([].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(cageSquares), [collectionInfoEle]), {
    padding: [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(Array(cageSquares.length).fill(0.5)), [{
      // default: 0,
      top: 26,
      bottom: -10
    }]),
    borderRadius: 2,
    blur: 1,
    captionPosition: 'bottom',
    captionContent: collectionInfoCaptionContent.cloneNode(true),
    onShow: function onShow() {
      gameStore.selectSquareById(squareEle.dataset.id);
      return function () {
        gameStore.clearFocus();
        gameStore.ui.clearSelectedSquares();
      };
    }
  }), _shared_spotlight__WEBPACK_IMPORTED_MODULE_3__["default"].fromEles([instructionsButton, instructionsDropdown], {
    padding: [{
      right: 7,
      bottom: 7,
      default: 4
    }, {
      default: 6,
      top: 4
    }],
    borderRadius: 8,
    blur: 2,
    captionPosition: 'right',
    captionContent: instructionsCaptionContent.cloneNode(true),
    onShow: function onShow() {
      instructionsDropdown.classList.add('show');
      return function () {
        return instructionsDropdown.classList.remove('show');
      };
    }
  })];
}

function getCaptionElements(captionEle) {
  return {
    nextBtn: captionEle.querySelector('#spotlight-next'),
    previousBtn: captionEle.querySelector('#spotlight-previous'),
    finishBtn: captionEle.querySelector('#spotlight-finish')
  };
}

function getCageSquares(gameStore) {
  var cornerCage = gameStore.puzzle.cagesArray.find(function (cage) {
    return cage.numPossibleRepeats > 0;
  });
  return Array.from(cornerCage.squares.map(function (square) {
    return document.querySelector(".square[data-id=\"".concat(square.id, "\"]"));
  }));
}

function createSVG() {
  return Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_1__["getTemplateById"])('spotlight-template').cloneNode(true);
}

function appendIfRemoved() {
  var _document$body;

  for (var _len = arguments.length, eles = new Array(_len), _key = 0; _key < _len; _key++) {
    eles[_key] = arguments[_key];
  }

  var removedEles = eles.filter(function (ele) {
    return !document.body.contains(ele);
  });

  (_document$body = document.body).append.apply(_document$body, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(removedEles));
}

/***/ }),

/***/ "./src/scripts/shared/constants.js":
/*!*****************************************!*\
  !*** ./src/scripts/shared/constants.js ***!
  \*****************************************/
/*! exports provided: ADD, SUBTRACT, MULTIPLY, DIVIDE, ARROW_REGEX, UP_OR_DOWN_REGEX, LEFT_OR_RIGHT_REGEX, NUM_REGEX, ICONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ADD", function() { return ADD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SUBTRACT", function() { return SUBTRACT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MULTIPLY", function() { return MULTIPLY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIVIDE", function() { return DIVIDE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARROW_REGEX", function() { return ARROW_REGEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UP_OR_DOWN_REGEX", function() { return UP_OR_DOWN_REGEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LEFT_OR_RIGHT_REGEX", function() { return LEFT_OR_RIGHT_REGEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NUM_REGEX", function() { return NUM_REGEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ICONS", function() { return ICONS; });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ "./node_modules/@babel/runtime/helpers/wrapNativeSuper.js");
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4__);






function _wrapRegExp(re, groups) { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _RegExp = _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4___default()(RegExp); var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = _RegExp.call(this, re, flags); _groups.set(_this, groups || _groups.get(re)); return _this; } _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(BabelRegExp, _RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = []; args.push.apply(args, arguments); if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(args[args.length - 1]) !== "object") { args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }

var ADD = '+';
var SUBTRACT = '−';
var MULTIPLY = '⨉';
var DIVIDE = '÷';
var ARROW_REGEX = /*#__PURE__*/_wrapRegExp(/^Arrow(.*)/, {
  dir: 1
});
var UP_OR_DOWN_REGEX = /*#__PURE__*/_wrapRegExp(/^Arrow(Up|Down)/, {
  dir: 1
});
var LEFT_OR_RIGHT_REGEX = /*#__PURE__*/_wrapRegExp(/^Arrow(Left|Right)/, {
  dir: 1
});
var NUM_REGEX = /*#__PURE__*/_wrapRegExp(/^(Digit|Numpad)([0-9])/, {
  num: 2
});
var ICONS = {
  info: 'fas fa-info-circle',
  ban: 'fas fa-ban',
  circle: 'far fa-circle',
  circleFilled: 'fas fa-circle',
  square: 'far fa-square',
  slash: 'fas fa-slash',
  clear: 'fas fa-eraser',
  reset: 'fas fa-undo-alt',
  select: 'far fa-check-circle',
  confirm: 'fas fa-check-circle'
};

/***/ }),

/***/ "./src/scripts/shared/dom_partials.js":
/*!********************************************!*\
  !*** ./src/scripts/shared/dom_partials.js ***!
  \********************************************/
/*! exports provided: baseIcons, eliminatedIcons, alternativeIcons, requiredIcons */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "baseIcons", function() { return baseIcons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eliminatedIcons", function() { return eliminatedIcons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alternativeIcons", function() { return alternativeIcons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "requiredIcons", function() { return requiredIcons; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./src/scripts/shared/constants.js");
/* harmony import */ var _general_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./general_util */ "./src/scripts/shared/general_util.js");



var createBasicIcon = function createBasicIcon(iconName) {
  var icon = document.createElement('i');
  icon.className = _constants__WEBPACK_IMPORTED_MODULE_0__["ICONS"][iconName];
  return icon;
};

var createIcon = function createIcon(iconName) {
  var iconSpan = document.createElement('span');
  iconSpan.appendChild(createBasicIcon(iconName));

  for (var _len = arguments.length, flags = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    flags[_key - 1] = arguments[_key];
  }

  iconSpan.className = Object(_general_util__WEBPACK_IMPORTED_MODULE_1__["generateClassName"])('possibility-icon', flags);
  return iconSpan;
};

var baseIcons = function baseIcons() {
  return [createIcon('square')];
};
var eliminatedIcons = function eliminatedIcons() {
  return [createIcon('square', 'eliminated'), createIcon('slash', 'small')];
};
var alternativeIcons = function alternativeIcons() {
  return [createIcon('square', 'alternative'), createIcon('square', 'alternative-inner')];
};
var requiredIcons = function requiredIcons() {
  return [createIcon('square', 'required')];
};

/***/ }),

/***/ "./src/scripts/shared/dom_util.js":
/*!****************************************!*\
  !*** ./src/scripts/shared/dom_util.js ***!
  \****************************************/
/*! exports provided: extractPosFromSquare, mountDropdown, addNoFocusClickListener, getTemplateNode, getTemplateById, isEquivalentNode, haveEquivalentChildren, updateChildrenToMatch, generateHighlightFuncs, createSVGElement, applyStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractPosFromSquare", function() { return extractPosFromSquare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mountDropdown", function() { return mountDropdown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addNoFocusClickListener", function() { return addNoFocusClickListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTemplateNode", function() { return getTemplateNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTemplateById", function() { return getTemplateById; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEquivalentNode", function() { return isEquivalentNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "haveEquivalentChildren", function() { return haveEquivalentChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateChildrenToMatch", function() { return updateChildrenToMatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateHighlightFuncs", function() { return generateHighlightFuncs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSVGElement", function() { return createSVGElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyStyle", function() { return applyStyle; });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _general_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./general_util */ "./src/scripts/shared/general_util.js");




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }


var extractPosFromSquare = function extractPosFromSquare(square) {
  return square === null || square === void 0 ? void 0 : square.dataset.pos.split(',');
};
var mountDropdown = function mountDropdown(button, dropdown, showClass) {
  document.addEventListener('click', function (e) {
    var outsideDropdown = !dropdown.contains(e.target);
    var onButton = outsideDropdown && button.contains(e.target);
    var isShowing = dropdown.classList.contains(showClass);

    if (isShowing && outsideDropdown || !isShowing && onButton) {
      if (isShowing) button.blur();
      dropdown.classList.toggle(showClass);
    }
  });
};
var addNoFocusClickListener = function addNoFocusClickListener(element, listener) {
  return element.addEventListener('mousedown', function (e) {
    e.preventDefault();
    listener(e);
  });
};
var getTemplateNode = function getTemplateNode(template) {
  var firstChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return firstChild ? template.content.firstElementChild : template.content;
};
var getTemplateById = function getTemplateById(id) {
  var firstChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return getTemplateNode(document.getElementById(id), firstChild);
};
function isEquivalentNode(nodeA, nodeB) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return nodeA.nodeName === nodeB.nodeName && haveEquivalentAttributes(nodeA, nodeB, options) && haveEquivalentChildren(nodeA, nodeB, options);
}
function haveEquivalentChildren(nodeOrListA, nodeOrListB) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var childrenA = nodeOrListA instanceof Node ? Array.from(nodeOrListA.childNodes) : nodeOrListA;
  var childrenB = nodeOrListB instanceof Node ? Array.from(nodeOrListB.childNodes) : nodeOrListB;

  if (childrenA.length !== childrenB.length) {
    return false;
  } else if (childrenA.length === 0) {
    return true;
  } else {
    for (var i = 0; i < childrenA.length; i++) {
      var childA = childrenA[i];
      var childB = childrenB[i];

      if (!isEquivalentNode(childA, childB, options)) {
        return false;
      }
    }

    return true;
  }
}

function haveEquivalentAttributes(nodeA, nodeB) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var attributesA = nodeA.getAttributeNames();
  var attributesB = nodeB.getAttributeNames();

  if (options.attributes) {
    attributesA = attributesA.filter(function (attr) {
      return options.attributes.includes(attr);
    });
    attributesB = attributesB.filter(function (attr) {
      return options.attributes.includes(attr);
    });
  }

  if (attributesA.length !== attributesB.length) {
    return false;
  }

  return attributesA.every(function (attr) {
    return nodeA.getAttribute(attr) === nodeB.getAttribute(attr);
  });
}

function updateChildrenToMatch(nodeA, nodeOrListB, comparator) {
  var childrenB = nodeOrListB instanceof Node ? Array.from(nodeOrListB.children) : nodeOrListB;
  var getNextAChild = Object(_general_util__WEBPACK_IMPORTED_MODULE_3__["genStepper"])(Array.from(nodeA.children));
  var getNextBChild = Object(_general_util__WEBPACK_IMPORTED_MODULE_3__["genStepper"])(childrenB);
  var childA = getNextAChild();
  var childB = getNextBChild();

  while (typeof childA !== 'undefined' || typeof childB !== 'undefined') {
    if (typeof childA === 'undefined') {
      nodeA.append(childB);
      childB = getNextBChild();
    } else if (typeof childB === 'undefined') {
      childA.remove();
      childA = getNextAChild();
    } else {
      switch (comparator(childA, childB)) {
        case -1:
          childA.remove();
          childA = getNextAChild();
          break;

        case 0:
          updateAttributesToMatch(childA, childB);
          childA = getNextAChild();
          childB = getNextBChild();
          break;

        case 1:
          nodeA.insertBefore(childB.cloneNode(true), childA);
          childB = getNextBChild();
          break;
      }
    }
  }
}

function updateAttributesToMatch(nodeA, nodeB) {
  nodeA.getAttributeNames().forEach(function (attr) {
    var _map = [nodeA, nodeB].map(function (node) {
      return node.getAttribute(attr);
    }),
        _map2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_map, 2),
        valA = _map2[0],
        valB = _map2[1];

    if (valA !== valB) nodeA.setAttribute(attr, valB);
  });
} // function _highlightEle(ele, {
//   padding = 0,
//   paddingLeft,
//   paddingRight,
//   paddingTop,
//   paddingBottom,
//   captionTemplate = null,
//   captionAnchor = [1, 0],
//   centerCaption = true,
//   fuzzy = true,
//   top,
//   left,
//   right,
//   bottom,
// } = {}) {
//   paddingLeft = paddingLeft || padding
//   paddingRight = paddingRight || padding
//   paddingTop = paddingTop || padding
//   paddingBottom = paddingBottom || padding
//   const {
//     top: eleTop,
//     right: eleRight,
//     left: eleLeft,
//     bottom: eleBottom,
//     height: eleHeight,
//     width: eleWidth,
//   } = ele.getBoundingClientRect()
//   const paddedTop = toPixels(eleTop - paddingTop)
//   const paddedRight = toPixels(eleRight + paddingRight)
//   const paddedBottom = toPixels(eleBottom + paddingBottom)
//   const paddedLeft = toPixels(eleLeft - paddingLeft)
//   const paddedHeight = toPixels(eleHeight + paddingTop + paddingBottom)
//   const paddedWidth = toPixels(eleWidth + paddingLeft + paddingRight)
//   const above = {
//     top: 0,
//     left: 0,
//     right: 0,
//     height: paddedTop,
//   }
//   const below = {
//     top: paddedBottom,
//     left: 0,
//     right: 0,
//     bottom: 0,
//   }
//   const toLeft = {
//     top: paddedTop,
//     height: paddedHeight,
//     left: 0,
//     width: paddedLeft,
//   }
//   const toRight = {
//     top: paddedTop,
//     height: paddedHeight,
//     right: 0,
//     left: paddedRight,
//   }
//   const [
//     aboveEle,
//     belowEle,
//     toLeftEle,
//     toRightEle,
//   ] = [above, below, toLeft, toRight].map(style => {
//     const ele = document.createElement('div')
//     ele.className = 'dim'
//     Object.entries(style).forEach(([prop, val]) => {
//       ele.style[prop] = val
//     })
//     document.body.append(ele)
//     return ele
//   })
//   let fuzzyEle
//   if (fuzzy) {
//     fuzzyEle = document.createElement('div')
//     fuzzyEle.className = 'highlight-shadow'
//     fuzzyEle.style.top = paddedTop
//     fuzzyEle.style.left = paddedLeft
//     fuzzyEle.style.height = paddedHeight
//     fuzzyEle.style.width = paddedWidth
//     document.body.append(fuzzyEle)
//   }
//   const removeEles = () => [
//     aboveEle,
//     belowEle,
//     toLeftEle,
//     toRightEle,
//     fuzzyEle,
//   ].forEach(ele => ele && ele.remove())
//   if (captionTemplate && captionAnchor) {
//     try {
//       const [anchor, style, dataShift] = prepareCaptionEle({
//         aboveEle,
//         belowEle,
//         toLeftEle,
//         toRightEle,
//         captionAnchor,
//         top,
//         right,
//         bottom,
//         left,
//         midX: toPixels(eleRight - (eleWidth / 2))
//       })
//       const captionEle = captionTemplate.cloneNode(true)
//       Object.entries(style).forEach(([prop, val]) => {
//         if (val !== undefined) captionEle.style[prop] = val
//       })
//       if (centerCaption) captionEle.classList.add('caption')
//       if (dataShift) captionEle.dataset.shift = dataShift
//       anchor.append(captionEle)
//     } catch (e) {
//       removeEles()
//       throw e
//     }
//   }
//   return removeEles
// }
// function _prepareCaptionEle({
//   aboveEle,
//   belowEle,
//   toLeftEle,
//   toRightEle,
//   captionAnchor,
//   top,
//   right,
//   bottom,
//   left,
//   midX
// }) {
//   const anchorMap = {
//     top: [0, -1],
//     topRight: [1, -1],
//     right: [1, 0],
//     bottomRight: [1, 1],
//     bottom: [0, 1],
//     bottomLeft: [-1, 1],
//     left: [-1, 0],
//     topLeft: [-1, -1],
//   }
//   if (typeof captionAnchor === 'string') {
//     captionAnchor = anchorMap[captionAnchor]
//   }
//   if (!(captionAnchor instanceof Array)) {
//     throw new Error('captionAnchor must be an ordered pair array or valid string')
//   }
//   const [anchor, {
//     top: defaultTop,
//     right: defaultRight,
//     bottom: defaultBottom,
//     left: defaultLeft,
//   }, dataShift] = funcSwitch(captionAnchor, areEqualArrays, ({ _case }) => {
//     _case([[0, -1]], () => [aboveEle, { bottom: 0, left: midX }, 'left'])
//     _case([[1, -1]], () => [toRightEle, { bottom: '100%', left: 0 }])
//     _case([[1, 0]], () => [toRightEle, { top: '50%', left: 0 }, 'up'])
//     _case([[1, 1]], () => [toRightEle, { top: '100%', left: 0 }])
//     _case([[0, 1]], () => [belowEle, { top: 0, left: midX }, 'left'])
//     _case([[-1, 1]], () => [toLeftEle, { top: '100%', right: 0 }])
//     _case([[-1, 0]], () => [toLeftEle, { top: '50%', right: 0 }, 'up'])
//     _case([[-1, -1]], () => [toLeftEle, { bottom: '100%', right: 0 }])
//   })
//   return [anchor, {
//     top: mergeProp(defaultTop, top),
//     right: mergeProp(defaultRight, right),
//     bottom: mergeProp(defaultBottom, bottom),
//     left: mergeProp(defaultLeft, left),
//   }, dataShift]
// }


var generateHighlightFuncs = function generateHighlightFuncs() {
  for (var _len = arguments.length, eles = new Array(_len), _key = 0; _key < _len; _key++) {
    eles[_key] = arguments[_key];
  }

  var unhighlight = null;
  return [function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!unhighlight) {
      unhighlight = highlightEles.apply(void 0, eles.concat([options]));
    }
  }, function () {
    if (unhighlight) {
      unhighlight();
      unhighlight = null;
    }
  }];
};

function highlightEles() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  // parse args
  var lastArg = args[args.length - 1];
  var eles = lastArg instanceof Node ? args : args.slice(0, -1);

  var _ref = lastArg instanceof Node ? {} : lastArg,
      _ref$padding = _ref.padding,
      padding = _ref$padding === void 0 ? 0 : _ref$padding,
      paddingTop = _ref.paddingTop,
      paddingRight = _ref.paddingRight,
      paddingBottom = _ref.paddingBottom,
      paddingLeft = _ref.paddingLeft,
      _ref$captionTemplate = _ref.captionTemplate,
      captionTemplate = _ref$captionTemplate === void 0 ? null : _ref$captionTemplate,
      _ref$captionPos = _ref.captionPos,
      captionPos = _ref$captionPos === void 0 ? 'right' : _ref$captionPos,
      captionAttrs = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1___default()(_ref, ["padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "captionTemplate", "captionPos"]); // create highlight wrappers to frame highlighted eles


  var _getPositionStyles = getPositionStyles(eles, {
    paddingTop: paddingTop || padding,
    paddingRight: paddingRight || padding,
    paddingBottom: paddingBottom || padding,
    paddingLeft: paddingLeft || padding
  }),
      _getPositionStyles2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_getPositionStyles, 2),
      wrapperStyles = _getPositionStyles2[0],
      outerWrapperStyle = _getPositionStyles2[1];

  var wrappers = wrapperStyles.map(function (style) {
    var wrapper = generateDivWithStyle(style);
    wrapper.className = Object(_general_util__WEBPACK_IMPORTED_MODULE_3__["generateClassName"])('highlight-wrapper', [[eles.length === 1, 'fuzzy']]);
    document.body.append(wrapper);
    return wrapper;
  }); // if multiple highlight elements, create outer wrapper to anchor caption to

  var outerWrapper = wrappers[0];

  if (wrappers.length > 1) {
    outerWrapper = generateDivWithStyle(outerWrapperStyle);
    outerWrapper.className = 'highlight-outer-wrapper';
    document.body.append(outerWrapper);
  } // create background dimming element


  var dimEle = document.createElement('div');
  dimEle.className = 'dim dim--full';
  document.body.append(dimEle); // lift highlighted eles above highlight wrappers

  eles.forEach(function (ele) {
    ele.style.zIndex = 8;
    var elePosition = getComputedStyle(ele).getPropertyValue('position');
    if (elePosition === 'static') ele.style.position = 'relative';
  }); // cleanup all DOM mutations

  var cleanup = function cleanup() {
    wrappers.forEach(function (wrapper) {
      return wrapper.remove();
    });
    dimEle.remove();
    outerWrapper.remove();
    eles.forEach(function (ele) {
      ele.style.zIndex = null;
      ele.style.position = null;
    });
  }; // if caption provided, prepare and attach


  if (captionTemplate && captionAnchor) {
    try {
      var _prepareCaptionEle = prepareCaptionEle(_objectSpread({
        captionAnchor: captionAnchor
      }, attrs)),
          _prepareCaptionEle2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_prepareCaptionEle, 2),
          style = _prepareCaptionEle2[0],
          shift = _prepareCaptionEle2[1];

      var captionEle = captionTemplate.cloneNode(true);
      Object.entries(style).forEach(function (_ref2) {
        var _ref3 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref2, 2),
            prop = _ref3[0],
            val = _ref3[1];

        if (val !== undefined) captionEle.style[prop] = val;
      });
      if (centerCaption && shift) captionEle.dataset.shift = shift;
      captionEle.classList.add('caption');
      outerWrapper.append(captionEle);
    } catch (e) {
      cleanup();
      throw e;
    }
  }

  return cleanup;
}

function prepareCaptionEle(_ref4) {
  var captionAnchor = _ref4.captionAnchor,
      top = _ref4.top,
      right = _ref4.right,
      bottom = _ref4.bottom,
      left = _ref4.left;

  var _stringSwitch = Object(_general_util__WEBPACK_IMPORTED_MODULE_3__["stringSwitch"])(captionAnchor, function (_ref5) {
    var _case = _ref5._case;

    _case('top', function () {
      return {
        bottom: '100%',
        left: '50%',
        shift: 'left'
      };
    });

    _case('topRight', function () {
      return {
        bottom: '100%',
        left: '100%'
      };
    });

    _case('right', function () {
      return {
        top: '50%',
        left: '100%',
        shift: 'up'
      };
    });

    _case('bottomRight', function () {
      return {
        top: '100%',
        left: '100%'
      };
    });

    _case('bottom', function () {
      return {
        top: '100%',
        left: '50%',
        shift: 'left'
      };
    });

    _case('bottomLeft', function () {
      return {
        top: '100%',
        right: '100%'
      };
    });

    _case('left', function () {
      return {
        top: '50%',
        right: '100%',
        shift: 'up'
      };
    });

    _case('topLeft', function () {
      return {
        bottom: '100%',
        right: '100%'
      };
    });

    _default(function () {
      throw new Error('Invalid captionAnchor ');
    });
  }),
      defaultTop = _stringSwitch.top,
      defaultRight = _stringSwitch.right,
      defaultBottom = _stringSwitch.bottom,
      defaultLeft = _stringSwitch.left,
      shift = _stringSwitch.shift;

  return [{
    top: mergeProp(defaultTop, top),
    right: mergeProp(defaultRight, right),
    bottom: mergeProp(defaultBottom, bottom),
    left: mergeProp(defaultLeft, left)
  }, shift];
}

function generateDivWithStyle(style) {
  var div = document.createElement('div');
  Object.entries(style).forEach(function (_ref6) {
    var _ref7 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref6, 2),
        prop = _ref7[0],
        val = _ref7[1];

    if (val !== undefined) div.style[prop] = val;
  });
  return div;
}

function getPositionStyles(eles) {
  var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref8$paddingTop = _ref8.paddingTop,
      paddingTop = _ref8$paddingTop === void 0 ? 0 : _ref8$paddingTop,
      _ref8$paddingRight = _ref8.paddingRight,
      paddingRight = _ref8$paddingRight === void 0 ? 0 : _ref8$paddingRight,
      _ref8$paddingBottom = _ref8.paddingBottom,
      paddingBottom = _ref8$paddingBottom === void 0 ? 0 : _ref8$paddingBottom,
      _ref8$paddingLeft = _ref8.paddingLeft,
      paddingLeft = _ref8$paddingLeft === void 0 ? 0 : _ref8$paddingLeft;

  var toPx = function toPx(num) {
    return "".concat(num, "px");
  };

  var outerTop, outerRight, outerBottom, outerLeft;
  var attributes = eles.map(function (ele) {
    var _ele$getBoundingClien = ele.getBoundingClientRect(),
        top = _ele$getBoundingClien.top,
        right = _ele$getBoundingClien.right,
        bottom = _ele$getBoundingClien.bottom,
        left = _ele$getBoundingClien.left;

    if (outerTop === undefined || top < outerTop) outerTop = top;
    if (outerRight === undefined || right > outerRight) outerRight = right;
    if (outerBottom === undefined || bottom > outerBottom) outerBottom = bottom;
    if (outerLeft === undefined || left < outerLeft) outerLeft = left;
    return {
      top: toPx(top - paddingTop),
      left: toPx(left - paddingLeft),
      height: toPx(bottom - top + paddingTop + paddingBottom),
      width: toPx(right - left + paddingRight + paddingLeft)
    };
  });
  return [attributes, {
    top: toPx(outerTop - paddingTop),
    left: toPx(outerLeft - paddingLeft),
    height: toPx(outerBottom - outerTop + paddingTop + paddingBottom),
    width: toPx(outerRight - outerLeft + paddingRight + paddingLeft)
  }];
}

function mergeProp(defaultProp, argProp) {
  if (defaultProp === undefined) {
    return argProp;
  } else {
    return argProp ? "calc(".concat(defaultProp, " + ").concat(argProp, ")") : defaultProp;
  }
}

var createSVGElement = function createSVGElement(tag) {
  return document.createElementNS('http://www.w3.org/2000/svg', tag);
};
var applyStyle = function applyStyle(ele, style) {
  var clear = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (clear) ele.style = null;
  Object.entries(style).forEach(function (_ref9) {
    var _ref10 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref9, 2),
        attr = _ref10[0],
        val = _ref10[1];

    return ele.style[attr] = val;
  });
};
window.cap = document.createElement('div');
window.cap.style.width = '200px';
window.cap.style.height = '200px';
window.cap.style.background = 'red';
window.cap.style.position = 'absolute';
window.cap.style.zIndex = 100;
window.opts = {
  captionTemplate: cap,
  captionAnchor: 'bottom'
};
window.ghf = generateHighlightFuncs;
window.hh = highlightEles;

window.sa = function () {
  return [document.querySelector('.square[data-id="71"]'), document.querySelector('.square[data-id="72"]'), document.querySelector('.square[data-id="73"]')];
};

/***/ }),

/***/ "./src/scripts/shared/general_util.js":
/*!********************************************!*\
  !*** ./src/scripts/shared/general_util.js ***!
  \********************************************/
/*! exports provided: isTruthy, combos, maxPossibleRepeats, areEqualArrays, arrayUnion, includesArray, indexOfArray, includesDistinct, nextId, classes, generateClassName, copyPuzzle, wait, product, sum, difference, quotient, getNumFromCode, getDirFromCode, kebabToCamel, genStepper, throttle, togglePresenceInArray, pushIfNotIncluded, removeIfIncluded, getInterveningPositions, stringSwitch, funcSwitch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTruthy", function() { return isTruthy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combos", function() { return combos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxPossibleRepeats", function() { return maxPossibleRepeats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areEqualArrays", function() { return areEqualArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayUnion", function() { return arrayUnion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "includesArray", function() { return includesArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indexOfArray", function() { return indexOfArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "includesDistinct", function() { return includesDistinct; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextId", function() { return nextId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "classes", function() { return classes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateClassName", function() { return generateClassName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPuzzle", function() { return copyPuzzle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wait", function() { return wait; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "product", function() { return product; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return sum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "difference", function() { return difference; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quotient", function() { return quotient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNumFromCode", function() { return getNumFromCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDirFromCode", function() { return getDirFromCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kebabToCamel", function() { return kebabToCamel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genStepper", function() { return genStepper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return throttle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "togglePresenceInArray", function() { return togglePresenceInArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pushIfNotIncluded", function() { return pushIfNotIncluded; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeIfIncluded", function() { return removeIfIncluded; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInterveningPositions", function() { return getInterveningPositions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringSwitch", function() { return stringSwitch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "funcSwitch", function() { return funcSwitch; });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "./src/scripts/shared/constants.js");





var _marked = /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default.a.mark(genBasicStepper);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }


var isTruthy = function isTruthy(a) {
  return a;
};
var combos = function combos(numElements, _ref) {
  var _ref$min = _ref.min,
      min = _ref$min === void 0 ? 1 : _ref$min,
      _ref$max = _ref.max,
      max = _ref$max === void 0 ? 9 : _ref$max,
      _ref$numRepeatsAllowe = _ref.numRepeatsAllowed,
      numRepeatsAllowed = _ref$numRepeatsAllowe === void 0 ? 0 : _ref$numRepeatsAllowe;
  var rangeSize = max - min + 1;
  var nextOptions = {
    min: min + 1,
    max: max,
    numRepeatsAllowed: numRepeatsAllowed
  };

  if (numElements === 0) {
    // 0 elements; return the empty combo
    return [[]];
  } else if (rangeSize <= 0 || numElements > rangeSize + numRepeatsAllowed) {
    // impossible request; return no combos
    return [];
  } else {
    // recursive step
    var withRepeatedMin = numRepeatsAllowed > 0 && numElements >= 2 ? combos(numElements - 2, _objectSpread(_objectSpread({}, nextOptions), {}, {
      numRepeatsAllowed: numRepeatsAllowed - 1
    })).map(function (combo) {
      return [min, min].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(combo));
    }) : [];
    var withMin = combos(numElements - 1, nextOptions).map(function (combo) {
      return [min].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(combo));
    });
    var withoutMin = combos(numElements, nextOptions);
    return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(withRepeatedMin), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(withMin), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(withoutMin));
  }
};
var maxPossibleRepeats = function maxPossibleRepeats(positions) {
  var curIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var filled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var nextFillVal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  if (curIdx + 1 > positions.length) {
    return Object.values(filled).map(function (_ref2) {
      var rows = _ref2.rows;
      return rows.length;
    }).filter(function (numSquaresWithVal) {
      return numSquaresWithVal === 2;
    }).length;
  } else {
    var _positions$curIdx = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(positions[curIdx], 2),
        nextRow = _positions$curIdx[0],
        nextCol = _positions$curIdx[1];

    var possibleVals = Object.keys(filled).filter(function (val) {
      var _filled$val = filled[val],
          rows = _filled$val.rows,
          cols = _filled$val.cols;
      return !rows.includes(nextRow) && !cols.includes(nextCol);
    }).concat(nextFillVal);
    return possibleVals.reduce(function (maxRepeats, val) {
      var filledClone = deepClone(filled);
      filledClone[val] = filledClone[val] || {
        rows: [],
        cols: []
      };
      filledClone[val].rows.push(nextRow);
      filledClone[val].cols.push(nextCol);
      var maxRepeatsWithVal = maxPossibleRepeats(positions, curIdx + 1, filledClone, nextFillVal + 1);
      return maxRepeatsWithVal > maxRepeats ? maxRepeatsWithVal : maxRepeats;
    }, 0);
  }
};
var areEqualArrays = function areEqualArrays(a, b) {
  return a.length === b.length && a.every(function (ele, idx) {
    return ele === b[idx];
  });
};
var arrayUnion = function arrayUnion(a, b) {
  var aCounts = {};
  a.forEach(function (ele) {
    return aCounts[ele] = aCounts[ele] ? aCounts[ele] + 1 : 1;
  });
  var union = [];
  b.forEach(function (ele) {
    if (aCounts[ele] && aCounts[ele] > 0) {
      aCounts[ele]--;
      union.push(ele);
    }
  });
  return union;
};
var includesArray = function includesArray(outerArray, innerArray) {
  return outerArray.some(function (subArray) {
    return areEqualArrays(subArray, innerArray);
  });
};
var indexOfArray = function indexOfArray(outerArray, innerArray) {
  return outerArray.findIndex(function (subArray) {
    return areEqualArrays(subArray, innerArray);
  });
};
var includesDistinct = function includesDistinct(array) {
  var visitedIndices = {};

  for (var _len = arguments.length, requiredElements = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    requiredElements[_key - 1] = arguments[_key];
  }

  return requiredElements.every(function (requiredEle) {
    var eleIndex = array.findIndex(function (ele, idx) {
      return ele === requiredEle && !visitedIndices[idx];
    });

    if (eleIndex === -1) {
      return false;
    } else {
      visitedIndices[eleIndex] = true;
      return true;
    }
  });
};
var nextId = function () {
  var id = 0;
  return function () {
    return "".concat(id++);
  };
}();
var classes = function classes() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return args.map(function (arg) {
    if (arg instanceof Array) {
      return arg[0] ? arg[1] : arg[2];
    } else {
      return arg;
    }
  }).filter(function (arg) {
    return arg;
  }).join(' ');
};

function evalClassNameComponent(component) {
  if (component instanceof Array) {
    return component[0] ? component[1] : component[2];
  } else {
    return component;
  }
}

function evalClassNameComponents(components) {
  return components.map(evalClassNameComponent).filter(isTruthy);
}

function evalClassNameFlags(base, flags) {
  return evalClassNameComponents(flags).map(function (flag) {
    return "".concat(base, "--").concat(flag);
  });
}

function generateClassNameFromArray(components) {
  return evalClassNameComponents(components).join(' ');
}

function generateClassNameFromBaseAndFlags(base, flags) {
  return [base].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(evalClassNameFlags(base, flags))).join(' ');
}

function generateClassNameFromOptions(_ref3) {
  var _ref3$base = _ref3.base,
      base = _ref3$base === void 0 ? null : _ref3$base,
      _ref3$flags = _ref3.flags,
      flags = _ref3$flags === void 0 ? [] : _ref3$flags,
      _ref3$classes = _ref3.classes,
      classes = _ref3$classes === void 0 ? [] : _ref3$classes;
  var classNames = evalClassNameComponents([base].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(classes)));
  var flagNames = evalClassNameFlags(base, flags);
  return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(classNames), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(flagNames)).join(' ');
}

var generateClassName = function generateClassName(dynamicArg, flags) {
  if (dynamicArg instanceof Array) {
    return generateClassNameFromArray(dynamicArg);
  } else if (typeof dynamicArg === 'string' && flags instanceof Array) {
    return generateClassNameFromBaseAndFlags(dynamicArg, flags);
  } else {
    return generateClassNameFromOptions(dynamicArg);
  }
};
var copyPuzzle = function copyPuzzle(puzzle) {
  var copy = puzzle.clone();
  copy.resetUuid();
  return copy;
};
var wait = function wait(ms) {
  return new Promise(function (resolve) {
    return window.setTimeout(resolve, ms);
  });
};
var product = function product(numArray) {
  return numArray.reduce(function (product, num) {
    return product * num;
  }, 1);
};
var sum = function sum(numArray) {
  return numArray.reduce(function (sum, num) {
    return sum + num;
  }, 0);
};
var difference = function difference(_ref4) {
  var _ref5 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref4, 2),
      a = _ref5[0],
      b = _ref5[1];

  var _ref6 = a > b ? [a, b] : [b, a],
      _ref7 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref6, 2),
      larger = _ref7[0],
      smaller = _ref7[1];

  return larger - smaller;
};
var quotient = function quotient(_ref8) {
  var _ref9 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref8, 2),
      a = _ref9[0],
      b = _ref9[1];

  var _ref10 = a > b ? [a, b] : [b, a],
      _ref11 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref10, 2),
      larger = _ref11[0],
      smaller = _ref11[1];

  return larger / smaller;
}; // export const stringSwitch = (
//   input,
//   casesFn,
//   {
//     fallthrough = false,
//     multipleMatches = false
//   } = {}
// ) => {
//   if (typeof input !== 'string') {
//     throw new Error('First argument to stringSwitch must be a string')
//   } else if (typeof casesFn !== 'function') {
//     throw new Error('Second argument to stringSwitch must be a function')
//   }
//   let matched = false
//   let result
//   function _case(...args) {
//     const { exec, isMatch } = _parseCaseArgs(args)
//     const shouldExecByMatch = isMatch(input) && (!matched || multipleMatches)
//     const shouldExecByFallthrough = matched && fallthrough
//     if (shouldExecByMatch || shouldExecByFallthrough) {
//       matched = true
//       result = exec(input)
//     }
//   }
//   function _default(exec) {
//     if (typeof exec !== 'function') {
//       throw new Error('Argument to default function must be a function')
//     }
//     if (!matched || fallthrough) {
//       result = exec(input)
//     }
//   }
//   function _ensure(exec) {
//     if (typeof exec !== 'function') {
//       throw new Error('Argument to ensure function must be a function')
//     }
//     if (matched) {
//       exec(input)
//     }
//   }
//   casesFn({ _case, _default, _ensure })
//   return result
// }
// function _parseCaseArgs(args) {
//   const exec = args.pop()
//   if (typeof exec !== 'function') {
//     throw new Error('Last argument to case function must be a callback to execute if the case matches')
//   }
//   const isMatch = input => args.every(matcher => _parseMatcher(matcher)(input))
//   return { exec, isMatch }
// }
// function _parseMatcher(matcher) {
//   const matcherType = matcher.constructor.name
//   switch (matcherType) {
//     case 'BabelRegExp':
//     case 'RegExp':
//       return input => matcher.test(input)
//     case 'String':
//       return input => matcher === input
//     case 'Boolean':
//       return () => matcher
//     case 'Array':
//       return input => matcher.some(sub => _parseMatcher(sub)(input))
//     default:
//       throw new Error(`Matcher arguments to case function must be a string, regular expression, boolean, or array of such. Instead, received ${matcherType}`)
//   }
// }

var getNumFromCode = function getNumFromCode(code) {
  var _NUM_REGEX$exec;

  return parseInt((_NUM_REGEX$exec = _constants__WEBPACK_IMPORTED_MODULE_4__["NUM_REGEX"].exec(code)) === null || _NUM_REGEX$exec === void 0 ? void 0 : _NUM_REGEX$exec.groups.num);
};
var getDirFromCode = function getDirFromCode(code) {
  var _ARROW_REGEX$exec, _ARROW_REGEX$exec$gro;

  return (_ARROW_REGEX$exec = _constants__WEBPACK_IMPORTED_MODULE_4__["ARROW_REGEX"].exec(code)) === null || _ARROW_REGEX$exec === void 0 ? void 0 : (_ARROW_REGEX$exec$gro = _ARROW_REGEX$exec.groups) === null || _ARROW_REGEX$exec$gro === void 0 ? void 0 : _ARROW_REGEX$exec$gro.dir;
};
var kebabToCamel = function kebabToCamel(string) {
  return string.split('-').map(function (segment, idx) {
    return idx > 0 ? segment[0].toUpperCase() + segment.slice(1) : segment;
  }).join('');
};
var genStepper = function genStepper(iterable) {
  var basicStepper = genBasicStepper(iterable);
  return function () {
    return basicStepper.next().value;
  };
};

function genBasicStepper(iterable) {
  return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default.a.wrap(function genBasicStepper$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          return _context.delegateYield(iterable, "t0", 1);

        case 1:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

function deepClone(obj) {
  switch (obj.constructor.name) {
    case 'Object':
      return Object.fromEntries(Object.entries(obj).map(function (_ref12) {
        var _ref13 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref12, 2),
            key = _ref13[0],
            val = _ref13[1];

        return [key, deepClone(val)];
      }));

    case 'Array':
      return obj.map(function (ele) {
        return deepClone(ele);
      });

    default:
      return obj;
  }
}

var throttle = function throttle(func) {
  var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
  var lastFired = Date.now();
  return function () {
    var now = Date.now();

    if (now - lastFired >= ms) {
      lastFired = now;
      func.apply(void 0, arguments);
    }
  };
};
var togglePresenceInArray = function togglePresenceInArray(array, ele) {
  var indexOfFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (array, ele) {
    return array.indexOf(ele);
  };
  var idx = indexOfFunc(array, ele);

  if (idx >= 0) {
    array.splice(idx, 1);
  } else {
    array.push(ele);
  }
};
var pushIfNotIncluded = function pushIfNotIncluded(array, ele) {
  var includesFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (array, ele) {
    return array.includes(ele);
  };
  if (!includesFunc(array, ele)) array.push(ele);
};
var removeIfIncluded = function removeIfIncluded(array, ele) {
  var indexOfFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (array, ele) {
    return array.indexOf(ele);
  };
  var idx = indexOfFunc(array, ele);

  if (idx >= 0) {
    array.splice(idx, 1);
  }
};
var getInterveningPositions = function getInterveningPositions(_ref14, _ref15) {
  var _ref16 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref14, 2),
      startX = _ref16[0],
      startY = _ref16[1];

  var _ref17 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_ref15, 2),
      endX = _ref17[0],
      endY = _ref17[1];

  var xRange = getRange(startX, endX);
  var yRange = getRange(startY, endY);
  return xRange.reduce(function (positions, x) {
    var newPositions = yRange.map(function (y) {
      return [x, y];
    });
    return positions.concat(newPositions);
  }, []);
};

function getRange(a, b) {
  var mapper = a < b ? function (_, idx) {
    return idx + a;
  } : function (_, idx) {
    return a - idx;
  };
  return Array.from({
    length: Math.abs(a - b) + 1
  }).map(mapper);
}

var stringSwitch = function stringSwitch(input, casesFn, options) {
  validateStringSwitchArgs({
    input: input,
    casesFn: casesFn
  });

  var caseArgParser = function caseArgParser(args) {
    return stringSwitchCaseArgParser(input, args);
  };

  return baseSwitch(caseArgParser, casesFn, options);
};
var funcSwitch = function funcSwitch(input, comparator, casesFn, options) {
  validateFuncSwitchArgs({
    comparator: comparator,
    casesFn: casesFn
  });

  var caseArgParser = function caseArgParser(args) {
    return funcSwitchCaseArgParser(input, comparator, args);
  };

  return baseSwitch(caseArgParser, casesFn, options);
};

function baseSwitch(caseArgParser, casesFn) {
  var _ref18 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref18$fallthrough = _ref18.fallthrough,
      fallthrough = _ref18$fallthrough === void 0 ? false : _ref18$fallthrough,
      _ref18$multipleMatche = _ref18.multipleMatches,
      multipleMatches = _ref18$multipleMatche === void 0 ? false : _ref18$multipleMatche;

  var matched = false;
  var result;

  function _case() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    var _caseArgParser = caseArgParser(args),
        exec = _caseArgParser.exec,
        isMatch = _caseArgParser.isMatch;

    var shouldExecByMatch = isMatch() && (!matched || multipleMatches);
    var shouldExecByFallthrough = matched && fallthrough;

    if (shouldExecByMatch || shouldExecByFallthrough) {
      matched = true;
      result = exec();
    }
  }

  function _default(exec) {
    if (typeof exec !== 'function') {
      throw new Error('Argument to default function must be a function');
    }

    if (!matched || fallthrough) {
      result = exec();
    }
  }

  function _ensure(exec) {
    if (typeof exec !== 'function') {
      throw new Error('Argument to ensure function must be a function');
    }

    if (matched) {
      exec();
    }
  }

  casesFn({
    _case: _case,
    _default: _default,
    _ensure: _ensure
  });
  return result;
}

function validateStringSwitchArgs(_ref19) {
  var input = _ref19.input,
      casesFn = _ref19.casesFn;

  if (typeof input !== 'string') {
    throw new Error('First argument to stringSwitch must be a string');
  } else if (typeof casesFn !== 'function') {
    throw new Error('Second argument to stringSwitch must be a function');
  }
}

function validateFuncSwitchArgs(_ref20) {
  var comparator = _ref20.comparator,
      casesFn = _ref20.casesFn;

  if (typeof comparator !== 'function') {
    throw new Error('Second argument to funcSwitch must be a comparator function');
  } else if (typeof casesFn !== 'function') {
    throw new Error('Third argument to funcSwitch must be a function that defines your case statements');
  }
}

function stringSwitchCaseArgParser(input, args) {
  var exec = args.pop();

  if (typeof exec !== 'function') {
    throw new Error('Last argument to case function must be a callback to execute if the case matches');
  }

  var isMatch = function isMatch() {
    return args.every(function (matcher) {
      return parseMatcher(matcher)(input);
    });
  };

  return {
    exec: exec,
    isMatch: isMatch
  };
}

function funcSwitchCaseArgParser(input, comparator, args) {
  var exec = args.pop();

  if (typeof exec !== 'function') {
    throw new Error('Last argument to case function must be a callback to execute if the case matches');
  }

  var isMatch = function isMatch() {
    return comparator.apply(void 0, [input].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(args[0]))) && args.slice(1).every(function (matcher) {
      return parseMatcher(matcher)(input);
    });
  };

  return {
    exec: exec,
    isMatch: isMatch
  };
}

function parseMatcher(matcher) {
  var isMatcherType = function isMatcherType(type) {
    return matcher instanceof type;
  };

  if (typeof matcher === 'string') {
    return function (input) {
      return matcher === input;
    };
  } else if (typeof matcher === 'boolean') {
    return function () {
      return matcher;
    };
  } else if (isMatcherType(RegExp)) {
    return function (input) {
      return matcher.test(input);
    };
  } else if (isMatcherType(Array)) {
    return function (input) {
      return matcher.some(function (sub) {
        return parseMatcher(sub)(input);
      });
    };
  } else {
    throw new Error("Matcher arguments to case function must be a string, regular expression, boolean, or array of such. Instead, received ".concat(matcher));
  }
}

/***/ }),

/***/ "./src/scripts/shared/lru_cache.js":
/*!*****************************************!*\
  !*** ./src/scripts/shared/lru_cache.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LRUCache; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__);




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var newNode = function newNode(options) {
  return _objectSpread({
    key: null,
    value: null,
    prev: null,
    next: null,
    lastUpdated: new Date()
  }, options);
};

var LRUCache = /*#__PURE__*/function () {
  function LRUCache(max) {
    var _this = this;

    var timeBeforeClear = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, LRUCache);

    this.max = max;
    this.head = newNode();
    this.tail = newNode();
    this.timeBeforeClear = timeBeforeClear;
    window.setInterval(function () {
      _this._removeBefore(_this.timeBeforeClear);
    }, 10000);
    this.reset();
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(LRUCache, [{
    key: "get",
    value: function get(key) {
      var node = this.map[key];
      if (node) node.lastUpdated = new Date();
      return node === null || node === void 0 ? void 0 : node.value;
    }
  }, {
    key: "set",
    value: function set(key, value) {
      var previousLast = this.tail.prev;
      var node = newNode({
        key: key,
        value: value,
        prev: previousLast,
        next: this.tail
      });
      previousLast.next = node;
      this.tail.prev = node;
      this.size++;
      if (this.size > this.max) this._removeOldest();
      this.map[key] = node;
      return node === null || node === void 0 ? void 0 : node.value;
    }
  }, {
    key: "remove",
    value: function remove(key) {
      var node = this.map[key];
      return this._remove(node);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.map = {};
      this.size = 0;
      this.head.next = this.tail;
      this.tail.prev = this.head;
    }
  }, {
    key: "_remove",
    value: function _remove(node) {
      if (node && node !== this.head && node !== this.tail) {
        var beforeNode = node.prev,
            afterNode = node.next;
        beforeNode.next = afterNode;
        afterNode.prev = beforeNode;
        this.size--;
        delete this.map[node.key];
      }

      return node === null || node === void 0 ? void 0 : node.value;
    }
  }, {
    key: "_removeOldest",
    value: function _removeOldest() {
      var oldest = this.head.next;
      return this._remove(oldest);
    }
  }, {
    key: "_removeBefore",
    value: function _removeBefore(ms) {
      if (!ms) return;
      var now = new Date();
      var newMap = {};
      var validNode = this.head;

      while (validNode.next !== this.tail && now - validNode.next.lastUpdated < ms) {
        validNode = validNode.next;
        newMap[validNode.key] = validNode;
      }

      validNode.next = this.tail;
      this.tail.prev = validNode;
      this.map = newMap;
    }
  }]);

  return LRUCache;
}();



/***/ }),

/***/ "./src/scripts/shared/spotlight.js":
/*!*****************************************!*\
  !*** ./src/scripts/shared/spotlight.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _dom_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom_util */ "./src/scripts/shared/dom_util.js");
/* harmony import */ var _general_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./general_util */ "./src/scripts/shared/general_util.js");







function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



var clockwiseOrder = ['top', 'right', 'bottom', 'left'];
var sideSigns = {
  top: -1,
  right: 1,
  bottom: 1,
  left: -1
};
var overflowPx = 20;

var Spotlight = /*#__PURE__*/function () {
  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default()(Spotlight, null, [{
    key: "fromEles",
    value: function fromEles(eles, options) {
      return new Spotlight(_objectSpread({
        eles: eles
      }, options));
    }
  }, {
    key: "fromEle",
    value: function fromEle(ele, options) {
      return new Spotlight(_objectSpread({
        eles: [ele]
      }, options));
    }
  }]);

  function Spotlight() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4___default()(this, Spotlight);

    Object.assign(this, {
      padding: 0,
      blur: 2,
      captionOffsetX: 0,
      captionOffsetY: 0,
      captionPosition: 'right',
      onShow: function onShow() {
        return function () {};
      }
    }, options);
    this.generate();
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5___default()(Spotlight, [{
    key: "generate",
    value: function generate() {
      var _this = this;

      this.bounds = this.eles.map(function (ele, idx) {
        var padding = _this.padding instanceof Array ? _this.padding[idx] : _this.padding;
        return getPaddedBoundingRect(ele, padding);
      });
      this.subPaths = [];
      this.visited = {};
      this._anchorBounds = null;
      var i = 0;

      while (!this.isComplete && i < 5) {
        this._addNextSubPath();

        i++;
      }
    }
  }, {
    key: "_addNextSubPath",
    value: function _addNextSubPath() {
      var subPath = [];

      this._beginSubPath(subPath);

      var i = 0;

      while (!this._isCompleteSubPath(subPath) && i < 100) {
        this._addNextPoint(subPath);

        i++;
      }

      var overflowOffsetSubPath = subPath.map(function (point) {
        return point.map(function (i) {
          return i + overflowPx / 2;
        });
      });
      this.subPaths.push(overflowOffsetSubPath);
    }
  }, {
    key: "_addNextPoint",
    value: function _addNextPoint(subPath) {
      var _this2 = this;

      var _stringSwitch = Object(_general_util__WEBPACK_IMPORTED_MODULE_7__["stringSwitch"])(this.curBoundSide, function (_ref) {
        var _case = _ref._case;

        _case(['left', 'right'], function () {
          return [0, 1];
        });

        _case(['top', 'bottom'], function () {
          return [1, 0];
        });
      }),
          _stringSwitch2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_stringSwitch, 2),
          staticIdx = _stringSwitch2[0],
          changingIdx = _stringSwitch2[1];

      var curPoint = this._getLastPoint(subPath);

      var curStaticDim = curPoint[staticIdx];
      var curChangingDim = curPoint[changingIdx];
      var nextCurBoundSide = getNextSide(this.curBoundSide);

      var closestDim = this._getDim(this.curBoundIdx, nextCurBoundSide);

      if (curChangingDim === closestDim) {
        this.curBoundSide = nextCurBoundSide;
        return;
      }

      var closestBoundIdx = this.curBoundIdx;
      var interceptSide = getOppositeSide(nextCurBoundSide);
      this.boundsIndices.forEach(function (idx) {
        var _this2$_getOtherDimRa = _this2._getOtherDimRange(idx, interceptSide),
            _this2$_getOtherDimRa2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_this2$_getOtherDimRa, 2),
            staticDimLower = _this2$_getOtherDimRa2[0],
            staticDimUpper = _this2$_getOtherDimRa2[1];

        if (curStaticDim < staticDimLower || curStaticDim > staticDimUpper) {
          return;
        }

        var interceptDim = _this2._getDim(idx, interceptSide);

        if (Math.sign(interceptDim - curChangingDim) === sideSigns[nextCurBoundSide] && Math.sign(closestDim - interceptDim) === sideSigns[nextCurBoundSide]) {
          closestDim = interceptDim;
          closestBoundIdx = idx;
        }
      });
      var nextPoint = [null, null];
      nextPoint[staticIdx] = curStaticDim;
      nextPoint[changingIdx] = closestDim; // side effects

      subPath.push(nextPoint);
      this.visited[closestBoundIdx] = true;
      this.curBoundSide = closestBoundIdx !== this.curBoundIdx ? interceptSide : nextCurBoundSide;
      this.curBoundIdx = closestBoundIdx;
    }
  }, {
    key: "_getDim",
    value: function _getDim(boundOrIdx, side) {
      return typeof boundOrIdx === 'number' ? this.bounds[boundOrIdx][side] : boundOrIdx[side];
    }
  }, {
    key: "_getNextBoundIdx",
    value: function _getNextBoundIdx() {
      var _this3 = this;

      return this.boundsIndices.find(function (idx) {
        return !_this3.visited[idx];
      });
    }
  }, {
    key: "_beginSubPath",
    value: function _beginSubPath(subPath) {
      this.curBoundIdx = this._getNextBoundIdx();
      this.visited[this.curBoundIdx] = true;
      this.curBoundSide = 'top';
      var _this$curBound = this.curBound,
          left = _this$curBound.left,
          top = _this$curBound.top;
      subPath.push([left, top]);
    }
  }, {
    key: "_getFirstPoint",
    value: function _getFirstPoint(subPath) {
      return subPath[0];
    }
  }, {
    key: "_getLastPoint",
    value: function _getLastPoint(subPath) {
      return subPath[subPath.length - 1];
    }
  }, {
    key: "_getOtherDimRange",
    value: function _getOtherDimRange(boundIdx, side) {
      var bound = this.bounds[boundIdx];
      return Object(_general_util__WEBPACK_IMPORTED_MODULE_7__["stringSwitch"])(side, function (_ref2) {
        var _case = _ref2._case;

        _case(['left', 'right'], function () {
          return [bound.top, bound.bottom];
        });

        _case(['top', 'bottom'], function () {
          return [bound.left, bound.right];
        });
      });
    }
  }, {
    key: "_isCompleteSubPath",
    value: function _isCompleteSubPath(subPath) {
      return subPath.length > 1 && Object(_general_util__WEBPACK_IMPORTED_MODULE_7__["areEqualArrays"])(this._getFirstPoint(subPath), this._getLastPoint(subPath));
    }
  }, {
    key: "_getSubPathD",
    value: function _getSubPathD(subPath) {
      var m = "M ".concat(subPath[0].join());
      var l = "L ".concat(subPath.slice(1).map(function (p) {
        return p.join();
      }).join(' '));
      return "".concat(m, " ").concat(l);
    }
  }, {
    key: "getD",
    value: function getD(vbw, vbh) {
      return "M 0,0 L ".concat(vbw, ",0 ").concat(vbw, ",").concat(vbh, " 0,").concat(vbh, " 0,0 ").concat(this.innerPath);
    } // getD(vbw, vbh) {
    //   const getSubPathD = this.borderRadius
    //     ? this._getRoundedSubPathD
    //     : this._getSubPathD
    //   const outerPath = `M 0,0 L ${vbw},0 ${vbw},${vbh} 0,${vbh} 0,0`
    //   const innerPaths = this.subPaths.map(getSubPathD.bind(this)).join(' ')
    //   return `${outerPath} ${innerPaths} z`
    // }

  }, {
    key: "updateSVG",
    value: function updateSVG() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          svg = _ref3.element,
          _ref3$regenerate = _ref3.regenerate,
          regenerate = _ref3$regenerate === void 0 ? true : _ref3$regenerate;

      if (!svg) return;
      if (regenerate) this.generate();
      var vbw = window.innerWidth + overflowPx;
      var vbh = window.innerHeight + overflowPx;
      svg.setAttribute('viewBox', "0 0 ".concat(vbw, " ").concat(vbh));
      svg.querySelector('path').setAttribute('d', this.getD(vbw, vbh));
      svg.querySelector('feGaussianBlur').setAttribute('stdDeviation', this.blur);
      return svg;
    }
  }, {
    key: "updateCaption",
    value: function updateCaption() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          caption = _ref4.element,
          _ref4$regenerate = _ref4.regenerate,
          regenerate = _ref4$regenerate === void 0 ? true : _ref4$regenerate;

      if (!caption) return;
      if (regenerate) this.generate();
      Object(_dom_util__WEBPACK_IMPORTED_MODULE_6__["applyStyle"])(caption, this.captionStyle, true);
      return caption;
    } //0 0 1

  }, {
    key: "_getRoundedSubPathD",
    value: function _getRoundedSubPathD(subPath) {
      var _this4 = this;

      // const m = `M ${this._getNudgedPoint(subPath[0], subPath[1])}`
      var hookPoints = [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(subPath), [subPath[1]]);
      var pathParts = Array.from({
        length: hookPoints.length - 2
      }).reduce(function (parts, _, idx) {
        return parts.concat(_this4._getPathHook(hookPoints.slice(idx, idx + 3)));
      }, []);
      return ['M', pathParts[pathParts.length - 1]].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1___default()(pathParts)).join(' ');
      return "".concat(m, " ").concat(hooks.join(' '));
    }
  }, {
    key: "_getPathHook",
    value: function _getPathHook(_ref5) {
      var _ref6 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_2___default()(_ref5, 3),
          prev = _ref6[0],
          cur = _ref6[1],
          next = _ref6[2];

      // const [startPoint, endPoint] = this._getNudgedPoints(prev, cur, next)
      // const  = this._getNudgedPoint(cur, next)
      var startPoint = this._getNudgedPoint(cur, prev);

      var endPoint = this._getNudgedPoint(cur, next);

      var radii = getAbsDiff(startPoint, endPoint);
      var clockwise = Math.sign(next[1] - prev[1]) === Math.sign(cur[0] * 2 - prev[0] - next[0]); //   const l = `L ${startPoint.join()}`
      // const a = `A ${radii.join(' ')} 0 0 ${clockwise ? '1' : '0'} ${endPoint.join(' ')}`
      // return `${l} ${a}`

      return ['L', startPoint, 'A', radii, 0, 0, clockwise ? 1 : 0, endPoint];
    }
  }, {
    key: "_getNudgedPoint",
    value: function _getNudgedPoint(a, b) {
      var _this5 = this;

      return [0, 1].map(function (i) {
        var diff = b[i] - a[i];
        var mag = Math.min(_this5.borderRadius, Math.abs(diff) / 2);
        return a[i] + mag * Math.sign(diff);
      });
    } // _getNudgedPoints(prev, cur, next) {
    //   let mag = this.borderRadius
    //   const dirs = [prev, next].map(pos =>
    //     [0, 1].map(i => {
    //       const diff = pos[i] - cur[i]
    //       const maxDiffRadius = Math.abs(diff) / 2
    //       if (maxDiffRadius > 0 && maxDiffRadius < mag) {
    //         mag = maxDiffRadius
    //       }
    //       return Math.sign(diff)
    //     })
    //   )
    //   return dirs.map(dir => dir.map((sign, idx) => cur[idx] + sign * mag))
    //   const prevDir = [0, 1].map(i => Math.sign(prev[i] - cur[i]))
    //   const nextDir = [0, 1].map(i => Math.sign(next[i] - cur[i]))
    //   return [0, 1].map(i => {
    //     const diff = b[i] - a[i]
    //     const mag = Math.min(this.borderRadius, Math.abs(diff) / 2)
    //     return a[i] + mag * Math.sign(diff)
    //   })
    // }

  }, {
    key: "innerPath",
    get: function get() {
      var getSubPathD = this.borderRadius ? this._getRoundedSubPathD : this._getSubPathD;
      return this.subPaths.map(getSubPathD.bind(this)).join(' ') + ' z';
    }
  }, {
    key: "anchorBounds",
    get: function get() {
      if (!this._anchorBounds) {
        if (this.bounds.length > 1 && typeof this.anchorEle === 'number') {
          this._anchorBounds = this.bounds[this.anchorEle];
        } else if (this.bounds.length > 1) {
          this._anchorBounds = this.bounds.reduce(function (anchorBounds, bound) {
            return {
              top: Math.min(anchorBounds.top, bound.top),
              left: Math.min(anchorBounds.left, bound.left),
              right: Math.max(anchorBounds.right, bound.right),
              bottom: Math.max(anchorBounds.bottom, bound.bottom)
            };
          });
        } else {
          this._anchorBounds = this.bounds[0];
        }
      }

      return this._anchorBounds;
    }
  }, {
    key: "positionStyles",
    get: function get() {
      var _this$anchorBounds = this.anchorBounds,
          boundsTop = _this$anchorBounds.top,
          boundsRight = _this$anchorBounds.right,
          boundsLeft = _this$anchorBounds.left,
          boundsBottom = _this$anchorBounds.bottom;
      var upperTop = toPixels(boundsTop);
      var midTop = toPixels((boundsTop + boundsBottom) / 2);
      var lowerTop = toPixels(boundsBottom);
      var startLeft = toPixels(boundsLeft);
      var midLeft = toPixels((boundsLeft + boundsRight) / 2);
      var endLeft = toPixels(boundsRight);
      return {
        top: {
          top: upperTop,
          left: midLeft
        },
        topRight: {
          top: upperTop,
          left: endLeft
        },
        right: {
          top: midTop,
          left: endLeft
        },
        bottomRight: {
          top: lowerTop,
          left: endLeft
        },
        bottom: {
          top: lowerTop,
          left: midLeft
        },
        bottomLeft: {
          top: lowerTop,
          left: startLeft
        },
        left: {
          top: midTop,
          left: startLeft
        },
        topLeft: {
          top: upperTop,
          left: startLeft
        }
      };
    }
  }, {
    key: "captionStyle",
    get: function get() {
      var positionStyle = this.positionStyles[this.captionPosition];
      var xShift = Object(_general_util__WEBPACK_IMPORTED_MODULE_7__["stringSwitch"])(this.captionPosition, function (_ref7) {
        var _case = _ref7._case,
            _default = _ref7._default;

        _case(/(L|l)eft/, function () {
          return '-100%';
        });

        _case(['top', 'bottom'], function () {
          return '-50%';
        });

        _default(function () {
          return '0';
        });
      });
      var yShift = Object(_general_util__WEBPACK_IMPORTED_MODULE_7__["stringSwitch"])(this.captionPosition, function (_ref8) {
        var _case = _ref8._case,
            _default = _ref8._default;

        _case(/top/, function () {
          return '-100%';
        });

        _case(['left', 'right'], function () {
          return '-50%';
        });

        _default(function () {
          return '0';
        });
      });
      var translateX = "calc(".concat(xShift, " + ").concat(this.captionOffsetX, ")");
      var translateY = "calc(".concat(yShift, " + ").concat(this.captionOffsetY, ")");
      return _objectSpread(_objectSpread({}, positionStyle), {}, {
        transform: "translateX(".concat(translateX, ") translateY(").concat(translateY, ")")
      });
    }
  }, {
    key: "curBound",
    get: function get() {
      return this.bounds[this.curBoundIdx];
    }
  }, {
    key: "isComplete",
    get: function get() {
      return this._getNextBoundIdx() === undefined;
    }
  }, {
    key: "boundsIndices",
    get: function get() {
      return Array.from({
        length: this.bounds.length
      }).map(function (_, idx) {
        return idx;
      });
    }
  }]);

  return Spotlight;
}();

function getNextSide(curSide) {
  var idx = clockwiseOrder.indexOf(curSide);
  var nextSideIdx = (idx + 1 + 4) % 4;
  return clockwiseOrder[nextSideIdx];
}

function getOppositeSide(side) {
  var idx = clockwiseOrder.indexOf(side);
  var oppositeIdx = (idx + 2) % 4;
  return clockwiseOrder[oppositeIdx];
}

function toPixels(num) {
  return "".concat(num, "px");
}

function getPaddedBoundingRect(ele, padding) {
  var _padding$default, _padding$top, _padding$left, _padding$right, _padding$bottom;

  var bound = ele.getBoundingClientRect();
  var defaultPadding = _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(padding) === 'object' ? (_padding$default = padding.default) !== null && _padding$default !== void 0 ? _padding$default : 0 : padding;
  return {
    top: bound.top - ((_padding$top = padding.top) !== null && _padding$top !== void 0 ? _padding$top : defaultPadding),
    left: bound.left - ((_padding$left = padding.left) !== null && _padding$left !== void 0 ? _padding$left : defaultPadding),
    right: bound.right + ((_padding$right = padding.right) !== null && _padding$right !== void 0 ? _padding$right : defaultPadding),
    bottom: bound.bottom + ((_padding$bottom = padding.bottom) !== null && _padding$bottom !== void 0 ? _padding$bottom : defaultPadding)
  };
} // _getRoundedSubPathD(subPath) {
//   const m = `M ${subPath[0].join()}`
//   const l = `L ${subPath.slice(1).map(p => p.join()).join(' ')}`
//   return `${m} ${l}`
// }
// function getNudgeDiff(a, b, px) {
//   return [0, 1].map(i => {
//     const diff = b[i] - a[i]
//     const mag = Math.min(px, Math.abs(diff) / 2)
//     return mag * Math.sign(diff)
//   })
// }
// function getNudgedPoint(a, b) {
//   return [0, 1].map(i => {
//     const diff = b[i] - a[i]
//     const mag = Math.min(this.borderRadius, Math.abs(diff) / 2)
//     return a[i] + mag * Math.sign(diff)
//   })
// }


function getAbsDiff(a, b) {
  return [0, 1].map(function (i) {
    return Math.abs(a[i] - b[i]);
  });
} // function getPathHook(prev, cur, next, radius) {
//   const startPoint = getNudgedPoint(cur, prev, radius)
//   const endPoint = getNudgedPoint(cur, next, radius)
//   const radii = getAbsDiff(startPoint, endPoint)
//   const l = `L ${startPoint.join()}`
//   const a = `A ${radii.join(' ')} 0 0 1 ${endPoint.join(' ')}`
//   return `${l} ${a}`
// }
// function vecAdd(...vecs) {
//   return Array.from({ length: vecs[0].length })
//     .map((_, idx) => vecs.reduce((sum, vec) => vec[idx] + sum, 0))
// }


/* harmony default export */ __webpack_exports__["default"] = (Spotlight); // clockwise
// pos, pos -> higherx, lowery
// neg, pos -> higherx, highery
// pos, neg -> lowerx, lowery
// neg, neg -> lowerx, highery
// if sign of second matches sign of x diff

/***/ }),

/***/ "./src/scripts/shared/storage_util.js":
/*!********************************************!*\
  !*** ./src/scripts/shared/storage_util.js ***!
  \********************************************/
/*! exports provided: dbAdd, dbGet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dbAdd", function() { return dbAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dbGet", function() { return dbGet; });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1__);



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var dbAdd;
var dbGet;

if (Worker && indexedDB) {
  var storageWorker = new Worker('./dist/worker.js');
  var resolutionRegistry = {};

  storageWorker.onmessage = function (msg) {
    var _msg$data = msg.data,
        requestId = _msg$data.requestId,
        otherData = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_1___default()(_msg$data, ["requestId"]);

    var resolve = resolutionRegistry[requestId];

    if (resolve) {
      resolve(otherData);
      delete resolutionRegistry[requestId];
    } else {
      console.log('Failed to find matching request for: ', msg);
    }
  };

  dbAdd = function dbAdd(key, value) {
    return send({
      type: 'ADD',
      key: key,
      value: value
    }).then(function (_ref) {
      var status = _ref.status;
      return status === 'success';
    });
  };

  dbGet = function dbGet(key) {
    return send({
      type: 'GET',
      key: key
    }).then(function (_ref2) {
      var result = _ref2.result;
      console.log(result);
      return result;
    });
  };

  function send(message, timeout) {
    var requestId = Math.random();
    storageWorker.postMessage(_objectSpread(_objectSpread({}, message), {}, {
      requestId: requestId
    }));
    return new Promise(function (resolve, reject) {
      if (timeout !== undefined) {
        var timeoutId = window.setTimeout(function () {
          reject('Request timed out');
        }, timeout);

        resolutionRegistry[requestId] = function (data) {
          window.clearTimeout(timeoutId);
          resolve(data);
        };
      } else {
        resolutionRegistry[requestId] = resolve;
      }
    });
  }
} else {
  dbAdd = function dbAdd(key, value) {
    window.localStorage.setItem(key, JSON.stringify(value));
  };

  dbGet = function dbGet(key) {
    var item = window.localStorage.getItem(key);
    return JSON.parse(item);
  };
}

window.dbAdd = dbAdd;
window.dbGet = dbGet;

/***/ }),

/***/ "./src/scripts/store/base.js":
/*!***********************************!*\
  !*** ./src/scripts/store/base.js ***!
  \***********************************/
/*! exports provided: Id, Position, GameBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Id", function() { return Id; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameBase", function() { return GameBase; });
/* harmony import */ var mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mobx-state-tree */ "./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js");
/* harmony import */ var _shared_general_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/general_util */ "./src/scripts/shared/general_util.js");


var Id = mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].identifier, _shared_general_util__WEBPACK_IMPORTED_MODULE_1__["nextId"]);
var Position = mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].refinement('Position', mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].array(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].integer), function (array) {
  return array.length === 2;
});
var GameBase = mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].model('GameBase').views(function (self) {
  return {
    get root() {
      return Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getRoot"])(self);
    },

    get rootOptions() {
      var _self$root;

      return (_self$root = self.root) === null || _self$root === void 0 ? void 0 : _self$root.options;
    },

    get rootUi() {
      var _self$root2;

      return (_self$root2 = self.root) === null || _self$root2 === void 0 ? void 0 : _self$root2.ui;
    },

    get rootPuzzle() {
      return self.root.puzzle;
    },

    get env() {
      return Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["getEnv"])(self);
    }

  };
});

/***/ }),

/***/ "./src/scripts/store/collections.js":
/*!******************************************!*\
  !*** ./src/scripts/store/collections.js ***!
  \******************************************/
/*! exports provided: Cage, Group */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cage", function() { return Cage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return Group; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mobx-state-tree */ "./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js");
/* harmony import */ var _shared_general_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/general_util */ "./src/scripts/shared/general_util.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "./src/scripts/store/base.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter */ "./src/scripts/store/filter.js");
/* harmony import */ var _square__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./square */ "./src/scripts/store/square.js");

// import { types } from 'mobx-state-tree'
// import { createIcon, getTemplateById } from '../shared/dom_util'
// import {
//   combos,
//   includesArray,
//   indexOfArray,
//   product,
//   sum,
//   quotient,
//   difference,
//   includesDistinct,
//   maxPossibleRepeats,
//   stringSwitch,
// } from '../shared/general_util'
// import { Id, GameBase } from './base'
// import Rules from './rules'
// import Square from './square'
// const Collection = GameBase
//   .named('Collection')
//   .props({
//     id: Id,
//     squares: types.array(types.reference(types.late(() => Square))),
//     rules: types.optional(Rules, () => Rules.create()),
//     eliminatedCombos: types.optional(
//       types.array(types.array(types.integer)),
//       () => []
//     ),
//   })
//   .views(self => {
//     return {
//       get numSquares() {
//         return self.squares.length
//       },
//       get positions() {
//         return self.squares.map(square => square.position)
//       },
//       get squareValues() {
//         return self.squares
//           .map(square => square.value)
//           .filter(val => typeof val === 'number')
//       },
//       // get boundingBox() {
//       //   const sortedSquareRows = self.squares.map(sq => sq.row).sort()
//       //   const sortedSquareCols = self.squares.map(sq => sq.col).sort()
//       //   const minRow = sortedSquareRows[0]
//       //   const minCol = sortedSquareCols[0]
//       //   const maxRow = sortedSquareRows[sortedSquareRows.length - 1]
//       //   const maxCol = sortedSquareCols[sortedSquareCols.length - 1]
//       //   return [[minRow, minCol], [maxRow, maxCol]]
//       // },
//       get allCombos() {
//         return combos(self.numSquares, ({
//           min: 1,
//           max: self.env.globals.size,
//           numRepeatsAllowed: self.numPossibleRepeats
//         }))
//       },
//       get filteredCombos() {
//         return self.allCombos
//           .filter(self.isFilteredCombo)
//       },
//       get possibleCombos() {
//         return self.allCombos
//           .filter(self.isPossibleCombo)
//       },
//       get numPossibleRepeats() {
//         return maxPossibleRepeats(self.positions)
//       },
//       get comboEles() {
//         return self.filteredCombos.map(combo => {
//           const comboEle = self.env.templates.combo.cloneNode(true)
//           comboEle.dataset.combo = combo.join(',')
//           comboEle.innerText = combo.join(' | ')
//           if (self.isEliminatedCombo(combo)) {
//             comboEle.classList.add('combo--eliminated')
//           }
//           return comboEle
//         })
//       },
//       compareComboEles(comboA, comboB) {
//         const comboStrA = comboA.dataset.combo
//         const comboStrB = comboB.dataset.combo
//         if (comboStrA === comboStrB) {
//           return 0
//         } else if (comboStrA < comboStrB) {
//           return -1
//         } else {
//           return 1
//         }
//       },
//       isFilteredCombo(combo) {
//         return self.rules.isPossibleCombo(combo)
//       },
//       isEliminatedCombo(combo) {
//         return includesArray(self.eliminatedCombos, combo)
//       },
//       isPossibleCombo(combo) {
//         return (
//           self.isFilteredCombo(combo)
//           && !self.isEliminatedCombo(combo)
//         )
//       },
//       isPossibleValue(value) {
//         return self.possibleCombos.some(combo =>
//           includesDistinct(combo, ...self.squareValues, value))
//       },
//     }
//   })
//   .actions(self => {
//     return {
//       addSquare(square) {
//         self.squares.push(square.id)
//       },
//       toggleCombo(combo) {
//         const comboIndex = indexOfArray(self.eliminatedCombos, combo)
//         if (comboIndex >= 0) {
//           self.eliminatedCombos.splice(comboIndex, 1)
//         } else {
//           self.eliminatedCombos.push(combo)
//         }
//       },
//       // eliminateCombo(combo) {
//       //   if (!includesArray(self.eliminatedCombos, combo)) {
//       //     self.eliminatedCombos.push(combo)
//       //   }
//       // },
//       // uneliminateCombo(combo) {
//       //   const comboIndex = indexOfArray(self.eliminatedCombos, combo)
//       //   if (comboIndex >= 0) {
//       //     self.eliminatedCombos.splice(comboIndex, 1)
//       //   }
//       // },
//       setCombos(combos) {
//         const sortedCombos = combos.map(combo => combo.sort())
//         self.eliminatedCombos = self.allCombos
//           .filter(combo => !includesArray(sortedCombos, combo))
//       },
//     }
//   })
// export const Cage = Collection
//   .named('Cage')
//   .props({
//     operation: types.enumeration('Operation', ['+', '−', '⨉', '÷']),
//     result: types.integer,
//     autoElimMathImpossibilities: types.optional(types.boolean, () => false),
//   })
//   .views(self => {
//     const superIsRulePossibleCombo = self.isFilteredCombo
//     return {
//       get bounds() {
//         const bounds = {
//           topSquares: [],
//           leftSquares: [],
//           anchor: self.squares[0],
//         }
//         self.squares.forEach(square => {
//           const isTop = !self.squares.some(square.isBelow)
//           const isLeft = !self.squares.some(square.isRightOf)
//           if (isTop) bounds.topSquares.push(square)
//           if (isLeft) bounds.leftSquares.push(square)
//           if (isTop && isLeft && square.comesBefore(bounds.anchor)) {
//             bounds.anchor = square
//           }
//         })
//         return bounds;
//       },
//       get anchor() {
//         return self.bounds.anchor
//       },
//       get labelText() {
//         return `${self.result} ${self.operation}`
//       },
//       isFilteredCombo(combo) {
//         return (
//           self.rootOptions.autoElimMathImpossibilities
//           || self.autoElimMathImpossibilities
//         ) ? (
//           superIsRulePossibleCombo(combo)
//           && self.isMathematicalPossibility(combo)
//         ) : superIsRulePossibleCombo(combo)
//       },
//       isMathematicalPossibility(combo) {
//         switch (self.operation) {
//           case '+':
//             return sum(combo) === self.result
//           case '−':
//             return difference(combo) === self.result
//           case '⨉':
//             return product(combo) === self.result
//           case '÷':
//             return quotient(combo) === self.result
//           default:
//             throw new Error(`Operation ${self.operation} doesn't match one of +, -, ⨉, or ÷`)
//         }
//       }
//     }
//   })
// export const Group = Collection
//   .named('Group')





var Collection = _base__WEBPACK_IMPORTED_MODULE_3__["GameBase"].named('Collection').props({
  id: _base__WEBPACK_IMPORTED_MODULE_3__["Id"],
  squares: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].array(mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].reference(mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].late(function () {
    return _square__WEBPACK_IMPORTED_MODULE_5__["default"];
  }))),
  filter: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].optional(_filter__WEBPACK_IMPORTED_MODULE_4__["default"], function () {
    return _filter__WEBPACK_IMPORTED_MODULE_4__["default"].create();
  }),
  eliminatedCombos: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].array(mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].array(mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].integer)), function () {
    return [];
  })
}).views(function (self) {
  return {
    get numSquares() {
      return self.squares.length;
    },

    get positions() {
      return self.squares.map(function (square) {
        return square.position;
      });
    },

    get squareValues() {
      return self.squares.map(function (square) {
        return square.value;
      }).filter(function (val) {
        return typeof val === 'number';
      });
    },

    // get boundingBox() {
    //   const sortedSquareRows = self.squares.map(sq => sq.row).sort()
    //   const sortedSquareCols = self.squares.map(sq => sq.col).sort()
    //   const minRow = sortedSquareRows[0]
    //   const minCol = sortedSquareCols[0]
    //   const maxRow = sortedSquareRows[sortedSquareRows.length - 1]
    //   const maxCol = sortedSquareCols[sortedSquareCols.length - 1]
    //   return [[minRow, minCol], [maxRow, maxCol]]
    // },
    get allCombos() {
      return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["combos"])(self.numSquares, {
        min: 1,
        max: self.env.globals.size,
        numRepeatsAllowed: self.numPossibleRepeats
      });
    },

    get filteredCombos() {
      return self.allCombos.filter(self.isFilteredCombo);
    },

    get possibleCombos() {
      return self.allCombos.filter(self.isPossibleCombo);
    },

    get numPossibleRepeats() {
      return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["maxPossibleRepeats"])(self.positions);
    },

    get comboEles() {
      return self.filteredCombos.map(function (combo) {
        var comboEle = self.env.templates.combo.cloneNode(true);
        comboEle.dataset.combo = combo.join(',');
        comboEle.innerText = combo.join(' | ');

        if (self.isEliminatedCombo(combo)) {
          comboEle.classList.add('combo--eliminated');
        }

        return comboEle;
      });
    },

    compareComboEles: function compareComboEles(comboA, comboB) {
      var comboStrA = comboA.dataset.combo;
      var comboStrB = comboB.dataset.combo;

      if (comboStrA === comboStrB) {
        return 0;
      } else if (comboStrA < comboStrB) {
        return -1;
      } else {
        return 1;
      }
    },
    isFilteredCombo: function isFilteredCombo(combo) {
      return self.filter.isPossibleCombo(combo);
    },
    isEliminatedCombo: function isEliminatedCombo(combo) {
      return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["includesArray"])(self.eliminatedCombos, combo);
    },
    isPossibleCombo: function isPossibleCombo(combo) {
      return self.isFilteredCombo(combo) && !self.isEliminatedCombo(combo);
    },
    isPossibleValue: function isPossibleValue(value) {
      return self.possibleCombos.some(function (combo) {
        return _shared_general_util__WEBPACK_IMPORTED_MODULE_2__["includesDistinct"].apply(void 0, [combo].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(self.squareValues), [value]));
      });
    }
  };
}).actions(function (self) {
  return {
    addSquare: function addSquare(square) {
      self.squares.push(square.id);
    },
    toggleCombo: function toggleCombo(combo) {
      Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["togglePresenceInArray"])(self.eliminatedCombos, combo, _shared_general_util__WEBPACK_IMPORTED_MODULE_2__["indexOfArray"]);
    },
    setCombos: function setCombos(combos) {
      var sortedCombos = combos.map(function (combo) {
        return combo.sort();
      });
      self.eliminatedCombos = self.allCombos.filter(function (combo) {
        return !Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["includesArray"])(sortedCombos, combo);
      });
    },
    reset: function reset() {
      self.filter.reset();
      self.eliminatedCombos = [];
    }
  };
});
var Cage = Collection.named('Cage').props({
  operation: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].enumeration('Operation', ['+', '−', '⨉', '÷']),
  result: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].integer,
  autoElimMathImpossibilities: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].boolean, function () {
    return false;
  })
}).views(function (self) {
  var superIsRulePossibleCombo = self.isFilteredCombo;
  return {
    get bounds() {
      var bounds = {
        topSquares: [],
        leftSquares: [],
        anchor: self.squares[0]
      };
      self.squares.forEach(function (square) {
        var isTop = !self.squares.some(square.isBelow);
        var isLeft = !self.squares.some(square.isRightOf);
        if (isTop) bounds.topSquares.push(square);
        if (isLeft) bounds.leftSquares.push(square);

        if (isTop && isLeft && square.comesBefore(bounds.anchor)) {
          bounds.anchor = square;
        }
      });
      return bounds;
    },

    get anchor() {
      return self.bounds.anchor;
    },

    get labelText() {
      return "".concat(self.result, " ").concat(self.operation);
    },

    isFilteredCombo: function isFilteredCombo(combo) {
      return self.rootOptions.autoElimMathImpossibilities || self.autoElimMathImpossibilities ? superIsRulePossibleCombo(combo) && self.isMathematicalPossibility(combo) : superIsRulePossibleCombo(combo);
    },
    isMathematicalPossibility: function isMathematicalPossibility(combo) {
      switch (self.operation) {
        case '+':
          return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["sum"])(combo) === self.result;

        case '−':
          return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["difference"])(combo) === self.result;

        case '⨉':
          return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["product"])(combo) === self.result;

        case '÷':
          return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["quotient"])(combo) === self.result;

        default:
          throw new Error("Operation ".concat(self.operation, " doesn't match one of +, -, \u2A09, or \xF7"));
      }
    }
  };
});
var Group = Collection.named('Group');

/***/ }),

/***/ "./src/scripts/store/filter.js":
/*!*************************************!*\
  !*** ./src/scripts/store/filter.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mobx-state-tree */ "./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js");
/* harmony import */ var _shared_dom_partials__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/dom_partials */ "./src/scripts/shared/dom_partials.js");
/* harmony import */ var _shared_general_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/general_util */ "./src/scripts/shared/general_util.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "./src/scripts/store/base.js");




var FilterPossibility = _base__WEBPACK_IMPORTED_MODULE_3__["GameBase"].named('FilterPossibility').props({
  value: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].integer,
  status: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].enumeration('Status', ['none', 'required', 'eliminated', 'alternative']), function () {
    return 'none';
  })
}).views(function (self) {
  var modeStatusMap = {
    and: 'required',
    not: 'eliminated',
    or: 'alternative'
  };

  var hoverFlag = function hoverFlag(mode) {
    if (self.status === 'none') {
      return "hover-".concat(modeStatusMap[mode]);
    } else if (!self.matchesMode(mode)) {
      return 'not-allowed';
    }
  };

  var getStatusIcon = function getStatusIcon(status) {
    return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["stringSwitch"])(status, function (_ref) {
      var _case = _ref._case;

      _case('required', function () {
        return Object(_shared_dom_partials__WEBPACK_IMPORTED_MODULE_1__["requiredIcons"])();
      });

      _case('eliminated', function () {
        return Object(_shared_dom_partials__WEBPACK_IMPORTED_MODULE_1__["eliminatedIcons"])();
      });

      _case('alternative', function () {
        return Object(_shared_dom_partials__WEBPACK_IMPORTED_MODULE_1__["alternativeIcons"])();
      });

      _case('none', function () {
        return Object(_shared_dom_partials__WEBPACK_IMPORTED_MODULE_1__["baseIcons"])();
      });
    });
  };

  return {
    get noHoverIcons() {
      return getStatusIcon(self.status);
    },

    matchesMode: function matchesMode(mode) {
      return self.status === modeStatusMap[mode];
    },
    hoverIcons: function hoverIcons(mode) {
      return self.status === 'none' ? getStatusIcon(modeStatusMap[mode]) : getStatusIcon(self.status);
    },
    className: function className(mode) {
      return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["generateClassName"])('filter-possibility', [self.status, hoverFlag(mode)]);
    }
  };
}).actions(function (self) {
  return {
    toggle: function toggle(status) {
      if (self.status === status) {
        self.status = 'none';
      } else if (self.status === 'none') {
        self.status = status;
      } else {
        console.log("Cannot toggle from ".concat(self.status, " to ").concat(status));
      }
    }
  };
});
var Filter = _base__WEBPACK_IMPORTED_MODULE_3__["GameBase"].named('Filter').props({
  possibilities: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].array(FilterPossibility), function () {
    return [];
  })
}).views(function (self) {
  return {
    get required() {
      return self.possibilities.filter(function (possibility) {
        return possibility.status === 'required';
      });
    },

    get requiredValues() {
      return self.required.map(function (possibility) {
        return possibility.value;
      });
    },

    get eliminated() {
      return self.possibilities.filter(function (possibility) {
        return possibility.status === 'eliminated';
      });
    },

    get eliminatedValues() {
      return self.eliminated.map(function (possibility) {
        return possibility.value;
      });
    },

    get alternatives() {
      return self.possibilities.filter(function (possibility) {
        return possibility.status === 'alternative';
      });
    },

    get alternativeValues() {
      return self.alternatives.map(function (possibility) {
        return possibility.value;
      });
    },

    getPossibilityByValue: function getPossibilityByValue(val) {
      return self.possibilities.find(function (possibility) {
        return possibility.value === val;
      });
    },
    filterPossibilityStatus: function filterPossibilityStatus(val) {
      return self.getPossibilityByValue(val).status;
    },
    isRequiredValue: function isRequiredValue(val) {
      return self.filterPossibilityStatus(val) === 'required';
    },
    isEliminatedValue: function isEliminatedValue(val) {
      return self.filterPossibilityStatus(val) === 'eliminated';
    },
    isAlternativeValue: function isAlternativeValue(val) {
      return self.filterPossibilityStatus(val) === 'alternative';
    },
    isStandardValue: function isStandardValue(val) {
      return self.filterPossibilityStatus(val) === 'none';
    },
    isPossibleCombo: function isPossibleCombo(combo) {
      return self.requiredValues.every(function (val) {
        return combo.includes(val);
      }) && self.eliminatedValues.every(function (val) {
        return !combo.includes(val);
      }) && (self.alternativeValues.length === 0 || self.alternativeValues.some(function (val) {
        return combo.includes(val);
      }));
    },
    noHoverIcons: function noHoverIcons(val) {
      return self.getPossibilityByValue(val).noHoverIcons;
    },
    hoverIcons: function hoverIcons(val, mode) {
      return self.getPossibilityByValue(val).hoverIcons(mode);
    },
    className: function className(val, mode) {
      return self.getPossibilityByValue(val).className(mode);
    }
  };
}).actions(function (self) {
  return {
    initialize: function initialize(size) {
      self.possibilities = Array.from(Array(size), function (_, idx) {
        return FilterPossibility.create({
          value: idx + 1
        });
      });
    },
    toggle: function toggle(val, mode) {
      var status = Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["stringSwitch"])(mode, function (_ref2) {
        var _case = _ref2._case;

        _case('and', function () {
          return 'required';
        });

        _case('not', function () {
          return 'eliminated';
        });

        _case('or', function () {
          return 'alternative';
        });
      });
      self.getPossibilityByValue(val).toggle(status);
    },
    clearMode: function clearMode(mode) {
      self.possibilities.forEach(function (possibility) {
        if (possibility.matchesMode(mode)) {
          possibility.status = 'none';
        }
      });
    },
    reset: function reset() {
      self.possibilities.forEach(function (possibility) {
        return possibility.status = 'none';
      });
    }
  };
});
/* harmony default export */ __webpack_exports__["default"] = (Filter);

/***/ }),

/***/ "./src/scripts/store/game.js":
/*!***********************************!*\
  !*** ./src/scripts/store/game.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mobx-state-tree */ "./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base */ "./src/scripts/store/base.js");
/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui */ "./src/scripts/store/ui.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./options */ "./src/scripts/store/options.js");
/* harmony import */ var _puzzle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./puzzle */ "./src/scripts/store/puzzle.js");
/* harmony import */ var _meta__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./meta */ "./src/scripts/store/meta.js");
/* harmony import */ var _shared_general_util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../shared/general_util */ "./src/scripts/shared/general_util.js");
/* harmony import */ var _shared_storage_util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../shared/storage_util */ "./src/scripts/shared/storage_util.js");



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }










var Game = _base__WEBPACK_IMPORTED_MODULE_4__["GameBase"].named('Game').props({
  puzzle: mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["types"].optional(_puzzle__WEBPACK_IMPORTED_MODULE_7__["default"], function () {
    return _puzzle__WEBPACK_IMPORTED_MODULE_7__["default"].create();
  }),
  curPuzzleIdx: mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["types"].integer, 0),
  meta: mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["types"].optional(_meta__WEBPACK_IMPORTED_MODULE_8__["default"], function () {
    return _meta__WEBPACK_IMPORTED_MODULE_8__["default"].create();
  }),
  options: mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["types"].optional(_options__WEBPACK_IMPORTED_MODULE_6__["default"], function () {
    return _options__WEBPACK_IMPORTED_MODULE_6__["default"].create();
  }),
  ui: mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["types"].optional(_ui__WEBPACK_IMPORTED_MODULE_5__["default"], function () {
    return _ui__WEBPACK_IMPORTED_MODULE_5__["default"].create();
  })
}).volatile(function (self) {
  return {
    storedSnapshot: null
  };
}).extend(function (self) {
  var takePuzzleSnapshot = function takePuzzleSnapshot() {
    var snapshotId = parseInt(Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_9__["nextId"])());
    var puzzle = Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["getSnapshot"])(self.puzzle);
    self.env.snapshots[snapshotId] = puzzle;
    return snapshotId;
  };

  var getOrSetPuzzle = function getOrSetPuzzle(id) {
    var cachedGame = self.env.puzzleCache.get(id);

    if (cachedGame) {
      return cachedGame.puzzle;
    } else {
      var puzzle = _puzzle__WEBPACK_IMPORTED_MODULE_7__["default"].create(self.env.snapshots[id]);
      self.env.puzzleCache.set(id, Game.create({
        puzzle: puzzle
      }, self.env));
      return puzzle;
    }
  };

  var getNewPuzzleIdx = function getNewPuzzleIdx() {
    var puzzles = self.env.puzzles;
    var randomIdx = Math.floor(Math.random() * puzzles.length);
    return randomIdx === self.curPuzzleIdx ? getNewPuzzleIdx() : randomIdx;
  };

  var noHistory = function noHistory() {
    window.setTimeout(function () {
      self.env.history.pop();
    }, 0);
  };

  var ifCurSquareEmpty = function ifCurSquareEmpty(cb) {
    if (self.ui.curSquare.hasValue) {
      noHistory();
    } else {
      cb();
    }
  };

  var getStoredSnapshot = function getStoredSnapshot() {
    return self.storedSnapshot ? Promise.resolve(self.storedSnapshot) : Object(_shared_storage_util__WEBPACK_IMPORTED_MODULE_10__["dbGet"])('gameStore').then(function (snapshot) {
      self.setStoredSnapshot(snapshot);
      return snapshot;
    });
  };

  var recordedActions = {
    setFocusedSquare: function setFocusedSquare(value) {
      if (self.options.autoBlock && !self.ui.curSquare.isPossibleValue(value)) {
        self.ui.curSquare.conflictingSquares(value).forEach(function (square) {
          return square.setConflict();
        });
        self.ui.curSquare.setMistake(value);
        window.setTimeout(function () {
          self.env.history.pop();
        }, 0);
      } else {
        self.ui.curSquare.value = value;
        self.ui.isStaging = false;
      }
    },
    toggleFocusedSquarePossibility: function toggleFocusedSquarePossibility(val) {
      ifCurSquareEmpty(function () {
        return self.ui.curSquare.togglePossibility(val);
      });
    },
    resetFocusedSquarePossibilities: function resetFocusedSquarePossibilities() {
      var square = self.ui.curSquare;

      if (!square.hasEliminations && !square.hasValue) {
        noHistory();
      } else {
        self.ui.curSquare.eliminatedPossibilities = [];
        self.ui.curSquare.value = null;
      }
    },
    setStagedPossibilities: function setStagedPossibilities() {
      ifCurSquareEmpty(function () {
        self.ui.curSquare.setStagedPossibilities();
        self.ui.clearStagedPossibilities();
      });
    },
    clearFocusedSquare: function clearFocusedSquare() {
      self.setFocusedSquare(null);
    },
    toggleSelectionPossibility: function toggleSelectionPossibility(val) {
      self.ui.toggleSelectionPossibility(val);
    },
    toggleCurCageCombo: function toggleCurCageCombo(combo) {
      self.ui.curCage.toggleCombo(combo);
    },
    toggleFilterPossibility: function toggleFilterPossibility(val) {
      self.ui.toggleFilterPossibility(val);
    },
    clearFilterMode: function clearFilterMode() {
      self.ui.clearFilterMode();
    },
    clearFilter: function clearFilter() {
      self.ui.clearFilter();
    },
    enterIf: function enterIf() {
      var mainSnapshotId = takePuzzleSnapshot();
      self.meta.enterIf(mainSnapshotId);
    },
    enterThen: function enterThen() {
      var ifSnapshotId = takePuzzleSnapshot();
      self.meta.enterThen(ifSnapshotId);
    },
    finishImplication: function finishImplication() {
      var thenSnapshotId = takePuzzleSnapshot();
      self.meta.setImplication(thenSnapshotId);
      self.exitImplication();
    },
    exitImplication: function exitImplication() {
      Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["applySnapshot"])(self.puzzle, self.meta.mainSnapshot);
      self.meta.clearImplication();
    }
  };
  var silentActions = {
    newPuzzle: function newPuzzle() {
      var newIdx = getNewPuzzleIdx();
      self.curPuzzleIdx = newIdx;
      self.ui.reset();
      self.puzzle = _puzzle__WEBPACK_IMPORTED_MODULE_7__["default"].create();
      self.initialize();
    },
    resetPuzzle: function resetPuzzle() {
      self.ui.reset();
      self.puzzle.reset();
    },
    resetToStoredSnapshot: Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["flow"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee() {
      var snapshot;
      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return getStoredSnapshot();

            case 2:
              snapshot = _context.sent;
              console.log(snapshot);

              try {
                Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["applySnapshot"])(self, snapshot);
                self.resetPuzzle();
                self.options.reset();
              } catch (_unused) {
                self.initialize();
              }

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })),
    applyStoredSnapshot: Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["flow"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee2() {
      var snapshot;
      return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return getStoredSnapshot();

            case 2:
              snapshot = _context2.sent;

              try {
                Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["applySnapshot"])(self, snapshot);
              } catch (_unused2) {
                console.log('Unable to apply stored snapshot');
              }

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })),
    setStoredSnapshot: function setStoredSnapshot(snapshot) {
      self.storedSnapshot = snapshot;
    },
    initialize: function initialize() {
      var _self$env$puzzles$sel = self.env.puzzles[self.curPuzzleIdx],
          cages = _self$env$puzzles$sel.cages,
          solution = _self$env$puzzles$sel.solution;
      cages.forEach(function (_ref) {
        var operation = _ref.operation,
            result = _ref.result,
            squares = _ref.squares;
        var cage = self.puzzle.cages.put({
          operation: operation,
          result: result
        });
        cage.filter.initialize(self.env.globals.size);
        squares.forEach(function (position) {
          var square = self.puzzle.squares.put({
            position: position,
            solution: solution[position[0]][position[1]],
            cage: cage.id
          });
          cage.addSquare(square);
        });
      });
    },
    attachHooks: function attachHooks() {
      Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["onAction"])(self, function (action) {
        if (self.shouldRecordAction(action)) {
          self.env.future = [];
          self.env.history.push(self.currentState);
        }
      });
      Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["onSnapshot"])(self, function (snapshot) {
        Object(_shared_storage_util__WEBPACK_IMPORTED_MODULE_10__["dbAdd"])('gameStore', snapshot);
        var _self$env = self.env,
            history = _self$env.history,
            snapshots = _self$env.snapshots,
            future = _self$env.future;
        Object(_shared_storage_util__WEBPACK_IMPORTED_MODULE_10__["dbAdd"])('env', {
          history: history,
          snapshots: snapshots,
          future: future
        });
      });
    },
    beginStaging: function beginStaging() {
      if (!self.ui.curSquare.hasValue) {
        self.ui.isStaging = true;
      }
    },
    stopStaging: function stopStaging() {
      self.ui.isStaging = false;

      if (self.ui.hasStagedPossibilities) {
        self.setStagedPossibilities();
      }
    },
    toggleStagedPossibility: function toggleStagedPossibility(val) {
      self.ui.toggleStagedPossibility(val);
    },
    clearStagedPossibilities: function clearStagedPossibilities() {
      self.ui.clearStagedPossibilities();
    },
    selectSquareByDir: function selectSquareByDir(dir) {
      self.ui.selectSquareByDir(dir);
    },
    selectSquareByPos: function selectSquareByPos(pos) {
      self.ui.selectSquareByPos(pos);
    },
    selectSquareById: function selectSquareById(id) {
      self.ui.selectSquareById(id);
    },
    clearFocus: function clearFocus() {
      self.ui.curSquare = null;
    },
    undoOrRedo: function undoOrRedo(_ref2) {
      var popFrom = _ref2.popFrom,
          pushTo = _ref2.pushTo;

      if (popFrom.length > 0) {
        pushTo.push(self.currentState);
        var nextState = popFrom.pop();
        Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["applySnapshot"])(self.puzzle, nextState.puzzle);
        Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["applySnapshot"])(self.meta, nextState.meta);
      }
    },
    undo: function undo() {
      self.undoOrRedo({
        popFrom: self.env.history,
        pushTo: self.env.future
      });
    },
    redo: function redo() {
      self.undoOrRedo({
        popFrom: self.env.future,
        pushTo: self.env.history
      });
    }
  };
  return {
    views: {
      get recordedActions() {
        return Object.keys(recordedActions);
      },

      get currentState() {
        return {
          puzzle: Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["getSnapshot"])(self.puzzle),
          meta: Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_3__["getSnapshot"])(self.meta)
        };
      },

      shouldRecordAction: function shouldRecordAction(action) {
        return self.recordedActions.includes(action.name);
      },
      implicationPuzzles: function implicationPuzzles() {
        return self.meta.implications.map(self.getPuzzlesFromImplication);
      },
      possibleImplications: function possibleImplications() {
        return self.implicationPuzzles().filter(function (_ref3) {
          var thenPuzzle = _ref3.thenPuzzle;
          return self.isPossiblePuzzle(thenPuzzle);
        });
      },
      fulfilledImplications: function fulfilledImplications() {
        return self.possibleImplications().filter(function (_ref4) {
          var ifPuzzle = _ref4.ifPuzzle;
          return self.isFulfilledPuzzle(ifPuzzle);
        });
      },
      getPuzzlesFromImplication: function getPuzzlesFromImplication(_ref5) {
        var _ref6 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(_ref5, 2),
            ifId = _ref6[0],
            thenId = _ref6[1];

        return {
          ifPuzzle: getOrSetPuzzle(ifId),
          thenPuzzle: getOrSetPuzzle(thenId)
        };
      },
      isPossiblePuzzle: function isPossiblePuzzle(puzzle) {
        return puzzle.squaresArray.every(function (square) {
          var curSquare = self.puzzle.squares.get(square.id);
          return curSquare.isConsistentWith(square);
        });
      },
      isFulfilledPuzzle: function isFulfilledPuzzle(puzzle) {
        return puzzle.squaresArray.every(function (square) {
          var curSquare = self.puzzle.squares.get(square.id);
          return curSquare.isLogicalSubsetOf(square);
        });
      }
    },
    actions: _objectSpread(_objectSpread({}, recordedActions), silentActions)
  };
});
/* harmony default export */ __webpack_exports__["default"] = (Game);

/***/ }),

/***/ "./src/scripts/store/meta.js":
/*!***********************************!*\
  !*** ./src/scripts/store/meta.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mobx-state-tree */ "./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./src/scripts/store/base.js");
/* harmony import */ var _puzzle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./puzzle */ "./src/scripts/store/puzzle.js");



var Meta = _base__WEBPACK_IMPORTED_MODULE_1__["GameBase"].named('Meta').props({
  implications: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].array(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].array(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].number)), function () {
    return [];
  }),
  mainId: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].maybeNull(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].integer),
  ifId: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].maybeNull(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].integer),
  mode: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__["types"].enumeration('Mode', ['main', 'if', 'then']), function () {
    return 'main';
  })
}).volatile(function (self) {
  return {
    _stagedMain: {
      id: null,
      puzzle: null
    },
    _stagedIf: {
      id: null,
      puzzle: null
    }
  };
}).views(function (self) {
  return {
    get mainSnapshot() {
      return self.env.snapshots[self.mainId];
    },

    get ifSnapshot() {
      return self.env.snapshots[self.ifId];
    },

    get stagedMain() {
      var _self$_stagedMain = self._stagedMain,
          id = _self$_stagedMain.id,
          puzzle = _self$_stagedMain.puzzle;

      if (self.mode !== 'if' && self.mode !== 'then') {
        return null;
      } else if (id === self.mainId && puzzle) {
        return puzzle;
      } else {
        var _puzzle = _puzzle__WEBPACK_IMPORTED_MODULE_2__["default"].create(self.mainSnapshot);

        self._stagedMain = {
          id: self.mainId,
          puzzle: _puzzle
        };
        return _puzzle;
      }
    },

    get stagedIf() {
      var _self$_stagedIf = self._stagedIf,
          id = _self$_stagedIf.id,
          puzzle = _self$_stagedIf.puzzle;

      if (self.mode !== 'then') {
        return null;
      } else if (id === self.ifId && puzzle) {
        return puzzle;
      } else {
        var _puzzle2 = _puzzle__WEBPACK_IMPORTED_MODULE_2__["default"].create(self.ifSnapshot);

        self._stagedIf = {
          id: self.ifId,
          puzzle: _puzzle2
        };
        return _puzzle2;
      }
    }

  };
}).actions(function (self) {
  return {
    enterIf: function enterIf(mainId) {
      self.mainId = mainId;
      self.mode = 'if';
    },
    enterThen: function enterThen(ifId) {
      self.ifId = ifId;
      self.mode = 'then';
    },
    setImplication: function setImplication(thenId) {
      var implication = [self.ifId, thenId];
      self.implications.push(implication);
    },
    clearImplication: function clearImplication() {
      self._stagedMain = {
        id: null,
        puzzle: null
      };
      self._stagedIf = {
        id: null,
        puzzle: null
      };
      self.mainId = null;
      self.ifId = null;
      self.mode = 'main';
    }
  };
});
/* harmony default export */ __webpack_exports__["default"] = (Meta);

/***/ }),

/***/ "./src/scripts/store/options.js":
/*!**************************************!*\
  !*** ./src/scripts/store/options.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shared_general_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/general_util */ "./src/scripts/shared/general_util.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./src/scripts/store/base.js");


var Options = _base__WEBPACK_IMPORTED_MODULE_1__["GameBase"].named('Options').props({
  autoBlock: true,
  autoEliminate: true,
  autoElimMathImpossibilities: true,
  maxDisplayedPossibilities: 9,
  walkthrough: false
}).views(function (self) {
  return {
    get autoBlockClassName() {
      return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_0__["generateClassName"])('toggle', [[self.autoBlock, 'on']]);
    },

    get autoElimClassName() {
      return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_0__["generateClassName"])('toggle', [[self.autoEliminate, 'on']]);
    },

    get autoElimMathImpossibilitiesClassName() {
      return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_0__["generateClassName"])('toggle', [[self.autoElimMathImpossibilities, 'on']]);
    },

    get walkthroughClassName() {
      return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_0__["generateClassName"])('toggle', [[self.walkthrough, 'on']]);
    }

  };
}).actions(function (self) {
  return {
    setOption: function setOption(option, val) {
      self[option] = val;
    },
    toggleAutoBlock: function toggleAutoBlock() {
      self.autoBlock = !self.autoBlock;
    },
    toggleAutoEliminate: function toggleAutoEliminate() {
      self.autoEliminate = !self.autoEliminate;
    },
    toggleAutoElimMathImpossibilities: function toggleAutoElimMathImpossibilities() {
      self.autoElimMathImpossibilities = !self.autoElimMathImpossibilities;
    },
    toggleWalkthrough: function toggleWalkthrough() {
      self.walkthrough = !self.walkthrough;
    },
    setMaxDisplayedPossibilities: function setMaxDisplayedPossibilities(num) {
      if (num < 2 || num > 9) {
        return false;
      } else {
        self.maxDisplayedPossibilities = num;
        return true;
      }
    },
    reset: function reset() {
      self.autoBlock = true;
      self.autoEliminate = true;
      self.autoElimMathImpossibilities = true;
      self.maxDisplayedPossibilities = 9;
      self.alwaysShowWalkthrough = false;
    }
  };
});
/* harmony default export */ __webpack_exports__["default"] = (Options);

/***/ }),

/***/ "./src/scripts/store/puzzle.js":
/*!*************************************!*\
  !*** ./src/scripts/store/puzzle.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mobx-state-tree */ "./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js");
/* harmony import */ var _shared_general_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/general_util */ "./src/scripts/shared/general_util.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "./src/scripts/store/base.js");
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./collections */ "./src/scripts/store/collections.js");
/* harmony import */ var _square__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./square */ "./src/scripts/store/square.js");






var Puzzle = _base__WEBPACK_IMPORTED_MODULE_3__["GameBase"].named('Puzzle').props({
  id: _base__WEBPACK_IMPORTED_MODULE_3__["Id"],
  uuid: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].string, _shared_general_util__WEBPACK_IMPORTED_MODULE_2__["nextId"]),
  squares: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].map(_square__WEBPACK_IMPORTED_MODULE_5__["default"]),
  cages: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].map(_collections__WEBPACK_IMPORTED_MODULE_4__["Cage"]),
  groups: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__["types"].map(_collections__WEBPACK_IMPORTED_MODULE_4__["Group"])
}).views(function (self) {
  var posToIdMap = {};
  return {
    get collections() {
      return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(self.cages.values()), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(self.groups.values()));
    },

    get squaresArray() {
      return Array.from(self.squares.values());
    },

    get cagesArray() {
      return Array.from(self.cages.values());
    },

    get groupsArray() {
      return Array.from(self.groups.values());
    },

    getSquareByPos: function getSquareByPos(pos) {
      if (!self.isValidPos(pos)) return null;
      var strPos = pos.join(',');

      if (!posToIdMap[strPos]) {
        posToIdMap[strPos] = self.squaresArray.find(function (sq) {
          return sq.position.join(',') === strPos;
        });
      }

      return posToIdMap[strPos];
    },
    getSquaresByRow: function getSquaresByRow(row) {
      return self.squaresArray.filter(function (square) {
        return square.row === row;
      });
    },
    getSquaresByCol: function getSquaresByCol(col) {
      return self.squaresArray.filter(function (square) {
        return square.col === col;
      });
    },
    getCollectionsBySquare: function getCollectionsBySquare(square) {
      return self.collections.filter(function (c) {
        return c.squares.includes(square);
      });
    },
    isValidPos: function isValidPos(pos) {
      return pos.every(function (n) {
        return n >= 0 && n <= 9;
      });
    }
  };
}).actions(function (self) {
  return {
    resetUuid: function resetUuid() {
      self.uuid = Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_2__["nextId"])();
    },
    reset: function reset() {
      self.squaresArray.forEach(function (square) {
        return square.reset();
      });
      self.collections.forEach(function (collection) {
        return collection.reset();
      });
    }
  };
});
/* harmony default export */ __webpack_exports__["default"] = (Puzzle);

/***/ }),

/***/ "./src/scripts/store/square.js":
/*!*************************************!*\
  !*** ./src/scripts/store/square.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mobx-state-tree */ "./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js");
/* harmony import */ var _shared_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/constants */ "./src/scripts/shared/constants.js");
/* harmony import */ var _shared_general_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/general_util */ "./src/scripts/shared/general_util.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base */ "./src/scripts/store/base.js");
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./collections */ "./src/scripts/store/collections.js");







var Square = _base__WEBPACK_IMPORTED_MODULE_5__["GameBase"].named('Square').props({
  id: _base__WEBPACK_IMPORTED_MODULE_5__["Id"],
  position: _base__WEBPACK_IMPORTED_MODULE_5__["Position"],
  cage: mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].maybeNull(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].reference(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].late(function () {
    return _collections__WEBPACK_IMPORTED_MODULE_6__["Cage"];
  }))),
  value: mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].maybeNull(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].integer),
  mistakeValue: mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].maybeNull(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].integer),
  solution: mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].integer,
  eliminatedPossibilities: mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].array(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].integer), function () {
    return [];
  }),
  status: mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].enumeration('Status', ['none', 'mistake', 'conflict']), function () {
    return 'none';
  })
}).extend(function (self) {
  var initialPossibilities = Array.from(Array(9), function (_, idx) {
    return idx + 1;
  });
  return {
    views: {
      get collections() {
        return self.rootPuzzle.getCollectionsBySquare(self);
      },

      get rowSquares() {
        return self.rootPuzzle.getSquaresByRow(self.row).filter(function (square) {
          return square !== self;
        });
      },

      get colSquares() {
        return self.rootPuzzle.getSquaresByCol(self.col).filter(function (square) {
          return square !== self;
        });
      },

      get rowColSquares() {
        return [].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(self.rowSquares), _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(self.colSquares));
      },

      get rowColValues() {
        return self.rowColSquares.map(function (square) {
          return square.value;
        }).filter(function (val) {
          return typeof val === 'number';
        });
      },

      get collectionPossibilities() {
        return initialPossibilities.filter(function (val) {
          return self.collections.every(function (c) {
            return c.isPossibleValue(val);
          });
        });
      },

      get squarePossiblities() {
        return initialPossibilities.filter(function (val) {
          return !self.eliminatedPossibilities.includes(val);
        });
      },

      get squareAndCollectionPossibilities() {
        return self.collectionPossibilities.filter(function (val) {
          return self.squarePossiblities.includes(val);
        });
      },

      get possibilities() {
        return self.hasValue ? [self.value] : self.squareAndCollectionPossibilities.filter(function (val) {
          return !self.isAutoEliminatedValue(val);
        });
      },

      get dataPos() {
        return self.position.join(',');
      },

      get row() {
        return self.position[0];
      },

      get col() {
        return self.position[1];
      },

      get isCorrect() {
        return self.value === self.solution;
      },

      get isCageTop() {
        return self.row > 0 && self.cage.bounds.topSquares.includes(self);
      },

      get isCageLeft() {
        return self.col > 0 && self.cage.bounds.leftSquares.includes(self);
      },

      get isFocused() {
        return self.rootUi.curSquare === self;
      },

      get isSelected() {
        return !self.isFocused && self.rootUi.selectedSquares.includes(self);
      },

      get isStaging() {
        return self.isFocused && self.rootUi.isStaging;
      },

      get hasEliminations() {
        return self.eliminatedPossibilities.length > 0;
      },

      get hasValue() {
        return typeof self.value === 'number';
      },

      get label() {
        return self.cage.anchor === self ? self.cage.labelText : '';
      },

      get displayedValue() {
        return self.status === 'mistake' ? self.mistakeValue : self.value;
      },

      get displayedPossibilities() {
        return self.isStaging ? self.rootUi.stagedPossibilities : self.possibilities;
      },

      get className() {
        return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_4__["generateClassName"])('square', [[self.status !== 'none', self.status], [self.isFocused, 'focused'], [self.isSelected, 'selected']]);
      },

      get shouldShowPossibilities() {
        return self.rootOptions.maxDisplayedPossibilities >= self.displayedPossibilities.length && self.value === null && self.mistakeValue === null;
      },

      get initialHtml() {
        var ele = self.env.templates.square.cloneNode(true);
        ele.dataset.pos = self.dataPos;
        return ele;
      },

      conflictingSquares: function conflictingSquares(val) {
        return val === null ? [] : self.rowColSquares.filter(function (square) {
          return square.value === val;
        });
      },
      possibilityStatuses: function possibilityStatuses(val) {
        if (self.hasValue) {
          return self.value === val ? ['chosen'] : ['unchosen'];
        } else {
          var statuses = [];

          if (self.isSquareEliminatedValue(val)) {
            statuses.push('square-eliminated');
          }

          if (self.isCollectionEliminatedValue(val)) {
            statuses.push('collection-eliminated');
          }

          if (self.isAutoEliminatedValue(val)) {
            statuses.push('auto-eliminated');
          }

          return statuses.length > 0 ? statuses : ['possible'];
        }
      },
      isPossibleValue: function isPossibleValue(val) {
        return val === null || val === self.value ? true : self.possibilities.includes(val);
      },
      isSquareEliminatedValue: function isSquareEliminatedValue(val) {
        return self.eliminatedPossibilities.includes(val);
      },
      isCollectionEliminatedValue: function isCollectionEliminatedValue(val) {
        return !self.collectionPossibilities.includes(val);
      },
      isAutoEliminatedValue: function isAutoEliminatedValue(val) {
        return self.rootOptions.autoEliminate && self.rowColValues.includes(val);
      },
      isActiveMistake: function isActiveMistake(val) {
        return self.status === 'mistake' && self.mistakeValue === val && !self.isAutoEliminatedValue(val);
      },
      isStagedPossibility: function isStagedPossibility(val) {
        return self.rootUi.stagedPossibilities.includes(val);
      },
      isVisiblePossibility: function isVisiblePossibility(val) {
        return self.shouldShowPossibilities && self.displayedPossibilities.includes(val);
      },
      possibilityClassName: function possibilityClassName(val) {
        return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_4__["generateClassName"])('square_possibility', [[self.isVisiblePossibility(val), 'show']]);
      },
      infoPossibilityStagingClassName: function infoPossibilityStagingClassName(val) {
        return self.isStagedPossibility(val) ? 'possible' : 'staged-eliminated';
      },
      infoPossibilityClassName: function infoPossibilityClassName(val) {
        return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_4__["generateClassName"])('square-info_possibility', self.isStaging ? [self.infoPossibilityStagingClassName(val)] : [[self.isActiveMistake(val), 'mistake']].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(self.possibilityStatuses(val))));
      },
      infoPossibilityIconClassNames: function infoPossibilityIconClassNames(val) {
        if (self.isStaging) {
          return self.isStagedPossibility(val) ? {
            hover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].ban,
            noHover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].circle
          } : {
            hover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].circle,
            noHover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].ban
          };
        } else {
          return self.isSquareEliminatedValue(val) && !self.hasValue ? {
            hover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].ban,
            noHover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].ban
          } : {
            hover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].ban,
            noHover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].circle
          };
        }
      },
      isBelow: function isBelow(otherSquare) {
        return otherSquare.row === self.row - 1 && otherSquare.col === self.col;
      },
      isRightOf: function isRightOf(otherSquare) {
        return otherSquare.row === self.row && otherSquare.col === self.col - 1;
      },
      isAbove: function isAbove(otherSquare) {
        return otherSquare.isBelow(self);
      },
      isLeftOf: function isLeftOf(otherSquare) {
        return otherSquare.isRightOf(self);
      },
      comesBefore: function comesBefore(otherSquare) {
        switch (Math.sign(otherSquare.row - self.row)) {
          case 1:
            return true;

          case 0:
            return otherSquare.col > self.col;

          case -1:
            return false;
        }
      },
      isLogicalSupersetOf: function isLogicalSupersetOf(otherSquare) {
        return otherSquare.possibilities.every(self.isPossibleValue);
      },
      isLogicalSubsetOf: function isLogicalSubsetOf(otherSquare) {
        return otherSquare.isLogicalSupersetOf(self);
      },
      isConsistentWith: function isConsistentWith(otherSquare) {
        var possibilityOverlap = Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_4__["arrayUnion"])(otherSquare.possibilities, self.possibilities);
        return possibilityOverlap.length > 0;
      }
    },
    actions: {
      setMistake: Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["flow"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee(val) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                self.mistakeValue = val;
                self.status = 'mistake';
                _context.next = 4;
                return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_4__["wait"])(self.env.globals.mistakeTimeoutMs);

              case 4:
                self.status = 'none';
                self.mistakeValue = null;

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })),
      setConflict: Object(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["flow"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee2() {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                self.status = 'conflict';
                _context2.next = 3;
                return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_4__["wait"])(self.env.globals.mistakeTimeoutMs);

              case 3:
                self.status = 'none';

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      })),
      togglePossibility: function togglePossibility(val) {
        Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_4__["togglePresenceInArray"])(self.eliminatedPossibilities, val);
      },
      eliminatePossibility: function eliminatePossibility(val) {
        Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_4__["pushIfNotIncluded"])(self.eliminatedPossibilities, val);
      },
      uneliminatePossibility: function uneliminatePossibility(val) {
        Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_4__["removeIfIncluded"])(self.eliminatedPossibilities, val);
      },
      setStagedPossibilities: function setStagedPossibilities() {
        self.eliminatedPossibilities = initialPossibilities.filter(function (num) {
          return !self.rootUi.stagedPossibilities.includes(num);
        });
      },
      reset: function reset() {
        self.status = 'none';
        self.value = null;
        self.mistakeValue = null;
        self.eliminatedPossibilities = [];
      }
    }
  };
});
/* harmony default export */ __webpack_exports__["default"] = (Square);

/***/ }),

/***/ "./src/scripts/store/ui.js":
/*!*********************************!*\
  !*** ./src/scripts/store/ui.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mobx-state-tree */ "./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js");
/* harmony import */ var _shared_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/constants */ "./src/scripts/shared/constants.js");
/* harmony import */ var _shared_dom_partials__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/dom_partials */ "./src/scripts/shared/dom_partials.js");
/* harmony import */ var _shared_general_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/general_util */ "./src/scripts/shared/general_util.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./base */ "./src/scripts/store/base.js");
/* harmony import */ var _collections__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./collections */ "./src/scripts/store/collections.js");
/* harmony import */ var _square__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./square */ "./src/scripts/store/square.js");









var UI = _base__WEBPACK_IMPORTED_MODULE_6__["GameBase"].named('UI').props({
  curSquare: mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].maybeNull(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].reference(_square__WEBPACK_IMPORTED_MODULE_8__["default"])),
  curCollection: mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].maybeNull(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].union(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].reference(_collections__WEBPACK_IMPORTED_MODULE_7__["Group"]), mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].reference(_collections__WEBPACK_IMPORTED_MODULE_7__["Cage"]))),
  isStaging: mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].boolean, function () {
    return false;
  }),
  stagedPossibilities: mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].array(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].integer), function () {
    return [];
  }),
  filterMode: mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].enumeration('FilterMode', ['and', 'not', 'or']), function () {
    return 'and';
  }),
  selectedSquares: mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].optional(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].array(mobx_state_tree__WEBPACK_IMPORTED_MODULE_2__["types"].reference(_square__WEBPACK_IMPORTED_MODULE_8__["default"])), function () {
    return [];
  })
}).views(function (self) {
  return {
    get curPosition() {
      var _self$curSquare;

      return (_self$curSquare = self.curSquare) === null || _self$curSquare === void 0 ? void 0 : _self$curSquare.position;
    },

    get curCage() {
      var _self$curSquare2;

      return (_self$curSquare2 = self.curSquare) === null || _self$curSquare2 === void 0 ? void 0 : _self$curSquare2.cage;
    },

    get curCageFilteredCombos() {
      var _self$curCage;

      return ((_self$curCage = self.curCage) === null || _self$curCage === void 0 ? void 0 : _self$curCage.filteredCombos) || [];
    },

    get curCagePossibleCombos() {
      var _self$curCage2;

      return ((_self$curCage2 = self.curCage) === null || _self$curCage2 === void 0 ? void 0 : _self$curCage2.possibleCombos) || [];
    },

    get hasStagedPossibilities() {
      return self.stagedPossibilities.length > 0;
    },

    get squareInfoSelectClassName() {
      return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_5__["generateClassName"])('square-info_btn', [[!self.curSquare || self.curSquare.hasValue, 'disabled']]);
    },

    get squareInfoClearClassName() {
      return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_5__["generateClassName"])('square-info_btn', [[!self.curSquare, 'disabled']]);
    },

    get squareInfoSelectIconClassName() {
      return self.isStaging ? _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].confirm : _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].select;
    },

    get squareInfoClearIconClassName() {
      return self.isStaging ? _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].reset : _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].clear;
    },

    get lastSelectedSquare() {
      return self.selectedSquares[self.selectedSquares.length - 1];
    },

    get hasSelection() {
      return self.selectedSquares.length > 1;
    },

    get shouldShowCollection() {
      return self.curCage && !self.hasSelection;
    },

    get collectionClassName() {
      return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_5__["generateClassName"])('collection-info', [[self.shouldShowCollection, self.filterMode, 'none']]);
    },

    isValidPos: function isValidPos(pos) {
      return pos.every(function (coord) {
        return coord >= 0 && coord < self.env.globals.size;
      });
    },
    isSelectionEliminatedValue: function isSelectionEliminatedValue(val) {
      return self.selectedSquares.every(function (square) {
        return square.isSquareEliminatedValue(val);
      });
    },
    selectionPossibilityStatuses: function selectionPossibilityStatuses(val) {
      var squareStatuses = self.selectedSquares.map(function (square) {
        return square.possibilityStatuses(val);
      });
      var sharedStatuses = ['square-eliminated', 'collection-eliminated', 'auto-eliminated'].filter(function (status) {
        return squareStatuses.every(function (s) {
          return s.includes(status);
        });
      });
      return sharedStatuses.length > 0 ? sharedStatuses : ['possible'];
    },
    filterNoHoverIcons: function filterNoHoverIcons(val) {
      return self.shouldShowCollection ? self.curCage.filter.noHoverIcons(val) : Object(_shared_dom_partials__WEBPACK_IMPORTED_MODULE_4__["baseIcons"])();
    },
    filterHoverIcons: function filterHoverIcons(val) {
      return self.shouldShowCollection ? self.curCage.filter.hoverIcons(val, self.filterMode) : Object(_shared_dom_partials__WEBPACK_IMPORTED_MODULE_4__["baseIcons"])();
    },
    filterPossibilityClassName: function filterPossibilityClassName(val) {
      return self.shouldShowCollection ? self.curCage.filter.className(val, self.filterMode) : Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_5__["generateClassName"])('filter-possibility', ['none', 'disabled']);
    },
    squareInfoPossibilityClassName: function squareInfoPossibilityClassName(val) {
      if (self.hasSelection) {
        return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_5__["generateClassName"])('square-info_possibility', self.selectionPossibilityStatuses(val));
      } else {
        return self.curSquare ? self.curSquare.infoPossibilityClassName(val) : Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_5__["generateClassName"])('square-info_possibility', ['disabled']);
      }
    },
    squareInfoPossibilityIconClassNames: function squareInfoPossibilityIconClassNames(val) {
      if (self.hasSelection) {
        return self.isSelectionEliminatedValue(val) ? {
          hover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].ban,
          noHover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].ban
        } : {
          hover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].ban,
          noHover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].circle
        };
      } else {
        return self.curSquare ? self.curSquare.infoPossibilityIconClassNames(val) : {
          hover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].circle,
          noHover: _shared_constants__WEBPACK_IMPORTED_MODULE_3__["ICONS"].circle
        };
      }
    }
  };
}).actions(function (self) {
  return {
    reset: function reset() {
      self.curSquare = null;
      self.curCollection = null;
      self.isStaging = false;
      self.stagedPossibilities = [];
      self.filterMode = 'and';
      self.selectedSquares = [];
    },
    selectSquareByDir: function selectSquareByDir(dir) {
      var _self$curPosition = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(self.curPosition, 2),
          curRow = _self$curPosition[0],
          curCol = _self$curPosition[1];

      var newPos = Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_5__["stringSwitch"])(dir, function (_ref) {
        var _case = _ref._case;

        _case('Up', function () {
          return [curRow - 1, curCol];
        });

        _case('Right', function () {
          return [curRow, curCol + 1];
        });

        _case('Down', function () {
          return [curRow + 1, curCol];
        });

        _case('Left', function () {
          return [curRow, curCol - 1];
        });
      });
      if (self.isValidPos(newPos)) self.selectSquareByPos(newPos);
    },
    selectSquareByPos: function selectSquareByPos(pos) {
      self.selectSquare(self.rootPuzzle.getSquareByPos(pos));
    },
    selectSquareById: function selectSquareById(id) {
      self.selectSquare(self.rootPuzzle.squares.get(id));
    },
    selectSquare: function selectSquare(square) {
      self.curSquare = square;
      self.selectedSquares = [square];
      self.isStaging = false;
    },
    selectThroughSquare: function selectThroughSquare(squareId) {
      if (self.selectedSquares.length > 0) {
        var _self$selectedSquares;

        var nextSquarePos = self.rootPuzzle.squares.get(squareId).position;
        var prevSquarePos = self.lastSelectedSquare.position;

        (_self$selectedSquares = self.selectedSquares).push.apply(_self$selectedSquares, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_5__["getInterveningPositions"])(prevSquarePos, nextSquarePos).map(function (pos) {
          return self.rootPuzzle.getSquareByPos(pos);
        }).filter(function (square) {
          return !self.selectedSquares.includes(square);
        })));
      }
    },
    toggleSelectedSquare: function toggleSelectedSquare(squareId) {
      Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_5__["togglePresenceInArray"])(self.selectedSquares, squareId, function () {
        return self.selectedSquares.findIndex(function (s) {
          return s.id === squareId;
        });
      });
      if (self.curSquare.id === squareId) self.curSquare = null;
    },
    clearStagedPossibilities: function clearStagedPossibilities() {
      self.stagedPossibilities = [];
    },
    toggleStagedPossibility: function toggleStagedPossibility(val) {
      var valIndex = self.stagedPossibilities.indexOf(val);

      if (valIndex >= 0) {
        self.stagedPossibilities.splice(valIndex, 1);
      } else {
        self.stagedPossibilities.push(val);
      }
    },
    toggleSelectionPossibility: function toggleSelectionPossibility(val) {
      if (self.isSelectionEliminatedValue(val)) {
        self.selectedSquares.forEach(function (square) {
          return square.uneliminatePossibility(val);
        });
      } else {
        self.selectedSquares.forEach(function (square) {
          return square.eliminatePossibility(val);
        });
      }
    },
    clearSelectedSquares: function clearSelectedSquares() {
      self.selectedSquares = [];
    },
    toggleFilterPossibility: function toggleFilterPossibility(val) {
      self.curCage.filter.toggle(val, self.filterMode);
    },
    clearFilterMode: function clearFilterMode() {
      if (self.curCage) {
        self.curCage.filter.clearMode(self.filterMode);
      }
    },
    clearFilter: function clearFilter() {
      if (self.curCage) {
        self.curCage.filter.initialize(self.env.globals.size);
      }
    },
    setFilterMode: function setFilterMode(mode) {
      self.filterMode = mode;
    },
    changeFilterModeByDir: function changeFilterModeByDir(dir) {
      var modes = ['and', 'not', 'or'];
      var idxDiff = dir === 'Left' ? -1 : 1;
      var newIdx = (modes.indexOf(self.filterMode) + idxDiff + 3) % 3;
      self.filterMode = modes[newIdx];
    }
  };
});
/* harmony default export */ __webpack_exports__["default"] = (UI);

/***/ }),

/***/ "./src/scripts/views/header_view.js":
/*!******************************************!*\
  !*** ./src/scripts/views/header_view.js ***!
  \******************************************/
/*! exports provided: setupHeader, getHeaderElements */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupHeader", function() { return setupHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHeaderElements", function() { return getHeaderElements; });
/* harmony import */ var _setup_setup_puzzle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../setup/setup_puzzle */ "./src/scripts/setup/setup_puzzle.js");
/* harmony import */ var _shared_dom_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/dom_util */ "./src/scripts/shared/dom_util.js");


function setupHeader(_ref) {
  var gameStore = _ref.gameStore,
      env = _ref.env,
      elements = _ref.elements,
      _ref$elements$headerE = _ref.elements.headerEles,
      aboutButton = _ref$elements$headerE.aboutButton,
      aboutDropdown = _ref$elements$headerE.aboutDropdown,
      instructionsButton = _ref$elements$headerE.instructionsButton,
      instructionsDropdown = _ref$elements$headerE.instructionsDropdown,
      optionsButton = _ref$elements$headerE.optionsButton,
      optionsDropdown = _ref$elements$headerE.optionsDropdown,
      undoButton = _ref$elements$headerE.undoButton,
      redoButton = _ref$elements$headerE.redoButton,
      newButton = _ref$elements$headerE.newButton,
      resetButton = _ref$elements$headerE.resetButton;
  Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_1__["mountDropdown"])(aboutButton, aboutDropdown, 'show');
  Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_1__["mountDropdown"])(instructionsButton, instructionsDropdown, 'show');
  Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_1__["mountDropdown"])(optionsButton, optionsDropdown, 'show');
  Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_1__["addNoFocusClickListener"])(undoButton, gameStore.undo);
  Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_1__["addNoFocusClickListener"])(redoButton, gameStore.redo);
  Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_1__["addNoFocusClickListener"])(newButton, function () {
    return Object(_setup_setup_puzzle__WEBPACK_IMPORTED_MODULE_0__["newPuzzle"])({
      gameStore: gameStore,
      env: env,
      elements: elements
    });
  });
  Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_1__["addNoFocusClickListener"])(resetButton, function () {
    return Object(_setup_setup_puzzle__WEBPACK_IMPORTED_MODULE_0__["resetPuzzle"])({
      gameStore: gameStore,
      env: env,
      elements: elements
    });
  });
}
function getHeaderElements() {
  return {
    aboutButton: document.querySelector('#header-about'),
    aboutDropdown: document.querySelector('#header-about .header_dropdown'),
    instructionsButton: document.querySelector('#header-instructions'),
    instructionsDropdown: document.querySelector('#header-instructions .header_dropdown'),
    optionsButton: document.querySelector('#header-options'),
    optionsDropdown: document.querySelector('#header-options .header_dropdown'),
    undoButton: document.querySelector('#header-undo'),
    redoButton: document.querySelector('#header-redo'),
    newButton: document.querySelector('#header-new'),
    resetButton: document.querySelector('#header-reset')
  };
}

/***/ }),

/***/ "./src/scripts/views/info_collection_view.js":
/*!***************************************************!*\
  !*** ./src/scripts/views/info_collection_view.js ***!
  \***************************************************/
/*! exports provided: setupCollectionInfo, getCollectionInfoElements */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupCollectionInfo", function() { return setupCollectionInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCollectionInfoElements", function() { return getCollectionInfoElements; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mobx */ "./node_modules/mobx/dist/mobx.esm.js");
/* harmony import */ var _shared_dom_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/dom_util */ "./src/scripts/shared/dom_util.js");



function setupCollectionInfo(game) {
  setupListeners(game);
  makeReactive(game);
}

function setupListeners(_ref) {
  var gameStore = _ref.gameStore,
      _ref$elements$collect = _ref.elements.collectionInfoEles,
      comboListEle = _ref$elements$collect.comboListEle,
      possibilityEles = _ref$elements$collect.possibilityEles,
      andModeButton = _ref$elements$collect.andModeButton,
      notModeButton = _ref$elements$collect.notModeButton,
      orModeButton = _ref$elements$collect.orModeButton,
      clearModeButton = _ref$elements$collect.clearModeButton,
      clearAllButton = _ref$elements$collect.clearAllButton;
  comboListEle.addEventListener('click', function (e) {
    if (!gameStore.ui.curCage) return;
    var comboEle = e.target.closest('.combo');

    if (comboEle) {
      var combo = comboEle.dataset.combo.split(',').map(function (valStr) {
        return parseInt(valStr);
      });
      gameStore.toggleCurCageCombo(combo);
    }
  });
  Array.from(possibilityEles).map(function (possibilityEle) {
    var val = parseInt(possibilityEle.dataset.val);

    function restoreHover() {
      possibilityEle.classList.remove('prevent-hover');
      possibilityEle.removeEventListener('mouseleave', restoreHover);
    }

    possibilityEle.addEventListener('click', function () {
      if (!gameStore.ui.curCage) return;
      gameStore.toggleFilterPossibility(val);
      possibilityEle.classList.add('prevent-hover');
      possibilityEle.addEventListener('mouseleave', restoreHover);
    });
  });

  var addFilterBtnListener = function addFilterBtnListener(btn, mode) {
    btn.addEventListener('click', function () {
      if (gameStore.ui.shouldShowCollection) {
        gameStore.ui.setFilterMode(mode);
      }
    });
  };

  addFilterBtnListener(andModeButton, 'and');
  addFilterBtnListener(notModeButton, 'not');
  addFilterBtnListener(orModeButton, 'or');
  clearModeButton.addEventListener('click', function () {
    if (gameStore.ui.shouldShowCollection) gameStore.clearFilterMode();
  });
  clearAllButton.addEventListener('click', function () {
    if (gameStore.ui.shouldShowCollection) gameStore.clearFilter();
  });
}

function makeReactive(_ref2) {
  var gameStore = _ref2.gameStore,
      _ref2$elements = _ref2.elements,
      collectionInfoEle = _ref2$elements.collectionInfoEle,
      _ref2$elements$collec = _ref2$elements.collectionInfoEles,
      comboListEle = _ref2$elements$collec.comboListEle,
      possibilityEles = _ref2$elements$collec.possibilityEles;
  var possibilityReactions = Array.from(possibilityEles).map(function (possibilityEle) {
    var val = parseInt(possibilityEle.dataset.val);
    var noHoverIconsDiv = possibilityEle.querySelector('.possibility-icons--no-hover');
    var hoverIconsDiv = possibilityEle.querySelector('.possibility-icons--hover');

    var updateIcons = function updateIcons(iconsDiv, newIcons) {
      if (!Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_2__["haveEquivalentChildren"])(iconsDiv, newIcons, {
        attributes: ['class']
      })) {
        iconsDiv.replaceChildren.apply(iconsDiv, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(newIcons));
      }
    };

    return function () {
      possibilityEle.className = gameStore.ui.filterPossibilityClassName(val);
      updateIcons(noHoverIconsDiv, gameStore.ui.filterNoHoverIcons(val));
      updateIcons(hoverIconsDiv, gameStore.ui.filterHoverIcons(val));
    };
  });
  var reactions = [function renderCombos() {
    if (gameStore.ui.shouldShowCollection) {
      Object(_shared_dom_util__WEBPACK_IMPORTED_MODULE_2__["updateChildrenToMatch"])(comboListEle, gameStore.ui.curCage.comboEles, gameStore.ui.curCage.compareComboEles);
    }
  }, function renderFilterModeClassName() {
    collectionInfoEle.className = gameStore.ui.collectionClassName;
  }].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(possibilityReactions));
  var disposers = reactions.map(function (fn) {
    return Object(mobx__WEBPACK_IMPORTED_MODULE_1__["autorun"])(fn);
  });
  return disposers;
}

function getCollectionInfoElements() {
  return {
    comboListEle: document.querySelector('.combos_list'),
    filterEle: document.querySelector('.collection-filter'),
    possibilityEles: document.querySelectorAll('.filter-possibility'),
    andModeButton: document.querySelector('#filter-and'),
    notModeButton: document.querySelector('#filter-not'),
    orModeButton: document.querySelector('#filter-or'),
    clearModeButton: document.querySelector('#filter-clear-mode'),
    clearAllButton: document.querySelector('#filter-clear-all')
  };
}

/***/ }),

/***/ "./src/scripts/views/info_square_view.js":
/*!***********************************************!*\
  !*** ./src/scripts/views/info_square_view.js ***!
  \***********************************************/
/*! exports provided: setupSquareInfo, getSquareInfoElements */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupSquareInfo", function() { return setupSquareInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSquareInfoElements", function() { return getSquareInfoElements; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mobx */ "./node_modules/mobx/dist/mobx.esm.js");


function setupSquareInfo(game) {
  setupListeners(game);
  makeReactive(game);
}

function setupListeners(_ref) {
  var gameStore = _ref.gameStore,
      _ref$elements$squareI = _ref.elements.squareInfoEles,
      possibilityEles = _ref$elements$squareI.possibilityEles,
      select = _ref$elements$squareI.select,
      clear = _ref$elements$squareI.clear;
  possibilityEles.forEach(function (possibilityEle) {
    var val = parseInt(possibilityEle.dataset.val);

    function restoreHover() {
      possibilityEle.classList.remove('prevent-hover');
      possibilityEle.removeEventListener('mouseleave', restoreHover);
    }

    possibilityEle.addEventListener('click', function () {
      if (!gameStore.ui.curSquare || gameStore.ui.hasFocusedSquareValue) {
        return;
      }

      if (gameStore.ui.isStaging) {
        gameStore.toggleStagedPossibility(val);
      } else if (gameStore.ui.hasSelection) {
        gameStore.toggleSelectionPossibility(val);
      } else {
        gameStore.toggleFocusedSquarePossibility(val);
      }

      possibilityEle.classList.add('prevent-hover');
      possibilityEle.addEventListener('mouseleave', restoreHover);
    });
  });
  select.addEventListener('click', function () {
    if (!gameStore.ui.curSquare || gameStore.ui.curSquare.hasValue) {
      return;
    } else if (gameStore.ui.isStaging) {
      gameStore.stopStaging();
    } else {
      gameStore.beginStaging();
    }
  });
  clear.addEventListener('click', function () {
    if (!gameStore.ui.curSquare) {
      return;
    } else if (gameStore.ui.isStaging) {
      gameStore.clearStagedPossibilities();
    } else {
      gameStore.resetFocusedSquarePossibilities();
    }
  });
}

function makeReactive(_ref2) {
  var gameStore = _ref2.gameStore,
      _ref2$elements$square = _ref2.elements.squareInfoEles,
      squareLabelText = _ref2$elements$square.squareLabelText,
      possibilityEles = _ref2$elements$square.possibilityEles,
      selectIcon = _ref2$elements$square.selectIcon,
      clearIcon = _ref2$elements$square.clearIcon,
      select = _ref2$elements$square.select,
      clear = _ref2$elements$square.clear;
  var possibilityReactions = Array.from(possibilityEles).map(function (possibilityEle) {
    var val = parseInt(possibilityEle.dataset.val);
    return function () {
      possibilityEle.className = gameStore.ui.squareInfoPossibilityClassName(val);
      var iconClassNames = gameStore.ui.squareInfoPossibilityIconClassNames(val);

      var _getPossibilityIcons = getPossibilityIcons(possibilityEle),
          noHover = _getPossibilityIcons.noHover,
          hover = _getPossibilityIcons.hover;

      noHover.className = iconClassNames.noHover;
      hover.className = iconClassNames.hover;
    };
  });
  var reactions = [function renderIconClassNames() {
    selectIcon.className = gameStore.ui.squareInfoSelectIconClassName;
    clearIcon.className = gameStore.ui.squareInfoClearIconClassName;
  }, function renderButtonsClassName() {
    select.className = gameStore.ui.squareInfoSelectClassName;
    clear.className = gameStore.ui.squareInfoClearClassName;
  }, function renderDisabledSelect() {
    if (gameStore.ui.squareInfoSelectIsDisabled) {
      select.disabled = true;
    } else {
      select.disabled = false;
    }
  }, function renderDisabledClear() {
    if (gameStore.ui.squareInfoClearIsDisabled) {
      clear.disabled = true;
    } else {
      clear.disabled = false;
    }
  }, function renderLabelText() {
    if (gameStore.ui.hasSelection) {
      squareLabelText.innerHTML = 'Selection';
    } else {
      squareLabelText.innerHTML = 'Square';
    }
  }].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(possibilityReactions));
  var disposers = reactions.map(function (fn) {
    return Object(mobx__WEBPACK_IMPORTED_MODULE_1__["autorun"])(fn);
  });
  return disposers;
}

function getSquareInfoElements() {
  return {
    squareLabelText: document.querySelector('#square-label text'),
    possibilityEles: document.querySelectorAll('.square-info_possibility'),
    select: document.querySelector('#square-info_select-only'),
    selectIcon: document.querySelector('#square-info_select-only i'),
    clear: document.querySelector('#square-info_clear'),
    clearIcon: document.querySelector('#square-info_clear i')
  };
}

function getPossibilityIcons(possibilityEle) {
  return {
    noHover: possibilityEle.querySelector('.no-hover i'),
    hover: possibilityEle.querySelector('.hover i')
  };
}

/***/ }),

/***/ "./src/scripts/views/options_view.js":
/*!*******************************************!*\
  !*** ./src/scripts/views/options_view.js ***!
  \*******************************************/
/*! exports provided: setupOptions, getOptionsElements */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupOptions", function() { return setupOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOptionsElements", function() { return getOptionsElements; });
/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mobx */ "./node_modules/mobx/dist/mobx.esm.js");
/* harmony import */ var _dev__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dev */ "./src/scripts/dev.js");
/* harmony import */ var _setup_walkthrough__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../setup/walkthrough */ "./src/scripts/setup/walkthrough.js");
/* harmony import */ var _shared_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/constants */ "./src/scripts/shared/constants.js");
/* harmony import */ var _shared_general_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/general_util */ "./src/scripts/shared/general_util.js");





function setupOptions(game) {
  setupListeners(game);
  makeOptionsReactive(game);
}

function setupListeners(_ref) {
  var options = _ref.gameStore.options,
      _ref$elements$options = _ref.elements.optionsEles,
      autoBlock = _ref$elements$options.autoBlock,
      autoElim = _ref$elements$options.autoElim,
      autoElimMathImpossibilities = _ref$elements$options.autoElimMathImpossibilities,
      walkthrough = _ref$elements$options.walkthrough,
      maxPossibilitiesInput = _ref$elements$options.maxPossibilitiesInput;
  autoBlock.addEventListener('click', options.toggleAutoBlock);
  autoElim.addEventListener('click', options.toggleAutoEliminate);
  walkthrough.addEventListener('click', options.toggleWalkthrough);
  autoElimMathImpossibilities.addEventListener('click', options.toggleAutoElimMathImpossibilities);
  maxPossibilitiesInput.addEventListener('keydown', function (e) {
    e.preventDefault();
    var num = Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_4__["stringSwitch"])(e.code, function (_ref2) {
      var _case = _ref2._case;

      _case(_shared_constants__WEBPACK_IMPORTED_MODULE_3__["NUM_REGEX"], function () {
        return Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_4__["getNumFromCode"])(e.code);
      });

      _case(_shared_constants__WEBPACK_IMPORTED_MODULE_3__["ARROW_REGEX"], function () {
        var dir = Object(_shared_general_util__WEBPACK_IMPORTED_MODULE_4__["getDirFromCode"])(e.code);
        var num = options.maxDisplayedPossibilities;
        return dir === 'Up' || dir === 'Right' ? num + 1 : num - 1;
      });
    });

    if (num) {
      var success = options.setMaxDisplayedPossibilities(num);
      if (!success) Object(_dev__WEBPACK_IMPORTED_MODULE_1__["devLog"])('Bad Input!');
    }
  });
}

function makeOptionsReactive(_ref3) {
  var options = _ref3.gameStore.options,
      _ref3$elements$option = _ref3.elements.optionsEles,
      autoBlock = _ref3$elements$option.autoBlock,
      autoElim = _ref3$elements$option.autoElim,
      autoElimMathImpossibilities = _ref3$elements$option.autoElimMathImpossibilities,
      maxPossibilitiesInput = _ref3$elements$option.maxPossibilitiesInput,
      walkthrough = _ref3$elements$option.walkthrough;
  var reactions = [function renderAutoBlock() {
    autoBlock.className = options.autoBlockClassName;
  }, function renderAutoElim() {
    autoElim.className = options.autoElimClassName;
  }, function renderAutoElimMathImpossibilities() {
    autoElimMathImpossibilities.className = options.autoElimMathImpossibilitiesClassName;
  }, function renderWalkthrough() {
    walkthrough.className = options.walkthroughClassName;
  }, function renderMaxPossibilitiesInput() {
    maxPossibilitiesInput.value = options.maxDisplayedPossibilities;
  }];
  var disposers = reactions.map(function (fn) {
    return Object(mobx__WEBPACK_IMPORTED_MODULE_0__["autorun"])(fn);
  });
  return disposers;
}

function getOptionsElements() {
  return {
    autoBlock: document.querySelector('#option-auto-block'),
    autoElim: document.querySelector('#option-auto-elim'),
    walkthrough: document.querySelector('#option-walkthrough'),
    autoElimMathImpossibilities: document.querySelector('#option-auto-elim-math-impossibilities'),
    maxPossibilitiesInput: document.querySelector('#option-max-possibilities .option_num-input'),
    maxPossibilitiesError: document.querySelector('#option-max-possibilities .option_error')
  };
}

/***/ }),

/***/ "./src/scripts/views/square_view.js":
/*!******************************************!*\
  !*** ./src/scripts/views/square_view.js ***!
  \******************************************/
/*! exports provided: setupSquares, getSquareElement, getSquareElementsFromId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setupSquares", function() { return setupSquares; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSquareElement", function() { return getSquareElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSquareElementsFromId", function() { return getSquareElementsFromId; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mobx */ "./node_modules/mobx/dist/mobx.esm.js");


function setupSquares(_ref) {
  var gameStore = _ref.gameStore,
      templates = _ref.env.templates,
      puzzleEle = _ref.elements.puzzleEle;
  var squareEles = new DocumentFragment();
  var disposers = gameStore.puzzle.squaresArray.map(function (square) {
    var squareEle = templates.square.cloneNode(true);
    var squareElements = getSquareElementsFromSquare(squareEle);
    setupSquare(square, squareElements);
    squareEles.appendChild(squareEle);
    return makeSquareReactive(square, squareElements);
  });
  puzzleEle.replaceChildren(squareEles);
  return function () {
    return disposers.forEach(function (disposer) {
      return disposer();
    });
  };
}

function setupSquare(square, _ref2) {
  var squareEle = _ref2.squareEle,
      label = _ref2.label,
      cageTop = _ref2.cageTop,
      cageLeft = _ref2.cageLeft;
  squareEle.dataset.pos = square.dataPos;
  squareEle.dataset.id = square.id;
  label.innerText = square.label;

  if (!square.isCageTop) {
    cageTop.remove();
  }

  if (!square.isCageLeft) {
    cageLeft.remove();
  }
}

function makeSquareReactive(square, _ref3) {
  var squareEle = _ref3.squareEle,
      value = _ref3.value,
      possibilityEles = _ref3.possibilityEles;
  var possibilityReactions = Array.from(possibilityEles).map(function (possibilityEle) {
    return function () {
      var val = parseInt(possibilityEle.dataset.val);
      possibilityEle.className = square.possibilityClassName(val);
    };
  });
  var reactions = [function renderValNode() {
    value.innerText = square.displayedValue;
  }, function renderClassName() {
    squareEle.className = square.className;
  }].concat(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(possibilityReactions));
  var disposers = reactions.map(function (fn) {
    return Object(mobx__WEBPACK_IMPORTED_MODULE_1__["autorun"])(fn);
  });
  return function () {
    return disposers.forEach(function (disposer) {
      return disposer();
    });
  };
}

function getSquareElement(id) {
  return document.querySelector(squareSelector(id));
}
function getSquareElementsFromId(id) {
  var _createSquareChildSel = createSquareChildSelectors(id),
      getChild = _createSquareChildSel.getChild,
      getChildren = _createSquareChildSel.getChildren;

  return {
    squareEle: getSquareElement(id, parent),
    cageTop: getChild('.square_cage-top'),
    cageLeft: getChild('.square_cage-left'),
    label: getChild('.square_label'),
    value: getChild('.square_value'),
    possibilityEles: getChildren('.square_possibility')
  };
}

function createSquareChildSelectors(id) {
  var getSelector = function getSelector(subSelector) {
    return [squareSelector(id), subSelector].join(' ');
  };

  return {
    getChild: function getChild(subSelector) {
      return document.querySelector(getSelector(subSelector));
    },
    getChildren: function getChildren(subSelector) {
      return document.querySelectorAll(getSelector(subSelector));
    }
  };
}

function squareSelector(id) {
  return ".square[data-id=\"".concat(id, "\"]");
}

function getSquareElementsFromSquare(squareEle) {
  return {
    squareEle: squareEle,
    cageTop: squareEle.querySelector('.square_cage-top'),
    cageLeft: squareEle.querySelector('.square_cage-left'),
    label: squareEle.querySelector('.square_label'),
    value: squareEle.querySelector('.square_value'),
    possibilityEles: squareEle.querySelectorAll('.square_possibility')
  };
}

/***/ }),

/***/ "./src/styles/index.scss":
/*!*******************************!*\
  !*** ./src/styles/index.scss ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvd3JhcE5hdGl2ZVN1cGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZS02NC9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbG9uZS9jbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNhbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNhbi9saWIvY3ljbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzYW4vbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc2FuL2xpYi9wYXRoLWdldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNhbi9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpbmtlZC1saXN0L19zb3VyY2UvbGlua2VkLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpbmtlZC1saXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2J4LXN0YXRlLXRyZWUvZGlzdC9tb2J4LXN0YXRlLXRyZWUubW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2J4L2Rpc3QvbW9ieC5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21zdC1taWRkbGV3YXJlcy9kaXN0L21zdC1taWRkbGV3YXJlcy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlbW90ZWRldi9saWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZW1vdGVkZXYvbGliL2RldlRvb2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZW1vdGVkZXYvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ybi1ob3N0LWRldGVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2MtY2hhbm5lbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2MtY2hhbm5lbC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjLWVycm9ycy9kZWN5Y2xlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYy1lcnJvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjLWZvcm1hdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0Y2x1c3Rlci1jbGllbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldGNsdXN0ZXItY2xpZW50L2xpYi9hdXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXRjbHVzdGVyLWNsaWVudC9saWIvZmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0Y2x1c3Rlci1jbGllbnQvbGliL3Jlc3BvbnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXRjbHVzdGVyLWNsaWVudC9saWIvc2NjbGllbnRzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldGNsdXN0ZXItY2xpZW50L2xpYi9zY3RyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0Y2x1c3Rlci1jbGllbnQvbGliL3dzLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldGNsdXN0ZXItY2xpZW50L25vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0Y2x1c3Rlci1jbGllbnQvbm9kZV9tb2R1bGVzL3V1aWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldGNsdXN0ZXItY2xpZW50L25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0Y2x1c3Rlci1jbGllbnQvbm9kZV9tb2R1bGVzL3V1aWQvbGliL3JuZy1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXRjbHVzdGVyLWNsaWVudC9ub2RlX21vZHVsZXMvdXVpZC92MS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0Y2x1c3Rlci1jbGllbnQvbm9kZV9tb2R1bGVzL3V1aWQvdjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2RhdGEvcHV6emxlXzAxLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2RhdGEvcHV6emxlXzAyLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2RhdGEvcHV6emxlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9kZXYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvc2V0dXAvbGlzdGVuZXJzL2NsaWNrX2xpc3RlbmVycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9zZXR1cC9saXN0ZW5lcnMva2V5Ym9hcmRfbGlzdGVuZXJzLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3NldHVwL3NldHVwX2RvbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9zZXR1cC9zZXR1cF9lbnYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvc2V0dXAvc2V0dXBfZ2FtZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9zZXR1cC9zZXR1cF9wdXp6bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvc2V0dXAvd2Fsa3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvc2hhcmVkL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9zaGFyZWQvZG9tX3BhcnRpYWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3NoYXJlZC9kb21fdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9zaGFyZWQvZ2VuZXJhbF91dGlsLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3NoYXJlZC9scnVfY2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvc2hhcmVkL3Nwb3RsaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9zaGFyZWQvc3RvcmFnZV91dGlsLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3N0b3JlL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvc3RvcmUvY29sbGVjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvc3RvcmUvZmlsdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3N0b3JlL2dhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvc3RvcmUvbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9zdG9yZS9vcHRpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3N0b3JlL3B1enpsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9zdG9yZS9zcXVhcmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvc3RvcmUvdWkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdmlld3MvaGVhZGVyX3ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdmlld3MvaW5mb19jb2xsZWN0aW9uX3ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdmlld3MvaW5mb19zcXVhcmVfdmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy92aWV3cy9vcHRpb25zX3ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdmlld3Mvc3F1YXJlX3ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9pbmRleC5zY3NzP2M4MDciXSwibmFtZXMiOlsiaWQiLCJzaXplIiwiZGlmZmljdWx0eSIsIm9wZXJhdGlvbnMiLCJBREQiLCJTVUJUUkFDVCIsIk1VTFRJUExZIiwiRElWSURFIiwiY2FnZXMiLCJzcXVhcmVzIiwib3BlcmF0aW9uIiwicmVzdWx0Iiwic29sdXRpb24iLCJwMSIsInAyIiwiZGV2RmxhZyIsImFjdGl2YXRlRGV2RmxhZyIsInNldHVwRGV2IiwiZ2FtZSIsImNvbm5lY3RSZWR1eERldnRvb2xzIiwicmVtb3RlZGV2IiwiZ2FtZVN0b3JlIiwidW5wcm90ZWN0Iiwic2V0dXBQYWxldHRlIiwid2luZG93IiwiZ3MiLCJscnUiLCJMUlVDYWNoZSIsImdldFNuYXAiLCJnZXRTbmFwc2hvdCIsImFwcGx5U25hcCIsImFwcGx5U25hcHNob3QiLCJkZXZMb2ciLCJjb25zb2xlIiwibG9nIiwiQ09MT1JTIiwidG9nZ2xlUGFsZXR0ZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVyVGV4dCIsInBhbGV0dGUiLCJjbGFzc05hbWUiLCJmb3JFYWNoIiwiY29sb3IiLCJjb2xvckRpdiIsImNvbG9yTGFiZWwiLCJhcHBlbmRDaGlsZCIsInRlc3REaXYiLCJvbmNsaWNrIiwiY2xhc3NMaXN0IiwidG9nZ2xlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImJvZHkiLCJhcHBlbmQiLCJwcm9jZXNzIiwiZ2V0TmV3RW52IiwiZW52IiwiZWxlbWVudHMiLCJzZXR1cERPTSIsInNldHVwR2FtZSIsIm1vdW50Q2xpY2tMaXN0ZW5lcnMiLCJwdXp6bGVFbGUiLCJpbmZvRWxlIiwiZSIsInBhdGgiLCJpbmNsdWRlcyIsImNsZWFyRm9jdXMiLCJ1aSIsImNsZWFyU2VsZWN0ZWRTcXVhcmVzIiwic3F1YXJlIiwidGFyZ2V0IiwiY2xvc2VzdCIsInNxdWFyZUlkIiwiZGF0YXNldCIsInNoaWZ0S2V5Iiwic2VsZWN0VGhyb3VnaFNxdWFyZSIsIm1ldGFLZXkiLCJ0b2dnbGVTZWxlY3RlZFNxdWFyZSIsInNlbGVjdFNxdWFyZUJ5SWQiLCJtb3VudEtleWJvYXJkTGlzdGVuZXJzIiwiY3VyU3F1YXJlIiwic3RyaW5nU3dpdGNoIiwiY29kZSIsIl9jYXNlIiwiX2Vuc3VyZSIsImN0cmxLZXkiLCJiZWdpblN0YWdpbmciLCJhbHRLZXkiLCJOVU1fUkVHRVgiLCJ0b2dnbGVGb2N1c2VkU3F1YXJlUG9zc2liaWxpdHkiLCJnZXROdW1Gcm9tQ29kZSIsInRvZ2dsZUZpbHRlclBvc3NpYmlsaXR5Iiwic2V0Rm9jdXNlZFNxdWFyZSIsInRvZ2dsZVN0YWdlZFBvc3NpYmlsaXR5IiwiQVJST1dfUkVHRVgiLCJzZWxlY3RTcXVhcmVCeURpciIsImdldERpckZyb21Db2RlIiwicmVzZXRGb2N1c2VkU3F1YXJlUG9zc2liaWxpdGllcyIsImNsZWFyRmlsdGVyIiwiY2xlYXJGb2N1c2VkU3F1YXJlIiwiY2xlYXJTdGFnZWRQb3NzaWJpbGl0aWVzIiwiTEVGVF9PUl9SSUdIVF9SRUdFWCIsImNoYW5nZUZpbHRlck1vZGVCeURpciIsInNldEZpbHRlck1vZGUiLCJwcmV2ZW50RGVmYXVsdCIsInVuZG8iLCJyZWRvIiwia2V5Iiwic3RvcFN0YWdpbmciLCJnbG9iYWxzIiwidGVtcGxhdGVzIiwic2V0dXBPcHRpb25zIiwic2V0dXBTcXVhcmVUZW1wbGF0ZSIsInNldHVwU3F1YXJlUG9zc2liaWxpdGllcyIsInNldHVwRmlsdGVyUG9zc2liaWxpdGllcyIsInNldHVwTGFiZWxzIiwic2V0dXBJY29ucyIsInNldHVwTG9jYWxpemF0aW9ucyIsImdldEVsZW1lbnRzIiwicXVlcnlTZWxlY3RvciIsInNxdWFyZUluZm9FbGUiLCJjb2xsZWN0aW9uSW5mb0VsZSIsImhlYWRlckVsZSIsInNxdWFyZUluZm9FbGVzIiwiZ2V0U3F1YXJlSW5mb0VsZW1lbnRzIiwiY29sbGVjdGlvbkluZm9FbGVzIiwiZ2V0Q29sbGVjdGlvbkluZm9FbGVtZW50cyIsImhlYWRlckVsZXMiLCJnZXRIZWFkZXJFbGVtZW50cyIsIm9wdGlvbnNFbGVzIiwiZ2V0T3B0aW9uc0VsZW1lbnRzIiwic3F1YXJlRWxlIiwiZ2V0U3F1YXJlRWxlbWVudCIsInNxdWFyZUVsZXMiLCJnZXRTcXVhcmVFbGVtZW50c0Zyb21JZCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpY29uIiwiSUNPTlMiLCJrZWJhYlRvQ2FtZWwiLCJtb2RlbFBvc3NpYmlsaXR5IiwiaSIsInBvc3NpYmlsaXR5IiwiY2xvbmVOb2RlIiwidmFsIiwiYmVmb3JlIiwicmVtb3ZlIiwic3F1YXJlUG9zc2liaWxpdGllcyIsIkRvY3VtZW50RnJhZ21lbnQiLCJzcXVhcmVJbmZvUG9zc2liaWxpdHkiLCJwcmVwZW5kIiwiZmlsdGVyUG9zc2liaWxpdGllcyIsImZpbHRlclBvc3NpYmlsaXR5IiwibmF2aWdhdG9yIiwicGxhdGZvcm0iLCJzdGFydHNXaXRoIiwiY3JlYXRlTGFiZWwiLCJpbmZvTGFiZWwiLCJ0ZXh0IiwidGVtcGxhdGUiLCJsYWJlbCIsInNldEF0dHJpYnV0ZSIsInRleHRDb250ZW50Iiwib3B0aW9uIiwidG9nZ2xlVGVtcGxhdGUiLCJvcHRpb25Ub2dnbGUiLCJudW1UZW1wbGF0ZSIsIm9wdGlvbk51bSIsIm9wdGlvbnNEYXRhIiwiaW5wdXRJZCIsImlucHV0VGVtcGxhdGUiLCJpbmZvVGV4dCIsImhvdmVyVGV4dCIsIm9wdGlvbnMiLCJtYXAiLCJkYXRhIiwiY3JlYXRlT3B0aW9uIiwiaW5wdXQiLCJnZXRTdGF0aWNFbnYiLCJnZXREZWZhdWx0RHluYW1pY0VudiIsImRiR2V0Iiwib2xkRW52IiwiT2JqZWN0IiwiYXNzaWduIiwicmVzZXRFbnYiLCJwdXp6bGVzIiwibWlzdGFrZVRpbWVvdXRNcyIsImdldFRlbXBsYXRlQnlJZCIsImNvbWJvIiwic3BvdGxpZ2h0Iiwic3BvdGxpZ2h0Q2FwdGlvbiIsInB1enpsZUNhcHRpb25Db250ZW50IiwiY2FnZUNhcHRpb25Db250ZW50IiwiaW5mb0NhcHRpb25Db250ZW50Iiwic3F1YXJlSW5mb0NhcHRpb25Db250ZW50IiwiY29sbGVjdGlvbkluZm9DYXB0aW9uQ29udGVudCIsImluc3RydWN0aW9uc0NhcHRpb25Db250ZW50Iiwic25hcHNob3RzIiwiaGlzdG9yeSIsImZ1dHVyZSIsInB1enpsZUNhY2hlIiwiUkVTVE9SRV9GTEFHIiwiY3JlYXRlR2FtZVN0b3JlIiwic2V0dXBTcXVhcmVJbmZvIiwic2V0dXBDb2xsZWN0aW9uSW5mbyIsInNldHVwUHV6emxlIiwic3RvcmVkU25hcHNob3QiLCJ3YWxrdGhyb3VnaCIsInNldHVwSGVhZGVyIiwiYXBwbHlTdG9yZWRTbmFwc2hvdCIsImF0dGFjaEhvb2tzIiwiR2FtZSIsImNyZWF0ZSIsInJlc2V0VG9TdG9yZWRTbmFwc2hvdCIsImluaXRpYWxpemUiLCJkaXNwb3NlckZ1bmMiLCJuZXdQdXp6bGUiLCJzZXR1cFNxdWFyZXMiLCJyZXNldFB1enpsZSIsInJlc3RvcmVQdXp6bGUiLCJjYXB0aW9uIiwic3ZnIiwiY2xlYW51cCIsInN0ZXBzIiwiZ2V0U3BvdGxpZ2h0cyIsInVwZGF0ZSIsInVwZGF0ZVNWRyIsImVsZW1lbnQiLCJyZWdlbmVyYXRlIiwidXBkYXRlQ2FwdGlvbiIsImNhcHRpb25Db250ZW50IiwiY2xlYW51cFNob3ciLCJvblNob3ciLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYXBwZW5kSWZSZW1vdmVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJmaW5pc2giLCJoYW5kbGVLZXlkb3duIiwicHVzaCIsImdldENhcHRpb25FbGVtZW50cyIsIm5leHRCdG4iLCJwcmV2aW91c0J0biIsImZpbmlzaEJ0biIsImN1clN0ZXAiLCJuZXh0IiwicHJldiIsImFkZE5vRm9jdXNDbGlja0xpc3RlbmVyIiwiaW5zdHJ1Y3Rpb25zQnV0dG9uIiwiaW5zdHJ1Y3Rpb25zRHJvcGRvd24iLCJjYWdlU3F1YXJlcyIsImdldENhZ2VTcXVhcmVzIiwiU3BvdGxpZ2h0IiwiZnJvbUVsZSIsInBhZGRpbmciLCJib3JkZXJSYWRpdXMiLCJkZWZhdWx0IiwibGVmdCIsImJsdXIiLCJjYXB0aW9uUG9zaXRpb24iLCJjYXB0aW9uT2Zmc2V0WCIsImNhcHRpb25PZmZzZXRZIiwiZnJvbUVsZXMiLCJ0b3AiLCJib3R0b20iLCJBcnJheSIsImxlbmd0aCIsImZpbGwiLCJyaWdodCIsImFkZCIsImNhcHRpb25FbGUiLCJjb3JuZXJDYWdlIiwicHV6emxlIiwiY2FnZXNBcnJheSIsImZpbmQiLCJjYWdlIiwibnVtUG9zc2libGVSZXBlYXRzIiwiZnJvbSIsImNyZWF0ZVNWRyIsImVsZXMiLCJyZW1vdmVkRWxlcyIsImZpbHRlciIsImVsZSIsImNvbnRhaW5zIiwiVVBfT1JfRE9XTl9SRUdFWCIsImluZm8iLCJiYW4iLCJjaXJjbGUiLCJjaXJjbGVGaWxsZWQiLCJzbGFzaCIsImNsZWFyIiwicmVzZXQiLCJzZWxlY3QiLCJjb25maXJtIiwiY3JlYXRlQmFzaWNJY29uIiwiaWNvbk5hbWUiLCJjcmVhdGVJY29uIiwiaWNvblNwYW4iLCJmbGFncyIsImdlbmVyYXRlQ2xhc3NOYW1lIiwiYmFzZUljb25zIiwiZWxpbWluYXRlZEljb25zIiwiYWx0ZXJuYXRpdmVJY29ucyIsInJlcXVpcmVkSWNvbnMiLCJleHRyYWN0UG9zRnJvbVNxdWFyZSIsInBvcyIsInNwbGl0IiwibW91bnREcm9wZG93biIsImJ1dHRvbiIsImRyb3Bkb3duIiwic2hvd0NsYXNzIiwib3V0c2lkZURyb3Bkb3duIiwib25CdXR0b24iLCJpc1Nob3dpbmciLCJsaXN0ZW5lciIsImdldFRlbXBsYXRlTm9kZSIsImZpcnN0Q2hpbGQiLCJjb250ZW50IiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJnZXRFbGVtZW50QnlJZCIsImlzRXF1aXZhbGVudE5vZGUiLCJub2RlQSIsIm5vZGVCIiwibm9kZU5hbWUiLCJoYXZlRXF1aXZhbGVudEF0dHJpYnV0ZXMiLCJoYXZlRXF1aXZhbGVudENoaWxkcmVuIiwibm9kZU9yTGlzdEEiLCJub2RlT3JMaXN0QiIsImNoaWxkcmVuQSIsIk5vZGUiLCJjaGlsZE5vZGVzIiwiY2hpbGRyZW5CIiwiY2hpbGRBIiwiY2hpbGRCIiwiYXR0cmlidXRlc0EiLCJnZXRBdHRyaWJ1dGVOYW1lcyIsImF0dHJpYnV0ZXNCIiwiYXR0cmlidXRlcyIsImF0dHIiLCJldmVyeSIsImdldEF0dHJpYnV0ZSIsInVwZGF0ZUNoaWxkcmVuVG9NYXRjaCIsImNvbXBhcmF0b3IiLCJjaGlsZHJlbiIsImdldE5leHRBQ2hpbGQiLCJnZW5TdGVwcGVyIiwiZ2V0TmV4dEJDaGlsZCIsInVwZGF0ZUF0dHJpYnV0ZXNUb01hdGNoIiwiaW5zZXJ0QmVmb3JlIiwibm9kZSIsInZhbEEiLCJ2YWxCIiwiZ2VuZXJhdGVIaWdobGlnaHRGdW5jcyIsInVuaGlnaGxpZ2h0IiwiaGlnaGxpZ2h0RWxlcyIsImFyZ3MiLCJsYXN0QXJnIiwic2xpY2UiLCJwYWRkaW5nVG9wIiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ0JvdHRvbSIsInBhZGRpbmdMZWZ0IiwiY2FwdGlvblRlbXBsYXRlIiwiY2FwdGlvblBvcyIsImNhcHRpb25BdHRycyIsImdldFBvc2l0aW9uU3R5bGVzIiwid3JhcHBlclN0eWxlcyIsIm91dGVyV3JhcHBlclN0eWxlIiwid3JhcHBlcnMiLCJzdHlsZSIsIndyYXBwZXIiLCJnZW5lcmF0ZURpdldpdGhTdHlsZSIsIm91dGVyV3JhcHBlciIsImRpbUVsZSIsInpJbmRleCIsImVsZVBvc2l0aW9uIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJwb3NpdGlvbiIsImNhcHRpb25BbmNob3IiLCJwcmVwYXJlQ2FwdGlvbkVsZSIsImF0dHJzIiwic2hpZnQiLCJlbnRyaWVzIiwicHJvcCIsInVuZGVmaW5lZCIsImNlbnRlckNhcHRpb24iLCJfZGVmYXVsdCIsIkVycm9yIiwiZGVmYXVsdFRvcCIsImRlZmF1bHRSaWdodCIsImRlZmF1bHRCb3R0b20iLCJkZWZhdWx0TGVmdCIsIm1lcmdlUHJvcCIsImRpdiIsInRvUHgiLCJudW0iLCJvdXRlclRvcCIsIm91dGVyUmlnaHQiLCJvdXRlckJvdHRvbSIsIm91dGVyTGVmdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImhlaWdodCIsIndpZHRoIiwiZGVmYXVsdFByb3AiLCJhcmdQcm9wIiwiY3JlYXRlU1ZHRWxlbWVudCIsInRhZyIsImNyZWF0ZUVsZW1lbnROUyIsImFwcGx5U3R5bGUiLCJjYXAiLCJiYWNrZ3JvdW5kIiwib3B0cyIsImdoZiIsImhoIiwic2EiLCJnZW5CYXNpY1N0ZXBwZXIiLCJpc1RydXRoeSIsImEiLCJjb21ib3MiLCJudW1FbGVtZW50cyIsIm1pbiIsIm1heCIsIm51bVJlcGVhdHNBbGxvd2VkIiwicmFuZ2VTaXplIiwibmV4dE9wdGlvbnMiLCJ3aXRoUmVwZWF0ZWRNaW4iLCJ3aXRoTWluIiwid2l0aG91dE1pbiIsIm1heFBvc3NpYmxlUmVwZWF0cyIsInBvc2l0aW9ucyIsImN1cklkeCIsImZpbGxlZCIsIm5leHRGaWxsVmFsIiwidmFsdWVzIiwicm93cyIsIm51bVNxdWFyZXNXaXRoVmFsIiwibmV4dFJvdyIsIm5leHRDb2wiLCJwb3NzaWJsZVZhbHMiLCJrZXlzIiwiY29scyIsImNvbmNhdCIsInJlZHVjZSIsIm1heFJlcGVhdHMiLCJmaWxsZWRDbG9uZSIsImRlZXBDbG9uZSIsIm1heFJlcGVhdHNXaXRoVmFsIiwiYXJlRXF1YWxBcnJheXMiLCJiIiwiaWR4IiwiYXJyYXlVbmlvbiIsImFDb3VudHMiLCJ1bmlvbiIsImluY2x1ZGVzQXJyYXkiLCJvdXRlckFycmF5IiwiaW5uZXJBcnJheSIsInNvbWUiLCJzdWJBcnJheSIsImluZGV4T2ZBcnJheSIsImZpbmRJbmRleCIsImluY2x1ZGVzRGlzdGluY3QiLCJhcnJheSIsInZpc2l0ZWRJbmRpY2VzIiwicmVxdWlyZWRFbGVtZW50cyIsInJlcXVpcmVkRWxlIiwiZWxlSW5kZXgiLCJuZXh0SWQiLCJjbGFzc2VzIiwiYXJnIiwiam9pbiIsImV2YWxDbGFzc05hbWVDb21wb25lbnQiLCJjb21wb25lbnQiLCJldmFsQ2xhc3NOYW1lQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJldmFsQ2xhc3NOYW1lRmxhZ3MiLCJiYXNlIiwiZmxhZyIsImdlbmVyYXRlQ2xhc3NOYW1lRnJvbUFycmF5IiwiZ2VuZXJhdGVDbGFzc05hbWVGcm9tQmFzZUFuZEZsYWdzIiwiZ2VuZXJhdGVDbGFzc05hbWVGcm9tT3B0aW9ucyIsImNsYXNzTmFtZXMiLCJmbGFnTmFtZXMiLCJkeW5hbWljQXJnIiwiY29weVB1enpsZSIsImNvcHkiLCJjbG9uZSIsInJlc2V0VXVpZCIsIndhaXQiLCJtcyIsInNldFRpbWVvdXQiLCJwcm9kdWN0IiwibnVtQXJyYXkiLCJzdW0iLCJkaWZmZXJlbmNlIiwibGFyZ2VyIiwic21hbGxlciIsInF1b3RpZW50IiwicGFyc2VJbnQiLCJleGVjIiwiZ3JvdXBzIiwiZGlyIiwic3RyaW5nIiwic2VnbWVudCIsInRvVXBwZXJDYXNlIiwiaXRlcmFibGUiLCJiYXNpY1N0ZXBwZXIiLCJ2YWx1ZSIsIm9iaiIsImNvbnN0cnVjdG9yIiwibmFtZSIsImZyb21FbnRyaWVzIiwidGhyb3R0bGUiLCJmdW5jIiwibGFzdEZpcmVkIiwiRGF0ZSIsIm5vdyIsInRvZ2dsZVByZXNlbmNlSW5BcnJheSIsImluZGV4T2ZGdW5jIiwiaW5kZXhPZiIsInNwbGljZSIsInB1c2hJZk5vdEluY2x1ZGVkIiwiaW5jbHVkZXNGdW5jIiwicmVtb3ZlSWZJbmNsdWRlZCIsImdldEludGVydmVuaW5nUG9zaXRpb25zIiwic3RhcnRYIiwic3RhcnRZIiwiZW5kWCIsImVuZFkiLCJ4UmFuZ2UiLCJnZXRSYW5nZSIsInlSYW5nZSIsIngiLCJuZXdQb3NpdGlvbnMiLCJ5IiwibWFwcGVyIiwiXyIsIk1hdGgiLCJhYnMiLCJjYXNlc0ZuIiwidmFsaWRhdGVTdHJpbmdTd2l0Y2hBcmdzIiwiY2FzZUFyZ1BhcnNlciIsInN0cmluZ1N3aXRjaENhc2VBcmdQYXJzZXIiLCJiYXNlU3dpdGNoIiwiZnVuY1N3aXRjaCIsInZhbGlkYXRlRnVuY1N3aXRjaEFyZ3MiLCJmdW5jU3dpdGNoQ2FzZUFyZ1BhcnNlciIsImZhbGx0aHJvdWdoIiwibXVsdGlwbGVNYXRjaGVzIiwibWF0Y2hlZCIsImlzTWF0Y2giLCJzaG91bGRFeGVjQnlNYXRjaCIsInNob3VsZEV4ZWNCeUZhbGx0aHJvdWdoIiwicG9wIiwibWF0Y2hlciIsInBhcnNlTWF0Y2hlciIsImlzTWF0Y2hlclR5cGUiLCJ0eXBlIiwiUmVnRXhwIiwidGVzdCIsInN1YiIsIm5ld05vZGUiLCJsYXN0VXBkYXRlZCIsInRpbWVCZWZvcmVDbGVhciIsImhlYWQiLCJ0YWlsIiwic2V0SW50ZXJ2YWwiLCJfcmVtb3ZlQmVmb3JlIiwicHJldmlvdXNMYXN0IiwiX3JlbW92ZU9sZGVzdCIsIl9yZW1vdmUiLCJiZWZvcmVOb2RlIiwiYWZ0ZXJOb2RlIiwib2xkZXN0IiwibmV3TWFwIiwidmFsaWROb2RlIiwiY2xvY2t3aXNlT3JkZXIiLCJzaWRlU2lnbnMiLCJvdmVyZmxvd1B4IiwiZ2VuZXJhdGUiLCJib3VuZHMiLCJnZXRQYWRkZWRCb3VuZGluZ1JlY3QiLCJzdWJQYXRocyIsInZpc2l0ZWQiLCJfYW5jaG9yQm91bmRzIiwiaXNDb21wbGV0ZSIsIl9hZGROZXh0U3ViUGF0aCIsInN1YlBhdGgiLCJfYmVnaW5TdWJQYXRoIiwiX2lzQ29tcGxldGVTdWJQYXRoIiwiX2FkZE5leHRQb2ludCIsIm92ZXJmbG93T2Zmc2V0U3ViUGF0aCIsInBvaW50IiwiY3VyQm91bmRTaWRlIiwic3RhdGljSWR4IiwiY2hhbmdpbmdJZHgiLCJjdXJQb2ludCIsIl9nZXRMYXN0UG9pbnQiLCJjdXJTdGF0aWNEaW0iLCJjdXJDaGFuZ2luZ0RpbSIsIm5leHRDdXJCb3VuZFNpZGUiLCJnZXROZXh0U2lkZSIsImNsb3Nlc3REaW0iLCJfZ2V0RGltIiwiY3VyQm91bmRJZHgiLCJjbG9zZXN0Qm91bmRJZHgiLCJpbnRlcmNlcHRTaWRlIiwiZ2V0T3Bwb3NpdGVTaWRlIiwiYm91bmRzSW5kaWNlcyIsIl9nZXRPdGhlckRpbVJhbmdlIiwic3RhdGljRGltTG93ZXIiLCJzdGF0aWNEaW1VcHBlciIsImludGVyY2VwdERpbSIsInNpZ24iLCJuZXh0UG9pbnQiLCJib3VuZE9ySWR4Iiwic2lkZSIsIl9nZXROZXh0Qm91bmRJZHgiLCJjdXJCb3VuZCIsImJvdW5kSWR4IiwiYm91bmQiLCJfZ2V0Rmlyc3RQb2ludCIsIm0iLCJsIiwicCIsInZidyIsInZiaCIsImlubmVyUGF0aCIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImdldEQiLCJjYXB0aW9uU3R5bGUiLCJob29rUG9pbnRzIiwicGF0aFBhcnRzIiwicGFydHMiLCJfZ2V0UGF0aEhvb2siLCJob29rcyIsImN1ciIsInN0YXJ0UG9pbnQiLCJfZ2V0TnVkZ2VkUG9pbnQiLCJlbmRQb2ludCIsInJhZGlpIiwiZ2V0QWJzRGlmZiIsImNsb2Nrd2lzZSIsImRpZmYiLCJtYWciLCJnZXRTdWJQYXRoRCIsIl9nZXRSb3VuZGVkU3ViUGF0aEQiLCJfZ2V0U3ViUGF0aEQiLCJiaW5kIiwiYW5jaG9yRWxlIiwiYW5jaG9yQm91bmRzIiwiYm91bmRzVG9wIiwiYm91bmRzUmlnaHQiLCJib3VuZHNMZWZ0IiwiYm91bmRzQm90dG9tIiwidXBwZXJUb3AiLCJ0b1BpeGVscyIsIm1pZFRvcCIsImxvd2VyVG9wIiwic3RhcnRMZWZ0IiwibWlkTGVmdCIsImVuZExlZnQiLCJ0b3BSaWdodCIsImJvdHRvbVJpZ2h0IiwiYm90dG9tTGVmdCIsInRvcExlZnQiLCJwb3NpdGlvblN0eWxlIiwicG9zaXRpb25TdHlsZXMiLCJ4U2hpZnQiLCJ5U2hpZnQiLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsInRyYW5zZm9ybSIsImN1clNpZGUiLCJuZXh0U2lkZUlkeCIsIm9wcG9zaXRlSWR4IiwiZGVmYXVsdFBhZGRpbmciLCJkYkFkZCIsIldvcmtlciIsImluZGV4ZWREQiIsInN0b3JhZ2VXb3JrZXIiLCJyZXNvbHV0aW9uUmVnaXN0cnkiLCJvbm1lc3NhZ2UiLCJtc2ciLCJyZXF1ZXN0SWQiLCJvdGhlckRhdGEiLCJzZW5kIiwidGhlbiIsInN0YXR1cyIsIm1lc3NhZ2UiLCJ0aW1lb3V0IiwicmFuZG9tIiwicG9zdE1lc3NhZ2UiLCJyZWplY3QiLCJ0aW1lb3V0SWQiLCJjbGVhclRpbWVvdXQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsIml0ZW0iLCJnZXRJdGVtIiwicGFyc2UiLCJJZCIsInR5cGVzIiwib3B0aW9uYWwiLCJpZGVudGlmaWVyIiwiUG9zaXRpb24iLCJyZWZpbmVtZW50IiwiaW50ZWdlciIsIkdhbWVCYXNlIiwibW9kZWwiLCJ2aWV3cyIsInNlbGYiLCJyb290IiwiZ2V0Um9vdCIsInJvb3RPcHRpb25zIiwicm9vdFVpIiwicm9vdFB1enpsZSIsImdldEVudiIsIkNvbGxlY3Rpb24iLCJuYW1lZCIsInByb3BzIiwicmVmZXJlbmNlIiwibGF0ZSIsIlNxdWFyZSIsIkZpbHRlciIsImVsaW1pbmF0ZWRDb21ib3MiLCJudW1TcXVhcmVzIiwic3F1YXJlVmFsdWVzIiwiYWxsQ29tYm9zIiwiZmlsdGVyZWRDb21ib3MiLCJpc0ZpbHRlcmVkQ29tYm8iLCJwb3NzaWJsZUNvbWJvcyIsImlzUG9zc2libGVDb21ibyIsImNvbWJvRWxlcyIsImNvbWJvRWxlIiwiaXNFbGltaW5hdGVkQ29tYm8iLCJjb21wYXJlQ29tYm9FbGVzIiwiY29tYm9BIiwiY29tYm9CIiwiY29tYm9TdHJBIiwiY29tYm9TdHJCIiwiaXNQb3NzaWJsZVZhbHVlIiwiYWN0aW9ucyIsImFkZFNxdWFyZSIsInRvZ2dsZUNvbWJvIiwic2V0Q29tYm9zIiwic29ydGVkQ29tYm9zIiwic29ydCIsIkNhZ2UiLCJlbnVtZXJhdGlvbiIsImF1dG9FbGltTWF0aEltcG9zc2liaWxpdGllcyIsImJvb2xlYW4iLCJzdXBlcklzUnVsZVBvc3NpYmxlQ29tYm8iLCJ0b3BTcXVhcmVzIiwibGVmdFNxdWFyZXMiLCJhbmNob3IiLCJpc1RvcCIsImlzQmVsb3ciLCJpc0xlZnQiLCJpc1JpZ2h0T2YiLCJjb21lc0JlZm9yZSIsImxhYmVsVGV4dCIsImlzTWF0aGVtYXRpY2FsUG9zc2liaWxpdHkiLCJHcm91cCIsIkZpbHRlclBvc3NpYmlsaXR5IiwibW9kZVN0YXR1c01hcCIsImFuZCIsIm5vdCIsIm9yIiwiaG92ZXJGbGFnIiwibW9kZSIsIm1hdGNoZXNNb2RlIiwiZ2V0U3RhdHVzSWNvbiIsIm5vSG92ZXJJY29ucyIsImhvdmVySWNvbnMiLCJwb3NzaWJpbGl0aWVzIiwicmVxdWlyZWQiLCJyZXF1aXJlZFZhbHVlcyIsImVsaW1pbmF0ZWQiLCJlbGltaW5hdGVkVmFsdWVzIiwiYWx0ZXJuYXRpdmVzIiwiYWx0ZXJuYXRpdmVWYWx1ZXMiLCJnZXRQb3NzaWJpbGl0eUJ5VmFsdWUiLCJmaWx0ZXJQb3NzaWJpbGl0eVN0YXR1cyIsImlzUmVxdWlyZWRWYWx1ZSIsImlzRWxpbWluYXRlZFZhbHVlIiwiaXNBbHRlcm5hdGl2ZVZhbHVlIiwiaXNTdGFuZGFyZFZhbHVlIiwiY2xlYXJNb2RlIiwiUHV6emxlIiwiY3VyUHV6emxlSWR4IiwibWV0YSIsIk1ldGEiLCJPcHRpb25zIiwiVUkiLCJ2b2xhdGlsZSIsImV4dGVuZCIsInRha2VQdXp6bGVTbmFwc2hvdCIsInNuYXBzaG90SWQiLCJnZXRPclNldFB1enpsZSIsImNhY2hlZEdhbWUiLCJnZXQiLCJzZXQiLCJnZXROZXdQdXp6bGVJZHgiLCJyYW5kb21JZHgiLCJmbG9vciIsIm5vSGlzdG9yeSIsImlmQ3VyU3F1YXJlRW1wdHkiLCJjYiIsImhhc1ZhbHVlIiwiZ2V0U3RvcmVkU25hcHNob3QiLCJzbmFwc2hvdCIsInNldFN0b3JlZFNuYXBzaG90IiwicmVjb3JkZWRBY3Rpb25zIiwiYXV0b0Jsb2NrIiwiY29uZmxpY3RpbmdTcXVhcmVzIiwic2V0Q29uZmxpY3QiLCJzZXRNaXN0YWtlIiwiaXNTdGFnaW5nIiwidG9nZ2xlUG9zc2liaWxpdHkiLCJoYXNFbGltaW5hdGlvbnMiLCJlbGltaW5hdGVkUG9zc2liaWxpdGllcyIsInNldFN0YWdlZFBvc3NpYmlsaXRpZXMiLCJ0b2dnbGVTZWxlY3Rpb25Qb3NzaWJpbGl0eSIsInRvZ2dsZUN1ckNhZ2VDb21ibyIsImN1ckNhZ2UiLCJjbGVhckZpbHRlck1vZGUiLCJlbnRlcklmIiwibWFpblNuYXBzaG90SWQiLCJlbnRlclRoZW4iLCJpZlNuYXBzaG90SWQiLCJmaW5pc2hJbXBsaWNhdGlvbiIsInRoZW5TbmFwc2hvdElkIiwic2V0SW1wbGljYXRpb24iLCJleGl0SW1wbGljYXRpb24iLCJtYWluU25hcHNob3QiLCJjbGVhckltcGxpY2F0aW9uIiwic2lsZW50QWN0aW9ucyIsIm5ld0lkeCIsImZsb3ciLCJwdXQiLCJvbkFjdGlvbiIsImFjdGlvbiIsInNob3VsZFJlY29yZEFjdGlvbiIsImN1cnJlbnRTdGF0ZSIsIm9uU25hcHNob3QiLCJoYXNTdGFnZWRQb3NzaWJpbGl0aWVzIiwic2VsZWN0U3F1YXJlQnlQb3MiLCJ1bmRvT3JSZWRvIiwicG9wRnJvbSIsInB1c2hUbyIsIm5leHRTdGF0ZSIsImltcGxpY2F0aW9uUHV6emxlcyIsImltcGxpY2F0aW9ucyIsImdldFB1enpsZXNGcm9tSW1wbGljYXRpb24iLCJwb3NzaWJsZUltcGxpY2F0aW9ucyIsInRoZW5QdXp6bGUiLCJpc1Bvc3NpYmxlUHV6emxlIiwiZnVsZmlsbGVkSW1wbGljYXRpb25zIiwiaWZQdXp6bGUiLCJpc0Z1bGZpbGxlZFB1enpsZSIsImlmSWQiLCJ0aGVuSWQiLCJzcXVhcmVzQXJyYXkiLCJpc0NvbnNpc3RlbnRXaXRoIiwiaXNMb2dpY2FsU3Vic2V0T2YiLCJudW1iZXIiLCJtYWluSWQiLCJtYXliZU51bGwiLCJfc3RhZ2VkTWFpbiIsIl9zdGFnZWRJZiIsImlmU25hcHNob3QiLCJzdGFnZWRNYWluIiwic3RhZ2VkSWYiLCJpbXBsaWNhdGlvbiIsImF1dG9FbGltaW5hdGUiLCJtYXhEaXNwbGF5ZWRQb3NzaWJpbGl0aWVzIiwiYXV0b0Jsb2NrQ2xhc3NOYW1lIiwiYXV0b0VsaW1DbGFzc05hbWUiLCJhdXRvRWxpbU1hdGhJbXBvc3NpYmlsaXRpZXNDbGFzc05hbWUiLCJ3YWxrdGhyb3VnaENsYXNzTmFtZSIsInNldE9wdGlvbiIsInRvZ2dsZUF1dG9CbG9jayIsInRvZ2dsZUF1dG9FbGltaW5hdGUiLCJ0b2dnbGVBdXRvRWxpbU1hdGhJbXBvc3NpYmlsaXRpZXMiLCJ0b2dnbGVXYWxrdGhyb3VnaCIsInNldE1heERpc3BsYXllZFBvc3NpYmlsaXRpZXMiLCJhbHdheXNTaG93V2Fsa3Rocm91Z2giLCJ1dWlkIiwicG9zVG9JZE1hcCIsImNvbGxlY3Rpb25zIiwiZ3JvdXBzQXJyYXkiLCJnZXRTcXVhcmVCeVBvcyIsImlzVmFsaWRQb3MiLCJzdHJQb3MiLCJzcSIsImdldFNxdWFyZXNCeVJvdyIsInJvdyIsImdldFNxdWFyZXNCeUNvbCIsImNvbCIsImdldENvbGxlY3Rpb25zQnlTcXVhcmUiLCJjIiwibiIsImNvbGxlY3Rpb24iLCJtaXN0YWtlVmFsdWUiLCJpbml0aWFsUG9zc2liaWxpdGllcyIsInJvd1NxdWFyZXMiLCJjb2xTcXVhcmVzIiwicm93Q29sU3F1YXJlcyIsInJvd0NvbFZhbHVlcyIsImNvbGxlY3Rpb25Qb3NzaWJpbGl0aWVzIiwic3F1YXJlUG9zc2libGl0aWVzIiwic3F1YXJlQW5kQ29sbGVjdGlvblBvc3NpYmlsaXRpZXMiLCJpc0F1dG9FbGltaW5hdGVkVmFsdWUiLCJkYXRhUG9zIiwiaXNDb3JyZWN0IiwiaXNDYWdlVG9wIiwiaXNDYWdlTGVmdCIsImlzRm9jdXNlZCIsImlzU2VsZWN0ZWQiLCJzZWxlY3RlZFNxdWFyZXMiLCJkaXNwbGF5ZWRWYWx1ZSIsImRpc3BsYXllZFBvc3NpYmlsaXRpZXMiLCJzdGFnZWRQb3NzaWJpbGl0aWVzIiwic2hvdWxkU2hvd1Bvc3NpYmlsaXRpZXMiLCJpbml0aWFsSHRtbCIsInBvc3NpYmlsaXR5U3RhdHVzZXMiLCJzdGF0dXNlcyIsImlzU3F1YXJlRWxpbWluYXRlZFZhbHVlIiwiaXNDb2xsZWN0aW9uRWxpbWluYXRlZFZhbHVlIiwiaXNBY3RpdmVNaXN0YWtlIiwiaXNTdGFnZWRQb3NzaWJpbGl0eSIsImlzVmlzaWJsZVBvc3NpYmlsaXR5IiwicG9zc2liaWxpdHlDbGFzc05hbWUiLCJpbmZvUG9zc2liaWxpdHlTdGFnaW5nQ2xhc3NOYW1lIiwiaW5mb1Bvc3NpYmlsaXR5Q2xhc3NOYW1lIiwiaW5mb1Bvc3NpYmlsaXR5SWNvbkNsYXNzTmFtZXMiLCJob3ZlciIsIm5vSG92ZXIiLCJvdGhlclNxdWFyZSIsImlzQWJvdmUiLCJpc0xlZnRPZiIsImlzTG9naWNhbFN1cGVyc2V0T2YiLCJwb3NzaWJpbGl0eU92ZXJsYXAiLCJlbGltaW5hdGVQb3NzaWJpbGl0eSIsInVuZWxpbWluYXRlUG9zc2liaWxpdHkiLCJjdXJDb2xsZWN0aW9uIiwiZmlsdGVyTW9kZSIsImN1clBvc2l0aW9uIiwiY3VyQ2FnZUZpbHRlcmVkQ29tYm9zIiwiY3VyQ2FnZVBvc3NpYmxlQ29tYm9zIiwic3F1YXJlSW5mb1NlbGVjdENsYXNzTmFtZSIsInNxdWFyZUluZm9DbGVhckNsYXNzTmFtZSIsInNxdWFyZUluZm9TZWxlY3RJY29uQ2xhc3NOYW1lIiwic3F1YXJlSW5mb0NsZWFySWNvbkNsYXNzTmFtZSIsImxhc3RTZWxlY3RlZFNxdWFyZSIsImhhc1NlbGVjdGlvbiIsInNob3VsZFNob3dDb2xsZWN0aW9uIiwiY29sbGVjdGlvbkNsYXNzTmFtZSIsImNvb3JkIiwiaXNTZWxlY3Rpb25FbGltaW5hdGVkVmFsdWUiLCJzZWxlY3Rpb25Qb3NzaWJpbGl0eVN0YXR1c2VzIiwic3F1YXJlU3RhdHVzZXMiLCJzaGFyZWRTdGF0dXNlcyIsInMiLCJmaWx0ZXJOb0hvdmVySWNvbnMiLCJmaWx0ZXJIb3Zlckljb25zIiwiZmlsdGVyUG9zc2liaWxpdHlDbGFzc05hbWUiLCJzcXVhcmVJbmZvUG9zc2liaWxpdHlDbGFzc05hbWUiLCJzcXVhcmVJbmZvUG9zc2liaWxpdHlJY29uQ2xhc3NOYW1lcyIsImN1clJvdyIsImN1ckNvbCIsIm5ld1BvcyIsInNlbGVjdFNxdWFyZSIsIm5leHRTcXVhcmVQb3MiLCJwcmV2U3F1YXJlUG9zIiwidmFsSW5kZXgiLCJtb2RlcyIsImlkeERpZmYiLCJhYm91dEJ1dHRvbiIsImFib3V0RHJvcGRvd24iLCJvcHRpb25zQnV0dG9uIiwib3B0aW9uc0Ryb3Bkb3duIiwidW5kb0J1dHRvbiIsInJlZG9CdXR0b24iLCJuZXdCdXR0b24iLCJyZXNldEJ1dHRvbiIsInNldHVwTGlzdGVuZXJzIiwibWFrZVJlYWN0aXZlIiwiY29tYm9MaXN0RWxlIiwicG9zc2liaWxpdHlFbGVzIiwiYW5kTW9kZUJ1dHRvbiIsIm5vdE1vZGVCdXR0b24iLCJvck1vZGVCdXR0b24iLCJjbGVhck1vZGVCdXR0b24iLCJjbGVhckFsbEJ1dHRvbiIsInZhbFN0ciIsInBvc3NpYmlsaXR5RWxlIiwicmVzdG9yZUhvdmVyIiwiYWRkRmlsdGVyQnRuTGlzdGVuZXIiLCJidG4iLCJwb3NzaWJpbGl0eVJlYWN0aW9ucyIsIm5vSG92ZXJJY29uc0RpdiIsImhvdmVySWNvbnNEaXYiLCJ1cGRhdGVJY29ucyIsImljb25zRGl2IiwibmV3SWNvbnMiLCJyZXBsYWNlQ2hpbGRyZW4iLCJyZWFjdGlvbnMiLCJyZW5kZXJDb21ib3MiLCJyZW5kZXJGaWx0ZXJNb2RlQ2xhc3NOYW1lIiwiZGlzcG9zZXJzIiwiZm4iLCJhdXRvcnVuIiwiZmlsdGVyRWxlIiwiaGFzRm9jdXNlZFNxdWFyZVZhbHVlIiwic3F1YXJlTGFiZWxUZXh0Iiwic2VsZWN0SWNvbiIsImNsZWFySWNvbiIsImljb25DbGFzc05hbWVzIiwiZ2V0UG9zc2liaWxpdHlJY29ucyIsInJlbmRlckljb25DbGFzc05hbWVzIiwicmVuZGVyQnV0dG9uc0NsYXNzTmFtZSIsInJlbmRlckRpc2FibGVkU2VsZWN0Iiwic3F1YXJlSW5mb1NlbGVjdElzRGlzYWJsZWQiLCJkaXNhYmxlZCIsInJlbmRlckRpc2FibGVkQ2xlYXIiLCJzcXVhcmVJbmZvQ2xlYXJJc0Rpc2FibGVkIiwicmVuZGVyTGFiZWxUZXh0IiwiaW5uZXJIVE1MIiwibWFrZU9wdGlvbnNSZWFjdGl2ZSIsImF1dG9FbGltIiwibWF4UG9zc2liaWxpdGllc0lucHV0Iiwic3VjY2VzcyIsInJlbmRlckF1dG9CbG9jayIsInJlbmRlckF1dG9FbGltIiwicmVuZGVyQXV0b0VsaW1NYXRoSW1wb3NzaWJpbGl0aWVzIiwicmVuZGVyV2Fsa3Rocm91Z2giLCJyZW5kZXJNYXhQb3NzaWJpbGl0aWVzSW5wdXQiLCJtYXhQb3NzaWJpbGl0aWVzRXJyb3IiLCJzcXVhcmVFbGVtZW50cyIsImdldFNxdWFyZUVsZW1lbnRzRnJvbVNxdWFyZSIsInNldHVwU3F1YXJlIiwibWFrZVNxdWFyZVJlYWN0aXZlIiwiZGlzcG9zZXIiLCJjYWdlVG9wIiwiY2FnZUxlZnQiLCJyZW5kZXJWYWxOb2RlIiwicmVuZGVyQ2xhc3NOYW1lIiwic3F1YXJlU2VsZWN0b3IiLCJjcmVhdGVTcXVhcmVDaGlsZFNlbGVjdG9ycyIsImdldENoaWxkIiwiZ2V0Q2hpbGRyZW4iLCJwYXJlbnQiLCJnZXRTZWxlY3RvciIsInN1YlNlbGVjdG9yIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7Ozs7OztBQ0pBLHVCQUF1QixtQkFB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLGlCQUFpQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RCxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJIQUEySCxjQUFjO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixzQkFBc0I7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLHFKQUFxSjtBQUNySjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsMkRBQWMseUNBQXlDO0FBQ2pFO0FBQ0E7O0FBRUEsNEVBQTRFLFNBQVMsNkRBQWdCLDRDQUE0QztBQUNqSixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0EsNEJBQTRCLGtDQUFrQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBVTtBQUNwQzs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFVO0FBQ25DOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVELDJCQUEyQixtREFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4QkFBOEIscURBQVE7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3RkFBd0Y7QUFDeEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtGQUErRix1QkFBdUI7QUFDdEg7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVkscUVBQWdDO0FBQzVDLFVBQVUsNkVBQWdDO0FBQzFDO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFLFVBQVU7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sRUFBRTtBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGlEQUFpRDs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixxREFBUTtBQUN2QztBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVELGdEQUFnRCxtREFBTTtBQUN0RCw4QkFBOEIsbURBQU07QUFDcEMsMkJBQTJCLG1EQUFNOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0EsNEJBQTRCLG1EQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQsK0JBQStCLG1EQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNB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QUFFQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxTQUFTOztBQUVWO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLCtCQUErQiw4REFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFNBQVMsYUFBb0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7O0FBRW5ELCtDQUErQztBQUMvQztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7OztBQUd2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBOztBQUVBO0FBQ0EsMkVBQTJFLG1CQUFtQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFHQUFxRyx5QkFBeUI7QUFDOUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLCtDQUFVO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyxDQUFDLGtEQUFhO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDREQUFlOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTSxzREFBUztBQUNmLE1BQU0sb0RBQU87QUFDYjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFNO0FBQ25CO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVELGtDQUFrQyxtREFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtB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QUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLCtEQUFrQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxvREFBTztBQUNmO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOzs7QUFHdkIsZUFBZTtBQUNmO0FBQ0EsT0FBTyxTQUFTLFNBQVM7QUFDekI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVELG9DQUFvQyxtREFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTs7QUFFL0U7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7O0FBRS9FO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQkFBb0I7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxXQUFXLHlDQUF5QztBQUMzRDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCw2QkFBNkIsdUNBQXVDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOzs7QUFHVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Es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Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxNQUFNLElBQXFDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0EsR0FBRzs7O0FBR0gsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNB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U0FBaUI7QUFDMUc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLFVBQVUsS0FBcUM7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FB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QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBd0MsRUFBRSxFQUFPO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkVBQTZFOztBQUU3RTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5COztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQSxVQUFVLEtBQXFDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUcsRUFBRTtBQUNMLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0g7QUFDcEg7QUFDQSxHQUFHLEVBQUU7QUFDTCxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLEtBQXFDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsRUFBRTtBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRDs7QUFFMUQsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQXFDLCtCQUErQixTQUFVO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSwrREFBK0QsS0FBcUMsK0JBQStCLFNBQVU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0RUFBNEU7QUFDNUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdILE1BQU0sS0FBcUM7QUFDM0M7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QixLQUFLO0FBQ0w7QUFDQTtBQUNBLDBEQUEwRDs7QUFFMUQsNENBQTRDOzs7QUFHNUM7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBLE9BQU87QUFDUCxvQkFBb0I7QUFDcEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxRQUFRLEtBQXFDO0FBQzdDO0FBQ0EsR0FBRyxVQUFVLElBQXFDO0FBQ2xEO0FBQ0E7O0FBRUEsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxLQUFxQzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsR0FBRzs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQXFDLDBCQUEwQixTQUF1QixFQUFFOztBQUV0SDs7QUFFQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7O0FBRUEsUUFBUSxLQUFxQztBQUM3QztBQUNBOztBQUVBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQSxzQkFBc0IsS0FBcUM7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDOztBQUU5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELG1CQUFtQjtBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRCwyQ0FBMkM7O0FBRTNDLDhCQUE4Qjs7QUFFOUI7QUFDQSxtRkFBbUY7O0FBRW5GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7Ozs7O0FDcnZMQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBbVU7QUFDblUsYUFBYSx1RkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtQkFBbUIscUVBQWE7QUFDaEM7QUFDQSxnQ0FBZ0Msb0ZBQTRCO0FBQzVELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNM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Q0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEU7Ozs7Ozs7Ozs7OztBQ3ZGYTs7QUFFYixpQ0FBaUMsbUJBQU8sQ0FBQywwREFBVTtBQUNuRCxxQ0FBcUMsbUJBQU8sQ0FBQywwREFBVSxFOzs7Ozs7Ozs7OztBQ0h2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDO0FBQzFDOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBLEdBQUcsZ0NBQWdDLGtCQUFrQjtBQUNyRDs7O0FBR0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FB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QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJGQUEyRjs7QUFFM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDOzs7Ozs7Ozs7Ozs7QUNqaUNBLDREQUFjLG1CQUFPLENBQUMsc0dBQW1COztBQUV6QyxlQUFlLG1CQUFPLENBQUMsdUVBQVk7O0FBRW5DLGtCQUFrQixtQkFBTyxDQUFDLDREQUFhOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGNBQWMsbUJBQU8sQ0FBQyxpRUFBSTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLG9EQUFXOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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UyxFQUFUQSxTQURLO0FBRUxvNUIsV0FBTyxFQUFFcDVCLFNBQVMsQ0FBQ1osYUFBVixDQUF3QixrQkFBeEIsQ0FGSjtBQUdMaTZCLFlBQVEsRUFBRXI1QixTQUFTLENBQUNaLGFBQVYsQ0FBd0IsbUJBQXhCLENBSEw7QUFJTHdDLFNBQUssRUFBRTVCLFNBQVMsQ0FBQ1osYUFBVixDQUF3QixlQUF4QixDQUpGO0FBS0xtWSxTQUFLLEVBQUV2WCxTQUFTLENBQUNaLGFBQVYsQ0FBd0IsZUFBeEIsQ0FMRjtBQU1MeTJCLG1CQUFlLEVBQUU3MUIsU0FBUyxDQUFDSSxnQkFBVixDQUEyQixxQkFBM0I7QUFOWixHQUFQO0FBUUQsQzs7Ozs7Ozs7Ozs7QUMvR0QsdUMiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2Rpc3QvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL3NjcmlwdHMvaW5kZXguanNcIik7XG4iLCJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7IiwiZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlczsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXlcIik7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkOyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0XCIpO1xuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBzZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0OyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5OyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsiLCJmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZUZ1bmN0aW9uOyIsImZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0OyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5OyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQ7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkOyIsInZhciBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlID0gcmVxdWlyZShcIi4vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiKTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllczsiLCJmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZTsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWRcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTsiLCJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZlwiKTtcblxudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbnZhciBpc05hdGl2ZUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vaXNOYXRpdmVGdW5jdGlvblwiKTtcblxudmFyIGNvbnN0cnVjdCA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdFwiKTtcblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIWlzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG5cbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIGdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuXG4gIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7IiwiLyohIGh0dHA6Ly9tdGhzLmJlL2Jhc2U2NCB2MC4xLjAgYnkgQG1hdGhpYXMgfCBNSVQgbGljZW5zZSAqL1xuO1xuXG4oZnVuY3Rpb24gKHJvb3QpIHtcbiAgLy8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYC5cbiAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0czsgLy8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuXG5cbiAgdmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7IC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsIGFuZCB1c2VcbiAgLy8gaXQgYXMgYHJvb3RgLlxuXG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuICB2YXIgSW52YWxpZENoYXJhY3RlckVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9O1xuXG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgSW52YWxpZENoYXJhY3RlckVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcic7XG5cbiAgdmFyIGVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAvLyBOb3RlOiB0aGUgZXJyb3IgbWVzc2FnZXMgdXNlZCB0aHJvdWdob3V0IHRoaXMgZmlsZSBtYXRjaCB0aG9zZSB1c2VkIGJ5XG4gICAgLy8gdGhlIG5hdGl2ZSBgYXRvYmAvYGJ0b2FgIGltcGxlbWVudGF0aW9uIGluIENocm9taXVtLlxuICAgIHRocm93IG5ldyBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IobWVzc2FnZSk7XG4gIH07XG5cbiAgdmFyIFRBQkxFID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nOyAvLyBodHRwOi8vd2hhdHdnLm9yZy9odG1sL2NvbW1vbi1taWNyb3N5bnRheGVzLmh0bWwjc3BhY2UtY2hhcmFjdGVyXG5cbiAgdmFyIFJFR0VYX1NQQUNFX0NIQVJBQ1RFUlMgPSAvW1xcdFxcblxcZlxcciBdL2c7IC8vIGBkZWNvZGVgIGlzIGRlc2lnbmVkIHRvIGJlIGZ1bGx5IGNvbXBhdGlibGUgd2l0aCBgYXRvYmAgYXMgZGVzY3JpYmVkIGluIHRoZVxuICAvLyBIVE1MIFN0YW5kYXJkLiBodHRwOi8vd2hhdHdnLm9yZy9odG1sL3dlYmFwcGFwaXMuaHRtbCNkb20td2luZG93YmFzZTY0LWF0b2JcbiAgLy8gVGhlIG9wdGltaXplZCBiYXNlNjQtZGVjb2RpbmcgYWxnb3JpdGhtIHVzZWQgaXMgYmFzZWQgb24gQGF0a+KAmXMgZXhjZWxsZW50XG4gIC8vIGltcGxlbWVudGF0aW9uLiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9hdGsvMTAyMDM5NlxuXG4gIHZhciBkZWNvZGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpbnB1dCA9IFN0cmluZyhpbnB1dCkucmVwbGFjZShSRUdFWF9TUEFDRV9DSEFSQUNURVJTLCAnJyk7XG4gICAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuICAgIGlmIChsZW5ndGggJSA0ID09IDApIHtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvPT0/JC8sICcnKTtcbiAgICAgIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoICUgNCA9PSAxIHx8IC8vIGh0dHA6Ly93aGF0d2cub3JnL0MjYWxwaGFudW1lcmljLWFzY2lpLWNoYXJhY3RlcnNcbiAgICAvW14rYS16QS1aMC05L10vLnRlc3QoaW5wdXQpKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBjaGFyYWN0ZXI6IHRoZSBzdHJpbmcgdG8gYmUgZGVjb2RlZCBpcyBub3QgY29ycmVjdGx5IGVuY29kZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIGJpdENvdW50ZXIgPSAwO1xuICAgIHZhciBiaXRTdG9yYWdlO1xuICAgIHZhciBidWZmZXI7XG4gICAgdmFyIG91dHB1dCA9ICcnO1xuICAgIHZhciBwb3NpdGlvbiA9IC0xO1xuXG4gICAgd2hpbGUgKCsrcG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICAgIGJ1ZmZlciA9IFRBQkxFLmluZGV4T2YoaW5wdXQuY2hhckF0KHBvc2l0aW9uKSk7XG4gICAgICBiaXRTdG9yYWdlID0gYml0Q291bnRlciAlIDQgPyBiaXRTdG9yYWdlICogNjQgKyBidWZmZXIgOiBidWZmZXI7IC8vIFVubGVzcyB0aGlzIGlzIHRoZSBmaXJzdCBvZiBhIGdyb3VwIG9mIDQgY2hhcmFjdGVyc+KAplxuXG4gICAgICBpZiAoYml0Q291bnRlcisrICUgNCkge1xuICAgICAgICAvLyDigKZjb252ZXJ0IHRoZSBmaXJzdCA4IGJpdHMgdG8gYSBzaW5nbGUgQVNDSUkgY2hhcmFjdGVyLlxuICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGICYgYml0U3RvcmFnZSA+PiAoLTIgKiBiaXRDb3VudGVyICYgNikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07IC8vIGBlbmNvZGVgIGlzIGRlc2lnbmVkIHRvIGJlIGZ1bGx5IGNvbXBhdGlibGUgd2l0aCBgYnRvYWAgYXMgZGVzY3JpYmVkIGluIHRoZVxuICAvLyBIVE1MIFN0YW5kYXJkOiBodHRwOi8vd2hhdHdnLm9yZy9odG1sL3dlYmFwcGFwaXMuaHRtbCNkb20td2luZG93YmFzZTY0LWJ0b2FcblxuXG4gIHZhciBlbmNvZGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG5cbiAgICBpZiAoL1teXFwwLVxceEZGXS8udGVzdChpbnB1dCkpIHtcbiAgICAgIC8vIE5vdGU6IG5vIG5lZWQgdG8gc3BlY2lhbC1jYXNlIGFzdHJhbCBzeW1ib2xzIGhlcmUsIGFzIHN1cnJvZ2F0ZXMgYXJlXG4gICAgICAvLyBtYXRjaGVkLCBhbmQgdGhlIGlucHV0IGlzIHN1cHBvc2VkIHRvIG9ubHkgY29udGFpbiBBU0NJSSBhbnl3YXkuXG4gICAgICBlcnJvcignVGhlIHN0cmluZyB0byBiZSBlbmNvZGVkIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3V0c2lkZSBvZiB0aGUgJyArICdMYXRpbjEgcmFuZ2UuJyk7XG4gICAgfVxuXG4gICAgdmFyIHBhZGRpbmcgPSBpbnB1dC5sZW5ndGggJSAzO1xuICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICB2YXIgcG9zaXRpb24gPSAtMTtcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICB2YXIgYztcbiAgICB2YXIgZDtcbiAgICB2YXIgYnVmZmVyOyAvLyBNYWtlIHN1cmUgYW55IHBhZGRpbmcgaXMgaGFuZGxlZCBvdXRzaWRlIG9mIHRoZSBsb29wLlxuXG4gICAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aCAtIHBhZGRpbmc7XG5cbiAgICB3aGlsZSAoKytwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgICAgLy8gUmVhZCB0aHJlZSBieXRlcywgaS5lLiAyNCBiaXRzLlxuICAgICAgYSA9IGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24pIDw8IDE2O1xuICAgICAgYiA9IGlucHV0LmNoYXJDb2RlQXQoKytwb3NpdGlvbikgPDwgODtcbiAgICAgIGMgPSBpbnB1dC5jaGFyQ29kZUF0KCsrcG9zaXRpb24pO1xuICAgICAgYnVmZmVyID0gYSArIGIgKyBjOyAvLyBUdXJuIHRoZSAyNCBiaXRzIGludG8gZm91ciBjaHVua3Mgb2YgNiBiaXRzIGVhY2gsIGFuZCBhcHBlbmQgdGhlXG4gICAgICAvLyBtYXRjaGluZyBjaGFyYWN0ZXIgZm9yIGVhY2ggb2YgdGhlbSB0byB0aGUgb3V0cHV0LlxuXG4gICAgICBvdXRwdXQgKz0gVEFCTEUuY2hhckF0KGJ1ZmZlciA+PiAxOCAmIDB4M0YpICsgVEFCTEUuY2hhckF0KGJ1ZmZlciA+PiAxMiAmIDB4M0YpICsgVEFCTEUuY2hhckF0KGJ1ZmZlciA+PiA2ICYgMHgzRikgKyBUQUJMRS5jaGFyQXQoYnVmZmVyICYgMHgzRik7XG4gICAgfVxuXG4gICAgaWYgKHBhZGRpbmcgPT0gMikge1xuICAgICAgYSA9IGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24pIDw8IDg7XG4gICAgICBiID0gaW5wdXQuY2hhckNvZGVBdCgrK3Bvc2l0aW9uKTtcbiAgICAgIGJ1ZmZlciA9IGEgKyBiO1xuICAgICAgb3V0cHV0ICs9IFRBQkxFLmNoYXJBdChidWZmZXIgPj4gMTApICsgVEFCTEUuY2hhckF0KGJ1ZmZlciA+PiA0ICYgMHgzRikgKyBUQUJMRS5jaGFyQXQoYnVmZmVyIDw8IDIgJiAweDNGKSArICc9JztcbiAgICB9IGVsc2UgaWYgKHBhZGRpbmcgPT0gMSkge1xuICAgICAgYnVmZmVyID0gaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbik7XG4gICAgICBvdXRwdXQgKz0gVEFCTEUuY2hhckF0KGJ1ZmZlciA+PiAyKSArIFRBQkxFLmNoYXJBdChidWZmZXIgPDwgNCAmIDB4M0YpICsgJz09JztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIHZhciBiYXNlNjQgPSB7XG4gICAgJ2VuY29kZSc6IGVuY29kZSxcbiAgICAnZGVjb2RlJzogZGVjb2RlLFxuICAgICd2ZXJzaW9uJzogJzAuMS4wJ1xuICB9OyAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcbiAgLy8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYmFzZTY0O1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuICAgIGlmIChmcmVlTW9kdWxlKSB7XG4gICAgICAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuICAgICAgZnJlZU1vZHVsZS5leHBvcnRzID0gYmFzZTY0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuICAgICAgZm9yICh2YXIga2V5IGluIGJhc2U2NCkge1xuICAgICAgICBiYXNlNjQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IGJhc2U2NFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuICAgIHJvb3QuYmFzZTY0ID0gYmFzZTY0O1xuICB9XG59KSh0aGlzKTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXk7XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5O1xudmFyIGxvb2t1cCA9IFtdO1xudmFyIHJldkxvb2t1cCA9IFtdO1xudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheTtcbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldO1xuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG59IC8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcblxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjI7XG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjM7XG5cbmZ1bmN0aW9uIGdldExlbnMoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoO1xuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpO1xuICB9IC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcblxuXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9Jyk7XG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuO1xuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlbiA/IDAgOiA0IC0gdmFsaWRMZW4gJSA0O1xuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dO1xufSAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTtcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTtcbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07XG4gIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47XG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzTGVuO1xufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheShiNjQpIHtcbiAgdmFyIHRtcDtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7XG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF07XG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdO1xuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKTtcbiAgdmFyIGN1ckJ5dGUgPSAwOyAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDAgPyB2YWxpZExlbiAtIDQgOiB2YWxpZExlbjtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDE2ICYgMHhGRjtcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMHhGRjtcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNDtcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyO1xuICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDggJiAweEZGO1xuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wO1xuICB2YXIgb3V0cHV0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYgJiAweEZGMDAwMCkgKyAodWludDhbaSArIDFdIDw8IDggJiAweEZGMDApICsgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpO1xuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkodWludDgpIHtcbiAgdmFyIHRtcDtcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aDtcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzOyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgaSArIG1heENodW5rTGVuZ3RoID4gbGVuMiA/IGxlbjIgOiBpICsgbWF4Q2h1bmtMZW5ndGgpKTtcbiAgfSAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cblxuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdO1xuICAgIHBhcnRzLnB1c2gobG9va3VwW3RtcCA+PiAyXSArIGxvb2t1cFt0bXAgPDwgNCAmIDB4M0ZdICsgJz09Jyk7XG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdO1xuICAgIHBhcnRzLnB1c2gobG9va3VwW3RtcCA+PiAxMF0gKyBsb29rdXBbdG1wID4+IDQgJiAweDNGXSArIGxvb2t1cFt0bXAgPDwgMiAmIDB4M0ZdICsgJz0nKTtcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbn0iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJyk7XG5cbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpO1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyO1xuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwO1xuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWQgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCA6IHR5cGVkQXJyYXlTdXBwb3J0KCk7XG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKTtcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgIGFyci5fX3Byb3RvX18gPSB7XG4gICAgICBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLFxuICAgICAgZm9vOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiA0MjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMDsgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPyAweDdmZmZmZmZmIDogMHgzZmZmZmZmZjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgIH1cblxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHRoYXQ7XG59XG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cblxuZnVuY3Rpb24gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgfSAvLyBDb21tb24gY2FzZS5cblxuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKTtcbiAgfVxuXG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MjsgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIHJldHVybiBhcnI7XG59O1xuXG5mdW5jdGlvbiBmcm9tKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7XG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSk7XG59XG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5cblxuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbn07XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlO1xuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheTtcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiYgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKTtcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG5cbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSk7XG4gIH1cblxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5cblxuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZyk7XG59O1xuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApO1xuXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoYXQ7XG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuXG5cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKTtcbn07XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5cblxuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKTtcbn07XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKTtcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbCk7XG4gIH1cblxuICByZXR1cm4gdGhhdDtcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NTtcbiAgfVxuXG4gIHJldHVybiB0aGF0O1xufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoOyAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KTtcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5O1xuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpO1xuICB9XG5cbiAgcmV0dXJuIHRoYXQ7XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDtcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7XG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0O1xuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbik7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopO1xuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICsgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJyk7XG4gIH1cblxuICByZXR1cm4gbGVuZ3RoIHwgMDtcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlcihsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKTtcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKTtcbn07XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJyk7XG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDA7XG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICBpZiAoeSA8IHgpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn07XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyhlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gIH1cblxuICB2YXIgaTtcblxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIHZhciBwb3MgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG5cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtcbiAgICB9XG5cbiAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDA7IC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlbjtcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoO1xuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMjtcblxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMTtcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoOyAvLyBhc3N1bWUgdXRmOFxuXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7IC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH0gLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cblxuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cblxuXG4gIGVuZCA+Pj49IDA7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufSAvLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cblxuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWU7XG5cbmZ1bmN0aW9uIHN3YXAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl07XG4gIGJbbl0gPSBiW21dO1xuICBiW21dID0gaTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMigpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJyk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJyk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpO1xuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJyk7XG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUztcblxuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJyk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJztcbiAgfVxuXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMDtcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDA7XG4gIH1cblxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpO1xuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgc3RhcnQgPj4+PSAwO1xuICBlbmQgPj4+PSAwO1xuICB0aGlzU3RhcnQgPj4+PSAwO1xuICB0aGlzRW5kID4+Pj0gMDtcbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDA7XG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydDtcbiAgdmFyIHkgPSBlbmQgLSBzdGFydDtcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpO1xuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCk7XG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXTtcbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gIGlmICh5IDwgeCkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufTsgLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5cblxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTE7IC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG5cbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDtcbiAgICBieXRlT2Zmc2V0ID0gMDtcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMDtcbiAgfVxuXG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgLy8gQ29lcmNlIHRvIE51bWJlci5cblxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IGJ1ZmZlci5sZW5ndGggLSAxO1xuICB9IC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG5cblxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldDtcblxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xO2Vsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDA7ZWxzZSByZXR1cm4gLTE7XG4gIH0gLy8gTm9ybWFsaXplIHZhbFxuXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZyk7XG4gIH0gLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcblxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRjsgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcik7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxO1xuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8IGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGluZGV4U2l6ZSA9IDI7XG4gICAgICBhcnJMZW5ndGggLz0gMjtcbiAgICAgIHZhbExlbmd0aCAvPSAyO1xuICAgICAgYnl0ZU9mZnNldCAvPSAyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGk7XG5cbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTE7XG5cbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleDtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDtcblxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXModmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gaGV4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0O1xuXG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpO1xuXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfSAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuXG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpO1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZDtcbiAgfVxuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7IC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDsgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcblxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwO1xuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9IC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcblxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nO1xuXG4gIGlmIChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH07XG59O1xuXG5mdW5jdGlvbiBiYXNlNjRTbGljZShidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZShidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSA9IHN0YXJ0O1xuXG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXTtcbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbDtcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IGZpcnN0Qnl0ZSA+IDB4RUYgPyA0IDogZmlyc3RCeXRlID4gMHhERiA/IDMgOiBmaXJzdEJ5dGUgPiAweEJGID8gMiA6IDE7XG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50O1xuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgc2Vjb25kQnl0ZSAmIDB4M0Y7XG5cbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdO1xuXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCB0aGlyZEJ5dGUgJiAweDNGO1xuXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM107XG5cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCBmb3VydGhCeXRlICYgMHgzRjtcblxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEO1xuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRjtcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpO1xuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKTtcbn0gLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5cblxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwO1xuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7XG5cbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cyk7IC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfSAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG5cblxuICB2YXIgcmVzID0gJyc7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJyc7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJyc7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuICB2YXIgb3V0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZShidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB2YXIgcmVzID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgc3RhcnQgPSB+fnN0YXJ0O1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW47XG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW47XG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDA7XG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcbiAgdmFyIG5ld0J1ZjtcblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmO1xufTtcbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0KG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKG9mZnNldCAlIDEgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpO1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXTtcbiAgdmFyIG11bCA9IDE7XG5cbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bDtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gdGhpc1tvZmZzZXRdO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMV07XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpICsgdGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gKiAweDEwMDAwMDAgKyAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgM10pO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cblxuICBtdWwgKj0gMHg4MDtcbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB2YWw7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG4gIHZhciBpID0gYnl0ZUxlbmd0aDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG5cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bDtcbiAgfVxuXG4gIG11bCAqPSAweDgwO1xuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuIHRoaXNbb2Zmc2V0XTtcbiAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4O1xuICByZXR1cm4gdmFsICYgMHg4MDAwID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8IHRoaXNbb2Zmc2V0XSA8PCA4O1xuICByZXR1cm4gdmFsICYgMHg4MDAwID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQ7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCAyNCB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOCk7XG59O1xuXG5mdW5jdGlvbiBjaGVja0ludChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcblxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAvIG11bCAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIHZhciBtdWwgPSAxO1xuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAvIG11bCAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4ZmY7XG4gIHJldHVybiBvZmZzZXQgKyAxO1xufTtcblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDE7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmIDB4ZmYgPDwgOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4O1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweGZmO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyAyO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODtcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgJiAweGZmO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyAyO1xufTtcblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSB2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4ICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0O1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gMTY7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4O1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyA0O1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDI0O1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gMTY7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiA4O1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDB4ZmY7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIDQ7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBzdWIgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG5cbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG5cbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCk7XG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHN1YiA9IDA7XG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG5cbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MCk7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMTtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweGZmO1xuICByZXR1cm4gb2Zmc2V0ICsgMTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgMjtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiA4O1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSAmIDB4ZmY7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIDI7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjtcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0O1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIDQ7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDI0O1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gMTY7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiA4O1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDB4ZmY7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIDQ7XG59O1xuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOCk7XG4gIH1cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0O1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVEb3VibGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KTtcbiAgfVxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KTtcbiAgcmV0dXJuIG9mZnNldCArIDg7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59OyAvLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5cblxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aDtcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwO1xuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7IC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMDtcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwOyAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG5cbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJyk7IC8vIEFyZSB3ZSBvb2I/XG5cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgdmFyIGk7XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbCh0YXJnZXQsIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0U3RhcnQpO1xuICB9XG5cbiAgcmV0dXJuIGxlbjtcbn07IC8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuXG5cbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kO1xuICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1O1xuICB9IC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpO1xuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMDtcbiAgaWYgKCF2YWwpIHZhbCA9IDA7XG4gIHZhciBpO1xuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpID8gdmFsIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKTtcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTsgLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZztcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4oc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpOyAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG5cbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJyc7IC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuXG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9JztcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0oc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKCk7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufVxuXG5mdW5jdGlvbiB0b0hleChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7XG4gIHZhciBjb2RlUG9pbnQ7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTsgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuXG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdmFsaWQgbGVhZFxuXG5cbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIDIgbGVhZHMgaW4gYSByb3dcblxuXG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG5cblxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDsgLy8gZW5jb2RlIHV0ZjhcblxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWs7XG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrO1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCwgY29kZVBvaW50ICYgMHgzRiB8IDB4ODApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrO1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCwgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLCBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MCk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrO1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCwgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLCBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyhzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG87XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVhaztcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGkgPSBjID4+IDg7XG4gICAgbG8gPSBjICUgMjU2O1xuICAgIGJ5dGVBcnJheS5wdXNoKGxvKTtcbiAgICBieXRlQXJyYXkucHVzaChoaSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpO1xufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCB8fCBpID49IHNyYy5sZW5ndGgpIGJyZWFrO1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTtcbiAgfVxuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBpc25hbih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufSIsInZhciBjbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9pbnN0YW5jZW9mKG9iaiwgdHlwZSkge1xuICAgIHJldHVybiB0eXBlICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuXG4gIHZhciBuYXRpdmVNYXA7XG5cbiAgdHJ5IHtcbiAgICBuYXRpdmVNYXAgPSBNYXA7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBtYXliZSBhIHJlZmVyZW5jZSBlcnJvciBiZWNhdXNlIG5vIGBNYXBgLiBHaXZlIGl0IGEgZHVtbXkgdmFsdWUgdGhhdCBub1xuICAgIC8vIHZhbHVlIHdpbGwgZXZlciBiZSBhbiBpbnN0YW5jZW9mLlxuICAgIG5hdGl2ZU1hcCA9IGZ1bmN0aW9uICgpIHt9O1xuICB9XG5cbiAgdmFyIG5hdGl2ZVNldDtcblxuICB0cnkge1xuICAgIG5hdGl2ZVNldCA9IFNldDtcbiAgfSBjYXRjaCAoXykge1xuICAgIG5hdGl2ZVNldCA9IGZ1bmN0aW9uICgpIHt9O1xuICB9XG5cbiAgdmFyIG5hdGl2ZVByb21pc2U7XG5cbiAgdHJ5IHtcbiAgICBuYXRpdmVQcm9taXNlID0gUHJvbWlzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIG5hdGl2ZVByb21pc2UgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIChjb3BpZXMpIGFuIE9iamVjdCB1c2luZyBkZWVwIGNvcHlpbmcuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSBkZWZhdWx0LCBidXQgaWYgeW91IGFyZSBjZXJ0YWluXG4gICAqIHRoZXJlIGFyZSBubyBjaXJjdWxhciByZWZlcmVuY2VzIGluIHlvdXIgb2JqZWN0LCB5b3UgY2FuIHNhdmUgc29tZSBDUFUgdGltZVxuICAgKiBieSBjYWxsaW5nIGNsb25lKG9iaiwgZmFsc2UpLlxuICAgKlxuICAgKiBDYXV0aW9uOiBpZiBgY2lyY3VsYXJgIGlzIGZhbHNlIGFuZCBgcGFyZW50YCBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzLFxuICAgKiB5b3VyIHByb2dyYW0gbWF5IGVudGVyIGFuIGluZmluaXRlIGxvb3AgYW5kIGNyYXNoLlxuICAgKlxuICAgKiBAcGFyYW0gYHBhcmVudGAgLSB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZFxuICAgKiBAcGFyYW0gYGNpcmN1bGFyYCAtIHNldCB0byB0cnVlIGlmIHRoZSBvYmplY3QgdG8gYmUgY2xvbmVkIG1heSBjb250YWluXG4gICAqICAgIGNpcmN1bGFyIHJlZmVyZW5jZXMuIChvcHRpb25hbCAtIHRydWUgYnkgZGVmYXVsdClcbiAgICogQHBhcmFtIGBkZXB0aGAgLSBzZXQgdG8gYSBudW1iZXIgaWYgdGhlIG9iamVjdCBpcyBvbmx5IHRvIGJlIGNsb25lZCB0b1xuICAgKiAgICBhIHBhcnRpY3VsYXIgZGVwdGguIChvcHRpb25hbCAtIGRlZmF1bHRzIHRvIEluZmluaXR5KVxuICAgKiBAcGFyYW0gYHByb3RvdHlwZWAgLSBzZXRzIHRoZSBwcm90b3R5cGUgdG8gYmUgdXNlZCB3aGVuIGNsb25pbmcgYW4gb2JqZWN0LlxuICAgKiAgICAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBwYXJlbnQgcHJvdG90eXBlKS5cbiAgICogQHBhcmFtIGBpbmNsdWRlTm9uRW51bWVyYWJsZWAgLSBzZXQgdG8gdHJ1ZSBpZiB0aGUgbm9uLWVudW1lcmFibGUgcHJvcGVydGllc1xuICAgKiAgICBzaG91bGQgYmUgY2xvbmVkIGFzIHdlbGwuIE5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgb24gdGhlIHByb3RvdHlwZVxuICAgKiAgICBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuIChvcHRpb25hbCAtIGZhbHNlIGJ5IGRlZmF1bHQpXG4gICovXG5cblxuICBmdW5jdGlvbiBjbG9uZShwYXJlbnQsIGNpcmN1bGFyLCBkZXB0aCwgcHJvdG90eXBlLCBpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICAgIGlmICh0eXBlb2YgY2lyY3VsYXIgPT09ICdvYmplY3QnKSB7XG4gICAgICBkZXB0aCA9IGNpcmN1bGFyLmRlcHRoO1xuICAgICAgcHJvdG90eXBlID0gY2lyY3VsYXIucHJvdG90eXBlO1xuICAgICAgaW5jbHVkZU5vbkVudW1lcmFibGUgPSBjaXJjdWxhci5pbmNsdWRlTm9uRW51bWVyYWJsZTtcbiAgICAgIGNpcmN1bGFyID0gY2lyY3VsYXIuY2lyY3VsYXI7XG4gICAgfSAvLyBtYWludGFpbiB0d28gYXJyYXlzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzLCB3aGVyZSBjb3JyZXNwb25kaW5nIHBhcmVudHNcbiAgICAvLyBhbmQgY2hpbGRyZW4gaGF2ZSB0aGUgc2FtZSBpbmRleFxuXG5cbiAgICB2YXIgYWxsUGFyZW50cyA9IFtdO1xuICAgIHZhciBhbGxDaGlsZHJlbiA9IFtdO1xuICAgIHZhciB1c2VCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9ICd1bmRlZmluZWQnO1xuICAgIGlmICh0eXBlb2YgY2lyY3VsYXIgPT0gJ3VuZGVmaW5lZCcpIGNpcmN1bGFyID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGRlcHRoID09ICd1bmRlZmluZWQnKSBkZXB0aCA9IEluZmluaXR5OyAvLyByZWN1cnNlIHRoaXMgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzZXQgYWxsUGFyZW50cyBhbmQgYWxsQ2hpbGRyZW5cblxuICAgIGZ1bmN0aW9uIF9jbG9uZShwYXJlbnQsIGRlcHRoKSB7XG4gICAgICAvLyBjbG9uaW5nIG51bGwgYWx3YXlzIHJldHVybnMgbnVsbFxuICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoZGVwdGggPT09IDApIHJldHVybiBwYXJlbnQ7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICB2YXIgcHJvdG87XG5cbiAgICAgIGlmICh0eXBlb2YgcGFyZW50ICE9ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZU1hcCkpIHtcbiAgICAgICAgY2hpbGQgPSBuZXcgbmF0aXZlTWFwKCk7XG4gICAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlU2V0KSkge1xuICAgICAgICBjaGlsZCA9IG5ldyBuYXRpdmVTZXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVQcm9taXNlKSkge1xuICAgICAgICBjaGlsZCA9IG5ldyBuYXRpdmVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBwYXJlbnQudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoX2Nsb25lKGVyciwgZGVwdGggLSAxKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzQXJyYXkocGFyZW50KSkge1xuICAgICAgICBjaGlsZCA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzUmVnRXhwKHBhcmVudCkpIHtcbiAgICAgICAgY2hpbGQgPSBuZXcgUmVnRXhwKHBhcmVudC5zb3VyY2UsIF9fZ2V0UmVnRXhwRmxhZ3MocGFyZW50KSk7XG4gICAgICAgIGlmIChwYXJlbnQubGFzdEluZGV4KSBjaGlsZC5sYXN0SW5kZXggPSBwYXJlbnQubGFzdEluZGV4O1xuICAgICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzRGF0ZShwYXJlbnQpKSB7XG4gICAgICAgIGNoaWxkID0gbmV3IERhdGUocGFyZW50LmdldFRpbWUoKSk7XG4gICAgICB9IGVsc2UgaWYgKHVzZUJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIocGFyZW50KSkge1xuICAgICAgICBjaGlsZCA9IG5ldyBCdWZmZXIocGFyZW50Lmxlbmd0aCk7XG4gICAgICAgIHBhcmVudC5jb3B5KGNoaWxkKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIEVycm9yKSkge1xuICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcbiAgICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocHJvdG8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgICAgIHByb3RvID0gcHJvdG90eXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaXJjdWxhcikge1xuICAgICAgICB2YXIgaW5kZXggPSBhbGxQYXJlbnRzLmluZGV4T2YocGFyZW50KTtcblxuICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gYWxsQ2hpbGRyZW5baW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgYWxsUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIGFsbENoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVNYXApKSB7XG4gICAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgdmFyIGtleUNoaWxkID0gX2Nsb25lKGtleSwgZGVwdGggLSAxKTtcblxuICAgICAgICAgIHZhciB2YWx1ZUNoaWxkID0gX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpO1xuXG4gICAgICAgICAgY2hpbGQuc2V0KGtleUNoaWxkLCB2YWx1ZUNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVNldCkpIHtcbiAgICAgICAgcGFyZW50LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGVudHJ5Q2hpbGQgPSBfY2xvbmUodmFsdWUsIGRlcHRoIC0gMSk7XG5cbiAgICAgICAgICBjaGlsZC5hZGQoZW50cnlDaGlsZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpIGluIHBhcmVudCkge1xuICAgICAgICB2YXIgYXR0cnM7XG5cbiAgICAgICAgaWYgKHByb3RvKSB7XG4gICAgICAgICAgYXR0cnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRycyAmJiBhdHRycy5zZXQgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRbaV0gPSBfY2xvbmUocGFyZW50W2ldLCBkZXB0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocGFyZW50KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBEb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IGNsb25pbmcgYSBzeW1ib2wgYmVjYXVzZSBpdCBpcyBhIHByaW1pdGl2ZSxcbiAgICAgICAgICAvLyBsaWtlIGEgbnVtYmVyIG9yIHN0cmluZy5cbiAgICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc1tpXTtcbiAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBzeW1ib2wpO1xuXG4gICAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZW51bWVyYWJsZSAmJiAhaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkW3N5bWJvbF0gPSBfY2xvbmUocGFyZW50W3N5bWJvbF0sIGRlcHRoIC0gMSk7XG5cbiAgICAgICAgICBpZiAoIWRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBzeW1ib2wsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgICAgdmFyIGFsbFByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwYXJlbnQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsUHJvcGVydHlOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBhbGxQcm9wZXJ0eU5hbWVzW2ldO1xuICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIHByb3BlcnR5TmFtZSk7XG5cbiAgICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkW3Byb3BlcnR5TmFtZV0gPSBfY2xvbmUocGFyZW50W3Byb3BlcnR5TmFtZV0sIGRlcHRoIC0gMSk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cblxuICAgIHJldHVybiBfY2xvbmUocGFyZW50LCBkZXB0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFNpbXBsZSBmbGF0IGNsb25lIHVzaW5nIHByb3RvdHlwZSwgYWNjZXB0cyBvbmx5IG9iamVjdHMsIHVzZWZ1bGwgZm9yIHByb3BlcnR5XG4gICAqIG92ZXJyaWRlIG9uIEZMQVQgY29uZmlndXJhdGlvbiBvYmplY3QgKG5vIG5lc3RlZCBwcm9wcykuXG4gICAqXG4gICAqIFVTRSBXSVRIIENBVVRJT04hIFRoaXMgbWF5IG5vdCBiZWhhdmUgYXMgeW91IHdpc2ggaWYgeW91IGRvIG5vdCBrbm93IGhvdyB0aGlzXG4gICAqIHdvcmtzLlxuICAgKi9cblxuXG4gIGNsb25lLmNsb25lUHJvdG90eXBlID0gZnVuY3Rpb24gY2xvbmVQcm90b3R5cGUocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgYyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgYy5wcm90b3R5cGUgPSBwYXJlbnQ7XG4gICAgcmV0dXJuIG5ldyBjKCk7XG4gIH07IC8vIHByaXZhdGUgdXRpbGl0eSBmdW5jdGlvbnNcblxuXG4gIGZ1bmN0aW9uIF9fb2JqVG9TdHIobykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG4gIH1cblxuICBjbG9uZS5fX29ialRvU3RyID0gX19vYmpUb1N0cjtcblxuICBmdW5jdGlvbiBfX2lzRGF0ZShvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBEYXRlXSc7XG4gIH1cblxuICBjbG9uZS5fX2lzRGF0ZSA9IF9faXNEYXRlO1xuXG4gIGZ1bmN0aW9uIF9faXNBcnJheShvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9XG5cbiAgY2xvbmUuX19pc0FycmF5ID0gX19pc0FycmF5O1xuXG4gIGZ1bmN0aW9uIF9faXNSZWdFeHAobykge1xuICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG4gIH1cblxuICBjbG9uZS5fX2lzUmVnRXhwID0gX19pc1JlZ0V4cDtcblxuICBmdW5jdGlvbiBfX2dldFJlZ0V4cEZsYWdzKHJlKSB7XG4gICAgdmFyIGZsYWdzID0gJyc7XG4gICAgaWYgKHJlLmdsb2JhbCkgZmxhZ3MgKz0gJ2cnO1xuICAgIGlmIChyZS5pZ25vcmVDYXNlKSBmbGFncyArPSAnaSc7XG4gICAgaWYgKHJlLm11bHRpbGluZSkgZmxhZ3MgKz0gJ20nO1xuICAgIHJldHVybiBmbGFncztcbiAgfVxuXG4gIGNsb25lLl9fZ2V0UmVnRXhwRmxhZ3MgPSBfX2dldFJlZ0V4cEZsYWdzO1xuICByZXR1cm4gY2xvbmU7XG59KCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xufSIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IC03O1xuICB2YXIgaSA9IGlzTEUgPyBuQnl0ZXMgLSAxIDogMDtcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxO1xuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcbiAgaSArPSBkO1xuICBlID0gcyAmICgxIDw8IC1uQml0cykgLSAxO1xuICBzID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IGVMZW47XG5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKHMgPyAtMSA6IDEpICogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG5cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gbUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDA7XG4gIHZhciBpID0gaXNMRSA/IDAgOiBuQnl0ZXMgLSAxO1xuICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMDtcbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IGUgPDwgbUxlbiB8IG07XG4gIGVMZW4gKz0gbUxlbjtcblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7IiwidmFyIHBhdGhHZXR0ZXIgPSByZXF1aXJlKCcuL3BhdGgtZ2V0dGVyJyk7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIFdNYXAgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgPyBXZWFrTWFwIDogZnVuY3Rpb24gKCkge1xuICB2YXIga2V5cyA9IFtdO1xuICB2YXIgdmFsdWVzID0gW107XG4gIHJldHVybiB7XG4gICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoa2V5c1tpXSA9PT0ga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07IC8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3VnbGFzY3JvY2tmb3JkL0pTT04tanMvYmxvYi9tYXN0ZXIvY3ljbGUuanNcblxuZXhwb3J0cy5kZWN5Y2xlID0gZnVuY3Rpb24gZGVjeWNsZShvYmplY3QsIG9wdGlvbnMsIHJlcGxhY2VyKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbWFwID0gbmV3IFdNYXAoKTtcbiAgdmFyIG5vQ2lyY3VsYXJPcHRpb24gPSAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdjaXJjdWxhcicpO1xuICB2YXIgd2l0aFJlZnMgPSBvcHRpb25zLnJlZnMgIT09IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gZGVyZXooX3ZhbHVlLCBwYXRoLCBrZXkpIHtcbiAgICAvLyBUaGUgZGVyZXogcmVjdXJzZXMgdGhyb3VnaCB0aGUgb2JqZWN0LCBwcm9kdWNpbmcgdGhlIGRlZXAgY29weS5cbiAgICB2YXIgaSwgLy8gVGhlIGxvb3AgY291bnRlclxuICAgIG5hbWUsIC8vIFByb3BlcnR5IG5hbWVcbiAgICBudTsgLy8gVGhlIG5ldyBvYmplY3Qgb3IgYXJyYXlcbiAgICAvLyB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCcsIHNvIGdvIG9uIGlmIHRoaXMgdmFsdWUgaXMgcmVhbGx5IGFuIG9iamVjdCBidXQgbm90XG4gICAgLy8gb25lIG9mIHRoZSB3ZWlyZCBidWlsdGluIG9iamVjdHMuXG5cbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgPyByZXBsYWNlcihrZXkgfHwgJycsIF92YWx1ZSkgOiBfdmFsdWU7XG5cbiAgICBpZiAob3B0aW9ucy5kYXRlICYmIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJGpzYW46ICdkJyArIHZhbHVlLmdldFRpbWUoKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yZWdleCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJGpzYW46ICdyJyArIHV0aWxzLmdldFJlZ2V4RmxhZ3ModmFsdWUpICsgJywnICsgdmFsdWUuc291cmNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zWydmdW5jdGlvbiddICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJGpzYW46ICdmJyArIHV0aWxzLnN0cmluZ2lmeUZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zWydmdW5jdGlvbiddKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uc1snbmFuJ10gJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICRqc2FuOiAnbidcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnNbJ2luZmluaXR5J10pIHtcbiAgICAgIGlmIChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPT09IHZhbHVlKSByZXR1cm4ge1xuICAgICAgICAkanNhbjogJ2knXG4gICAgICB9O1xuICAgICAgaWYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gdmFsdWUpIHJldHVybiB7XG4gICAgICAgICRqc2FuOiAneSdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnNbJ3VuZGVmaW5lZCddICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICRqc2FuOiAndSdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnNbJ2Vycm9yJ10gJiYgdmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJGpzYW46ICdlJyArIHZhbHVlLm1lc3NhZ2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnNbJ3N5bWJvbCddICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHZhciBzeW1ib2xLZXkgPSBTeW1ib2wua2V5Rm9yKHZhbHVlKTtcblxuICAgICAgaWYgKHN5bWJvbEtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgJGpzYW46ICdnJyArIHN5bWJvbEtleVxuICAgICAgICB9O1xuICAgICAgfSAvLyAnU3ltYm9sKGZvbyknLnNsaWNlKDcsIC0xKSA9PT0gJ2ZvbydcblxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAkanNhbjogJ3MnICsgdmFsdWUudG9TdHJpbmcoKS5zbGljZSg3LCAtMSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnNbJ21hcCddICYmIHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXAgJiYgdHlwZW9mIEFycmF5LmZyb20gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICRqc2FuOiAnbScgKyBKU09OLnN0cmluZ2lmeShkZWN5Y2xlKEFycmF5LmZyb20odmFsdWUpLCBvcHRpb25zLCByZXBsYWNlcikpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zWydzZXQnXSAmJiB0eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlIGluc3RhbmNlb2YgU2V0ICYmIHR5cGVvZiBBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAkanNhbjogJ2wnICsgSlNPTi5zdHJpbmdpZnkoZGVjeWNsZShBcnJheS5mcm9tKHZhbHVlKSwgb3B0aW9ucywgcmVwbGFjZXIpKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHZhciBrZXlTdHJpbmcgPSBrZXkgfHwgJyQnO1xuICAgICAgICByZXR1cm4gXCJ0b0pTT04gZmFpbGVkIGZvciAnXCIgKyAobWFwLmdldCh2YWx1ZSkgfHwga2V5U3RyaW5nKSArIFwiJ1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICEodmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykgJiYgISh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IG9yIGFycmF5LCBsb29rIHRvIHNlZSBpZiB3ZSBoYXZlIGFscmVhZHlcbiAgICAgIC8vIGVuY291bnRlcmVkIGl0LiBJZiBzbywgcmV0dXJuIGEgJHJlZi9wYXRoIG9iamVjdC5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBmb3VuZFBhdGggPSBtYXAuZ2V0KHZhbHVlKTtcblxuICAgICAgICBpZiAoZm91bmRQYXRoKSB7XG4gICAgICAgICAgaWYgKG5vQ2lyY3VsYXJPcHRpb24gJiYgd2l0aFJlZnMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICRqc2FuOiBmb3VuZFBhdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGguaW5kZXhPZihmb3VuZFBhdGgpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoIW5vQ2lyY3VsYXJPcHRpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvcHRpb25zLmNpcmN1bGFyID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5jaXJjdWxhcih2YWx1ZSwgcGF0aCwgZm91bmRQYXRoKSA6IG9wdGlvbnMuY2lyY3VsYXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICRqc2FuOiBmb3VuZFBhdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdpdGhSZWZzKSByZXR1cm4ge1xuICAgICAgICAgICAgJGpzYW46IGZvdW5kUGF0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBtYXAuc2V0KHZhbHVlLCBwYXRoKTtcbiAgICAgIH0gLy8gSWYgaXQgaXMgYW4gYXJyYXksIHJlcGxpY2F0ZSB0aGUgYXJyYXkuXG5cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIG51ID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgbnVbaV0gPSBkZXJleih2YWx1ZVtpXSwgcGF0aCArICdbJyArIGkgKyAnXScsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBpdCBpcyBhbiBvYmplY3QsIHJlcGxpY2F0ZSB0aGUgb2JqZWN0LlxuICAgICAgICBudSA9IHt9O1xuXG4gICAgICAgIGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIG5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGggPSAvXlxcdyskLy50ZXN0KG5hbWUpID8gJy4nICsgbmFtZSA6ICdbJyArIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgJ10nO1xuICAgICAgICAgICAgbnVbbmFtZV0gPSBuYW1lID09PSAnJGpzYW4nID8gW2RlcmV6KHZhbHVlW25hbWVdLCBwYXRoICsgbmV4dFBhdGgpXSA6IGRlcmV6KHZhbHVlW25hbWVdLCBwYXRoICsgbmV4dFBhdGgsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KG9iamVjdCwgJyQnKTtcbn07XG5cbmV4cG9ydHMucmV0cm9jeWNsZSA9IGZ1bmN0aW9uIHJldHJvY3ljbGUoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJleih2YWx1ZSkge1xuICAgIC8vIFRoZSByZXogZnVuY3Rpb24gd2Fsa3MgcmVjdXJzaXZlbHkgdGhyb3VnaCB0aGUgb2JqZWN0IGxvb2tpbmcgZm9yICRqc2FuXG4gICAgLy8gcHJvcGVydGllcy4gV2hlbiBpdCBmaW5kcyBvbmUgdGhhdCBoYXMgYSB2YWx1ZSB0aGF0IGlzIGEgcGF0aCwgdGhlbiBpdFxuICAgIC8vIHJlcGxhY2VzIHRoZSAkanNhbiBvYmplY3Qgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgdmFsdWUgdGhhdCBpcyBmb3VuZCBieVxuICAgIC8vIHRoZSBwYXRoLlxuICAgIHZhciBpLCBpdGVtLCBuYW1lLCBwYXRoO1xuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpdGVtID0gdmFsdWVbaV07XG5cbiAgICAgICAgICBpZiAoaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLiRqc2FuKSB7XG4gICAgICAgICAgICAgIHZhbHVlW2ldID0gdXRpbHMucmVzdG9yZShpdGVtLiRqc2FuLCAkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJleihpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICAgIC8vIGJhc2UgY2FzZSBwYXNzZWQgcmF3IG9iamVjdFxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVbbmFtZV0gPT09ICdzdHJpbmcnICYmIG5hbWUgPT09ICckanNhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5yZXN0b3JlKHZhbHVlLiRqc2FuLCAkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJyRqc2FuJykge1xuICAgICAgICAgICAgICB2YWx1ZVtuYW1lXSA9IHZhbHVlW25hbWVdWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlW25hbWVdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBpdGVtID0gdmFsdWVbbmFtZV07XG5cbiAgICAgICAgICAgICAgaWYgKGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uJGpzYW4pIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlW25hbWVdID0gdXRpbHMucmVzdG9yZShpdGVtLiRqc2FuLCAkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV6KGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSgkKTtcbn07IiwidmFyIGN5Y2xlID0gcmVxdWlyZSgnLi9jeWNsZScpO1xuXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlLCBfb3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeS5hcHBseShKU09OLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IF9vcHRpb25zIHx8IGZhbHNlO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgICdkYXRlJzogb3B0aW9ucyxcbiAgICAgICdmdW5jdGlvbic6IG9wdGlvbnMsXG4gICAgICAncmVnZXgnOiBvcHRpb25zLFxuICAgICAgJ3VuZGVmaW5lZCc6IG9wdGlvbnMsXG4gICAgICAnZXJyb3InOiBvcHRpb25zLFxuICAgICAgJ3N5bWJvbCc6IG9wdGlvbnMsXG4gICAgICAnbWFwJzogb3B0aW9ucyxcbiAgICAgICdzZXQnOiBvcHRpb25zLFxuICAgICAgJ25hbic6IG9wdGlvbnMsXG4gICAgICAnaW5maW5pdHknOiBvcHRpb25zXG4gICAgfTtcbiAgfVxuXG4gIHZhciBkZWN5Y2xlZCA9IGN5Y2xlLmRlY3ljbGUodmFsdWUsIG9wdGlvbnMsIHJlcGxhY2VyKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkZWN5Y2xlZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVjeWNsZSBhbHJlYWR5IGhhbmRsZXMgd2hlbiByZXBsYWNlciBpcyBhIGZ1bmN0aW9uLlxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkZWN5Y2xlZCwgQXJyYXkuaXNBcnJheShyZXBsYWNlcikgPyByZXBsYWNlciA6IG51bGwsIHNwYWNlKTtcbiAgfVxufTtcblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIHJldml2ZXIpIHtcbiAgdmFyIG5lZWRzUmV0cm9jeWNsZSA9IC9cIlxcJGpzYW5cIi8udGVzdCh0ZXh0KTtcbiAgdmFyIHBhcnNlZDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHBhcnNlZCA9IEpTT04ucGFyc2UodGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkID0gSlNPTi5wYXJzZSh0ZXh0LCByZXZpdmVyKTtcbiAgfVxuXG4gIGlmIChuZWVkc1JldHJvY3ljbGUpIHtcbiAgICBwYXJzZWQgPSBjeWNsZS5yZXRyb2N5Y2xlKHBhcnNlZCk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VkO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHBhdGhHZXR0ZXI7XG5cbmZ1bmN0aW9uIHBhdGhHZXR0ZXIob2JqLCBwYXRoKSB7XG4gIGlmIChwYXRoICE9PSAnJCcpIHtcbiAgICB2YXIgcGF0aHMgPSBnZXRQYXRocyhwYXRoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhdGggPSBwYXRoc1tpXS50b1N0cmluZygpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKTtcbiAgICAgIGlmICh0eXBlb2Ygb2JqW3BhdGhdID09PSAndW5kZWZpbmVkJyAmJiBpICE9PSBwYXRocy5sZW5ndGggLSAxKSBjb250aW51ZTtcbiAgICAgIG9iaiA9IG9ialtwYXRoXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBnZXRQYXRocyhwYXRoU3RyaW5nKSB7XG4gIHZhciByZWdleCA9IC8oPzpcXC4oXFx3KykpfCg/OlxcWyhcXGQrKVxcXSl8KD86XFxbXCIoKD86W15cXFxcXCJdfFxcXFwuKSopXCJcXF0pL2c7XG4gIHZhciBtYXRjaGVzID0gW107XG4gIHZhciBtYXRjaDtcblxuICB3aGlsZSAobWF0Y2ggPSByZWdleC5leGVjKHBhdGhTdHJpbmcpKSB7XG4gICAgbWF0Y2hlcy5wdXNoKG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8IG1hdGNoWzNdKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufSIsInZhciBwYXRoR2V0dGVyID0gcmVxdWlyZSgnLi9wYXRoLWdldHRlcicpO1xuXG52YXIganNhbiA9IHJlcXVpcmUoJy4vJyk7XG5cbmV4cG9ydHMuZ2V0UmVnZXhGbGFncyA9IGZ1bmN0aW9uIGdldFJlZ2V4RmxhZ3MocmVnZXgpIHtcbiAgdmFyIGZsYWdzID0gJyc7XG4gIGlmIChyZWdleC5pZ25vcmVDYXNlKSBmbGFncyArPSAnaSc7XG4gIGlmIChyZWdleC5nbG9iYWwpIGZsYWdzICs9ICdnJztcbiAgaWYgKHJlZ2V4Lm11bHRpbGluZSkgZmxhZ3MgKz0gJ20nO1xuICByZXR1cm4gZmxhZ3M7XG59O1xuXG5leHBvcnRzLnN0cmluZ2lmeUZ1bmN0aW9uID0gZnVuY3Rpb24gc3RyaW5naWZ5RnVuY3Rpb24oZm4sIGN1c3RvbVRvU3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgY3VzdG9tVG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY3VzdG9tVG9TdHJpbmcoZm4pO1xuICB9XG5cbiAgdmFyIHN0ciA9IGZuLnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaCgvXltee10qe3xeW149XSo9Pi8pO1xuICB2YXIgc3RhcnQgPSBtYXRjaCA/IG1hdGNoWzBdIDogJzxmdW5jdGlvbj4gJztcbiAgdmFyIGVuZCA9IHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICd9JyA/ICd9JyA6ICcnO1xuICByZXR1cm4gc3RhcnQucmVwbGFjZSgvXFxyXFxufFxcbi9nLCAnICcpLnJlcGxhY2UoL1xccysvZywgJyAnKSArICcgLyogLi4uICovICcgKyBlbmQ7XG59O1xuXG5leHBvcnRzLnJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKG9iaiwgcm9vdCkge1xuICB2YXIgdHlwZSA9IG9ialswXTtcbiAgdmFyIHJlc3QgPSBvYmouc2xpY2UoMSk7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnJCc6XG4gICAgICByZXR1cm4gcGF0aEdldHRlcihyb290LCBvYmopO1xuXG4gICAgY2FzZSAncic6XG4gICAgICB2YXIgY29tbWEgPSByZXN0LmluZGV4T2YoJywnKTtcbiAgICAgIHZhciBmbGFncyA9IHJlc3Quc2xpY2UoMCwgY29tbWEpO1xuICAgICAgdmFyIHNvdXJjZSA9IHJlc3Quc2xpY2UoY29tbWEgKyAxKTtcbiAgICAgIHJldHVybiBSZWdFeHAoc291cmNlLCBmbGFncyk7XG5cbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgrcmVzdCk7XG5cbiAgICBjYXNlICdmJzpcbiAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgcnVuIGpzYW4gcGFyc2VkIGZ1bmN0aW9uXCIpO1xuICAgICAgfTtcblxuICAgICAgZm4udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXN0O1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGZuO1xuXG4gICAgY2FzZSAndSc6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgY2FzZSAnZSc6XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocmVzdCk7XG4gICAgICBlcnJvci5zdGFjayA9ICdTdGFjayBpcyB1bmF2YWlsYWJsZSBmb3IganNhbiBwYXJzZWQgZXJyb3JzJztcbiAgICAgIHJldHVybiBlcnJvcjtcblxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIFN5bWJvbChyZXN0KTtcblxuICAgIGNhc2UgJ2cnOlxuICAgICAgcmV0dXJuIFN5bWJvbC5mb3IocmVzdCk7XG5cbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuZXcgTWFwKGpzYW4ucGFyc2UocmVzdCkpO1xuXG4gICAgY2FzZSAnbCc6XG4gICAgICByZXR1cm4gbmV3IFNldChqc2FuLnBhcnNlKHJlc3QpKTtcblxuICAgIGNhc2UgJ24nOlxuICAgICAgcmV0dXJuIE5hTjtcblxuICAgIGNhc2UgJ2knOlxuICAgICAgcmV0dXJuIEluZmluaXR5O1xuXG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gLUluZmluaXR5O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUud2FybigndW5rbm93biB0eXBlJywgb2JqKTtcbiAgICAgIHJldHVybiBvYmo7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cblxudmFyIGVycm9yTWVzc2FnZTtcbmVycm9yTWVzc2FnZSA9ICdBbiBhcmd1bWVudCB3aXRob3V0IGFwcGVuZCwgcHJlcGVuZCwgJyArICdvciBkZXRhY2ggbWV0aG9kcyB3YXMgZ2l2ZW4gdG8gYExpc3QnO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IExpc3Q6IEEgbGlua2VkIGxpc3QgaXMgYSBiaXQgbGlrZSBhbiBBcnJheSwgYnV0XG4gKiBrbm93cyBub3RoaW5nIGFib3V0IGhvdyBtYW55IGl0ZW1zIGFyZSBpbiBpdCwgYW5kIGtub3dzIG9ubHkgYWJvdXQgaXRzXG4gKiBmaXJzdCAoYGhlYWRgKSBhbmQgbGFzdCAoYHRhaWxgKSBpdGVtcy4gRWFjaCBpdGVtIChlLmcuIGBoZWFkYCwgYHRhaWxgLFxuICogJmMuKSBrbm93cyB3aGljaCBpdGVtIGNvbWVzIGJlZm9yZSBvciBhZnRlciBpdCAoaXRzIG1vcmUgbGlrZSB0aGVcbiAqIGltcGxlbWVudGF0aW9uIG9mIHRoZSBET00gaW4gSmF2YVNjcmlwdCkuXG4gKiBAZ2xvYmFsXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAY2xhc3MgUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBMaXN0LlxuICovXG5cbmZ1bmN0aW9uIExpc3QoKVxuLyppdGVtcy4uLiovXG57XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIExpc3QuZnJvbShhcmd1bWVudHMpO1xuICB9XG59XG5cbnZhciBMaXN0UHJvdG90eXBlO1xuTGlzdFByb3RvdHlwZSA9IExpc3QucHJvdG90eXBlO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGxpc3QgZnJvbSB0aGUgYXJndW1lbnRzIChlYWNoIGEgbGlzdCBpdGVtKSBwYXNzZWQgaW4uXG4gKiBAbmFtZSBMaXN0Lm9mXG4gKiBAcGFyYW0gey4uLkxpc3RJdGVtfSBbaXRlbXNdIC0gWmVybyBvciBtb3JlIGl0ZW1zIHRvIGF0dGFjaC5cbiAqIEByZXR1cm5zIHtsaXN0fSAtIEEgbmV3IGluc3RhbmNlIG9mIExpc3QuXG4gKi9cblxuTGlzdC5vZiA9IGZ1bmN0aW9uICgpXG4vKml0ZW1zLi4uKi9cbntcbiAgcmV0dXJuIExpc3QuZnJvbS5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGxpc3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXktbGlrZSBvYmplY3QgKGVhY2ggYSBsaXN0IGl0ZW0pXG4gKiBwYXNzZWQgaW4uXG4gKiBAbmFtZSBMaXN0LmZyb21cbiAqIEBwYXJhbSB7TGlzdEl0ZW1bXX0gW2l0ZW1zXSAtIFRoZSBpdGVtcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7bGlzdH0gLSBBIG5ldyBpbnN0YW5jZSBvZiBMaXN0LlxuICovXG5cblxuTGlzdC5mcm9tID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gIHZhciBsaXN0ID0gbmV3IHRoaXMoKSxcbiAgICAgIGxlbmd0aCxcbiAgICAgIGl0ZXJhdG9yLFxuICAgICAgaXRlbTtcblxuICBpZiAoaXRlbXMgJiYgKGxlbmd0aCA9IGl0ZW1zLmxlbmd0aCkpIHtcbiAgICBpdGVyYXRvciA9IC0xO1xuXG4gICAgd2hpbGUgKCsraXRlcmF0b3IgPCBsZW5ndGgpIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpdGVyYXRvcl07XG5cbiAgICAgIGlmIChpdGVtICE9PSBudWxsICYmIGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaXN0LmFwcGVuZChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn07XG4vKipcbiAqIExpc3QjaGVhZFxuICogRGVmYXVsdCB0byBgbnVsbGAuXG4gKi9cblxuXG5MaXN0UHJvdG90eXBlLmhlYWQgPSBudWxsO1xuLyoqXG4gKiBMaXN0I3RhaWxcbiAqIERlZmF1bHQgdG8gYG51bGxgLlxuICovXG5cbkxpc3RQcm90b3R5cGUudGFpbCA9IG51bGw7XG4vKipcbiAqIFJldHVybnMgdGhlIGxpc3QncyBpdGVtcyBhcyBhbiBhcnJheS4gVGhpcyBkb2VzICpub3QqIGRldGFjaCB0aGUgaXRlbXMuXG4gKiBAbmFtZSBMaXN0I3RvQXJyYXlcbiAqIEByZXR1cm5zIHtMaXN0SXRlbVtdfSAtIEFuIGFycmF5IG9mIChzdGlsbCBhdHRhY2hlZCkgTGlzdEl0ZW1zLlxuICovXG5cbkxpc3RQcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLmhlYWQsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoaXRlbSkge1xuICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIGl0ZW0gPSBpdGVtLm5leHQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogUHJlcGVuZHMgdGhlIGdpdmVuIGl0ZW0gdG8gdGhlIGxpc3Q6IEl0ZW0gd2lsbCBiZSB0aGUgbmV3IGZpcnN0IGl0ZW1cbiAqIChgaGVhZGApLlxuICogQG5hbWUgTGlzdCNwcmVwZW5kXG4gKiBAcGFyYW0ge0xpc3RJdGVtfSBpdGVtIC0gVGhlIGl0ZW0gdG8gcHJlcGVuZC5cbiAqIEByZXR1cm5zIHtMaXN0SXRlbX0gLSBBbiBpbnN0YW5jZSBvZiBMaXN0SXRlbSAodGhlIGdpdmVuIGl0ZW0pLlxuICovXG5cblxuTGlzdFByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgaWYgKCFpdGVtKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFpdGVtLmFwcGVuZCB8fCAhaXRlbS5wcmVwZW5kIHx8ICFpdGVtLmRldGFjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UgKyAnI3ByZXBlbmRgLicpO1xuICB9XG5cbiAgdmFyIHNlbGYsIGhlYWQ7IC8vIENhY2hlIHNlbGYuXG5cbiAgc2VsZiA9IHRoaXM7IC8vIElmIHNlbGYgaGFzIGEgZmlyc3QgaXRlbSwgZGVmZXIgcHJlcGVuZCB0byB0aGUgZmlyc3QgaXRlbXMgcHJlcGVuZFxuICAvLyBtZXRob2QsIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cblxuICBoZWFkID0gc2VsZi5oZWFkO1xuXG4gIGlmIChoZWFkKSB7XG4gICAgcmV0dXJuIGhlYWQucHJlcGVuZChpdGVtKTtcbiAgfSAvLyAuLi5vdGhlcndpc2UsIHRoZXJlIGlzIG5vIGBoZWFkYCAob3IgYHRhaWxgKSBpdGVtIHlldC5cbiAgLy8gRGV0YWNoIHRoZSBwcmVwZW5kZWUuXG5cblxuICBpdGVtLmRldGFjaCgpOyAvLyBTZXQgdGhlIHByZXBlbmRlZXMgcGFyZW50IGxpc3QgdG8gcmVmZXJlbmNlIHNlbGYuXG5cbiAgaXRlbS5saXN0ID0gc2VsZjsgLy8gU2V0IHNlbGYncyBmaXJzdCBpdGVtIHRvIHRoZSBwcmVwZW5kZWUsIGFuZCByZXR1cm4gdGhlIGl0ZW0uXG5cbiAgc2VsZi5oZWFkID0gaXRlbTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuLyoqXG4gKiBBcHBlbmRzIHRoZSBnaXZlbiBpdGVtIHRvIHRoZSBsaXN0OiBJdGVtIHdpbGwgYmUgdGhlIG5ldyBsYXN0IGl0ZW0gKGB0YWlsYClcbiAqIGlmIHRoZSBsaXN0IGhhZCBhIGZpcnN0IGl0ZW0sIGFuZCBpdHMgZmlyc3QgaXRlbSAoYGhlYWRgKSBvdGhlcndpc2UuXG4gKiBAbmFtZSBMaXN0I2FwcGVuZFxuICogQHBhcmFtIHtMaXN0SXRlbX0gaXRlbSAtIFRoZSBpdGVtIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtMaXN0SXRlbX0gLSBBbiBpbnN0YW5jZSBvZiBMaXN0SXRlbSAodGhlIGdpdmVuIGl0ZW0pLlxuICovXG5cblxuTGlzdFByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICBpZiAoIWl0ZW0pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWl0ZW0uYXBwZW5kIHx8ICFpdGVtLnByZXBlbmQgfHwgIWl0ZW0uZGV0YWNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSArICcjYXBwZW5kYC4nKTtcbiAgfVxuXG4gIHZhciBzZWxmLCBoZWFkLCB0YWlsOyAvLyBDYWNoZSBzZWxmLlxuXG4gIHNlbGYgPSB0aGlzOyAvLyBJZiBzZWxmIGhhcyBhIGxhc3QgaXRlbSwgZGVmZXIgYXBwZW5kaW5nIHRvIHRoZSBsYXN0IGl0ZW1zIGFwcGVuZFxuICAvLyBtZXRob2QsIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cblxuICB0YWlsID0gc2VsZi50YWlsO1xuXG4gIGlmICh0YWlsKSB7XG4gICAgcmV0dXJuIHRhaWwuYXBwZW5kKGl0ZW0pO1xuICB9IC8vIElmIHNlbGYgaGFzIGEgZmlyc3QgaXRlbSwgZGVmZXIgYXBwZW5kaW5nIHRvIHRoZSBmaXJzdCBpdGVtcyBhcHBlbmRcbiAgLy8gbWV0aG9kLCBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG5cblxuICBoZWFkID0gc2VsZi5oZWFkO1xuXG4gIGlmIChoZWFkKSB7XG4gICAgcmV0dXJuIGhlYWQuYXBwZW5kKGl0ZW0pO1xuICB9IC8vIC4uLm90aGVyd2lzZSwgdGhlcmUgaXMgbm8gYHRhaWxgIG9yIGBoZWFkYCBpdGVtIHlldC5cbiAgLy8gRGV0YWNoIHRoZSBhcHBlbmRlZS5cblxuXG4gIGl0ZW0uZGV0YWNoKCk7IC8vIFNldCB0aGUgYXBwZW5kZWVzIHBhcmVudCBsaXN0IHRvIHJlZmVyZW5jZSBzZWxmLlxuXG4gIGl0ZW0ubGlzdCA9IHNlbGY7IC8vIFNldCBzZWxmJ3MgZmlyc3QgaXRlbSB0byB0aGUgYXBwZW5kZWUsIGFuZCByZXR1cm4gdGhlIGl0ZW0uXG5cbiAgc2VsZi5oZWFkID0gaXRlbTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IExpc3RJdGVtOiBBIGxpbmtlZCBsaXN0IGl0ZW0gaXMgYSBiaXQgbGlrZSBET00gbm9kZTpcbiAqIEl0IGtub3dzIG9ubHkgYWJvdXQgaXRzIFwicGFyZW50XCIgKGBsaXN0YCksIHRoZSBpdGVtIGJlZm9yZSBpdCAoYHByZXZgKSxcbiAqIGFuZCB0aGUgaXRlbSBhZnRlciBpdCAoYG5leHRgKS5cbiAqIEBnbG9iYWxcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjbGFzcyBSZXByZXNlbnRzIGFuIGluc3RhbmNlIG9mIExpc3RJdGVtLlxuICovXG5cblxuZnVuY3Rpb24gTGlzdEl0ZW0oKSB7fVxuXG5MaXN0Lkl0ZW0gPSBMaXN0SXRlbTtcbnZhciBMaXN0SXRlbVByb3RvdHlwZSA9IExpc3RJdGVtLnByb3RvdHlwZTtcbkxpc3RJdGVtUHJvdG90eXBlLm5leHQgPSBudWxsO1xuTGlzdEl0ZW1Qcm90b3R5cGUucHJldiA9IG51bGw7XG5MaXN0SXRlbVByb3RvdHlwZS5saXN0ID0gbnVsbDtcbi8qKlxuICogRGV0YWNoZXMgdGhlIGl0ZW0gb3BlcmF0ZWQgb24gZnJvbSBpdHMgcGFyZW50IGxpc3QuXG4gKiBAbmFtZSBMaXN0SXRlbSNkZXRhY2hcbiAqIEByZXR1cm5zIHtMaXN0SXRlbX0gLSBUaGUgaXRlbSBvcGVyYXRlZCBvbi5cbiAqL1xuXG5MaXN0SXRlbVByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIC8vIENhY2hlIHNlbGYsIHRoZSBwYXJlbnQgbGlzdCwgYW5kIHRoZSBwcmV2aW91cyBhbmQgbmV4dCBpdGVtcy5cbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgbGlzdCA9IHNlbGYubGlzdCxcbiAgICAgIHByZXYgPSBzZWxmLnByZXYsXG4gICAgICBuZXh0ID0gc2VsZi5uZXh0OyAvLyBJZiB0aGUgaXRlbSBpcyBhbHJlYWR5IGRldGFjaGVkLCByZXR1cm4gc2VsZi5cblxuICBpZiAoIWxpc3QpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSAvLyBJZiBzZWxmIGlzIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIHBhcmVudCBsaXN0LCBsaW5rIHRoZSBsaXN0cyBsYXN0IGl0ZW1cbiAgLy8gdG8gdGhlIHByZXZpb3VzIGl0ZW0uXG5cblxuICBpZiAobGlzdC50YWlsID09PSBzZWxmKSB7XG4gICAgbGlzdC50YWlsID0gcHJldjtcbiAgfSAvLyBJZiBzZWxmIGlzIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBwYXJlbnQgbGlzdCwgbGluayB0aGUgbGlzdHMgZmlyc3QgaXRlbVxuICAvLyB0byB0aGUgbmV4dCBpdGVtLlxuXG5cbiAgaWYgKGxpc3QuaGVhZCA9PT0gc2VsZikge1xuICAgIGxpc3QuaGVhZCA9IG5leHQ7XG4gIH0gLy8gSWYgYm90aCB0aGUgbGFzdCBhbmQgZmlyc3QgaXRlbXMgaW4gdGhlIHBhcmVudCBsaXN0IGFyZSB0aGUgc2FtZSxcbiAgLy8gcmVtb3ZlIHRoZSBsaW5rIHRvIHRoZSBsYXN0IGl0ZW0uXG5cblxuICBpZiAobGlzdC50YWlsID09PSBsaXN0LmhlYWQpIHtcbiAgICBsaXN0LnRhaWwgPSBudWxsO1xuICB9IC8vIElmIGEgcHJldmlvdXMgaXRlbSBleGlzdHMsIGxpbmsgaXRzIG5leHQgaXRlbSB0byBzZWxmcyBuZXh0IGl0ZW0uXG5cblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IG5leHQ7XG4gIH0gLy8gSWYgYSBuZXh0IGl0ZW0gZXhpc3RzLCBsaW5rIGl0cyBwcmV2aW91cyBpdGVtIHRvIHNlbGZzIHByZXZpb3VzIGl0ZW0uXG5cblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXY7XG4gIH0gLy8gUmVtb3ZlIGxpbmtzIGZyb20gc2VsZiB0byBib3RoIHRoZSBuZXh0IGFuZCBwcmV2aW91cyBpdGVtcywgYW5kIHRvIHRoZVxuICAvLyBwYXJlbnQgbGlzdC5cblxuXG4gIHNlbGYucHJldiA9IHNlbGYubmV4dCA9IHNlbGYubGlzdCA9IG51bGw7IC8vIFJldHVybiBzZWxmLlxuXG4gIHJldHVybiBzZWxmO1xufTtcbi8qKlxuICogUHJlcGVuZHMgdGhlIGdpdmVuIGl0ZW0gKmJlZm9yZSogdGhlIGl0ZW0gb3BlcmF0ZWQgb24uXG4gKiBAbmFtZSBMaXN0SXRlbSNwcmVwZW5kXG4gKiBAcGFyYW0ge0xpc3RJdGVtfSBpdGVtIC0gVGhlIGl0ZW0gdG8gcHJlcGVuZC5cbiAqIEByZXR1cm5zIHtMaXN0SXRlbX0gLSBUaGUgaXRlbSBvcGVyYXRlZCBvbiwgb3IgZmFsc2Ugd2hlbiB0aGF0IGl0ZW0gaXMgbm90XG4gKiBhdHRhY2hlZC5cbiAqL1xuXG5cbkxpc3RJdGVtUHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICBpZiAoIWl0ZW0gfHwgIWl0ZW0uYXBwZW5kIHx8ICFpdGVtLnByZXBlbmQgfHwgIWl0ZW0uZGV0YWNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSArICdJdGVtI3ByZXBlbmRgLicpO1xuICB9IC8vIENhY2hlIHNlbGYsIHRoZSBwYXJlbnQgbGlzdCwgYW5kIHRoZSBwcmV2aW91cyBpdGVtLlxuXG5cbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgbGlzdCA9IHNlbGYubGlzdCxcbiAgICAgIHByZXYgPSBzZWxmLnByZXY7IC8vIElmIHNlbGYgaXMgZGV0YWNoZWQsIHJldHVybiBmYWxzZS5cblxuICBpZiAoIWxpc3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gRGV0YWNoIHRoZSBwcmVwZW5kZWUuXG5cblxuICBpdGVtLmRldGFjaCgpOyAvLyBJZiBzZWxmIGhhcyBhIHByZXZpb3VzIGl0ZW0uLi5cblxuICBpZiAocHJldikge1xuICAgIC8vIC4uLmxpbmsgdGhlIHByZXBlbmRlZXMgcHJldmlvdXMgaXRlbSwgdG8gc2VsZnMgcHJldmlvdXMgaXRlbS5cbiAgICBpdGVtLnByZXYgPSBwcmV2OyAvLyAuLi5saW5rIHRoZSBwcmV2aW91cyBpdGVtcyBuZXh0IGl0ZW0sIHRvIHNlbGYuXG5cbiAgICBwcmV2Lm5leHQgPSBpdGVtO1xuICB9IC8vIFNldCB0aGUgcHJlcGVuZGVlcyBuZXh0IGl0ZW0gdG8gc2VsZi5cblxuXG4gIGl0ZW0ubmV4dCA9IHNlbGY7IC8vIFNldCB0aGUgcHJlcGVuZGVlcyBwYXJlbnQgbGlzdCB0byBzZWxmcyBwYXJlbnQgbGlzdC5cblxuICBpdGVtLmxpc3QgPSBsaXN0OyAvLyBTZXQgdGhlIHByZXZpb3VzIGl0ZW0gb2Ygc2VsZiB0byB0aGUgcHJlcGVuZGVlLlxuXG4gIHNlbGYucHJldiA9IGl0ZW07IC8vIElmIHNlbGYgaXMgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIHBhcmVudCBsaXN0LCBsaW5rIHRoZSBsaXN0cyBmaXJzdCBpdGVtXG4gIC8vIHRvIHRoZSBwcmVwZW5kZWUuXG5cbiAgaWYgKHNlbGYgPT09IGxpc3QuaGVhZCkge1xuICAgIGxpc3QuaGVhZCA9IGl0ZW07XG4gIH0gLy8gSWYgdGhlIHRoZSBwYXJlbnQgbGlzdCBoYXMgbm8gbGFzdCBpdGVtLCBsaW5rIHRoZSBsaXN0cyBsYXN0IGl0ZW0gdG9cbiAgLy8gc2VsZi5cblxuXG4gIGlmICghbGlzdC50YWlsKSB7XG4gICAgbGlzdC50YWlsID0gc2VsZjtcbiAgfSAvLyBSZXR1cm4gdGhlIHByZXBlbmRlZS5cblxuXG4gIHJldHVybiBpdGVtO1xufTtcbi8qKlxuICogQXBwZW5kcyB0aGUgZ2l2ZW4gaXRlbSAqYWZ0ZXIqIHRoZSBpdGVtIG9wZXJhdGVkIG9uLlxuICogQG5hbWUgTGlzdEl0ZW0jYXBwZW5kXG4gKiBAcGFyYW0ge0xpc3RJdGVtfSBpdGVtIC0gVGhlIGl0ZW0gdG8gYXBwZW5kLlxuICogQHJldHVybnMge0xpc3RJdGVtfSAtIFRoZSBpdGVtIG9wZXJhdGVkIG9uLCBvciBmYWxzZSB3aGVuIHRoYXQgaXRlbSBpcyBub3RcbiAqIGF0dGFjaGVkLlxuICovXG5cblxuTGlzdEl0ZW1Qcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgLy8gSWYgaXRlbSBpcyBmYWxzZXksIHJldHVybiBmYWxzZS5cbiAgaWYgKCFpdGVtIHx8ICFpdGVtLmFwcGVuZCB8fCAhaXRlbS5wcmVwZW5kIHx8ICFpdGVtLmRldGFjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UgKyAnSXRlbSNhcHBlbmRgLicpO1xuICB9IC8vIENhY2hlIHNlbGYsIHRoZSBwYXJlbnQgbGlzdCwgYW5kIHRoZSBuZXh0IGl0ZW0uXG5cblxuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBsaXN0ID0gc2VsZi5saXN0LFxuICAgICAgbmV4dCA9IHNlbGYubmV4dDsgLy8gSWYgc2VsZiBpcyBkZXRhY2hlZCwgcmV0dXJuIGZhbHNlLlxuXG4gIGlmICghbGlzdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBEZXRhY2ggdGhlIGFwcGVuZGVlLlxuXG5cbiAgaXRlbS5kZXRhY2goKTsgLy8gSWYgc2VsZiBoYXMgYSBuZXh0IGl0ZW0uLi5cblxuICBpZiAobmV4dCkge1xuICAgIC8vIC4uLmxpbmsgdGhlIGFwcGVuZGVlcyBuZXh0IGl0ZW0sIHRvIHNlbGZzIG5leHQgaXRlbS5cbiAgICBpdGVtLm5leHQgPSBuZXh0OyAvLyAuLi5saW5rIHRoZSBuZXh0IGl0ZW1zIHByZXZpb3VzIGl0ZW0sIHRvIHRoZSBhcHBlbmRlZS5cblxuICAgIG5leHQucHJldiA9IGl0ZW07XG4gIH0gLy8gU2V0IHRoZSBhcHBlbmRlZXMgcHJldmlvdXMgaXRlbSB0byBzZWxmLlxuXG5cbiAgaXRlbS5wcmV2ID0gc2VsZjsgLy8gU2V0IHRoZSBhcHBlbmRlZXMgcGFyZW50IGxpc3QgdG8gc2VsZnMgcGFyZW50IGxpc3QuXG5cbiAgaXRlbS5saXN0ID0gbGlzdDsgLy8gU2V0IHRoZSBuZXh0IGl0ZW0gb2Ygc2VsZiB0byB0aGUgYXBwZW5kZWUuXG5cbiAgc2VsZi5uZXh0ID0gaXRlbTsgLy8gSWYgdGhlIHRoZSBwYXJlbnQgbGlzdCBoYXMgbm8gbGFzdCBpdGVtIG9yIGlmIHNlbGYgaXMgdGhlIHBhcmVudCBsaXN0c1xuICAvLyBsYXN0IGl0ZW0sIGxpbmsgdGhlIGxpc3RzIGxhc3QgaXRlbSB0byB0aGUgYXBwZW5kZWUuXG5cbiAgaWYgKHNlbGYgPT09IGxpc3QudGFpbCB8fCAhbGlzdC50YWlsKSB7XG4gICAgbGlzdC50YWlsID0gaXRlbTtcbiAgfSAvLyBSZXR1cm4gdGhlIGFwcGVuZGVlLlxuXG5cbiAgcmV0dXJuIGl0ZW07XG59O1xuLyoqXG4gKiBFeHBvc2UgYExpc3RgLlxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19zb3VyY2UvbGlua2VkLWxpc3QuanMnKTsiLCJpbXBvcnQgeyBpc0NvbXB1dGVkUHJvcCwgaXNPYnNlcnZhYmxlUHJvcCwgY3JlYXRlQXRvbSwgYWN0aW9uLCBjb21wdXRlZCwgX2FsbG93U3RhdGVDaGFuZ2VzSW5zaWRlQ29tcHV0ZWQsIHJlYWN0aW9uLCBydW5JbkFjdGlvbiwgb2JzZXJ2YWJsZSwgdmFsdWVzLCBlbnRyaWVzLCBfZ2V0R2xvYmFsU3RhdGUsIGlzT2JzZXJ2YWJsZUFycmF5LCBPYnNlcnZhYmxlTWFwLCBfaW50ZXJjZXB0UmVhZHMsIGludGVyY2VwdCwgb2JzZXJ2ZSwgX2dldEFkbWluaXN0cmF0aW9uLCBzZXQsIG1ha2VPYnNlcnZhYmxlLCBnZXRBdG9tIH0gZnJvbSAnbW9ieCc7XG52YXIgbGl2ZWxpbmVzc0NoZWNraW5nID0gXCJ3YXJuXCI7XG4vKipcbiAqIERlZmluZXMgd2hhdCBNU1Qgc2hvdWxkIGRvIHdoZW4gcnVubmluZyBpbnRvIHJlYWRzIC8gd3JpdGVzIHRvIG9iamVjdHMgdGhhdCBoYXZlIGRpZWQuXG4gKiBCeSBkZWZhdWx0IGl0IHdpbGwgcHJpbnQgYSB3YXJuaW5nLlxuICogVXNlIHRoZSBgXCJlcnJvclwiYCBvcHRpb24gdG8gZWFzeSBkZWJ1Z2dpbmcgdG8gc2VlIHdoZXJlIHRoZSBlcnJvciB3YXMgdGhyb3duIGFuZCB3aGVuIHRoZSBvZmZlbmRpbmcgcmVhZCAvIHdyaXRlIHRvb2sgcGxhY2VcbiAqXG4gKiBAcGFyYW0gbW9kZSBgXCJ3YXJuXCJgLCBgXCJlcnJvclwiYCBvciBgXCJpZ25vcmVcImBcbiAqL1xuXG5mdW5jdGlvbiBzZXRMaXZlbGluZXNzQ2hlY2tpbmcobW9kZSkge1xuICBsaXZlbGluZXNzQ2hlY2tpbmcgPSBtb2RlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxpdmVsaW5lc3MgY2hlY2tpbmcgbW9kZS5cbiAqXG4gKiBAcmV0dXJucyBgXCJ3YXJuXCJgLCBgXCJlcnJvclwiYCBvciBgXCJpZ25vcmVcImBcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpdmVsaW5lc3NDaGVja2luZygpIHtcbiAgcmV0dXJuIGxpdmVsaW5lc3NDaGVja2luZztcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIHNldExpdmVsaW5lc3NDaGVja2luZyBpbnN0ZWFkXG4gKiBAaGlkZGVuXG4gKlxuICogRGVmaW5lcyB3aGF0IE1TVCBzaG91bGQgZG8gd2hlbiBydW5uaW5nIGludG8gcmVhZHMgLyB3cml0ZXMgdG8gb2JqZWN0cyB0aGF0IGhhdmUgZGllZC5cbiAqIEJ5IGRlZmF1bHQgaXQgd2lsbCBwcmludCBhIHdhcm5pbmcuXG4gKiBVc2UgdGhlIGBcImVycm9yXCJgIG9wdGlvbiB0byBlYXN5IGRlYnVnZ2luZyB0byBzZWUgd2hlcmUgdGhlIGVycm9yIHdhcyB0aHJvd24gYW5kIHdoZW4gdGhlIG9mZmVuZGluZyByZWFkIC8gd3JpdGUgdG9vayBwbGFjZVxuICpcbiAqIEBwYXJhbSBtb2RlIGBcIndhcm5cImAsIGBcImVycm9yXCJgIG9yIGBcImlnbm9yZVwiYFxuICovXG5cblxuZnVuY3Rpb24gc2V0TGl2ZWx5bmVzc0NoZWNraW5nKG1vZGUpIHtcbiAgc2V0TGl2ZWxpbmVzc0NoZWNraW5nKG1vZGUpO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuXG52YXIgSG9vaztcblxuKGZ1bmN0aW9uIChIb29rKSB7XG4gIEhvb2tbXCJhZnRlckNyZWF0ZVwiXSA9IFwiYWZ0ZXJDcmVhdGVcIjtcbiAgSG9va1tcImFmdGVyQXR0YWNoXCJdID0gXCJhZnRlckF0dGFjaFwiO1xuICBIb29rW1wiYWZ0ZXJDcmVhdGlvbkZpbmFsaXphdGlvblwiXSA9IFwiYWZ0ZXJDcmVhdGlvbkZpbmFsaXphdGlvblwiO1xuICBIb29rW1wiYmVmb3JlRGV0YWNoXCJdID0gXCJiZWZvcmVEZXRhY2hcIjtcbiAgSG9va1tcImJlZm9yZURlc3Ryb3lcIl0gPSBcImJlZm9yZURlc3Ryb3lcIjtcbn0pKEhvb2sgfHwgKEhvb2sgPSB7fSkpO1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cblxuXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gIH07XG5cbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG5cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcblxuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMCkgdFtwXSA9IHNbcF07XG5cbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKSB0W3BbaV1dID0gc1twW2ldXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHtcbiAgICBsYWJlbDogMCxcbiAgICBzZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodFswXSAmIDEpIHRocm93IHRbMV07XG4gICAgICByZXR1cm4gdFsxXTtcbiAgICB9LFxuICAgIHRyeXM6IFtdLFxuICAgIG9wczogW11cbiAgfSxcbiAgICAgIGYsXG4gICAgICB5LFxuICAgICAgdCxcbiAgICAgIGc7XG4gIHJldHVybiBnID0ge1xuICAgIG5leHQ6IHZlcmIoMCksXG4gICAgXCJ0aHJvd1wiOiB2ZXJiKDEpLFxuICAgIFwicmV0dXJuXCI6IHZlcmIoMilcbiAgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBnO1xuXG4gIGZ1bmN0aW9uIHZlcmIobikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblxuICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXG4gICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3BbMV0sXG4gICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG5cbiAgICAgICAgICBfLnRyeXMucG9wKCk7XG5cbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG5cbiAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cbiAgICAgICAgICBfLnRyeXMucG9wKCk7XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb3AgPSBbNiwgZV07XG4gICAgICB5ID0gMDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZiA9IHQgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCxcbiAgICAgIGRvbmU6IHRydWVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcbiAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgbSA9IHMgJiYgb1tzXSxcbiAgICAgIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbyAmJiBvW2krK10sXG4gICAgICAgIGRvbmU6ICFvXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxuXG5mdW5jdGlvbiBfX3JlYWQobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLFxuICAgICAgcixcbiAgICAgIGFyID0gW10sXG4gICAgICBlO1xuXG4gIHRyeSB7XG4gICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZSA9IHtcbiAgICAgIGVycm9yOiBlcnJvclxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZSkgdGhyb3cgZS5lcnJvcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXI7XG59XG5cbmZ1bmN0aW9uIF9fc3ByZWFkKCkge1xuICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuXG4gIHJldHVybiBhcjtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgX2FjdHVhbF8gdHlwZSBvZiB0aGUgZ2l2ZW4gdHJlZSBub2RlLiAoT3IgdGhyb3dzKVxuICpcbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRUeXBlKG9iamVjdCkge1xuICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUob2JqZWN0LCAxKTtcbiAgcmV0dXJuIGdldFN0YXRlVHJlZU5vZGUob2JqZWN0KS50eXBlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBfZGVjbGFyZWRfIHR5cGUgb2YgdGhlIGdpdmVuIHN1YiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QsIGFycmF5IG9yIG1hcC5cbiAqIEluIHRoZSBjYXNlIG9mIGFycmF5cyBhbmQgbWFwcyB0aGUgcHJvcGVydHkgbmFtZSBpcyBvcHRpb25hbCBhbmQgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogY29uc3QgQm94ID0gdHlwZXMubW9kZWwoeyB4OiAwLCB5OiAwIH0pXG4gKiBjb25zdCBib3ggPSBCb3guY3JlYXRlKClcbiAqXG4gKiBjb25zb2xlLmxvZyhnZXRDaGlsZFR5cGUoYm94LCBcInhcIikubmFtZSkgLy8gJ251bWJlcidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvYmplY3RcbiAqIEBwYXJhbSBwcm9wZXJ0eU5hbWVcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDaGlsZFR5cGUob2JqZWN0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKG9iamVjdCwgMSk7XG4gIHJldHVybiBnZXRTdGF0ZVRyZWVOb2RlKG9iamVjdCkuZ2V0Q2hpbGRUeXBlKHByb3BlcnR5TmFtZSk7XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIGZvciBlYWNoIG11dGF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgcHJvdmlkZWQgbW9kZWwgaW5zdGFuY2UsIG9yIHRvIGFueSBvZiBpdHMgY2hpbGRyZW4uXG4gKiBTZWUgW3BhdGNoZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC1zdGF0ZS10cmVlI3BhdGNoZXMpIGZvciBtb3JlIGRldGFpbHMuIG9uUGF0Y2ggZXZlbnRzIGFyZSBlbWl0dGVkIGltbWVkaWF0ZWx5IGFuZCB3aWxsIG5vdCBhd2FpdCB0aGUgZW5kIG9mIGEgdHJhbnNhY3Rpb24uXG4gKiBQYXRjaGVzIGNhbiBiZSB1c2VkIHRvIGRlZXAgb2JzZXJ2ZSBhIG1vZGVsIHRyZWUuXG4gKlxuICogQHBhcmFtIHRhcmdldCB0aGUgbW9kZWwgaW5zdGFuY2UgZnJvbSB3aGljaCB0byByZWNlaXZlIHBhdGNoZXNcbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIGZvciBlYWNoIHBhdGNoLiBUaGUgcmV2ZXJzZVBhdGNoIGlzIGEgcGF0Y2ggdGhhdCB3b3VsZCBhY3R1YWxseSB1bmRvIHRoZSBlbWl0dGVkIHBhdGNoXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0byByZW1vdmUgdGhlIGxpc3RlbmVyXG4gKi9cblxuXG5mdW5jdGlvbiBvblBhdGNoKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUodGFyZ2V0LCAxKTtcbiAgYXNzZXJ0SXNGdW5jdGlvbihjYWxsYmFjaywgMik7XG4gIHJldHVybiBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkub25QYXRjaChjYWxsYmFjayk7XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCB3aGVuZXZlciBhIG5ldyBzbmFwc2hvdCBmb3IgdGhlIGdpdmVuIG1vZGVsIGluc3RhbmNlIGlzIGF2YWlsYWJsZS5cbiAqIFRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgYmUgZmlyZSBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IE1vYlggKHRyYW5zKWFjdGlvbi5cbiAqIFNlZSBbc25hcHNob3RzXShodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngtc3RhdGUtdHJlZSNzbmFwc2hvdHMpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIGNhbGxiYWNrXG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gb25TbmFwc2hvdCh0YXJnZXQsIGNhbGxiYWNrKSB7XG4gIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gIGFzc2VydElzRnVuY3Rpb24oY2FsbGJhY2ssIDIpO1xuICByZXR1cm4gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpLm9uU25hcHNob3QoY2FsbGJhY2spO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgSlNPTi1wYXRjaCB0byB0aGUgZ2l2ZW4gbW9kZWwgaW5zdGFuY2Ugb3IgYmFpbHMgb3V0IGlmIHRoZSBwYXRjaCBjb3VsZG4ndCBiZSBhcHBsaWVkXG4gKiBTZWUgW3BhdGNoZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC1zdGF0ZS10cmVlI3BhdGNoZXMpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQ2FuIGFwcGx5IGEgc2luZ2xlIHBhc3QsIG9yIGFuIGFycmF5IG9mIHBhdGNoZXMuXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIHBhdGNoXG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gYXBwbHlQYXRjaCh0YXJnZXQsIHBhdGNoKSB7XG4gIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gIGFzc2VydEFyZyhwYXRjaCwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gdHlwZW9mIHAgPT09IFwib2JqZWN0XCI7XG4gIH0sIFwib2JqZWN0IG9yIGFycmF5XCIsIDIpO1xuICBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkuYXBwbHlQYXRjaGVzKGFzQXJyYXkocGF0Y2gpKTtcbn1cbi8qKlxuICogU21hbGwgYWJzdHJhY3Rpb24gYXJvdW5kIGBvblBhdGNoYCBhbmQgYGFwcGx5UGF0Y2hgLCBhdHRhY2hlcyBhIHBhdGNoIGxpc3RlbmVyIHRvIGEgdHJlZSBhbmQgcmVjb3JkcyBhbGwgdGhlIHBhdGNoZXMuXG4gKiBSZXR1cm5zIGFuIHJlY29yZGVyIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlOlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogZXhwb3J0IGludGVyZmFjZSBJUGF0Y2hSZWNvcmRlciB7XG4gKiAgICAgIC8vIHRoZSByZWNvcmRlZCBwYXRjaGVzXG4gKiAgICAgIHBhdGNoZXM6IElKc29uUGF0Y2hbXVxuICogICAgICAvLyB0aGUgaW52ZXJzZSBvZiB0aGUgcmVjb3JkZWQgcGF0Y2hlc1xuICogICAgICBpbnZlcnNlUGF0Y2hlczogSUpzb25QYXRjaFtdXG4gKiAgICAgIC8vIHRydWUgaWYgY3VycmVudGx5IHJlY29yZGluZ1xuICogICAgICByZWNvcmRpbmc6IGJvb2xlYW5cbiAqICAgICAgLy8gc3RvcCByZWNvcmRpbmcgcGF0Y2hlc1xuICogICAgICBzdG9wKCk6IHZvaWRcbiAqICAgICAgLy8gcmVzdW1lIHJlY29yZGluZyBwYXRjaGVzXG4gKiAgICAgIHJlc3VtZSgpOiB2b2lkXG4gKiAgICAgIC8vIGFwcGx5IGFsbCB0aGUgcmVjb3JkZWQgcGF0Y2hlcyBvbiB0aGUgZ2l2ZW4gdGFyZ2V0ICh0aGUgb3JpZ2luYWwgc3ViamVjdCBpZiBvbWl0dGVkKVxuICogICAgICByZXBsYXkodGFyZ2V0PzogSUFueVN0YXRlVHJlZU5vZGUpOiB2b2lkXG4gKiAgICAgIC8vIHJldmVyc2UgYXBwbHkgdGhlIHJlY29yZGVkIHBhdGNoZXMgb24gdGhlIGdpdmVuIHRhcmdldCAgKHRoZSBvcmlnaW5hbCBzdWJqZWN0IGlmIG9taXR0ZWQpXG4gKiAgICAgIC8vIHN0b3BzIHRoZSByZWNvcmRlciBpZiBub3QgYWxyZWFkeSBzdG9wcGVkXG4gKiAgICAgIHVuZG8oKTogdm9pZFxuICogfVxuICogYGBgXG4gKlxuICogVGhlIG9wdGlvbmFsIGZpbHRlciBmdW5jdGlvbiBhbGxvd3MgdG8gc2tpcCByZWNvcmRpbmcgY2VydGFpbiBwYXRjaGVzLlxuICpcbiAqIEBwYXJhbSBzdWJqZWN0XG4gKiBAcGFyYW0gZmlsdGVyXG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gcmVjb3JkUGF0Y2hlcyhzdWJqZWN0LCBmaWx0ZXIpIHtcbiAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUoc3ViamVjdCwgMSk7XG4gIHZhciBkYXRhID0ge1xuICAgIHBhdGNoZXM6IFtdLFxuICAgIHJldmVyc2VkSW52ZXJzZVBhdGNoZXM6IFtdXG4gIH07IC8vIHdlIHdpbGwgZ2VuZXJhdGUgdGhlIGltbXV0YWJsZSBjb3B5IG9mIHBhdGNoZXMgb24gZGVtYW5kIGZvciBwdWJsaWMgY29uc3VtcHRpb25cblxuICB2YXIgcHVibGljRGF0YSA9IHt9O1xuICB2YXIgZGlzcG9zZXI7XG4gIHZhciByZWNvcmRlciA9IHtcbiAgICBnZXQgcmVjb3JkaW5nKCkge1xuICAgICAgcmV0dXJuICEhZGlzcG9zZXI7XG4gICAgfSxcblxuICAgIGdldCBwYXRjaGVzKCkge1xuICAgICAgaWYgKCFwdWJsaWNEYXRhLnBhdGNoZXMpIHtcbiAgICAgICAgcHVibGljRGF0YS5wYXRjaGVzID0gZGF0YS5wYXRjaGVzLnNsaWNlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwdWJsaWNEYXRhLnBhdGNoZXM7XG4gICAgfSxcblxuICAgIGdldCByZXZlcnNlZEludmVyc2VQYXRjaGVzKCkge1xuICAgICAgaWYgKCFwdWJsaWNEYXRhLnJldmVyc2VkSW52ZXJzZVBhdGNoZXMpIHtcbiAgICAgICAgcHVibGljRGF0YS5yZXZlcnNlZEludmVyc2VQYXRjaGVzID0gZGF0YS5yZXZlcnNlZEludmVyc2VQYXRjaGVzLnNsaWNlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwdWJsaWNEYXRhLnJldmVyc2VkSW52ZXJzZVBhdGNoZXM7XG4gICAgfSxcblxuICAgIGdldCBpbnZlcnNlUGF0Y2hlcygpIHtcbiAgICAgIGlmICghcHVibGljRGF0YS5pbnZlcnNlUGF0Y2hlcykge1xuICAgICAgICBwdWJsaWNEYXRhLmludmVyc2VQYXRjaGVzID0gZGF0YS5yZXZlcnNlZEludmVyc2VQYXRjaGVzLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHVibGljRGF0YS5pbnZlcnNlUGF0Y2hlcztcbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGRpc3Bvc2VyKSB7XG4gICAgICAgIGRpc3Bvc2VyKCk7XG4gICAgICAgIGRpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZGlzcG9zZXIpIHJldHVybjtcbiAgICAgIGRpc3Bvc2VyID0gb25QYXRjaChzdWJqZWN0LCBmdW5jdGlvbiAocGF0Y2gsIGludmVyc2VQYXRjaCkge1xuICAgICAgICAvLyBza2lwIHBhdGNoZXMgdGhhdCBhcmUgYXNrZWQgdG8gYmUgZmlsdGVyZWQgaWYgdGhlcmUncyBhIGZpbHRlciBpbiBwbGFjZVxuICAgICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXIocGF0Y2gsIGludmVyc2VQYXRjaCwgZ2V0UnVubmluZ0FjdGlvbkNvbnRleHQoKSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgICAgIGRhdGEucmV2ZXJzZWRJbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KGludmVyc2VQYXRjaCk7IC8vIG1hcmsgaW1tdXRhYmxlIHB1YmxpYyBwYXRjaGVzIGFzIGRpcnR5XG5cbiAgICAgICAgcHVibGljRGF0YS5wYXRjaGVzID0gdW5kZWZpbmVkO1xuICAgICAgICBwdWJsaWNEYXRhLmludmVyc2VQYXRjaGVzID0gdW5kZWZpbmVkO1xuICAgICAgICBwdWJsaWNEYXRhLnJldmVyc2VkSW52ZXJzZVBhdGNoZXMgPSB1bmRlZmluZWQ7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlcGxheTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgYXBwbHlQYXRjaCh0YXJnZXQgfHwgc3ViamVjdCwgZGF0YS5wYXRjaGVzKTtcbiAgICB9LFxuICAgIHVuZG86IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGFwcGx5UGF0Y2godGFyZ2V0IHx8IHN1YmplY3QsIGRhdGEucmV2ZXJzZWRJbnZlcnNlUGF0Y2hlcyk7XG4gICAgfVxuICB9O1xuICByZWNvcmRlci5yZXN1bWUoKTtcbiAgcmV0dXJuIHJlY29yZGVyO1xufVxuLyoqXG4gKiBUaGUgaW52ZXJzZSBvZiBgdW5wcm90ZWN0YC5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKi9cblxuXG5mdW5jdGlvbiBwcm90ZWN0KHRhcmdldCkge1xuICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KTtcbiAgaWYgKCFub2RlLmlzUm9vdCkgdGhyb3cgZmFpbCQxKFwiYHByb3RlY3RgIGNhbiBvbmx5IGJlIGludm9rZWQgb24gcm9vdCBub2Rlc1wiKTtcbiAgbm9kZS5pc1Byb3RlY3Rpb25FbmFibGVkID0gdHJ1ZTtcbn1cbi8qKlxuICogQnkgZGVmYXVsdCBpdCBpcyBub3QgYWxsb3dlZCB0byBkaXJlY3RseSBtb2RpZnkgYSBtb2RlbC4gTW9kZWxzIGNhbiBvbmx5IGJlIG1vZGlmaWVkIHRocm91Z2ggYWN0aW9ucy5cbiAqIEhvd2V2ZXIsIGluIHNvbWUgY2FzZXMgeW91IGRvbid0IGNhcmUgYWJvdXQgdGhlIGFkdmFudGFnZXMgKGxpa2UgcmVwbGF5YWJpbGl0eSwgdHJhY2VhYmlsaXR5LCBldGMpIHRoaXMgeWllbGRzLlxuICogRm9yIGV4YW1wbGUgYmVjYXVzZSB5b3UgYXJlIGJ1aWxkaW5nIGEgUG9DIG9yIGRvbid0IGhhdmUgYW55IG1pZGRsZXdhcmUgYXR0YWNoZWQgdG8geW91ciB0cmVlLlxuICpcbiAqIEluIHRoYXQgY2FzZSB5b3UgY2FuIGRpc2FibGUgdGhpcyBwcm90ZWN0aW9uIGJ5IGNhbGxpbmcgYHVucHJvdGVjdGAgb24gdGhlIHJvb3Qgb2YgeW91ciB0cmVlLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogY29uc3QgVG9kbyA9IHR5cGVzLm1vZGVsKHtcbiAqICAgICBkb25lOiBmYWxzZVxuICogfSkuYWN0aW9ucyhzZWxmID0+ICh7XG4gKiAgICAgdG9nZ2xlKCkge1xuICogICAgICAgICBzZWxmLmRvbmUgPSAhc2VsZi5kb25lXG4gKiAgICAgfVxuICogfSkpXG4gKlxuICogY29uc3QgdG9kbyA9IFRvZG8uY3JlYXRlKClcbiAqIHRvZG8uZG9uZSA9IHRydWUgLy8gdGhyb3dzIVxuICogdG9kby50b2dnbGUoKSAvLyBPS1xuICogdW5wcm90ZWN0KHRvZG8pXG4gKiB0b2RvLmRvbmUgPSBmYWxzZSAvLyBPS1xuICogYGBgXG4gKi9cblxuXG5mdW5jdGlvbiB1bnByb3RlY3QodGFyZ2V0KSB7XG4gIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gIHZhciBub2RlID0gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpO1xuICBpZiAoIW5vZGUuaXNSb290KSB0aHJvdyBmYWlsJDEoXCJgdW5wcm90ZWN0YCBjYW4gb25seSBiZSBpbnZva2VkIG9uIHJvb3Qgbm9kZXNcIik7XG4gIG5vZGUuaXNQcm90ZWN0aW9uRW5hYmxlZCA9IGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBpbiBwcm90ZWN0ZWQgbW9kZSwgQHNlZSBwcm90ZWN0XG4gKi9cblxuXG5mdW5jdGlvbiBpc1Byb3RlY3RlZCh0YXJnZXQpIHtcbiAgcmV0dXJuIGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5pc1Byb3RlY3RlZDtcbn1cbi8qKlxuICogQXBwbGllcyBhIHNuYXBzaG90IHRvIGEgZ2l2ZW4gbW9kZWwgaW5zdGFuY2VzLiBQYXRjaCBhbmQgc25hcHNob3QgbGlzdGVuZXJzIHdpbGwgYmUgaW52b2tlZCBhcyB1c3VhbC5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcGFyYW0gc25hcHNob3RcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBhcHBseVNuYXBzaG90KHRhcmdldCwgc25hcHNob3QpIHtcbiAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUodGFyZ2V0LCAxKTtcbiAgcmV0dXJuIGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5hcHBseVNuYXBzaG90KHNuYXBzaG90KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyBhIHNuYXBzaG90IGZyb20gdGhlIGdpdmVuIG1vZGVsIGluc3RhbmNlLiBUaGUgc25hcHNob3Qgd2lsbCBhbHdheXMgcmVmbGVjdCB0aGUgbGF0ZXN0IHN0YXRlIGJ1dCB1c2VcbiAqIHN0cnVjdHVyYWwgc2hhcmluZyB3aGVyZSBwb3NzaWJsZS4gRG9lc24ndCByZXF1aXJlIE1vYlggdHJhbnNhY3Rpb25zIHRvIGJlIGNvbXBsZXRlZC5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcGFyYW0gYXBwbHlQb3N0UHJvY2VzcyBJZiB0cnVlICh0aGUgZGVmYXVsdCkgdGhlbiBwb3N0UHJvY2Vzc1NuYXBzaG90IGdldHMgYXBwbGllZC5cbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTbmFwc2hvdCh0YXJnZXQsIGFwcGx5UG9zdFByb2Nlc3MpIHtcbiAgaWYgKGFwcGx5UG9zdFByb2Nlc3MgPT09IHZvaWQgMCkge1xuICAgIGFwcGx5UG9zdFByb2Nlc3MgPSB0cnVlO1xuICB9IC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcblxuXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KTtcbiAgaWYgKGFwcGx5UG9zdFByb2Nlc3MpIHJldHVybiBub2RlLnNuYXBzaG90O1xuICByZXR1cm4gZnJlZXplKG5vZGUudHlwZS5nZXRTbmFwc2hvdChub2RlLCBmYWxzZSkpO1xufVxuLyoqXG4gKiBHaXZlbiBhIG1vZGVsIGluc3RhbmNlLCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0IGhhcyBhIHBhcmVudCwgdGhhdCBpcywgaXMgcGFydCBvZiBhbm90aGVyIG9iamVjdCwgbWFwIG9yIGFycmF5LlxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEBwYXJhbSBkZXB0aCBIb3cgZmFyIHNob3VsZCB3ZSBsb29rIHVwd2FyZD8gMSBieSBkZWZhdWx0LlxuICogQHJldHVybnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGhhc1BhcmVudCh0YXJnZXQsIGRlcHRoKSB7XG4gIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgZGVwdGggPSAxO1xuICB9IC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcblxuXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICBhc3NlcnRJc051bWJlcihkZXB0aCwgMiwgMCk7XG4gIHZhciBwYXJlbnQgPSBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkucGFyZW50O1xuXG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAoLS1kZXB0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW1tZWRpYXRlIHBhcmVudCBvZiB0aGlzIG9iamVjdCwgb3IgdGhyb3dzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgaW1tZWRpYXRlIHBhcmVudCBjYW4gYmUgZWl0aGVyIGFuIG9iamVjdCwgbWFwIG9yIGFycmF5LCBhbmRcbiAqIGRvZXNuJ3QgbmVjZXNzYXJpbHkgcmVmZXIgdG8gdGhlIHBhcmVudCBtb2RlbC5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IGluIGNoaWxkIG5vZGVzIGFjY2VzcyB0byB0aGUgcm9vdCBpcyBvbmx5IHBvc3NpYmxlXG4gKiBvbmNlIHRoZSBgYWZ0ZXJBdHRhY2hgIGhvb2sgaGFzIGZpcmVkLlxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEBwYXJhbSBkZXB0aCBIb3cgZmFyIHNob3VsZCB3ZSBsb29rIHVwd2FyZD8gMSBieSBkZWZhdWx0LlxuICogQHJldHVybnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFBhcmVudCh0YXJnZXQsIGRlcHRoKSB7XG4gIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgZGVwdGggPSAxO1xuICB9IC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcblxuXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICBhc3NlcnRJc051bWJlcihkZXB0aCwgMiwgMCk7XG4gIHZhciBkID0gZGVwdGg7XG4gIHZhciBwYXJlbnQgPSBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkucGFyZW50O1xuXG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAoLS1kID09PSAwKSByZXR1cm4gcGFyZW50LnN0b3JlZFZhbHVlO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cblxuICB0aHJvdyBmYWlsJDEoXCJGYWlsZWQgdG8gZmluZCB0aGUgcGFyZW50IG9mIFwiICsgZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpICsgXCIgYXQgZGVwdGggXCIgKyBkZXB0aCk7XG59XG4vKipcbiAqIEdpdmVuIGEgbW9kZWwgaW5zdGFuY2UsIHJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgaGFzIGEgcGFyZW50IG9mIGdpdmVuIHR5cGUsIHRoYXQgaXMsIGlzIHBhcnQgb2YgYW5vdGhlciBvYmplY3QsIG1hcCBvciBhcnJheVxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gaGFzUGFyZW50T2ZUeXBlKHRhcmdldCwgdHlwZSkge1xuICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICBhc3NlcnRJc1R5cGUodHlwZSwgMik7XG4gIHZhciBwYXJlbnQgPSBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkucGFyZW50O1xuXG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAodHlwZS5pcyhwYXJlbnQuc3RvcmVkVmFsdWUpKSByZXR1cm4gdHJ1ZTtcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0YXJnZXQncyBwYXJlbnQgb2YgYSBnaXZlbiB0eXBlLCBvciB0aHJvd3MuXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRQYXJlbnRPZlR5cGUodGFyZ2V0LCB0eXBlKSB7XG4gIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gIGFzc2VydElzVHlwZSh0eXBlLCAyKTtcbiAgdmFyIHBhcmVudCA9IGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5wYXJlbnQ7XG5cbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmICh0eXBlLmlzKHBhcmVudC5zdG9yZWRWYWx1ZSkpIHJldHVybiBwYXJlbnQuc3RvcmVkVmFsdWU7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuXG4gIHRocm93IGZhaWwkMShcIkZhaWxlZCB0byBmaW5kIHRoZSBwYXJlbnQgb2YgXCIgKyBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkgKyBcIiBvZiBhIGdpdmVuIHR5cGVcIik7XG59XG4vKipcbiAqIEdpdmVuIGFuIG9iamVjdCBpbiBhIG1vZGVsIHRyZWUsIHJldHVybnMgdGhlIHJvb3Qgb2JqZWN0IG9mIHRoYXQgdHJlZS5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IGluIGNoaWxkIG5vZGVzIGFjY2VzcyB0byB0aGUgcm9vdCBpcyBvbmx5IHBvc3NpYmxlXG4gKiBvbmNlIHRoZSBgYWZ0ZXJBdHRhY2hgIGhvb2sgaGFzIGZpcmVkLlxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRSb290KHRhcmdldCkge1xuICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICByZXR1cm4gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpLnJvb3Quc3RvcmVkVmFsdWU7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHBhdGggb2YgdGhlIGdpdmVuIG9iamVjdCBpbiB0aGUgbW9kZWwgdHJlZVxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRQYXRoKHRhcmdldCkge1xuICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICByZXR1cm4gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpLnBhdGg7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHBhdGggb2YgdGhlIGdpdmVuIG9iamVjdCBhcyB1bmVzY2FwZWQgc3RyaW5nIGFycmF5LlxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRQYXRoUGFydHModGFyZ2V0KSB7XG4gIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gIHJldHVybiBzcGxpdEpzb25QYXRoKGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5wYXRoKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgdGhlIHJvb3Qgb2YgYSBtb2RlbCB0cmVlLlxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBpc1Jvb3QodGFyZ2V0KSB7XG4gIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gIHJldHVybiBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkuaXNSb290O1xufVxuLyoqXG4gKiBSZXNvbHZlcyBhIHBhdGggcmVsYXRpdmVseSB0byBhIGdpdmVuIG9iamVjdC5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vIHZhbHVlIGNhbiBiZSBmb3VuZC5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcGFyYW0gcGF0aCBlc2NhcGVkIGpzb24gcGF0aFxuICogQHJldHVybnNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRoKHRhcmdldCwgcGF0aCkge1xuICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICBhc3NlcnRJc1N0cmluZyhwYXRoLCAyKTtcbiAgdmFyIG5vZGUgPSByZXNvbHZlTm9kZUJ5UGF0aChnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCksIHBhdGgpO1xuICByZXR1cm4gbm9kZSA/IG5vZGUudmFsdWUgOiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFJlc29sdmVzIGEgbW9kZWwgaW5zdGFuY2UgZ2l2ZW4gYSByb290IHRhcmdldCwgdGhlIHR5cGUgYW5kIHRoZSBpZGVudGlmaWVyIHlvdSBhcmUgc2VhcmNoaW5nIGZvci5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vIHZhbHVlIGNhbiBiZSBmb3VuZC5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIGlkZW50aWZpZXJcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiByZXNvbHZlSWRlbnRpZmllcih0eXBlLCB0YXJnZXQsIGlkZW50aWZpZXIpIHtcbiAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICBhc3NlcnRJc1R5cGUodHlwZSwgMSk7XG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDIpO1xuICBhc3NlcnRJc1ZhbGlkSWRlbnRpZmllcihpZGVudGlmaWVyLCAzKTtcbiAgdmFyIG5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkucm9vdC5pZGVudGlmaWVyQ2FjaGUucmVzb2x2ZSh0eXBlLCBub3JtYWxpemVJZGVudGlmaWVyKGlkZW50aWZpZXIpKTtcbiAgcmV0dXJuIG5vZGUgPyBub2RlLnZhbHVlIDogdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpZGVudGlmaWVyIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAqIFRoaXMgaXMgdGhlICpzdHJpbmcgbm9ybWFsaXplZCogaWRlbnRpZmllciwgd2hpY2ggbWlnaHQgbm90IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBpZGVudGlmaWVyIGF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRJZGVudGlmaWVyKHRhcmdldCkge1xuICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICByZXR1cm4gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpLmlkZW50aWZpZXI7XG59XG4vKipcbiAqIFRlc3RzIGlmIGEgcmVmZXJlbmNlIGlzIHZhbGlkIChwb2ludGluZyB0byBhbiBleGlzdGluZyBub2RlIGFuZCBvcHRpb25hbGx5IGlmIGFsaXZlKSBhbmQgcmV0dXJucyBzdWNoIHJlZmVyZW5jZSBpZiBpdCB0aGUgY2hlY2sgcGFzc2VzLFxuICogZWxzZSBpdCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gZ2V0dGVyIEZ1bmN0aW9uIHRvIGFjY2VzcyB0aGUgcmVmZXJlbmNlLlxuICogQHBhcmFtIGNoZWNrSWZBbGl2ZSB0cnVlIHRvIGFsc28gbWFrZSBzdXJlIHRoZSByZWZlcmVuY2VkIG5vZGUgaXMgYWxpdmUgKGRlZmF1bHQpLCBmYWxzZSB0byBza2lwIHRoaXMgY2hlY2suXG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gdHJ5UmVmZXJlbmNlKGdldHRlciwgY2hlY2tJZkFsaXZlKSB7XG4gIGlmIChjaGVja0lmQWxpdmUgPT09IHZvaWQgMCkge1xuICAgIGNoZWNrSWZBbGl2ZSA9IHRydWU7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBub2RlID0gZ2V0dGVyKCk7XG5cbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkIHx8IG5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChpc1N0YXRlVHJlZU5vZGUobm9kZSkpIHtcbiAgICAgIGlmICghY2hlY2tJZkFsaXZlKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzQWxpdmUobm9kZSkgPyBub2RlIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBmYWlsJDEoXCJUaGUgcmVmZXJlbmNlIHRvIGJlIGNoZWNrZWQgaXMgbm90IG9uZSBvZiBub2RlLCBudWxsIG9yIHVuZGVmaW5lZFwiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEludmFsaWRSZWZlcmVuY2VFcnJvcikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aHJvdyBlO1xuICB9XG59XG4vKipcbiAqIFRlc3RzIGlmIGEgcmVmZXJlbmNlIGlzIHZhbGlkIChwb2ludGluZyB0byBhbiBleGlzdGluZyBub2RlIGFuZCBvcHRpb25hbGx5IGlmIGFsaXZlKSBhbmQgcmV0dXJucyBpZiB0aGUgY2hlY2sgcGFzc2VzIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gZ2V0dGVyIEZ1bmN0aW9uIHRvIGFjY2VzcyB0aGUgcmVmZXJlbmNlLlxuICogQHBhcmFtIGNoZWNrSWZBbGl2ZSB0cnVlIHRvIGFsc28gbWFrZSBzdXJlIHRoZSByZWZlcmVuY2VkIG5vZGUgaXMgYWxpdmUgKGRlZmF1bHQpLCBmYWxzZSB0byBza2lwIHRoaXMgY2hlY2suXG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZFJlZmVyZW5jZShnZXR0ZXIsIGNoZWNrSWZBbGl2ZSkge1xuICBpZiAoY2hlY2tJZkFsaXZlID09PSB2b2lkIDApIHtcbiAgICBjaGVja0lmQWxpdmUgPSB0cnVlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgbm9kZSA9IGdldHRlcigpO1xuXG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCB8fCBub2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc1N0YXRlVHJlZU5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBjaGVja0lmQWxpdmUgPyBpc0FsaXZlKG5vZGUpIDogdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZmFpbCQxKFwiVGhlIHJlZmVyZW5jZSB0byBiZSBjaGVja2VkIGlzIG5vdCBvbmUgb2Ygbm9kZSwgbnVsbCBvciB1bmRlZmluZWRcIik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBJbnZhbGlkUmVmZXJlbmNlRXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aHJvdyBlO1xuICB9XG59XG4vKipcbiAqIFRyeSB0byByZXNvbHZlIGEgZ2l2ZW4gcGF0aCByZWxhdGl2ZSB0byBhIGdpdmVuIG5vZGUuXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIHBhdGhcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiB0cnlSZXNvbHZlKHRhcmdldCwgcGF0aCkge1xuICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICBhc3NlcnRJc1N0cmluZyhwYXRoLCAyKTtcbiAgdmFyIG5vZGUgPSByZXNvbHZlTm9kZUJ5UGF0aChnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCksIHBhdGgsIGZhbHNlKTtcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIHJldHVybiBub2RlLnZhbHVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gRm9yIHdoYXQgZXZlciByZWFzb24gbm90IHJlc29sdmFibGUgKGUuZy4gdG90YWxseSBub3QgZXhpc3RpbmcgcGF0aCwgb3IgdmFsdWUgdGhhdCBjYW5ub3QgYmUgZmV0Y2hlZClcbiAgICAvLyBzZWUgdGVzdCAvIGlzc3VlOiAndHJ5IHJlc29sdmUgZG9lc24ndCB3b3JrICM2ODYnXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuLyoqXG4gKiBHaXZlbiB0d28gc3RhdGUgdHJlZSBub2RlcyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBzYW1lIHRyZWUsXG4gKiByZXR1cm5zIHRoZSBzaG9ydGVzdCBqc29ucGF0aCBuZWVkZWQgdG8gbmF2aWdhdGUgZnJvbSB0aGUgb25lIHRvIHRoZSBvdGhlclxuICpcbiAqIEBwYXJhbSBiYXNlXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVQYXRoKGJhc2UsIHRhcmdldCkge1xuICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZShiYXNlLCAxKTtcbiAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMik7XG4gIHJldHVybiBnZXRSZWxhdGl2ZVBhdGhCZXR3ZWVuTm9kZXMoZ2V0U3RhdGVUcmVlTm9kZShiYXNlKSwgZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGRlZXAgY29weSBvZiB0aGUgZ2l2ZW4gc3RhdGUgdHJlZSBub2RlIGFzIG5ldyB0cmVlLlxuICogU2hvcnQgaGFuZCBmb3IgYHNuYXBzaG90KHgpID0gZ2V0VHlwZSh4KS5jcmVhdGUoZ2V0U25hcHNob3QoeCkpYFxuICpcbiAqIF9UaXA6IGNsb25lIHdpbGwgY3JlYXRlIGEgbGl0ZXJhbCBjb3B5LCBpbmNsdWRpbmcgdGhlIHNhbWUgaWRlbnRpZmllcnMuIFRvIG1vZGlmeSBpZGVudGlmaWVycyBldGMgZHVyaW5nIGNsb25pbmcsIGRvbid0IHVzZSBjbG9uZSBidXQgdGFrZSBhIHNuYXBzaG90IG9mIHRoZSB0cmVlLCBtb2RpZnkgaXQsIGFuZCBjcmVhdGUgbmV3IGluc3RhbmNlX1xuICpcbiAqIEBwYXJhbSBzb3VyY2VcbiAqIEBwYXJhbSBrZWVwRW52aXJvbm1lbnQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNsb25lIHNob3VsZCBpbmhlcml0IHRoZSBzYW1lIGVudmlyb25tZW50IChgdHJ1ZWAsIHRoZSBkZWZhdWx0KSwgb3Igbm90IGhhdmUgYW4gZW52aXJvbm1lbnQgKGBmYWxzZWApLiBJZiBhbiBvYmplY3QgaXMgcGFzc2VkIGluIGFzIHNlY29uZCBhcmd1bWVudCwgdGhhdCB3aWxsIGFjdCBhcyB0aGUgZW52aXJvbm1lbnQgZm9yIHRoZSBjbG9uZWQgdHJlZS5cbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZShzb3VyY2UsIGtlZXBFbnZpcm9ubWVudCkge1xuICBpZiAoa2VlcEVudmlyb25tZW50ID09PSB2b2lkIDApIHtcbiAgICBrZWVwRW52aXJvbm1lbnQgPSB0cnVlO1xuICB9IC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcblxuXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZShzb3VyY2UsIDEpO1xuICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGUoc291cmNlKTtcbiAgcmV0dXJuIG5vZGUudHlwZS5jcmVhdGUobm9kZS5zbmFwc2hvdCwga2VlcEVudmlyb25tZW50ID09PSB0cnVlID8gbm9kZS5yb290LmVudmlyb25tZW50IDoga2VlcEVudmlyb25tZW50ID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IGtlZXBFbnZpcm9ubWVudCk7IC8vIGl0J3MgYW4gb2JqZWN0IG9yIHNvbWV0aGluZyBlbHNlXG59XG4vKipcbiAqIFJlbW92ZXMgYSBtb2RlbCBlbGVtZW50IGZyb20gdGhlIHN0YXRlIHRyZWUsIGFuZCBsZXQgaXQgbGl2ZSBvbiBhcyBhIG5ldyBzdGF0ZSB0cmVlXG4gKi9cblxuXG5mdW5jdGlvbiBkZXRhY2godGFyZ2V0KSB7XG4gIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gIGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5kZXRhY2goKTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogUmVtb3ZlcyBhIG1vZGVsIGVsZW1lbnQgZnJvbSB0aGUgc3RhdGUgdHJlZSwgYW5kIG1hcmsgaXQgYXMgZW5kLW9mLWxpZmU7IHRoZSBlbGVtZW50IHNob3VsZCBub3QgYmUgdXNlZCBhbnltb3JlXG4gKi9cblxuXG5mdW5jdGlvbiBkZXN0cm95KHRhcmdldCkge1xuICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KTtcbiAgaWYgKG5vZGUuaXNSb290KSBub2RlLmRpZSgpO2Vsc2Ugbm9kZS5wYXJlbnQucmVtb3ZlQ2hpbGQobm9kZS5zdWJwYXRoKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdGF0ZSB0cmVlIG5vZGUgaXMgbm90IGtpbGxlZCB5ZXQuXG4gKiBUaGlzIG1lYW5zIHRoYXQgdGhlIG5vZGUgaXMgc3RpbGwgYSBwYXJ0IG9mIGEgdHJlZSwgYW5kIHRoYXQgYGRlc3Ryb3lgXG4gKiBoYXMgbm90IGJlZW4gY2FsbGVkLiBJZiBhIG5vZGUgaXMgbm90IGFsaXZlIGFueW1vcmUsIHRoZSBvbmx5IHRoaW5nIG9uZSBjYW4gZG8gd2l0aCBpdFxuICogaXMgcmVxdWVzdGluZyBpdCdzIGxhc3QgcGF0aCBhbmQgc25hcHNob3RcbiAqXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gaXNBbGl2ZSh0YXJnZXQpIHtcbiAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUodGFyZ2V0LCAxKTtcbiAgcmV0dXJuIGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5vYnNlcnZhYmxlSXNBbGl2ZTtcbn1cbi8qKlxuICogVXNlIHRoaXMgdXRpbGl0eSB0byByZWdpc3RlciBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuZXZlciB0aGVcbiAqIHRhcmdldGVkIHN0YXRlIHRyZWUgbm9kZSBpcyBkZXN0cm95ZWQuIFRoaXMgaXMgYSB1c2VmdWwgYWx0ZXJuYXRpdmUgdG8gbWFuYWdpbmdcbiAqIGNsZWFudXAgbWV0aG9kcyB5b3Vyc2VsZiB1c2luZyB0aGUgYGJlZm9yZURlc3Ryb3lgIGhvb2suXG4gKlxuICogVGhpcyBtZXRob2RzIHJldHVybnMgdGhlIHNhbWUgZGlzcG9zZXIgdGhhdCB3YXMgcGFzc2VkIGFzIGFyZ3VtZW50LlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogY29uc3QgVG9kbyA9IHR5cGVzLm1vZGVsKHtcbiAqICAgdGl0bGU6IHR5cGVzLnN0cmluZ1xuICogfSkuYWN0aW9ucyhzZWxmID0+ICh7XG4gKiAgIGFmdGVyQ3JlYXRlKCkge1xuICogICAgIGNvbnN0IGF1dG9TYXZlRGlzcG9zZXIgPSByZWFjdGlvbihcbiAqICAgICAgICgpID0+IGdldFNuYXBzaG90KHNlbGYpLFxuICogICAgICAgc25hcHNob3QgPT4gc2VuZFNuYXBzaG90VG9TZXJ2ZXJTb21laG93KHNuYXBzaG90KVxuICogICAgIClcbiAqICAgICAvLyBzdG9wIHNlbmRpbmcgdXBkYXRlcyB0byBzZXJ2ZXIgaWYgdGhpc1xuICogICAgIC8vIGluc3RhbmNlIGlzIGRlc3Ryb3llZFxuICogICAgIGFkZERpc3Bvc2VyKHNlbGYsIGF1dG9TYXZlRGlzcG9zZXIpXG4gKiAgIH1cbiAqIH0pKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIGRpc3Bvc2VyXG4gKiBAcmV0dXJucyBUaGUgc2FtZSBkaXNwb3NlciB0aGF0IHdhcyBwYXNzZWQgYXMgYXJndW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZERpc3Bvc2VyKHRhcmdldCwgZGlzcG9zZXIpIHtcbiAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUodGFyZ2V0LCAxKTtcbiAgYXNzZXJ0SXNGdW5jdGlvbihkaXNwb3NlciwgMik7XG4gIHZhciBub2RlID0gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpO1xuICBub2RlLmFkZERpc3Bvc2VyKGRpc3Bvc2VyKTtcbiAgcmV0dXJuIGRpc3Bvc2VyO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbnZpcm9ubWVudCBvZiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlLiBGb3IgbW9yZSBpbmZvIG9uIGVudmlyb25tZW50cyxcbiAqIHNlZSBbRGVwZW5kZW5jeSBpbmplY3Rpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC1zdGF0ZS10cmVlI2RlcGVuZGVuY3ktaW5qZWN0aW9uKVxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgaW4gY2hpbGQgbm9kZXMgYWNjZXNzIHRvIHRoZSByb290IGlzIG9ubHkgcG9zc2libGVcbiAqIG9uY2UgdGhlIGBhZnRlckF0dGFjaGAgaG9vayBoYXMgZmlyZWRcbiAqXG4gKiBSZXR1cm5zIGFuIGVtcHR5IGVudmlyb25tZW50IGlmIHRoZSB0cmVlIHdhc24ndCBpbml0aWFsaXplZCB3aXRoIGFuIGVudmlyb25tZW50XG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHJldHVybnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVudih0YXJnZXQpIHtcbiAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUodGFyZ2V0LCAxKTtcbiAgdmFyIG5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCk7XG4gIHZhciBlbnYgPSBub2RlLnJvb3QuZW52aXJvbm1lbnQ7XG4gIGlmICghZW52KSByZXR1cm4gRU1QVFlfT0JKRUNUO1xuICByZXR1cm4gZW52O1xufVxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlcHRoIGZpcnN0IHdhbGsgdGhyb3VnaCBhIHRyZWUuXG4gKi9cblxuXG5mdW5jdGlvbiB3YWxrKHRhcmdldCwgcHJvY2Vzc29yKSB7XG4gIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gIGFzc2VydElzRnVuY3Rpb24ocHJvY2Vzc29yLCAyKTtcbiAgdmFyIG5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCk7IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpub191bnVzZWQtdmFyaWFibGVcblxuICBub2RlLmdldENoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoaXNTdGF0ZVRyZWVOb2RlKGNoaWxkLnN0b3JlZFZhbHVlKSkgd2FsayhjaGlsZC5zdG9yZWRWYWx1ZSwgcHJvY2Vzc29yKTtcbiAgfSk7XG4gIHByb2Nlc3Nvcihub2RlLnN0b3JlZFZhbHVlKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHJlZmxlY3Rpb24gb2YgdGhlIG1vZGVsIHR5cGUgcHJvcGVydGllcyBhbmQgbmFtZSBmb3IgZWl0aGVyIGEgbW9kZWwgdHlwZSBvciBtb2RlbCBub2RlLlxuICpcbiAqIEBwYXJhbSB0eXBlT3JOb2RlXG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlNZW1iZXJzKHR5cGVPck5vZGUpIHtcbiAgdmFyIHR5cGU7XG5cbiAgaWYgKGlzU3RhdGVUcmVlTm9kZSh0eXBlT3JOb2RlKSkge1xuICAgIHR5cGUgPSBnZXRUeXBlKHR5cGVPck5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSB0eXBlT3JOb2RlO1xuICB9XG5cbiAgYXNzZXJ0QXJnKHR5cGUsIGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIGlzTW9kZWxUeXBlKHQpO1xuICB9LCBcIm1vZGVsIHR5cGUgb3IgbW9kZWwgaW5zdGFuY2VcIiwgMSk7XG4gIHJldHVybiB7XG4gICAgbmFtZTogdHlwZS5uYW1lLFxuICAgIHByb3BlcnRpZXM6IF9fYXNzaWduKHt9LCB0eXBlLnByb3BlcnRpZXMpXG4gIH07XG59XG4vKipcbiAqIFJldHVybnMgYSByZWZsZWN0aW9uIG9mIHRoZSBtb2RlbCBub2RlLCBpbmNsdWRpbmcgbmFtZSwgcHJvcGVydGllcywgdmlld3MsIHZvbGF0aWxlIGFuZCBhY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRNZW1iZXJzKHRhcmdldCkge1xuICB2YXIgdHlwZSA9IGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS50eXBlO1xuXG4gIHZhciByZWZsZWN0ZWQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZ2V0UHJvcGVydHlNZW1iZXJzKHR5cGUpKSwge1xuICAgIGFjdGlvbnM6IFtdLFxuICAgIHZvbGF0aWxlOiBbXSxcbiAgICB2aWV3czogW11cbiAgfSk7XG5cbiAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSBpbiByZWZsZWN0ZWQucHJvcGVydGllcykgcmV0dXJuO1xuICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG5cbiAgICBpZiAoZGVzY3JpcHRvci5nZXQpIHtcbiAgICAgIGlmIChpc0NvbXB1dGVkUHJvcCh0YXJnZXQsIGtleSkpIHJlZmxlY3RlZC52aWV3cy5wdXNoKGtleSk7ZWxzZSByZWZsZWN0ZWQudm9sYXRpbGUucHVzaChrZXkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlLl9pc01TVEFjdGlvbiA9PT0gdHJ1ZSkgcmVmbGVjdGVkLmFjdGlvbnMucHVzaChrZXkpO2Vsc2UgaWYgKGlzT2JzZXJ2YWJsZVByb3AodGFyZ2V0LCBrZXkpKSByZWZsZWN0ZWQudm9sYXRpbGUucHVzaChrZXkpO2Vsc2UgcmVmbGVjdGVkLnZpZXdzLnB1c2goa2V5KTtcbiAgfSk7XG4gIHJldHVybiByZWZsZWN0ZWQ7XG59XG4vKipcbiAqIENhc3RzIGEgbm9kZSBzbmFwc2hvdCBvciBpbnN0YW5jZSB0eXBlIHRvIGFuIGluc3RhbmNlIHR5cGUgc28gaXQgY2FuIGJlIGFzc2lnbmVkIHRvIGEgdHlwZSBpbnN0YW5jZS5cbiAqIE5vdGUgdGhhdCB0aGlzIGlzIGp1c3QgYSBjYXN0IGZvciB0aGUgdHlwZSBzeXN0ZW0sIHRoaXMgaXMsIGl0IHdvbid0IGFjdHVhbGx5IGNvbnZlcnQgYSBzbmFwc2hvdCB0byBhbiBpbnN0YW5jZSxcbiAqIGJ1dCBqdXN0IGZvb2wgdHlwZXNjcmlwdCBpbnRvIHRoaW5raW5nIHNvLlxuICogRWl0aGVyIHdheSwgY2FzdGluZyB3aGVuIG91dHNpZGUgYW4gYXNzaWduYXRpb24gb3BlcmF0aW9uIHdvbid0IGNvbXBpbGUuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBNb2RlbEEgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIG46IHR5cGVzLm51bWJlclxuICogfSkuYWN0aW9ucyhzZWxmID0+ICh7XG4gKiAgIHNldE4oYU51bWJlcjogbnVtYmVyKSB7XG4gKiAgICAgc2VsZi5uID0gYU51bWJlclxuICogICB9XG4gKiB9KSlcbiAqXG4gKiBjb25zdCBNb2RlbEIgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIGlubmVyTW9kZWw6IE1vZGVsQVxuICogfSkuYWN0aW9ucyhzZWxmID0+ICh7XG4gKiAgIHNvbWVBY3Rpb24oKSB7XG4gKiAgICAgLy8gdGhpcyB3aWxsIGFsbG93IHRoZSBjb21waWxlciB0byBhc3NpZ24gYSBzbmFwc2hvdCB0byB0aGUgcHJvcGVydHlcbiAqICAgICBzZWxmLmlubmVyTW9kZWwgPSBjYXN0KHsgYTogNSB9KVxuICogICB9XG4gKiB9KSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzbmFwc2hvdE9ySW5zdGFuY2UgU25hcHNob3Qgb3IgaW5zdGFuY2VcbiAqIEByZXR1cm5zIFRoZSBzYW1lIG9iamVjdCBjYXN0ZWQgYXMgYW4gaW5zdGFuY2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGNhc3Qoc25hcHNob3RPckluc3RhbmNlKSB7XG4gIHJldHVybiBzbmFwc2hvdE9ySW5zdGFuY2U7XG59XG4vKipcbiAqIENhc3RzIGEgbm9kZSBpbnN0YW5jZSB0eXBlIHRvIGFuIHNuYXBzaG90IHR5cGUgc28gaXQgY2FuIGJlIGFzc2lnbmVkIHRvIGEgdHlwZSBzbmFwc2hvdCAoZS5nLiB0byBiZSB1c2VkIGluc2lkZSBhIGNyZWF0ZSBjYWxsKS5cbiAqIE5vdGUgdGhhdCB0aGlzIGlzIGp1c3QgYSBjYXN0IGZvciB0aGUgdHlwZSBzeXN0ZW0sIHRoaXMgaXMsIGl0IHdvbid0IGFjdHVhbGx5IGNvbnZlcnQgYW4gaW5zdGFuY2UgdG8gYSBzbmFwc2hvdCxcbiAqIGJ1dCBqdXN0IGZvb2wgdHlwZXNjcmlwdCBpbnRvIHRoaW5raW5nIHNvLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogY29uc3QgTW9kZWxBID0gdHlwZXMubW9kZWwoe1xuICogICBuOiB0eXBlcy5udW1iZXJcbiAqIH0pLmFjdGlvbnMoc2VsZiA9PiAoe1xuICogICBzZXROKGFOdW1iZXI6IG51bWJlcikge1xuICogICAgIHNlbGYubiA9IGFOdW1iZXJcbiAqICAgfVxuICogfSkpXG4gKlxuICogY29uc3QgTW9kZWxCID0gdHlwZXMubW9kZWwoe1xuICogICBpbm5lck1vZGVsOiBNb2RlbEFcbiAqIH0pXG4gKlxuICogY29uc3QgYSA9IE1vZGVsQS5jcmVhdGUoeyBuOiA1IH0pO1xuICogLy8gdGhpcyB3aWxsIGFsbG93IHRoZSBjb21waWxlciB0byB1c2UgYSBtb2RlbCBhcyBpZiBpdCB3ZXJlIGEgc25hcHNob3RcbiAqIGNvbnN0IGIgPSBNb2RlbEIuY3JlYXRlKHsgaW5uZXJNb2RlbDogY2FzdFRvU25hcHNob3QoYSl9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNuYXBzaG90T3JJbnN0YW5jZSBTbmFwc2hvdCBvciBpbnN0YW5jZVxuICogQHJldHVybnMgVGhlIHNhbWUgb2JqZWN0IGNhc3RlZCBhcyBhbiBpbnB1dCAoY3JlYXRpb24pIHNuYXBzaG90XG4gKi9cblxuXG5mdW5jdGlvbiBjYXN0VG9TbmFwc2hvdChzbmFwc2hvdE9ySW5zdGFuY2UpIHtcbiAgcmV0dXJuIHNuYXBzaG90T3JJbnN0YW5jZTtcbn1cbi8qKlxuICogQ2FzdHMgYSBub2RlIGluc3RhbmNlIHR5cGUgdG8gYSByZWZlcmVuY2Ugc25hcHNob3QgdHlwZSBzbyBpdCBjYW4gYmUgYXNzaWduZWQgdG8gYSByZWZlcm5lbmNlIHNuYXBzaG90IChlLmcuIHRvIGJlIHVzZWQgaW5zaWRlIGEgY3JlYXRlIGNhbGwpLlxuICogTm90ZSB0aGF0IHRoaXMgaXMganVzdCBhIGNhc3QgZm9yIHRoZSB0eXBlIHN5c3RlbSwgdGhpcyBpcywgaXQgd29uJ3QgYWN0dWFsbHkgY29udmVydCBhbiBpbnN0YW5jZSB0byBhIHJlZmVyZXJlbmNlIHNuYXBzaG90LFxuICogYnV0IGp1c3QgZm9vbCB0eXBlc2NyaXB0IGludG8gdGhpbmtpbmcgc28uXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBNb2RlbEEgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIGlkOiB0eXBlcy5pZGVudGlmaWVyLFxuICogICBuOiB0eXBlcy5udW1iZXJcbiAqIH0pLmFjdGlvbnMoc2VsZiA9PiAoe1xuICogICBzZXROKGFOdW1iZXI6IG51bWJlcikge1xuICogICAgIHNlbGYubiA9IGFOdW1iZXJcbiAqICAgfVxuICogfSkpXG4gKlxuICogY29uc3QgTW9kZWxCID0gdHlwZXMubW9kZWwoe1xuICogICByZWZBOiB0eXBlcy5yZWZlcmVuY2UoTW9kZWxBKVxuICogfSlcbiAqXG4gKiBjb25zdCBhID0gTW9kZWxBLmNyZWF0ZSh7IGlkOiAnc29tZUlkJywgbjogNSB9KTtcbiAqIC8vIHRoaXMgd2lsbCBhbGxvdyB0aGUgY29tcGlsZXIgdG8gdXNlIGEgbW9kZWwgYXMgaWYgaXQgd2VyZSBhIHJlZmVyZW5jZSBzbmFwc2hvdFxuICogY29uc3QgYiA9IE1vZGVsQi5jcmVhdGUoeyByZWZBOiBjYXN0VG9SZWZlcmVuY2VTbmFwc2hvdChhKX0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2UgSW5zdGFuY2VcbiAqIEByZXR1cm5zIFRoZSBzYW1lIG9iamVjdCBjYXN0ZWQgYXMgYW4gcmVmZXJlbmNlIHNuYXBzaG90IChzdHJpbmcgb3IgbnVtYmVyKVxuICovXG5cblxuZnVuY3Rpb24gY2FzdFRvUmVmZXJlbmNlU25hcHNob3QoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmlxdWUgbm9kZSBpZCAobm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggdGhlIGluc3RhbmNlIGlkZW50aWZpZXIpIGZvciBhXG4gKiBnaXZlbiBpbnN0YW5jZS5cbiAqIFRoaXMgaWQgaXMgYSBudW1iZXIgdGhhdCBpcyB1bmlxdWUgZm9yIGVhY2ggaW5zdGFuY2UuXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIHRhcmdldFxuICogQHJldHVybnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE5vZGVJZCh0YXJnZXQpIHtcbiAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gIHJldHVybiBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkubm9kZUlkO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbnZhciBCYXNlTm9kZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VOb2RlKHR5cGUsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB0eXBlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW52aXJvbm1lbnRcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGVudmlyb25tZW50XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2VzY2FwZWRTdWJwYXRoXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3VicGF0aFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N1YnBhdGhVcG9uRGVhdGhcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYXRoVXBvbkRlYXRoXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yZWRWYWx1ZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7IC8vIHVzdWFsbHkgdGhlIHNhbWUgdHlwZSBhcyB0aGUgdmFsdWUsIGJ1dCBub3QgYWx3YXlzIChzdWNoIGFzIHdpdGggcmVmZXJlbmNlcylcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsaXZlQXRvbVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N0YXRlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBOb2RlTGlmZUN5Y2xlLklOSVRJQUxJWklOR1xuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ob29rU3Vic2NyaWJlcnNcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYXJlbnRcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhdGhBdG9tXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcbiAgICB0aGlzLmVudmlyb25tZW50ID0gZW52aXJvbm1lbnQ7XG4gICAgdGhpcy5iYXNlU2V0UGFyZW50KHBhcmVudCwgc3VicGF0aCk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcInN1YnBhdGhcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnBhdGg7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlTm9kZS5wcm90b3R5cGUsIFwic3VicGF0aFVwb25EZWF0aFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3VicGF0aFVwb25EZWF0aDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VOb2RlLnByb3RvdHlwZSwgXCJwYXRoVXBvbkRlYXRoXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXRoVXBvbkRlYXRoO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuZ2V0VmFsdWUodGhpcyk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlTm9kZS5wcm90b3R5cGUsIFwic3RhdGVcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB2YXIgd2FzQWxpdmUgPSB0aGlzLmlzQWxpdmU7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHZhbDtcbiAgICAgIHZhciBpc0FsaXZlID0gdGhpcy5pc0FsaXZlO1xuXG4gICAgICBpZiAodGhpcy5hbGl2ZUF0b20gJiYgd2FzQWxpdmUgIT09IGlzQWxpdmUpIHtcbiAgICAgICAgdGhpcy5hbGl2ZUF0b20ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcImZpcmVJbnRlcm5hbEhvb2tcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmICh0aGlzLl9ob29rU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgdGhpcy5faG9va1N1YnNjcmliZXJzLmVtaXQobmFtZSwgdGhpcywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VOb2RlLnByb3RvdHlwZSwgXCJyZWdpc3Rlckhvb2tcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGhvb2ssIGhvb2tIYW5kbGVyKSB7XG4gICAgICBpZiAoIXRoaXMuX2hvb2tTdWJzY3JpYmVycykge1xuICAgICAgICB0aGlzLl9ob29rU3Vic2NyaWJlcnMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5faG9va1N1YnNjcmliZXJzLnJlZ2lzdGVyKGhvb2ssIGhvb2tIYW5kbGVyKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcImJhc2VTZXRQYXJlbnRcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHBhcmVudCwgc3VicGF0aCkge1xuICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgdGhpcy5fc3VicGF0aCA9IHN1YnBhdGg7XG4gICAgICB0aGlzLl9lc2NhcGVkU3VicGF0aCA9IHVuZGVmaW5lZDsgLy8gcmVnZW5lcmF0ZSB3aGVuIG5lZWRlZFxuXG4gICAgICBpZiAodGhpcy5wYXRoQXRvbSkge1xuICAgICAgICB0aGlzLnBhdGhBdG9tLnJlcG9ydENoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgIC8qXG4gICAgICogUmV0dXJucyAoZXNjYXBlZCkgcGF0aCByZXByZXNlbnRhdGlvbiBhcyBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEVzY2FwZWRQYXRoKHRydWUpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcImdldEVzY2FwZWRQYXRoXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChyZXBvcnRPYnNlcnZlZCkge1xuICAgICAgaWYgKHJlcG9ydE9ic2VydmVkKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXRoQXRvbSkge1xuICAgICAgICAgIHRoaXMucGF0aEF0b20gPSBjcmVhdGVBdG9tKFwicGF0aFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGF0aEF0b20ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnBhcmVudCkgcmV0dXJuIFwiXCI7IC8vIHJlZ2VuZXJhdGUgZXNjYXBlZCBzdWJwYXRoIGlmIG5lZWRlZFxuXG4gICAgICBpZiAodGhpcy5fZXNjYXBlZFN1YnBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9lc2NhcGVkU3VicGF0aCA9ICF0aGlzLl9zdWJwYXRoID8gXCJcIiA6IGVzY2FwZUpzb25QYXRoKHRoaXMuX3N1YnBhdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0RXNjYXBlZFBhdGgocmVwb3J0T2JzZXJ2ZWQpICsgXCIvXCIgKyB0aGlzLl9lc2NhcGVkU3VicGF0aDtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcImlzUm9vdFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPT09IG51bGw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlTm9kZS5wcm90b3R5cGUsIFwiaXNBbGl2ZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZSAhPT0gTm9kZUxpZmVDeWNsZS5ERUFEO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcImlzRGV0YWNoaW5nXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBOb2RlTGlmZUN5Y2xlLkRFVEFDSElORztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VOb2RlLnByb3RvdHlwZSwgXCJvYnNlcnZhYmxlSXNBbGl2ZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuYWxpdmVBdG9tKSB7XG4gICAgICAgIHRoaXMuYWxpdmVBdG9tID0gY3JlYXRlQXRvbShcImFsaXZlXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFsaXZlQXRvbS5yZXBvcnRPYnNlcnZlZCgpO1xuICAgICAgcmV0dXJuIHRoaXMuaXNBbGl2ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VOb2RlLnByb3RvdHlwZSwgXCJiYXNlRmluYWxpemVDcmVhdGlvblwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAod2hlbkZpbmFsaXplZCkge1xuICAgICAgaWYgKGRldk1vZGUoKSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBbGl2ZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgdGhyb3cgZmFpbChcImFzc2VydGlvbiBmYWlsZWQ6IGNhbm5vdCBmaW5hbGl6ZSB0aGUgY3JlYXRpb24gb2YgYSBub2RlIHRoYXQgaXMgYWxyZWFkeSBkZWFkXCIpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGdvYWw6IGFmdGVyQ3JlYXRlIGhvb2tzIHJ1bnMgZGVwdGgtZmlyc3QuIEFmdGVyIGF0dGFjaCBydW5zIHBhcmVudCBmaXJzdCwgc28gb24gYWZ0ZXJBdHRhY2ggdGhlIHBhcmVudCBoYXMgY29tcGxldGVkIGFscmVhZHlcblxuXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gTm9kZUxpZmVDeWNsZS5DUkVBVEVEKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgIGlmICh0aGlzLnBhcmVudC5zdGF0ZSAhPT0gTm9kZUxpZmVDeWNsZS5GSU5BTElaRUQpIHtcbiAgICAgICAgICAgIC8vIHBhcmVudCBub3QgcmVhZHkgeWV0LCBwb3N0cG9uZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZmlyZUhvb2soSG9vay5hZnRlckF0dGFjaCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlID0gTm9kZUxpZmVDeWNsZS5GSU5BTElaRUQ7XG5cbiAgICAgICAgaWYgKHdoZW5GaW5hbGl6ZWQpIHtcbiAgICAgICAgICB3aGVuRmluYWxpemVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcImJhc2VGaW5hbGl6ZURlYXRoXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9ob29rU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgdGhpcy5faG9va1N1YnNjcmliZXJzLmNsZWFyQWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N1YnBhdGhVcG9uRGVhdGggPSB0aGlzLl9zdWJwYXRoO1xuICAgICAgdGhpcy5fcGF0aFVwb25EZWF0aCA9IHRoaXMuZ2V0RXNjYXBlZFBhdGgoZmFsc2UpO1xuICAgICAgdGhpcy5iYXNlU2V0UGFyZW50KG51bGwsIFwiXCIpO1xuICAgICAgdGhpcy5zdGF0ZSA9IE5vZGVMaWZlQ3ljbGUuREVBRDtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcImJhc2VBYm91dFRvRGllXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZmlyZUhvb2soSG9vay5iZWZvcmVEZXN0cm95KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gQmFzZU5vZGU7XG59KCk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxudmFyIFNjYWxhck5vZGUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2NhbGFyTm9kZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTY2FsYXJOb2RlKHNpbXBsZVR5cGUsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxTbmFwc2hvdCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNpbXBsZVR5cGUsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQpIHx8IHRoaXM7XG5cbiAgICB0cnkge1xuICAgICAgX3RoaXMuc3RvcmVkVmFsdWUgPSBzaW1wbGVUeXBlLmNyZWF0ZU5ld0luc3RhbmNlKGluaXRpYWxTbmFwc2hvdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2hvcnQtY3V0IHRvIGRpZSB0aGUgaW5zdGFuY2UsIHRvIGF2b2lkIHRoZSBzbmFwc2hvdCBjb21wdXRlZCBzdGFydGluZyB0byB0aHJvdy4uLlxuICAgICAgX3RoaXMuc3RhdGUgPSBOb2RlTGlmZUN5Y2xlLkRFQUQ7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIF90aGlzLnN0YXRlID0gTm9kZUxpZmVDeWNsZS5DUkVBVEVEOyAvLyBmb3Igc2NhbGFyIG5vZGVzIHRoZXJlJ3Mgbm8gcG9pbnQgaW4gZmlyaW5nIHRoaXMgZXZlbnQgc2luY2UgaXQgd291bGQgZmlyZSBvbiB0aGUgY29uc3RydWN0b3IsIGJlZm9yZVxuICAgIC8vIGFueWJvZHkgY2FuIGFjdHVhbGx5IHJlZ2lzdGVyIGZvci9saXN0ZW4gdG8gaXRcbiAgICAvLyB0aGlzLmZpcmVIb29rKEhvb2suQWZ0ZXJDcmVhdGUpXG5cbiAgICBfdGhpcy5maW5hbGl6ZUNyZWF0aW9uKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NhbGFyTm9kZS5wcm90b3R5cGUsIFwicm9vdFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBmdXR1cmUgb3B0aW1pemF0aW9uOiBzdG9yZSByb290IHJlZiBpbiB0aGUgbm9kZSBhbmQgbWFpbnRhaW4gaXRcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHRocm93IGZhaWwkMShcIlRoaXMgc2NhbGFyIG5vZGUgaXMgbm90IHBhcnQgb2YgYSB0cmVlXCIpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnJvb3Q7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2FsYXJOb2RlLnByb3RvdHlwZSwgXCJzZXRQYXJlbnRcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5ld1BhcmVudCwgc3VicGF0aCkge1xuICAgICAgdmFyIHBhcmVudENoYW5nZWQgPSB0aGlzLnBhcmVudCAhPT0gbmV3UGFyZW50O1xuICAgICAgdmFyIHN1YnBhdGhDaGFuZ2VkID0gdGhpcy5zdWJwYXRoICE9PSBzdWJwYXRoO1xuXG4gICAgICBpZiAoIXBhcmVudENoYW5nZWQgJiYgIXN1YnBhdGhDaGFuZ2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRldk1vZGUoKSkge1xuICAgICAgICBpZiAoIXN1YnBhdGgpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHRocm93IGZhaWwkMShcImFzc2VydGlvbiBmYWlsZWQ6IHN1YnBhdGggZXhwZWN0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5ld1BhcmVudCkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgdGhyb3cgZmFpbCQxKFwiYXNzZXJ0aW9uIGZhaWxlZDogcGFyZW50IGV4cGVjdGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudENoYW5nZWQpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHRocm93IGZhaWwkMShcImFzc2VydGlvbiBmYWlsZWQ6IHNjYWxhciBub2RlcyBjYW5ub3QgY2hhbmdlIHRoZWlyIHBhcmVudFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVudmlyb25tZW50ID0gdW5kZWZpbmVkOyAvLyB1c2UgcGFyZW50J3NcblxuICAgICAgdGhpcy5iYXNlU2V0UGFyZW50KHRoaXMucGFyZW50LCBzdWJwYXRoKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NhbGFyTm9kZS5wcm90b3R5cGUsIFwic25hcHNob3RcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZyZWV6ZSh0aGlzLmdldFNuYXBzaG90KCkpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NhbGFyTm9kZS5wcm90b3R5cGUsIFwiZ2V0U25hcHNob3RcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5nZXRTbmFwc2hvdCh0aGlzKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NhbGFyTm9kZS5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhdGggPSAodGhpcy5pc0FsaXZlID8gdGhpcy5wYXRoIDogdGhpcy5wYXRoVXBvbkRlYXRoKSB8fCBcIjxyb290PlwiO1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5uYW1lICsgXCJAXCIgKyBwYXRoICsgKHRoaXMuaXNBbGl2ZSA/IFwiXCIgOiBcIiBbZGVhZF1cIik7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjYWxhck5vZGUucHJvdG90eXBlLCBcImRpZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNBbGl2ZSB8fCB0aGlzLnN0YXRlID09PSBOb2RlTGlmZUN5Y2xlLkRFVEFDSElORykgcmV0dXJuO1xuICAgICAgdGhpcy5hYm91dFRvRGllKCk7XG4gICAgICB0aGlzLmZpbmFsaXplRGVhdGgoKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NhbGFyTm9kZS5wcm90b3R5cGUsIFwiZmluYWxpemVDcmVhdGlvblwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJhc2VGaW5hbGl6ZUNyZWF0aW9uKCk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjYWxhck5vZGUucHJvdG90eXBlLCBcImFib3V0VG9EaWVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5iYXNlQWJvdXRUb0RpZSgpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2FsYXJOb2RlLnByb3RvdHlwZSwgXCJmaW5hbGl6ZURlYXRoXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYmFzZUZpbmFsaXplRGVhdGgoKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NhbGFyTm9kZS5wcm90b3R5cGUsIFwiZmlyZUhvb2tcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHRoaXMuZmlyZUludGVybmFsSG9vayhuYW1lKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gU2NhbGFyTm9kZTtcbn0oQmFzZU5vZGUpO1xuXG5TY2FsYXJOb2RlLnByb3RvdHlwZS5kaWUgPSBhY3Rpb24oU2NhbGFyTm9kZS5wcm90b3R5cGUuZGllKTtcbnZhciBuZXh0Tm9kZUlkID0gMTtcbnZhciBzbmFwc2hvdFJlYWN0aW9uT3B0aW9ucyA9IHtcbiAgb25FcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG52YXIgT2JqZWN0Tm9kZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhPYmplY3ROb2RlLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIE9iamVjdE5vZGUoY29tcGxleFR5cGUsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBsZXhUeXBlLCBwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50KSB8fCB0aGlzO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vZGVJZFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogKytuZXh0Tm9kZUlkXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImlkZW50aWZpZXJBdHRyaWJ1dGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpZGVudGlmaWVyXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTsgLy8gSWRlbnRpZmllciBpcyBhbHdheXMgbm9ybWFsaXplZCB0byBzdHJpbmcsIGV2ZW4gaWYgdGhlIGlkZW50aWZpZXIgcHJvcGVydHkgaXNuJ3RcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ1bm5vcm1hbGl6ZWRJZGVudGlmaWVyXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaWRlbnRpZmllckNhY2hlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaXNQcm90ZWN0aW9uRW5hYmxlZFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtaWRkbGV3YXJlc1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9hcHBseVBhdGNoZXNcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfYXBwbHlTbmFwc2hvdFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9hdXRvVW5ib3hcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTsgLy8gdW5ib3hpbmcgaXMgZGlzYWJsZWQgd2hlbiByZWFkaW5nIGNoaWxkIG5vZGVzXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX2lzUnVubmluZ0FjdGlvblwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gb25seSByZWxldmFudCBmb3Igcm9vdFxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9oYXNTbmFwc2hvdFJlYWN0aW9uXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfb2JzZXJ2YWJsZUluc3RhbmNlU3RhdGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IDBcbiAgICAgIC8qIFVOSU5JVElBTElaRUQgKi9cblxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfY2hpbGROb2Rlc1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9pbml0aWFsU25hcHNob3RcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfY2FjaGVkSW5pdGlhbFNuYXBzaG90XCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX2NhY2hlZEluaXRpYWxTbmFwc2hvdENyZWF0ZWRcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9zbmFwc2hvdENvbXB1dGVkXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX3NuYXBzaG90VXBvbkRlYXRoXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTsgLy8gI3JlZ2lvbiBpbnRlcm5hbCBldmVudCBoYW5kbGluZ1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9pbnRlcm5hbEV2ZW50c1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG4gICAgX3RoaXMuX3NuYXBzaG90Q29tcHV0ZWQgPSBjb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnJlZXplKF90aGlzLmdldFNuYXBzaG90KCkpO1xuICAgIH0pO1xuICAgIF90aGlzLnVuYm94ID0gX3RoaXMudW5ib3guYmluZChfdGhpcyk7XG4gICAgX3RoaXMuX2luaXRpYWxTbmFwc2hvdCA9IGZyZWV6ZShpbml0aWFsVmFsdWUpO1xuICAgIF90aGlzLmlkZW50aWZpZXJBdHRyaWJ1dGUgPSBjb21wbGV4VHlwZS5pZGVudGlmaWVyQXR0cmlidXRlO1xuXG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIF90aGlzLmlkZW50aWZpZXJDYWNoZSA9IG5ldyBJZGVudGlmaWVyQ2FjaGUoKTtcbiAgICB9XG5cbiAgICBfdGhpcy5fY2hpbGROb2RlcyA9IGNvbXBsZXhUeXBlLmluaXRpYWxpemVDaGlsZE5vZGVzKF90aGlzLCBfdGhpcy5faW5pdGlhbFNuYXBzaG90KTsgLy8gaWRlbnRpZmllciBjYW4gbm90IGJlIGNoYW5nZWQgZHVyaW5nIGxpZmVjeWNsZSBvZiBhIG5vZGVcbiAgICAvLyBzbyB3ZSBzYWZlbHkgY2FuIHJlYWQgaXQgZnJvbSBpbml0aWFsIHNuYXBzaG90XG5cbiAgICBfdGhpcy5pZGVudGlmaWVyID0gbnVsbDtcbiAgICBfdGhpcy51bm5vcm1hbGl6ZWRJZGVudGlmaWVyID0gbnVsbDtcblxuICAgIGlmIChfdGhpcy5pZGVudGlmaWVyQXR0cmlidXRlICYmIF90aGlzLl9pbml0aWFsU25hcHNob3QpIHtcbiAgICAgIHZhciBpZCA9IF90aGlzLl9pbml0aWFsU25hcHNob3RbX3RoaXMuaWRlbnRpZmllckF0dHJpYnV0ZV07XG5cbiAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHRyeSB3aXRoIHRoZSBhY3R1YWwgbm9kZSBpZiBub3QgKGZvciBvcHRpb25hbCBpZGVudGlmaWVycylcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IF90aGlzLl9jaGlsZE5vZGVzW190aGlzLmlkZW50aWZpZXJBdHRyaWJ1dGVdO1xuXG4gICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICBpZCA9IGNoaWxkTm9kZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGlkICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBpZCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aHJvdyBmYWlsJDEoXCJJbnN0YW5jZSBpZGVudGlmaWVyICdcIiArIF90aGlzLmlkZW50aWZpZXJBdHRyaWJ1dGUgKyBcIicgZm9yIHR5cGUgJ1wiICsgX3RoaXMudHlwZS5uYW1lICsgXCInIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBudW1iZXJcIik7XG4gICAgICB9IC8vIG5vcm1hbGl6ZSBpbnRlcm5hbCBpZGVudGlmaWVyIHRvIHN0cmluZ1xuXG5cbiAgICAgIF90aGlzLmlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKGlkKTtcbiAgICAgIF90aGlzLnVubm9ybWFsaXplZElkZW50aWZpZXIgPSBpZDtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgX3RoaXMuaWRlbnRpZmllckNhY2hlLmFkZE5vZGVUb0NhY2hlKF90aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50LnJvb3QuaWRlbnRpZmllckNhY2hlLmFkZE5vZGVUb0NhY2hlKF90aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiYXBwbHlQYXRjaGVzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwYXRjaGVzKSB7XG4gICAgICB0aGlzLmNyZWF0ZU9ic2VydmFibGVJbnN0YW5jZUlmTmVlZGVkKCk7XG5cbiAgICAgIHRoaXMuX2FwcGx5UGF0Y2hlcyhwYXRjaGVzKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiYXBwbHlTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoc25hcHNob3QpIHtcbiAgICAgIHRoaXMuY3JlYXRlT2JzZXJ2YWJsZUluc3RhbmNlSWZOZWVkZWQoKTtcblxuICAgICAgdGhpcy5fYXBwbHlTbmFwc2hvdChzbmFwc2hvdCk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImNyZWF0ZU9ic2VydmFibGVJbnN0YW5jZUlmTmVlZGVkXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9vYnNlcnZhYmxlSW5zdGFuY2VTdGF0ZSA9PT0gMFxuICAgICAgLyogVU5JTklUSUFMSVpFRCAqL1xuICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVPYnNlcnZhYmxlSW5zdGFuY2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJjcmVhdGVPYnNlcnZhYmxlSW5zdGFuY2VcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGVfMSwgX2E7XG5cbiAgICAgIGlmIChkZXZNb2RlKCkpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IE5vZGVMaWZlQ3ljbGUuSU5JVElBTElaSU5HKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJhc3NlcnRpb24gZmFpbGVkOiB0aGUgY3JlYXRpb24gb2YgdGhlIG9ic2VydmFibGUgaW5zdGFuY2UgbXVzdCBiZSBkb25lIG9uIHRoZSBpbml0aWFsaXppbmcgcGhhc2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fb2JzZXJ2YWJsZUluc3RhbmNlU3RhdGUgPSAxXG4gICAgICAvKiBDUkVBVElORyAqL1xuICAgICAgOyAvLyBtYWtlIHN1cmUgdGhlIHBhcmVudCBjaGFpbiBpcyBjcmVhdGVkIGFzIHdlbGxcbiAgICAgIC8vIGFycmF5IHdpdGggcGFyZW50IGNoYWluIGZyb20gcGFyZW50IHRvIGNoaWxkXG5cbiAgICAgIHZhciBwYXJlbnRDaGFpbiA9IFtdO1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50OyAvLyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyB3ZSBuZXZlciBnbyBiYWNrIGZ1cnRoZXIgdGhhbiB0aGUgbW9zdCBkaXJlY3RcbiAgICAgIC8vIHVuaW5pdGlhbGl6ZWQgcGFyZW50XG4gICAgICAvLyB0aGlzIGlzIGRvbmUgdG8gYXZvaWQgdHJhdmVyc2luZyB0aGUgd2hvbGUgdHJlZSB0byB0aGUgcm9vdCB3aGVuIHVzaW5nXG4gICAgICAvLyB0aGUgc2FtZSByZWZlcmVuY2UgYWdhaW5cblxuICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuX29ic2VydmFibGVJbnN0YW5jZVN0YXRlID09PSAwXG4gICAgICAvKiBVTklOSVRJQUxJWkVEICovXG4gICAgICApIHtcbiAgICAgICAgcGFyZW50Q2hhaW4udW5zaGlmdChwYXJlbnQpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSB1bmluaXRpYWxpemVkIHBhcmVudCBjaGFpbiBmcm9tIHBhcmVudCB0byBjaGlsZFxuICAgICAgICBmb3IgKHZhciBwYXJlbnRDaGFpbl8xID0gX192YWx1ZXMocGFyZW50Q2hhaW4pLCBwYXJlbnRDaGFpbl8xXzEgPSBwYXJlbnRDaGFpbl8xLm5leHQoKTsgIXBhcmVudENoYWluXzFfMS5kb25lOyBwYXJlbnRDaGFpbl8xXzEgPSBwYXJlbnRDaGFpbl8xLm5leHQoKSkge1xuICAgICAgICAgIHZhciBwID0gcGFyZW50Q2hhaW5fMV8xLnZhbHVlO1xuICAgICAgICAgIHAuY3JlYXRlT2JzZXJ2YWJsZUluc3RhbmNlSWZOZWVkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgZV8xID0ge1xuICAgICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAocGFyZW50Q2hhaW5fMV8xICYmICFwYXJlbnRDaGFpbl8xXzEuZG9uZSAmJiAoX2EgPSBwYXJlbnRDaGFpbl8xLnJldHVybikpIF9hLmNhbGwocGFyZW50Q2hhaW5fMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnN0b3JlZFZhbHVlID0gdHlwZS5jcmVhdGVOZXdJbnN0YW5jZSh0aGlzLl9jaGlsZE5vZGVzKTtcbiAgICAgICAgdGhpcy5wcmVib290KCk7XG4gICAgICAgIHRoaXMuX2lzUnVubmluZ0FjdGlvbiA9IHRydWU7XG4gICAgICAgIHR5cGUuZmluYWxpemVOZXdJbnN0YW5jZSh0aGlzLCB0aGlzLnN0b3JlZFZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gc2hvcnQtY3V0IHRvIGRpZSB0aGUgaW5zdGFuY2UsIHRvIGF2b2lkIHRoZSBzbmFwc2hvdCBjb21wdXRlZCBzdGFydGluZyB0byB0aHJvdy4uLlxuICAgICAgICB0aGlzLnN0YXRlID0gTm9kZUxpZmVDeWNsZS5ERUFEO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nQWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29ic2VydmFibGVJbnN0YW5jZVN0YXRlID0gMlxuICAgICAgLyogQ1JFQVRFRCAqL1xuICAgICAgO1xuXG4gICAgICB0aGlzLl9zbmFwc2hvdENvbXB1dGVkLnRyYWNrQW5kQ29tcHV0ZSgpO1xuXG4gICAgICBpZiAodGhpcy5pc1Jvb3QpIHRoaXMuX2FkZFNuYXBzaG90UmVhY3Rpb24oKTtcbiAgICAgIHRoaXMuX2NoaWxkTm9kZXMgPSBFTVBUWV9PQkpFQ1Q7XG4gICAgICB0aGlzLnN0YXRlID0gTm9kZUxpZmVDeWNsZS5DUkVBVEVEO1xuICAgICAgdGhpcy5maXJlSG9vayhIb29rLmFmdGVyQ3JlYXRlKTtcbiAgICAgIHRoaXMuZmluYWxpemVDcmVhdGlvbigpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJyb290XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgIHJldHVybiBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IHRoaXM7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJjbGVhclBhcmVudFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm47IC8vIGRldGFjaCBpZiBhdHRhY2hlZFxuXG4gICAgICB0aGlzLmZpcmVIb29rKEhvb2suYmVmb3JlRGV0YWNoKTtcbiAgICAgIHZhciBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBOb2RlTGlmZUN5Y2xlLkRFVEFDSElORztcbiAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgdmFyIG5ld0VudiA9IHJvb3QuZW52aXJvbm1lbnQ7XG4gICAgICB2YXIgbmV3SWRDYWNoZSA9IHJvb3QuaWRlbnRpZmllckNhY2hlLnNwbGl0Q2FjaGUodGhpcyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuc3VicGF0aCk7XG4gICAgICAgIHRoaXMuYmFzZVNldFBhcmVudChudWxsLCBcIlwiKTtcbiAgICAgICAgdGhpcy5lbnZpcm9ubWVudCA9IG5ld0VudjtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyQ2FjaGUgPSBuZXdJZENhY2hlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHByZXZpb3VzU3RhdGU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcInNldFBhcmVudFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobmV3UGFyZW50LCBzdWJwYXRoKSB7XG4gICAgICB2YXIgcGFyZW50Q2hhbmdlZCA9IG5ld1BhcmVudCAhPT0gdGhpcy5wYXJlbnQ7XG4gICAgICB2YXIgc3VicGF0aENoYW5nZWQgPSBzdWJwYXRoICE9PSB0aGlzLnN1YnBhdGg7XG5cbiAgICAgIGlmICghcGFyZW50Q2hhbmdlZCAmJiAhc3VicGF0aENoYW5nZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgICAgIGlmICghc3VicGF0aCkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgdGhyb3cgZmFpbCQxKFwiYXNzZXJ0aW9uIGZhaWxlZDogc3VicGF0aCBleHBlY3RlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV3UGFyZW50KSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJhc3NlcnRpb24gZmFpbGVkOiBuZXcgcGFyZW50IGV4cGVjdGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHBhcmVudENoYW5nZWQpIHtcbiAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJBIG5vZGUgY2Fubm90IGV4aXN0cyB0d2ljZSBpbiB0aGUgc3RhdGUgdHJlZS4gRmFpbGVkIHRvIGFkZCBcIiArIHRoaXMgKyBcIiB0byBwYXRoICdcIiArIG5ld1BhcmVudC5wYXRoICsgXCIvXCIgKyBzdWJwYXRoICsgXCInLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQgJiYgbmV3UGFyZW50LnJvb3QgPT09IHRoaXMpIHtcbiAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJBIHN0YXRlIHRyZWUgaXMgbm90IGFsbG93ZWQgdG8gY29udGFpbiBpdHNlbGYuIENhbm5vdCBhc3NpZ24gXCIgKyB0aGlzICsgXCIgdG8gcGF0aCAnXCIgKyBuZXdQYXJlbnQucGF0aCArIFwiL1wiICsgc3VicGF0aCArIFwiJ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQgJiYgISF0aGlzLmVudmlyb25tZW50ICYmIHRoaXMuZW52aXJvbm1lbnQgIT09IG5ld1BhcmVudC5yb290LmVudmlyb25tZW50KSB7XG4gICAgICAgICAgdGhyb3cgZmFpbCQxKFwiQSBzdGF0ZSB0cmVlIGNhbm5vdCBiZSBtYWRlIHBhcnQgb2YgYW5vdGhlciBzdGF0ZSB0cmVlIGFzIGxvbmcgYXMgdGhlaXIgZW52aXJvbm1lbnRzIGFyZSBkaWZmZXJlbnQuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnRDaGFuZ2VkKSB7XG4gICAgICAgIC8vIGF0dGFjaCB0byBuZXcgcGFyZW50XG4gICAgICAgIHRoaXMuZW52aXJvbm1lbnQgPSB1bmRlZmluZWQ7IC8vIHdpbGwgdXNlIHJvb3Qnc1xuXG4gICAgICAgIG5ld1BhcmVudC5yb290LmlkZW50aWZpZXJDYWNoZS5tZXJnZUNhY2hlKHRoaXMpO1xuICAgICAgICB0aGlzLmJhc2VTZXRQYXJlbnQobmV3UGFyZW50LCBzdWJwYXRoKTtcbiAgICAgICAgdGhpcy5maXJlSG9vayhIb29rLmFmdGVyQXR0YWNoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VicGF0aENoYW5nZWQpIHtcbiAgICAgICAgLy8gbW92aW5nIHRvIGEgbmV3IHN1YnBhdGggb24gdGhlIHNhbWUgcGFyZW50XG4gICAgICAgIHRoaXMuYmFzZVNldFBhcmVudCh0aGlzLnBhcmVudCwgc3VicGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImZpcmVIb29rXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmZpcmVJbnRlcm5hbEhvb2sobmFtZSk7XG4gICAgICB2YXIgZm4gPSB0aGlzLnN0b3JlZFZhbHVlICYmIHR5cGVvZiB0aGlzLnN0b3JlZFZhbHVlID09PSBcIm9iamVjdFwiICYmIHRoaXMuc3RvcmVkVmFsdWVbbmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyB3ZSBjaGVjayBmb3IgaXQgdG8gYWxsb3cgb2xkIG1vYnggcGVlciBkZXBlbmRlbmNpZXMgdGhhdCBkb24ndCBoYXZlIHRoZSBtZXRob2QgdG8gd29yayAoZXZlbiB3aGVuIHN0aWxsIGJ1Z2dlZClcbiAgICAgICAgaWYgKF9hbGxvd1N0YXRlQ2hhbmdlc0luc2lkZUNvbXB1dGVkKSB7XG4gICAgICAgICAgX2FsbG93U3RhdGVDaGFuZ2VzSW5zaWRlQ29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm4uYXBwbHkoX3RoaXMuc3RvcmVkVmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZuLmFwcGx5KHRoaXMuc3RvcmVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcInNuYXBzaG90XCIsIHtcbiAgICAvLyBhZHZhbnRhZ2Ugb2YgdXNpbmcgY29tcHV0ZWQgZm9yIGEgc25hcHNob3QgaXMgdGhhdCBuaWNlbHkgcmVzcGVjdHMgdHJhbnNhY3Rpb25zIGV0Yy5cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zbmFwc2hvdENvbXB1dGVkLmdldCgpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pOyAvLyBOT1RFOiB3ZSB1c2UgdGhpcyBtZXRob2QgdG8gZ2V0IHNuYXBzaG90IHdpdGhvdXQgY3JlYXRpbmcgQGNvbXB1dGVkIG92ZXJoZWFkXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImdldFNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5pc0FsaXZlKSByZXR1cm4gdGhpcy5fc25hcHNob3RVcG9uRGVhdGg7XG4gICAgICByZXR1cm4gdGhpcy5fb2JzZXJ2YWJsZUluc3RhbmNlU3RhdGUgPT09IDJcbiAgICAgIC8qIENSRUFURUQgKi9cbiAgICAgID8gdGhpcy5fZ2V0QWN0dWFsU25hcHNob3QoKSA6IHRoaXMuX2dldENhY2hlZEluaXRpYWxTbmFwc2hvdCgpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJfZ2V0QWN0dWFsU25hcHNob3RcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5nZXRTbmFwc2hvdCh0aGlzKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiX2dldENhY2hlZEluaXRpYWxTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX2NhY2hlZEluaXRpYWxTbmFwc2hvdENyZWF0ZWQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5fY2hpbGROb2RlcztcbiAgICAgICAgdmFyIHNuYXBzaG90ID0gdGhpcy5faW5pdGlhbFNuYXBzaG90O1xuICAgICAgICB0aGlzLl9jYWNoZWRJbml0aWFsU25hcHNob3QgPSB0eXBlLnByb2Nlc3NJbml0aWFsU25hcHNob3QoY2hpbGROb2Rlcywgc25hcHNob3QpO1xuICAgICAgICB0aGlzLl9jYWNoZWRJbml0aWFsU25hcHNob3RDcmVhdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZEluaXRpYWxTbmFwc2hvdDtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiaXNSdW5uaW5nQWN0aW9uXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1J1bm5pbmdBY3Rpb24pIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMuaXNSb290KSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuaXNSdW5uaW5nQWN0aW9uKCk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImFzc2VydEFsaXZlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB2YXIgbGl2ZWxpbmVzc0NoZWNraW5nID0gZ2V0TGl2ZWxpbmVzc0NoZWNraW5nKCk7XG5cbiAgICAgIGlmICghdGhpcy5pc0FsaXZlICYmIGxpdmVsaW5lc3NDaGVja2luZyAhPT0gXCJpZ25vcmVcIikge1xuICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9nZXRBc3NlcnRBbGl2ZUVycm9yKGNvbnRleHQpO1xuXG4gICAgICAgIHN3aXRjaCAobGl2ZWxpbmVzc0NoZWNraW5nKSB7XG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICB0aHJvdyBmYWlsJDEoZXJyb3IpO1xuXG4gICAgICAgICAgY2FzZSBcIndhcm5cIjpcbiAgICAgICAgICAgIHdhcm5FcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiX2dldEFzc2VydEFsaXZlRXJyb3JcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHZhciBlc2NhcGVkUGF0aCA9IHRoaXMuZ2V0RXNjYXBlZFBhdGgoZmFsc2UpIHx8IHRoaXMucGF0aFVwb25EZWF0aCB8fCBcIlwiO1xuICAgICAgdmFyIHN1YnBhdGggPSBjb250ZXh0LnN1YnBhdGggJiYgZXNjYXBlSnNvblBhdGgoY29udGV4dC5zdWJwYXRoKSB8fCBcIlwiO1xuICAgICAgdmFyIGFjdGlvbkNvbnRleHQgPSBjb250ZXh0LmFjdGlvbkNvbnRleHQgfHwgZ2V0Q3VycmVudEFjdGlvbkNvbnRleHQoKTsgLy8gdHJ5IHRvIHVzZSBhIHJlYWwgYWN0aW9uIGNvbnRleHQgaWYgcG9zc2libGUgc2luY2UgaXQgaW5jbHVkZXMgdGhlIGFjdGlvbiBuYW1lXG5cbiAgICAgIGlmIChhY3Rpb25Db250ZXh0ICYmIGFjdGlvbkNvbnRleHQudHlwZSAhPT0gXCJhY3Rpb25cIiAmJiBhY3Rpb25Db250ZXh0LnBhcmVudEFjdGlvbkV2ZW50KSB7XG4gICAgICAgIGFjdGlvbkNvbnRleHQgPSBhY3Rpb25Db250ZXh0LnBhcmVudEFjdGlvbkV2ZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgYWN0aW9uRnVsbFBhdGggPSBcIlwiO1xuXG4gICAgICBpZiAoYWN0aW9uQ29udGV4dCAmJiBhY3Rpb25Db250ZXh0Lm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAvLyB0cnkgdG8gdXNlIHRoZSBjb250ZXh0LCBhbmQgaWYgaXQgbm90IGF2YWlsYWJsZSB1c2UgdGhlIG5vZGUgb25lXG4gICAgICAgIHZhciBhY3Rpb25QYXRoID0gYWN0aW9uQ29udGV4dCAmJiBhY3Rpb25Db250ZXh0LmNvbnRleHQgJiYgZ2V0UGF0aChhY3Rpb25Db250ZXh0LmNvbnRleHQpIHx8IGVzY2FwZWRQYXRoO1xuICAgICAgICBhY3Rpb25GdWxsUGF0aCA9IGFjdGlvblBhdGggKyBcIi5cIiArIGFjdGlvbkNvbnRleHQubmFtZSArIFwiKClcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiWW91IGFyZSB0cnlpbmcgdG8gcmVhZCBvciB3cml0ZSB0byBhbiBvYmplY3QgdGhhdCBpcyBubyBsb25nZXIgcGFydCBvZiBhIHN0YXRlIHRyZWUuIChPYmplY3QgdHlwZTogJ1wiICsgdGhpcy50eXBlLm5hbWUgKyBcIicsIFBhdGggdXBvbiBkZWF0aDogJ1wiICsgZXNjYXBlZFBhdGggKyBcIicsIFN1YnBhdGg6ICdcIiArIHN1YnBhdGggKyBcIicsIEFjdGlvbjogJ1wiICsgYWN0aW9uRnVsbFBhdGggKyBcIicpLiBFaXRoZXIgZGV0YWNoIG5vZGVzIGZpcnN0LCBvciBkb24ndCB1c2Ugb2JqZWN0cyBhZnRlciByZW1vdmluZyAvIHJlcGxhY2luZyB0aGVtIGluIHRoZSB0cmVlLlwiO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJnZXRDaGlsZE5vZGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHN1YnBhdGgpIHtcbiAgICAgIHRoaXMuYXNzZXJ0QWxpdmUoe1xuICAgICAgICBzdWJwYXRoOiBzdWJwYXRoXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2F1dG9VbmJveCA9IGZhbHNlO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JzZXJ2YWJsZUluc3RhbmNlU3RhdGUgPT09IDJcbiAgICAgICAgLyogQ1JFQVRFRCAqL1xuICAgICAgICA/IHRoaXMudHlwZS5nZXRDaGlsZE5vZGUodGhpcywgc3VicGF0aCkgOiB0aGlzLl9jaGlsZE5vZGVzW3N1YnBhdGhdO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5fYXV0b1VuYm94ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiZ2V0Q2hpbGRyZW5cIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5hc3NlcnRBbGl2ZShFTVBUWV9PQkpFQ1QpO1xuICAgICAgdGhpcy5fYXV0b1VuYm94ID0gZmFsc2U7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYnNlcnZhYmxlSW5zdGFuY2VTdGF0ZSA9PT0gMlxuICAgICAgICAvKiBDUkVBVEVEICovXG4gICAgICAgID8gdGhpcy50eXBlLmdldENoaWxkcmVuKHRoaXMpIDogY29udmVydENoaWxkTm9kZXNUb0FycmF5KHRoaXMuX2NoaWxkTm9kZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5fYXV0b1VuYm94ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiZ2V0Q2hpbGRUeXBlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuZ2V0Q2hpbGRUeXBlKHByb3BlcnR5TmFtZSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImlzUHJvdGVjdGVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3QuaXNQcm90ZWN0aW9uRW5hYmxlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImFzc2VydFdyaXRhYmxlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB0aGlzLmFzc2VydEFsaXZlKGNvbnRleHQpO1xuXG4gICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nQWN0aW9uKCkgJiYgdGhpcy5pc1Byb3RlY3RlZCkge1xuICAgICAgICB0aHJvdyBmYWlsJDEoXCJDYW5ub3QgbW9kaWZ5ICdcIiArIHRoaXMgKyBcIicsIHRoZSBvYmplY3QgaXMgcHJvdGVjdGVkIGFuZCBjYW4gb25seSBiZSBtb2RpZmllZCBieSB1c2luZyBhbiBhY3Rpb24uXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJyZW1vdmVDaGlsZFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoc3VicGF0aCkge1xuICAgICAgdGhpcy50eXBlLnJlbW92ZUNoaWxkKHRoaXMsIHN1YnBhdGgpO1xuICAgIH1cbiAgfSk7IC8vIGJvdW5kIG9uIHRoZSBjb25zdHJ1Y3RvclxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJ1bmJveFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICBpZiAoIWNoaWxkTm9kZSkgcmV0dXJuIGNoaWxkTm9kZTtcbiAgICAgIHRoaXMuYXNzZXJ0QWxpdmUoe1xuICAgICAgICBzdWJwYXRoOiBjaGlsZE5vZGUuc3VicGF0aCB8fCBjaGlsZE5vZGUuc3VicGF0aFVwb25EZWF0aFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fYXV0b1VuYm94ID8gY2hpbGROb2RlLnZhbHVlIDogY2hpbGROb2RlO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJ0b1N0cmluZ1wiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGF0aCA9ICh0aGlzLmlzQWxpdmUgPyB0aGlzLnBhdGggOiB0aGlzLnBhdGhVcG9uRGVhdGgpIHx8IFwiPHJvb3Q+XCI7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IHRoaXMuaWRlbnRpZmllciA/IFwiKGlkOiBcIiArIHRoaXMuaWRlbnRpZmllciArIFwiKVwiIDogXCJcIjtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUubmFtZSArIFwiQFwiICsgcGF0aCArIGlkZW50aWZpZXIgKyAodGhpcy5pc0FsaXZlID8gXCJcIiA6IFwiIFtkZWFkXVwiKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiZmluYWxpemVDcmVhdGlvblwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmJhc2VGaW5hbGl6ZUNyZWF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKF90aGlzLmdldENoaWxkcmVuKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIGNoaWxkLmZpbmFsaXplQ3JlYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVfMl8xKSB7XG4gICAgICAgICAgZV8yID0ge1xuICAgICAgICAgICAgZXJyb3I6IGVfMl8xXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuZmlyZUludGVybmFsSG9vayhIb29rLmFmdGVyQ3JlYXRpb25GaW5hbGl6YXRpb24pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImRldGFjaFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNBbGl2ZSkgdGhyb3cgZmFpbCQxKFwiRXJyb3Igd2hpbGUgZGV0YWNoaW5nLCBub2RlIGlzIG5vdCBhbGl2ZS5cIik7XG4gICAgICB0aGlzLmNsZWFyUGFyZW50KCk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcInByZWJvb3RcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5fYXBwbHlQYXRjaGVzID0gY3JlYXRlQWN0aW9uSW52b2tlcih0aGlzLnN0b3JlZFZhbHVlLCBcIkBBUFBMWV9QQVRDSEVTXCIsIGZ1bmN0aW9uIChwYXRjaGVzKSB7XG4gICAgICAgIHBhdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAocGF0Y2gpIHtcbiAgICAgICAgICBpZiAoIXBhdGNoLnBhdGgpIHtcbiAgICAgICAgICAgIHNlbGYudHlwZS5hcHBseVNuYXBzaG90KHNlbGYsIHBhdGNoLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGFydHMgPSBzcGxpdEpzb25QYXRoKHBhdGNoLnBhdGgpO1xuICAgICAgICAgIHZhciBub2RlID0gcmVzb2x2ZU5vZGVCeVBhdGhQYXJ0cyhzZWxmLCBwYXJ0cy5zbGljZSgwLCAtMSkpO1xuICAgICAgICAgIG5vZGUuYXBwbHlQYXRjaExvY2FsbHkocGFydHNbcGFydHMubGVuZ3RoIC0gMV0sIHBhdGNoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2FwcGx5U25hcHNob3QgPSBjcmVhdGVBY3Rpb25JbnZva2VyKHRoaXMuc3RvcmVkVmFsdWUsIFwiQEFQUExZX1NOQVBTSE9UXCIsIGZ1bmN0aW9uIChzbmFwc2hvdCkge1xuICAgICAgICAvLyBpZiB0aGUgc25hcHNob3QgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgb25lLCBhdm9pZCBwZXJmb3JtaW5nIGEgcmVjb25jaWxlXG4gICAgICAgIGlmIChzbmFwc2hvdCA9PT0gc2VsZi5zbmFwc2hvdCkgcmV0dXJuOyAvLyBlbHNlLCBhcHBseSBpdCBieSBjYWxsaW5nIHRoZSB0eXBlIGxvZ2ljXG5cbiAgICAgICAgcmV0dXJuIHNlbGYudHlwZS5hcHBseVNuYXBzaG90KHNlbGYsIHNuYXBzaG90KTtcbiAgICAgIH0pO1xuICAgICAgYWRkSGlkZGVuRmluYWxQcm9wKHRoaXMuc3RvcmVkVmFsdWUsIFwiJHRyZWVub2RlXCIsIHRoaXMpO1xuICAgICAgYWRkSGlkZGVuRmluYWxQcm9wKHRoaXMuc3RvcmVkVmFsdWUsIFwidG9KU09OXCIsIHRvSlNPTik7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImRpZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNBbGl2ZSB8fCB0aGlzLnN0YXRlID09PSBOb2RlTGlmZUN5Y2xlLkRFVEFDSElORykgcmV0dXJuO1xuICAgICAgdGhpcy5hYm91dFRvRGllKCk7XG4gICAgICB0aGlzLmZpbmFsaXplRGVhdGgoKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiYWJvdXRUb0RpZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5fb2JzZXJ2YWJsZUluc3RhbmNlU3RhdGUgPT09IDBcbiAgICAgIC8qIFVOSU5JVElBTElaRUQgKi9cbiAgICAgICkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICB0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLmFib3V0VG9EaWUoKTtcbiAgICAgIH0pOyAvLyBiZWZvcmVEZXN0cm95IHNob3VsZCBydW4gYmVmb3JlIHRoZSBkaXNwb3NlcnMgc2luY2UgZWxzZSB3ZSBjb3VsZCBlbmQgdXAgaW4gYSBzaXR1YXRpb24gd2hlcmVcbiAgICAgIC8vIGEgZGlzcG9zZXIgYWRkZWQgd2l0aCBhZGREaXNwb3NlciBhdCB0aGlzIHN0YWdlIChiZWZvcmVEZXN0cm95KSBpcyBhY3R1YWxseSBuZXZlciByZWxlYXNlZFxuXG4gICAgICB0aGlzLmJhc2VBYm91dFRvRGllKCk7XG5cbiAgICAgIHRoaXMuX2ludGVybmFsRXZlbnRzRW1pdChcImRpc3Bvc2VcIlxuICAgICAgLyogRGlzcG9zZSAqL1xuICAgICAgKTtcblxuICAgICAgdGhpcy5faW50ZXJuYWxFdmVudHNDbGVhcihcImRpc3Bvc2VcIlxuICAgICAgLyogRGlzcG9zZSAqL1xuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiZmluYWxpemVEZWF0aFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpbnZhcmlhbnQ6IG5vdCBjYWxsZWQgZGlyZWN0bHkgYnV0IGZyb20gXCJkaWVcIlxuICAgICAgdGhpcy5nZXRDaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS5maW5hbGl6ZURlYXRoKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucm9vdC5pZGVudGlmaWVyQ2FjaGUubm90aWZ5RGllZCh0aGlzKTsgLy8gXCJraWxsXCIgdGhlIGNvbXB1dGVkIHByb3AgYW5kIGp1c3Qgc3RvcmUgdGhlIGxhc3Qgc25hcHNob3RcblxuICAgICAgdmFyIHNuYXBzaG90ID0gdGhpcy5zbmFwc2hvdDtcbiAgICAgIHRoaXMuX3NuYXBzaG90VXBvbkRlYXRoID0gc25hcHNob3Q7XG5cbiAgICAgIHRoaXMuX2ludGVybmFsRXZlbnRzQ2xlYXJBbGwoKTtcblxuICAgICAgdGhpcy5iYXNlRmluYWxpemVEZWF0aCgpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJvblNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvbkNoYW5nZSkge1xuICAgICAgdGhpcy5fYWRkU25hcHNob3RSZWFjdGlvbigpO1xuXG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxFdmVudHNSZWdpc3RlcihcInNuYXBzaG90XCJcbiAgICAgIC8qIFNuYXBzaG90ICovXG4gICAgICAsIG9uQ2hhbmdlKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiZW1pdFNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChzbmFwc2hvdCkge1xuICAgICAgdGhpcy5faW50ZXJuYWxFdmVudHNFbWl0KFwic25hcHNob3RcIlxuICAgICAgLyogU25hcHNob3QgKi9cbiAgICAgICwgc25hcHNob3QpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJvblBhdGNoXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxFdmVudHNSZWdpc3RlcihcInBhdGNoXCJcbiAgICAgIC8qIFBhdGNoICovXG4gICAgICAsIGhhbmRsZXIpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJlbWl0UGF0Y2hcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGJhc2VQYXRjaCwgc291cmNlKSB7XG4gICAgICBpZiAodGhpcy5faW50ZXJuYWxFdmVudHNIYXNTdWJzY3JpYmVycyhcInBhdGNoXCJcbiAgICAgIC8qIFBhdGNoICovXG4gICAgICApKSB7XG4gICAgICAgIHZhciBsb2NhbGl6ZWRQYXRjaCA9IGV4dGVuZCh7fSwgYmFzZVBhdGNoLCB7XG4gICAgICAgICAgcGF0aDogc291cmNlLnBhdGguc3Vic3RyKHRoaXMucGF0aC5sZW5ndGgpICsgXCIvXCIgKyBiYXNlUGF0Y2gucGF0aCAvLyBjYWxjdWxhdGUgdGhlIHJlbGF0aXZlIHBhdGggb2YgdGhlIHBhdGNoXG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHNwbGl0UGF0Y2gobG9jYWxpemVkUGF0Y2gpLCAyKSxcbiAgICAgICAgICAgIHBhdGNoID0gX2FbMF0sXG4gICAgICAgICAgICByZXZlcnNlUGF0Y2ggPSBfYVsxXTtcblxuICAgICAgICB0aGlzLl9pbnRlcm5hbEV2ZW50c0VtaXQoXCJwYXRjaFwiXG4gICAgICAgIC8qIFBhdGNoICovXG4gICAgICAgICwgcGF0Y2gsIHJldmVyc2VQYXRjaCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBhcmVudCkgdGhpcy5wYXJlbnQuZW1pdFBhdGNoKGJhc2VQYXRjaCwgc291cmNlKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiaGFzRGlzcG9zZXJcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGRpc3Bvc2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxFdmVudHNIYXMoXCJkaXNwb3NlXCJcbiAgICAgIC8qIERpc3Bvc2UgKi9cbiAgICAgICwgZGlzcG9zZXIpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJhZGREaXNwb3NlclwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoZGlzcG9zZXIpIHtcbiAgICAgIGlmICghdGhpcy5oYXNEaXNwb3NlcihkaXNwb3NlcikpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxFdmVudHNSZWdpc3RlcihcImRpc3Bvc2VcIlxuICAgICAgICAvKiBEaXNwb3NlICovXG4gICAgICAgICwgZGlzcG9zZXIsIHRydWUpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZmFpbCQxKFwiY2Fubm90IGFkZCBhIGRpc3Bvc2VyIHdoZW4gaXQgaXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBleGVjdXRpb25cIik7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcInJlbW92ZURpc3Bvc2VyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChkaXNwb3Nlcikge1xuICAgICAgaWYgKCF0aGlzLl9pbnRlcm5hbEV2ZW50c0hhcyhcImRpc3Bvc2VcIlxuICAgICAgLyogRGlzcG9zZSAqL1xuICAgICAgLCBkaXNwb3NlcikpIHtcbiAgICAgICAgdGhyb3cgZmFpbCQxKFwiY2Fubm90IHJlbW92ZSBhIGRpc3Bvc2VyIHdoaWNoIHdhcyBuZXZlciByZWdpc3RlcmVkIGZvciBleGVjdXRpb25cIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2ludGVybmFsRXZlbnRzVW5yZWdpc3RlcihcImRpc3Bvc2VcIlxuICAgICAgLyogRGlzcG9zZSAqL1xuICAgICAgLCBkaXNwb3Nlcik7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcInJlbW92ZU1pZGRsZXdhcmVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgIGlmICh0aGlzLm1pZGRsZXdhcmVzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubWlkZGxld2FyZXMuaW5kZXhPZihtaWRkbGV3YXJlKTtcblxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIHRoaXMubWlkZGxld2FyZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJhZGRNaWRkbGVXYXJlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChoYW5kbGVyLCBpbmNsdWRlSG9va3MpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChpbmNsdWRlSG9va3MgPT09IHZvaWQgMCkge1xuICAgICAgICBpbmNsdWRlSG9va3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWlkZGxld2FyZSA9IHtcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgaW5jbHVkZUhvb2tzOiBpbmNsdWRlSG9va3NcbiAgICAgIH07XG4gICAgICBpZiAoIXRoaXMubWlkZGxld2FyZXMpIHRoaXMubWlkZGxld2FyZXMgPSBbbWlkZGxld2FyZV07ZWxzZSB0aGlzLm1pZGRsZXdhcmVzLnB1c2gobWlkZGxld2FyZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW1vdmVNaWRkbGV3YXJlKG1pZGRsZXdhcmUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiYXBwbHlQYXRjaExvY2FsbHlcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHN1YnBhdGgsIHBhdGNoKSB7XG4gICAgICB0aGlzLmFzc2VydFdyaXRhYmxlKHtcbiAgICAgICAgc3VicGF0aDogc3VicGF0aFxuICAgICAgfSk7XG4gICAgICB0aGlzLmNyZWF0ZU9ic2VydmFibGVJbnN0YW5jZUlmTmVlZGVkKCk7XG4gICAgICB0aGlzLnR5cGUuYXBwbHlQYXRjaExvY2FsbHkodGhpcywgc3VicGF0aCwgcGF0Y2gpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJfYWRkU25hcHNob3RSZWFjdGlvblwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuX2hhc1NuYXBzaG90UmVhY3Rpb24pIHtcbiAgICAgICAgdmFyIHNuYXBzaG90RGlzcG9zZXIgPSByZWFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNuYXBzaG90O1xuICAgICAgICB9LCBmdW5jdGlvbiAoc25hcHNob3QpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdFNuYXBzaG90KHNuYXBzaG90KTtcbiAgICAgICAgfSwgc25hcHNob3RSZWFjdGlvbk9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFkZERpc3Bvc2VyKHNuYXBzaG90RGlzcG9zZXIpO1xuICAgICAgICB0aGlzLl9oYXNTbmFwc2hvdFJlYWN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyB3ZSBwcm94eSB0aGUgbWV0aG9kcyB0byBhdm9pZCBjcmVhdGluZyBhbiBFdmVudEhhbmRsZXJzIGluc3RhbmNlIHdoZW4gaXQgaXMgbm90IG5lZWRlZFxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJfaW50ZXJuYWxFdmVudHNIYXNTdWJzY3JpYmVyc1wiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX2ludGVybmFsRXZlbnRzICYmIHRoaXMuX2ludGVybmFsRXZlbnRzLmhhc1N1YnNjcmliZXJzKGV2ZW50KTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiX2ludGVybmFsRXZlbnRzUmVnaXN0ZXJcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGV2ZW50LCBldmVudEhhbmRsZXIsIGF0VGhlQmVnaW5uaW5nKSB7XG4gICAgICBpZiAoYXRUaGVCZWdpbm5pbmcgPT09IHZvaWQgMCkge1xuICAgICAgICBhdFRoZUJlZ2lubmluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2ludGVybmFsRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsRXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsRXZlbnRzLnJlZ2lzdGVyKGV2ZW50LCBldmVudEhhbmRsZXIsIGF0VGhlQmVnaW5uaW5nKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiX2ludGVybmFsRXZlbnRzSGFzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChldmVudCwgZXZlbnRIYW5kbGVyKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9pbnRlcm5hbEV2ZW50cyAmJiB0aGlzLl9pbnRlcm5hbEV2ZW50cy5oYXMoZXZlbnQsIGV2ZW50SGFuZGxlcik7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcIl9pbnRlcm5hbEV2ZW50c1VucmVnaXN0ZXJcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGV2ZW50LCBldmVudEhhbmRsZXIpIHtcbiAgICAgIGlmICh0aGlzLl9pbnRlcm5hbEV2ZW50cykge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbEV2ZW50cy51bnJlZ2lzdGVyKGV2ZW50LCBldmVudEhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJfaW50ZXJuYWxFdmVudHNFbWl0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIF9hO1xuXG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faW50ZXJuYWxFdmVudHMpIHtcbiAgICAgICAgKF9hID0gdGhpcy5faW50ZXJuYWxFdmVudHMpLmVtaXQuYXBwbHkoX2EsIF9fc3ByZWFkKFtldmVudF0sIGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiX2ludGVybmFsRXZlbnRzQ2xlYXJcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5faW50ZXJuYWxFdmVudHMpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxFdmVudHMuY2xlYXIoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJfaW50ZXJuYWxFdmVudHNDbGVhckFsbFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5faW50ZXJuYWxFdmVudHMpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxFdmVudHMuY2xlYXJBbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0Tm9kZTtcbn0oQmFzZU5vZGUpO1xuXG5PYmplY3ROb2RlLnByb3RvdHlwZS5jcmVhdGVPYnNlcnZhYmxlSW5zdGFuY2UgPSBhY3Rpb24oT2JqZWN0Tm9kZS5wcm90b3R5cGUuY3JlYXRlT2JzZXJ2YWJsZUluc3RhbmNlKTtcbk9iamVjdE5vZGUucHJvdG90eXBlLmRldGFjaCA9IGFjdGlvbihPYmplY3ROb2RlLnByb3RvdHlwZS5kZXRhY2gpO1xuT2JqZWN0Tm9kZS5wcm90b3R5cGUuZGllID0gYWN0aW9uKE9iamVjdE5vZGUucHJvdG90eXBlLmRpZSk7XG5cbnZhciBfYTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG52YXIgVHlwZUZsYWdzO1xuXG4oZnVuY3Rpb24gKFR5cGVGbGFncykge1xuICBUeXBlRmxhZ3NbVHlwZUZsYWdzW1wiU3RyaW5nXCJdID0gMV0gPSBcIlN0cmluZ1wiO1xuICBUeXBlRmxhZ3NbVHlwZUZsYWdzW1wiTnVtYmVyXCJdID0gMl0gPSBcIk51bWJlclwiO1xuICBUeXBlRmxhZ3NbVHlwZUZsYWdzW1wiQm9vbGVhblwiXSA9IDRdID0gXCJCb29sZWFuXCI7XG4gIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJEYXRlXCJdID0gOF0gPSBcIkRhdGVcIjtcbiAgVHlwZUZsYWdzW1R5cGVGbGFnc1tcIkxpdGVyYWxcIl0gPSAxNl0gPSBcIkxpdGVyYWxcIjtcbiAgVHlwZUZsYWdzW1R5cGVGbGFnc1tcIkFycmF5XCJdID0gMzJdID0gXCJBcnJheVwiO1xuICBUeXBlRmxhZ3NbVHlwZUZsYWdzW1wiTWFwXCJdID0gNjRdID0gXCJNYXBcIjtcbiAgVHlwZUZsYWdzW1R5cGVGbGFnc1tcIk9iamVjdFwiXSA9IDEyOF0gPSBcIk9iamVjdFwiO1xuICBUeXBlRmxhZ3NbVHlwZUZsYWdzW1wiRnJvemVuXCJdID0gMjU2XSA9IFwiRnJvemVuXCI7XG4gIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJPcHRpb25hbFwiXSA9IDUxMl0gPSBcIk9wdGlvbmFsXCI7XG4gIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJSZWZlcmVuY2VcIl0gPSAxMDI0XSA9IFwiUmVmZXJlbmNlXCI7XG4gIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJJZGVudGlmaWVyXCJdID0gMjA0OF0gPSBcIklkZW50aWZpZXJcIjtcbiAgVHlwZUZsYWdzW1R5cGVGbGFnc1tcIkxhdGVcIl0gPSA0MDk2XSA9IFwiTGF0ZVwiO1xuICBUeXBlRmxhZ3NbVHlwZUZsYWdzW1wiUmVmaW5lbWVudFwiXSA9IDgxOTJdID0gXCJSZWZpbmVtZW50XCI7XG4gIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJVbmlvblwiXSA9IDE2Mzg0XSA9IFwiVW5pb25cIjtcbiAgVHlwZUZsYWdzW1R5cGVGbGFnc1tcIk51bGxcIl0gPSAzMjc2OF0gPSBcIk51bGxcIjtcbiAgVHlwZUZsYWdzW1R5cGVGbGFnc1tcIlVuZGVmaW5lZFwiXSA9IDY1NTM2XSA9IFwiVW5kZWZpbmVkXCI7XG4gIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJJbnRlZ2VyXCJdID0gMTMxMDcyXSA9IFwiSW50ZWdlclwiO1xuICBUeXBlRmxhZ3NbVHlwZUZsYWdzW1wiQ3VzdG9tXCJdID0gMjYyMTQ0XSA9IFwiQ3VzdG9tXCI7XG4gIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJTbmFwc2hvdFByb2Nlc3NvclwiXSA9IDUyNDI4OF0gPSBcIlNuYXBzaG90UHJvY2Vzc29yXCI7XG59KShUeXBlRmxhZ3MgfHwgKFR5cGVGbGFncyA9IHt9KSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxudmFyIGNhbm5vdERldGVybWluZVN1YnR5cGUgPSBcImNhbm5vdERldGVybWluZVwiO1xuLyoqIEBoaWRkZW4gKi9cblxudmFyICR0eXBlID0gU3ltYm9sKFwiJHR5cGVcIik7XG4vKipcbiAqIEEgYmFzZSB0eXBlIHByb2R1Y2VzIGEgTVNUIG5vZGUgKE5vZGUgaW4gdGhlIHN0YXRlIHRyZWUpXG4gKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxudmFyIEJhc2VUeXBlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZVR5cGUobmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfYSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pOyAvLyB0aGVzZSBhcmUganVzdCB0byBtYWtlIGlubmVyIHR5cGVzIGF2YWlhbGFibGUgdG8gaW5oZXJpdGVkIGNsYXNzZXNcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIkNcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIlNcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIlRcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIk5cIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzVHlwZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVR5cGUucHJvdG90eXBlLCBcImNyZWF0ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoc25hcHNob3QsIGVudmlyb25tZW50KSB7XG4gICAgICB0eXBlY2hlY2tJbnRlcm5hbCh0aGlzLCBzbmFwc2hvdCk7XG4gICAgICByZXR1cm4gdGhpcy5pbnN0YW50aWF0ZShudWxsLCBcIlwiLCBlbnZpcm9ubWVudCwgc25hcHNob3QpLnZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlVHlwZS5wcm90b3R5cGUsIFwiZ2V0U25hcHNob3RcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIGFwcGx5UG9zdFByb2Nlc3MpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICB0aHJvdyBmYWlsJDEoXCJ1bmltcGxlbWVudGVkIG1ldGhvZFwiKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVR5cGUucHJvdG90eXBlLCBcImlzQXNzaWduYWJsZUZyb21cIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiB0eXBlID09PSB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlVHlwZS5wcm90b3R5cGUsIFwidmFsaWRhdGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGVTYWZlKHZhbHVlKTtcblxuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlVHlwZSA9IGdldFR5cGUodmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc0Fzc2lnbmFibGVGcm9tKHZhbHVlVHlwZSkgPyB0eXBlQ2hlY2tTdWNjZXNzKCkgOiB0eXBlQ2hlY2tGYWlsdXJlKGNvbnRleHQsIHZhbHVlKTsgLy8gaXQgaXMgdGVtcHRpbmcgdG8gY29tcGFyZSBzbmFwc2hvdHMsIGJ1dCBpbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIGFsd2F5cyBjbG9uZSBvbiBhc3NpZ25tZW50cy4uLlxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkU25hcHNob3QodmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlVHlwZS5wcm90b3R5cGUsIFwiaXNcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHRoaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZSh0aGluZywgW3tcbiAgICAgICAgcGF0aDogXCJcIixcbiAgICAgICAgdHlwZTogdGhpc1xuICAgICAgfV0pLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVR5cGUucHJvdG90eXBlLCBcIlR5cGVcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgIHRocm93IGZhaWwkMShcIkZhY3RvcnkuVHlwZSBzaG91bGQgbm90IGJlIGFjdHVhbGx5IGNhbGxlZC4gSXQgaXMganVzdCBhIFR5cGUgc2lnbmF0dXJlIHRoYXQgY2FuIGJlIHVzZWQgYXQgY29tcGlsZSB0aW1lIHdpdGggVHlwZXNjcmlwdCwgYnkgdXNpbmcgYHR5cGVvZiB0eXBlLlR5cGVgXCIpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVR5cGUucHJvdG90eXBlLCBcIlR5cGVXaXRob3V0U1ROXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICB0aHJvdyBmYWlsJDEoXCJGYWN0b3J5LlR5cGVXaXRob3V0U1ROIHNob3VsZCBub3QgYmUgYWN0dWFsbHkgY2FsbGVkLiBJdCBpcyBqdXN0IGEgVHlwZSBzaWduYXR1cmUgdGhhdCBjYW4gYmUgdXNlZCBhdCBjb21waWxlIHRpbWUgd2l0aCBUeXBlc2NyaXB0LCBieSB1c2luZyBgdHlwZW9mIHR5cGUuVHlwZVdpdGhvdXRTVE5gXCIpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVR5cGUucHJvdG90eXBlLCBcIlNuYXBzaG90VHlwZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgdGhyb3cgZmFpbCQxKFwiRmFjdG9yeS5TbmFwc2hvdFR5cGUgc2hvdWxkIG5vdCBiZSBhY3R1YWxseSBjYWxsZWQuIEl0IGlzIGp1c3QgYSBUeXBlIHNpZ25hdHVyZSB0aGF0IGNhbiBiZSB1c2VkIGF0IGNvbXBpbGUgdGltZSB3aXRoIFR5cGVzY3JpcHQsIGJ5IHVzaW5nIGB0eXBlb2YgdHlwZS5TbmFwc2hvdFR5cGVgXCIpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVR5cGUucHJvdG90eXBlLCBcIkNyZWF0aW9uVHlwZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgdGhyb3cgZmFpbCQxKFwiRmFjdG9yeS5DcmVhdGlvblR5cGUgc2hvdWxkIG5vdCBiZSBhY3R1YWxseSBjYWxsZWQuIEl0IGlzIGp1c3QgYSBUeXBlIHNpZ25hdHVyZSB0aGF0IGNhbiBiZSB1c2VkIGF0IGNvbXBpbGUgdGltZSB3aXRoIFR5cGVzY3JpcHQsIGJ5IHVzaW5nIGB0eXBlb2YgdHlwZS5DcmVhdGlvblR5cGVgXCIpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gQmFzZVR5cGU7XG59KCk7XG5cbl9hID0gJHR5cGU7XG5CYXNlVHlwZS5wcm90b3R5cGUuY3JlYXRlID0gYWN0aW9uKEJhc2VUeXBlLnByb3RvdHlwZS5jcmVhdGUpO1xuLyoqXG4gKiBBIGNvbXBsZXggdHlwZSBwcm9kdWNlcyBhIE1TVCBub2RlIChOb2RlIGluIHRoZSBzdGF0ZSB0cmVlKVxuICpcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cbnZhciBDb21wbGV4VHlwZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDb21wbGV4VHlwZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDb21wbGV4VHlwZShuYW1lKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSkgfHwgdGhpcztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpZGVudGlmaWVyQXR0cmlidXRlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGxleFR5cGUucHJvdG90eXBlLCBcImNyZWF0ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoc25hcHNob3QsIGVudmlyb25tZW50KSB7XG4gICAgICBpZiAoc25hcHNob3QgPT09IHZvaWQgMCkge1xuICAgICAgICBzbmFwc2hvdCA9IHRoaXMuZ2V0RGVmYXVsdFNuYXBzaG90KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNyZWF0ZS5jYWxsKHRoaXMsIHNuYXBzaG90LCBlbnZpcm9ubWVudCk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBsZXhUeXBlLnByb3RvdHlwZSwgXCJnZXRWYWx1ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgbm9kZS5jcmVhdGVPYnNlcnZhYmxlSW5zdGFuY2VJZk5lZWRlZCgpO1xuICAgICAgcmV0dXJuIG5vZGUuc3RvcmVkVmFsdWU7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBsZXhUeXBlLnByb3RvdHlwZSwgXCJ0cnlUb1JlY29uY2lsZU5vZGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGN1cnJlbnQsIG5ld1ZhbHVlKSB7XG4gICAgICBpZiAoY3VycmVudC5pc0RldGFjaGluZykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAoY3VycmVudC5zbmFwc2hvdCA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgLy8gbmV3VmFsdWUgaXMgdGhlIGN1cnJlbnQgc25hcHNob3Qgb2YgdGhlIG5vZGUsIG5vb3BcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0YXRlVHJlZU5vZGUobmV3VmFsdWUpICYmIGdldFN0YXRlVHJlZU5vZGUobmV3VmFsdWUpID09PSBjdXJyZW50KSB7XG4gICAgICAgIC8vIHRoZSBjdXJyZW50IG5vZGUgaXMgdGhlIHNhbWUgYXMgdGhlIG5ldyBvbmVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50LnR5cGUgPT09IHRoaXMgJiYgaXNNdXRhYmxlKG5ld1ZhbHVlKSAmJiAhaXNTdGF0ZVRyZWVOb2RlKG5ld1ZhbHVlKSAmJiAoIWN1cnJlbnQuaWRlbnRpZmllckF0dHJpYnV0ZSB8fCBjdXJyZW50LmlkZW50aWZpZXIgPT09IG5vcm1hbGl6ZUlkZW50aWZpZXIobmV3VmFsdWVbY3VycmVudC5pZGVudGlmaWVyQXR0cmlidXRlXSkpKSB7XG4gICAgICAgIC8vIHRoZSBuZXdWYWx1ZSBoYXMgbm8gbm9kZSwgc28gY2FuIGJlIHRyZWF0ZWQgbGlrZSBhIHNuYXBzaG90XG4gICAgICAgIC8vIHdlIGNhbiByZWNvbmNpbGVcbiAgICAgICAgY3VycmVudC5hcHBseVNuYXBzaG90KG5ld1ZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGxleFR5cGUucHJvdG90eXBlLCBcInJlY29uY2lsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoY3VycmVudCwgbmV3VmFsdWUsIHBhcmVudCwgc3VicGF0aCkge1xuICAgICAgdmFyIG5vZGVSZWNvbmNpbGVkID0gdGhpcy50cnlUb1JlY29uY2lsZU5vZGUoY3VycmVudCwgbmV3VmFsdWUpO1xuXG4gICAgICBpZiAobm9kZVJlY29uY2lsZWQpIHtcbiAgICAgICAgY3VycmVudC5zZXRQYXJlbnQocGFyZW50LCBzdWJwYXRoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9IC8vIGN1cnJlbnQgbm9kZSBjYW5ub3QgYmUgcmVjeWNsZWQgaW4gYW55IHdheVxuXG5cbiAgICAgIGN1cnJlbnQuZGllKCk7IC8vIG5vb3AgaWYgZGV0YWNoaW5nXG4gICAgICAvLyBhdHRlbXB0IHRvIHJldXNlIHRoZSBuZXcgb25lXG5cbiAgICAgIGlmIChpc1N0YXRlVHJlZU5vZGUobmV3VmFsdWUpICYmIHRoaXMuaXNBc3NpZ25hYmxlRnJvbShnZXRUeXBlKG5ld1ZhbHVlKSkpIHtcbiAgICAgICAgLy8gbmV3VmFsdWUgaXMgYSBOb2RlIGFzIHdlbGwsIG1vdmUgaXQgaGVyZS4uXG4gICAgICAgIHZhciBuZXdOb2RlID0gZ2V0U3RhdGVUcmVlTm9kZShuZXdWYWx1ZSk7XG4gICAgICAgIG5ld05vZGUuc2V0UGFyZW50KHBhcmVudCwgc3VicGF0aCk7XG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgfSAvLyBub3RoaW5nIHRvIGRvLCB3ZSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBub2RlXG5cblxuICAgICAgcmV0dXJuIHRoaXMuaW5zdGFudGlhdGUocGFyZW50LCBzdWJwYXRoLCB1bmRlZmluZWQsIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGxleFR5cGUucHJvdG90eXBlLCBcImdldFN1YlR5cGVzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBDb21wbGV4VHlwZTtcbn0oQmFzZVR5cGUpO1xuXG5Db21wbGV4VHlwZS5wcm90b3R5cGUuY3JlYXRlID0gYWN0aW9uKENvbXBsZXhUeXBlLnByb3RvdHlwZS5jcmVhdGUpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG52YXIgU2ltcGxlVHlwZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTaW1wbGVUeXBlLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFNpbXBsZVR5cGUoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVR5cGUucHJvdG90eXBlLCBcImNyZWF0ZU5ld0luc3RhbmNlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChzbmFwc2hvdCkge1xuICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVUeXBlLnByb3RvdHlwZSwgXCJnZXRWYWx1ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgLy8gaWYgd2UgZXZlciBmaW5kIGEgY2FzZSB3aGVyZSBzY2FsYXIgbm9kZXMgY2FuIGJlIGFjY2Vzc2VkIHdpdGhvdXQgaXRlcmF0aW5nIHRocm91Z2ggaXRzIHBhcmVudFxuICAgICAgLy8gdW5jb21tZW50IHRoaXMgdG8gbWFrZSBzdXJlIHRoZSBwYXJlbnQgY2hhaW4gaXMgY3JlYXRlZCB3aGVuIHRoaXMgaXMgYWNjZXNzZWRcbiAgICAgIC8vIGlmIChub2RlLnBhcmVudCkge1xuICAgICAgLy8gICAgIG5vZGUucGFyZW50LmNyZWF0ZU9ic2VydmFibGVJbnN0YW5jZUlmTmVlZGVkKClcbiAgICAgIC8vIH1cbiAgICAgIHJldHVybiBub2RlLnN0b3JlZFZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVUeXBlLnByb3RvdHlwZSwgXCJnZXRTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuc3RvcmVkVmFsdWU7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVR5cGUucHJvdG90eXBlLCBcInJlY29uY2lsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoY3VycmVudCwgbmV3VmFsdWUsIHBhcmVudCwgc3VicGF0aCkge1xuICAgICAgLy8gcmVjb25jaWxlIG9ubHkgaWYgdHlwZSBhbmQgdmFsdWUgYXJlIHN0aWxsIHRoZSBzYW1lLCBhbmQgb25seSBpZiB0aGUgbm9kZSBpcyBub3QgZGV0YWNoaW5nXG4gICAgICBpZiAoIWN1cnJlbnQuaXNEZXRhY2hpbmcgJiYgY3VycmVudC50eXBlID09PSB0aGlzICYmIGN1cnJlbnQuc3RvcmVkVmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzID0gdGhpcy5pbnN0YW50aWF0ZShwYXJlbnQsIHN1YnBhdGgsIHVuZGVmaW5lZCwgbmV3VmFsdWUpO1xuICAgICAgY3VycmVudC5kaWUoKTsgLy8gbm9vcCBpZiBkZXRhY2hpbmdcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2ltcGxlVHlwZS5wcm90b3R5cGUsIFwiZ2V0U3ViVHlwZXNcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFNpbXBsZVR5cGU7XG59KEJhc2VUeXBlKTtcbi8qKlxuICogUmV0dXJucyBpZiBhIGdpdmVuIHZhbHVlIHJlcHJlc2VudHMgYSB0eXBlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gaXNUeXBlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgJiYgdmFsdWUuaXNUeXBlID09PSB0cnVlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VydElzVHlwZSh0eXBlLCBhcmdOdW1iZXIpIHtcbiAgYXNzZXJ0QXJnKHR5cGUsIGlzVHlwZSwgXCJtb2J4LXN0YXRlLXRyZWUgdHlwZVwiLCBhcmdOdW1iZXIpO1xufVxuXG52YXIgcnVubmluZ0FjdGlvbnMgPSBuZXcgTWFwKCk7XG4vKipcbiAqIE5vdGU6IENvbnNpZGVyIG1pZ3JhdGluZyB0byBgY3JlYXRlQWN0aW9uVHJhY2tpbmdNaWRkbGV3YXJlMmAsIGl0IGlzIGVhc2llciB0byB1c2UuXG4gKlxuICogQ29udmVuaWVuY2UgdXRpbGl0eSB0byBjcmVhdGUgYWN0aW9uIGJhc2VkIG1pZGRsZXdhcmUgdGhhdCBzdXBwb3J0cyBhc3luYyBwcm9jZXNzZXMgbW9yZSBlYXNpbHkuXG4gKiBBbGwgaG9va3MgYXJlIGNhbGxlZCBmb3IgYm90aCBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzIGFjdGlvbnMuIEV4Y2VwdCB0aGF0IGVpdGhlciBgb25TdWNjZXNzYCBvciBgb25GYWlsYCBpcyBjYWxsZWRcbiAqXG4gKiBUaGUgY3JlYXRlIG1pZGRsZXdhcmUgdHJhY2tzIHRoZSBwcm9jZXNzIG9mIGFuIGFjdGlvbiAoYXNzdW1pbmcgaXQgcGFzc2VzIHRoZSBgZmlsdGVyYCkuXG4gKiBgb25SZXN1bWVgIGNhbiByZXR1cm4gYW55IHZhbHVlLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhcyBzZWNvbmQgYXJndW1lbnQgdG8gYW55IG90aGVyIGhvb2suIFRoaXMgbWFrZXMgaXQgcG9zc2libGUgdG8ga2VlcCBzdGF0ZSBkdXJpbmcgYSBwcm9jZXNzLlxuICpcbiAqIFNlZSB0aGUgYGF0b21pY2AgbWlkZGxld2FyZSBmb3IgYW4gZXhhbXBsZVxuICpcbiAqIEBwYXJhbSBob29rc1xuICogQHJldHVybnNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25UcmFja2luZ01pZGRsZXdhcmUoaG9va3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFjdGlvblRyYWNraW5nTWlkZGxld2FyZShjYWxsLCBuZXh0LCBhYm9ydCkge1xuICAgIHN3aXRjaCAoY2FsbC50eXBlKSB7XG4gICAgICBjYXNlIFwiYWN0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIWhvb2tzLmZpbHRlciB8fCBob29rcy5maWx0ZXIoY2FsbCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gaG9va3Mub25TdGFydChjYWxsKTtcbiAgICAgICAgICAgIGhvb2tzLm9uUmVzdW1lKGNhbGwsIGNvbnRleHQpO1xuICAgICAgICAgICAgcnVubmluZ0FjdGlvbnMuc2V0KGNhbGwuaWQsIHtcbiAgICAgICAgICAgICAgY2FsbDogY2FsbCxcbiAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIHJlcyA9IG5leHQoY2FsbCk7XG4gICAgICAgICAgICAgIGhvb2tzLm9uU3VzcGVuZChjYWxsLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgICBpZiAocnVubmluZ0FjdGlvbnMuZ2V0KGNhbGwuaWQpLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdBY3Rpb25zLmRlbGV0ZShjYWxsLmlkKTtcbiAgICAgICAgICAgICAgICBob29rcy5vblN1Y2Nlc3MoY2FsbCwgY29udGV4dCwgcmVzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJ1bm5pbmdBY3Rpb25zLmRlbGV0ZShjYWxsLmlkKTtcbiAgICAgICAgICAgICAgaG9va3Mub25GYWlsKGNhbGwsIGNvbnRleHQsIGUpO1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dChjYWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImZsb3dfc3Bhd25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciByb290ID0gcnVubmluZ0FjdGlvbnMuZ2V0KGNhbGwucm9vdElkKTtcbiAgICAgICAgICByb290LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gbmV4dChjYWxsKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiZmxvd19yZXN1bWVcIjpcbiAgICAgIGNhc2UgXCJmbG93X3Jlc3VtZV9lcnJvclwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHJvb3QgPSBydW5uaW5nQWN0aW9ucy5nZXQoY2FsbC5yb290SWQpO1xuICAgICAgICAgIGhvb2tzLm9uUmVzdW1lKGNhbGwsIHJvb3QuY29udGV4dCk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoY2FsbCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGhvb2tzLm9uU3VzcGVuZChjYWxsLCByb290LmNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiZmxvd190aHJvd1wiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHJvb3QgPSBydW5uaW5nQWN0aW9ucy5nZXQoY2FsbC5yb290SWQpO1xuICAgICAgICAgIHJ1bm5pbmdBY3Rpb25zLmRlbGV0ZShjYWxsLnJvb3RJZCk7XG4gICAgICAgICAgaG9va3Mub25GYWlsKGNhbGwsIHJvb3QuY29udGV4dCwgY2FsbC5hcmdzWzBdKTtcbiAgICAgICAgICByZXR1cm4gbmV4dChjYWxsKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiZmxvd19yZXR1cm5cIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciByb290ID0gcnVubmluZ0FjdGlvbnMuZ2V0KGNhbGwucm9vdElkKTtcbiAgICAgICAgICBydW5uaW5nQWN0aW9ucy5kZWxldGUoY2FsbC5yb290SWQpO1xuICAgICAgICAgIGhvb2tzLm9uU3VjY2VzcyhjYWxsLCByb290LmNvbnRleHQsIGNhbGwuYXJnc1swXSk7XG4gICAgICAgICAgcmV0dXJuIG5leHQoY2FsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciBSdW5uaW5nQWN0aW9uID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUnVubmluZ0FjdGlvbihob29rcywgY2FsbCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhvb2tzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBob29rc1xuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGNhbGxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmbG93c1BlbmRpbmdcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IDBcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5uaW5nXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoaG9va3MpIHtcbiAgICAgIGhvb2tzLm9uU3RhcnQoY2FsbCk7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bm5pbmdBY3Rpb24ucHJvdG90eXBlLCBcImZpbmlzaFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuaG9va3MpIHtcbiAgICAgICAgICB0aGlzLmhvb2tzLm9uRmluaXNoKHRoaXMuY2FsbCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bm5pbmdBY3Rpb24ucHJvdG90eXBlLCBcImluY0Zsb3dzUGVuZGluZ1wiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmZsb3dzUGVuZGluZysrO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5uaW5nQWN0aW9uLnByb3RvdHlwZSwgXCJkZWNGbG93c1BlbmRpbmdcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5mbG93c1BlbmRpbmctLTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVubmluZ0FjdGlvbi5wcm90b3R5cGUsIFwiaGFzRmxvd3NQZW5kaW5nXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dzUGVuZGluZyA+IDA7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBSdW5uaW5nQWN0aW9uO1xufSgpO1xuLyoqXG4gKiBDb252ZW5pZW5jZSB1dGlsaXR5IHRvIGNyZWF0ZSBhY3Rpb24gYmFzZWQgbWlkZGxld2FyZSB0aGF0IHN1cHBvcnRzIGFzeW5jIHByb2Nlc3NlcyBtb3JlIGVhc2lseS5cbiAqIFRoZSBmbG93IGlzIGxpa2UgdGhpczpcbiAqIC0gZm9yIGVhY2ggYWN0aW9uOiBpZiBmaWx0ZXIgcGFzc2VzIC0+IGBvblN0YXJ0YCAtPiAoaW5uZXIgYWN0aW9ucyByZWN1cnNpdmVseSkgLT4gYG9uRmluaXNoYFxuICpcbiAqIEV4YW1wbGU6IGlmIHdlIGhhZCBhbiBhY3Rpb24gYGFgIHRoYXQgY2FsbGVkIGluc2lkZSBhbiBhY3Rpb24gYGIxYCwgdGhlbiBgYjJgIHRoZSBmbG93IHdvdWxkIGJlOlxuICogLSBgZmlsdGVyKGEpYFxuICogLSBgb25TdGFydChhKWBcbiAqICAgLSBgZmlsdGVyKGIxKWBcbiAqICAgLSBgb25TdGFydChiMSlgXG4gKiAgIC0gYG9uRmluaXNoKGIxKWBcbiAqICAgLSBgZmlsdGVyKGIyKWBcbiAqICAgLSBgb25TdGFydChiMilgXG4gKiAgIC0gYG9uRmluaXNoKGIyKWBcbiAqIC0gYG9uRmluaXNoKGEpYFxuICpcbiAqIFRoZSBmbG93IGlzIHRoZSBzYW1lIG5vIG1hdHRlciBpZiB0aGUgYWN0aW9ucyBhcmUgc3luYyBvciBhc3luYy5cbiAqXG4gKiBTZWUgdGhlIGBhdG9taWNgIG1pZGRsZXdhcmUgZm9yIGFuIGV4YW1wbGVcbiAqXG4gKiBAcGFyYW0gaG9va3NcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25UcmFja2luZ01pZGRsZXdhcmUyKG1pZGRsZXdhcmVIb29rcykge1xuICB2YXIgcnVubmluZ0FjdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuICByZXR1cm4gZnVuY3Rpb24gYWN0aW9uVHJhY2tpbmdNaWRkbGV3YXJlKGNhbGwsIG5leHQpIHtcbiAgICAvLyBmaW5kIHBhcmVudFJ1bm5pbmdBY3Rpb25cbiAgICB2YXIgcGFyZW50UnVubmluZ0FjdGlvbiA9IGNhbGwucGFyZW50QWN0aW9uRXZlbnQgPyBydW5uaW5nQWN0aW9ucy5nZXQoY2FsbC5wYXJlbnRBY3Rpb25FdmVudCkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2FsbC50eXBlID09PSBcImFjdGlvblwiKSB7XG4gICAgICB2YXIgbmV3Q2FsbCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjYWxsKSwge1xuICAgICAgICAvLyBtYWtlIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBwYXJlbnQgYWN0aW9uIGVudlxuICAgICAgICBlbnY6IHBhcmVudFJ1bm5pbmdBY3Rpb24gJiYgcGFyZW50UnVubmluZ0FjdGlvbi5jYWxsLmVudixcbiAgICAgICAgcGFyZW50Q2FsbDogcGFyZW50UnVubmluZ0FjdGlvbiAmJiBwYXJlbnRSdW5uaW5nQWN0aW9uLmNhbGxcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcGFzc2VzRmlsdGVyID0gIW1pZGRsZXdhcmVIb29rcy5maWx0ZXIgfHwgbWlkZGxld2FyZUhvb2tzLmZpbHRlcihuZXdDYWxsKTtcbiAgICAgIHZhciBob29rcyA9IHBhc3Nlc0ZpbHRlciA/IG1pZGRsZXdhcmVIb29rcyA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBydW5uaW5nQWN0aW9uID0gbmV3IFJ1bm5pbmdBY3Rpb24oaG9va3MsIG5ld0NhbGwpO1xuICAgICAgcnVubmluZ0FjdGlvbnMuc2V0KGNhbGwsIHJ1bm5pbmdBY3Rpb24pO1xuICAgICAgdmFyIHJlcyA9IHZvaWQgMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzID0gbmV4dChjYWxsKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcnVubmluZ0FjdGlvbi5maW5pc2goZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghcnVubmluZ0FjdGlvbi5oYXNGbG93c1BlbmRpbmcpIHtcbiAgICAgICAgLy8gc3luYyBhY3Rpb24gZmluaXNoZWRcbiAgICAgICAgcnVubmluZ0FjdGlvbi5maW5pc2goKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFwYXJlbnRSdW5uaW5nQWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGNhbGwpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNhbGwudHlwZSkge1xuICAgICAgICBjYXNlIFwiZmxvd19zcGF3blwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBhcmVudFJ1bm5pbmdBY3Rpb24uaW5jRmxvd3NQZW5kaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dChjYWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBcImZsb3dfcmVzdW1lXCI6XG4gICAgICAgIGNhc2UgXCJmbG93X3Jlc3VtZV9lcnJvclwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KGNhbGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFwiZmxvd190aHJvd1wiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IGNhbGwuYXJnc1swXTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQoY2FsbCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBwYXJlbnRSdW5uaW5nQWN0aW9uLmRlY0Zsb3dzUGVuZGluZygpO1xuXG4gICAgICAgICAgICAgIGlmICghcGFyZW50UnVubmluZ0FjdGlvbi5oYXNGbG93c1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRSdW5uaW5nQWN0aW9uLmZpbmlzaChlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBcImZsb3dfcmV0dXJuXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQoY2FsbCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBwYXJlbnRSdW5uaW5nQWN0aW9uLmRlY0Zsb3dzUGVuZGluZygpO1xuXG4gICAgICAgICAgICAgIGlmICghcGFyZW50UnVubmluZ0FjdGlvbi5oYXNGbG93c1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRSdW5uaW5nQWN0aW9uLmZpbmlzaCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplQXJndW1lbnQobm9kZSwgYWN0aW9uTmFtZSwgaW5kZXgsIGFyZykge1xuICBpZiAoYXJnIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHtcbiAgICAkTVNUX0RBVEU6IGFyZy5nZXRUaW1lKClcbiAgfTtcbiAgaWYgKGlzUHJpbWl0aXZlKGFyZykpIHJldHVybiBhcmc7IC8vIFdlIHNob3VsZCBub3Qgc2VyaWFsaXplIE1TVCBub2RlcywgZXZlbiBpZiB3ZSBjYW4sIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyBpZiB0aGUgcmVjZWl2aW5nIHBhcnR5IGNhbiBoYW5kbGUgYSByYXcgc25hcHNob3QgaW5zdGVhZCBvZiBhblxuICAvLyBNU1QgdHlwZSBpbnN0YW5jZS4gU28gaWYgb25lIHdhbnRzIHRvIHNlcmlhbGl6ZSBhIE1TVCBub2RlIHRoYXQgd2FzIHBhc3MgaW4sIGVpdGhlciBleHBsaXRseSBwYXNzOiAxOiBhbiBpZCwgMjogYSAocmVsYXRpdmUpIHBhdGgsIDM6IGEgc25hcHNob3RcblxuICBpZiAoaXNTdGF0ZVRyZWVOb2RlKGFyZykpIHJldHVybiBzZXJpYWxpemVUaGVVbnNlcmlhbGl6YWJsZShcIltNU1ROb2RlOiBcIiArIGdldFR5cGUoYXJnKS5uYW1lICsgXCJdXCIpO1xuICBpZiAodHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gc2VyaWFsaXplVGhlVW5zZXJpYWxpemFibGUoXCJbZnVuY3Rpb25dXCIpO1xuICBpZiAodHlwZW9mIGFyZyA9PT0gXCJvYmplY3RcIiAmJiAhaXNQbGFpbk9iamVjdChhcmcpICYmICFpc0FycmF5KGFyZykpIHJldHVybiBzZXJpYWxpemVUaGVVbnNlcmlhbGl6YWJsZShcIltvYmplY3QgXCIgKyAoYXJnICYmIGFyZy5jb25zdHJ1Y3RvciAmJiBhcmcuY29uc3RydWN0b3IubmFtZSB8fCBcIkNvbXBsZXggT2JqZWN0XCIpICsgXCJdXCIpO1xuXG4gIHRyeSB7XG4gICAgLy8gQ2hlY2sgaWYgc2VyaWFsaXphYmxlLCBjeWNsZSBmcmVlIGV0Yy4uLlxuICAgIC8vIE1XRTogdGhlcmUgbXVzdCBiZSBhIGJldHRlciB3YXkuLi4uXG4gICAgSlNPTi5zdHJpbmdpZnkoYXJnKTsgLy8gb3IgdGhyb3dzXG5cbiAgICByZXR1cm4gYXJnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZVRoZVVuc2VyaWFsaXphYmxlKFwiXCIgKyBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUFyZ3VtZW50KGFkbSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcIiRNU1RfREFURVwiIGluIHZhbHVlKSByZXR1cm4gbmV3IERhdGUodmFsdWVbXCIkTVNUX0RBVEVcIl0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRoZVVuc2VyaWFsaXphYmxlKGJhc2VUeXBlKSB7XG4gIHJldHVybiB7XG4gICAgJE1TVF9VTlNFUklBTElaQUJMRTogdHJ1ZSxcbiAgICB0eXBlOiBiYXNlVHlwZVxuICB9O1xufVxuLyoqXG4gKiBBcHBsaWVzIGFuIGFjdGlvbiBvciBhIHNlcmllcyBvZiBhY3Rpb25zIGluIGEgc2luZ2xlIE1vYlggdHJhbnNhY3Rpb24uXG4gKiBEb2VzIG5vdCByZXR1cm4gYW55IHZhbHVlXG4gKiBUYWtlcyBhbiBhY3Rpb24gZGVzY3JpcHRpb24gYXMgcHJvZHVjZWQgYnkgdGhlIGBvbkFjdGlvbmAgbWlkZGxld2FyZS5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcGFyYW0gYWN0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gYXBwbHlBY3Rpb24odGFyZ2V0LCBhY3Rpb25zKSB7XG4gIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gIGFzc2VydEFyZyhhY3Rpb25zLCBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiB0eXBlb2YgYSA9PT0gXCJvYmplY3RcIjtcbiAgfSwgXCJvYmplY3Qgb3IgYXJyYXlcIiwgMik7XG4gIHJ1bkluQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICBhc0FycmF5KGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgcmV0dXJuIGJhc2VBcHBseUFjdGlvbih0YXJnZXQsIGFjdGlvbik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBiYXNlQXBwbHlBY3Rpb24odGFyZ2V0LCBhY3Rpb24pIHtcbiAgdmFyIHJlc29sdmVkVGFyZ2V0ID0gdHJ5UmVzb2x2ZSh0YXJnZXQsIGFjdGlvbi5wYXRoIHx8IFwiXCIpO1xuICBpZiAoIXJlc29sdmVkVGFyZ2V0KSB0aHJvdyBmYWlsJDEoXCJJbnZhbGlkIGFjdGlvbiBwYXRoOiBcIiArIChhY3Rpb24ucGF0aCB8fCBcIlwiKSk7XG4gIHZhciBub2RlID0gZ2V0U3RhdGVUcmVlTm9kZShyZXNvbHZlZFRhcmdldCk7IC8vIFJlc2VydmVkIGZ1bmN0aW9uc1xuXG4gIGlmIChhY3Rpb24ubmFtZSA9PT0gXCJAQVBQTFlfUEFUQ0hFU1wiKSB7XG4gICAgcmV0dXJuIGFwcGx5UGF0Y2guY2FsbChudWxsLCByZXNvbHZlZFRhcmdldCwgYWN0aW9uLmFyZ3NbMF0pO1xuICB9XG5cbiAgaWYgKGFjdGlvbi5uYW1lID09PSBcIkBBUFBMWV9TTkFQU0hPVFwiKSB7XG4gICAgcmV0dXJuIGFwcGx5U25hcHNob3QuY2FsbChudWxsLCByZXNvbHZlZFRhcmdldCwgYWN0aW9uLmFyZ3NbMF0pO1xuICB9XG5cbiAgaWYgKCEodHlwZW9mIHJlc29sdmVkVGFyZ2V0W2FjdGlvbi5uYW1lXSA9PT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgZmFpbCQxKFwiQWN0aW9uICdcIiArIGFjdGlvbi5uYW1lICsgXCInIGRvZXMgbm90IGV4aXN0IGluICdcIiArIG5vZGUucGF0aCArIFwiJ1wiKTtcbiAgcmV0dXJuIHJlc29sdmVkVGFyZ2V0W2FjdGlvbi5uYW1lXS5hcHBseShyZXNvbHZlZFRhcmdldCwgYWN0aW9uLmFyZ3MgPyBhY3Rpb24uYXJncy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVBcmd1bWVudChub2RlLCB2KTtcbiAgfSkgOiBbXSk7XG59XG4vKipcbiAqIFNtYWxsIGFic3RyYWN0aW9uIGFyb3VuZCBgb25BY3Rpb25gIGFuZCBgYXBwbHlBY3Rpb25gLCBhdHRhY2hlcyBhbiBhY3Rpb24gbGlzdGVuZXIgdG8gYSB0cmVlIGFuZCByZWNvcmRzIGFsbCB0aGUgYWN0aW9ucyBlbWl0dGVkLlxuICogUmV0dXJucyBhbiByZWNvcmRlciBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGV4cG9ydCBpbnRlcmZhY2UgSUFjdGlvblJlY29yZGVyIHtcbiAqICAgICAgLy8gdGhlIHJlY29yZGVkIGFjdGlvbnNcbiAqICAgICAgYWN0aW9uczogSVNlcmlhbGl6ZWRBY3Rpb25DYWxsW11cbiAqICAgICAgLy8gdHJ1ZSBpZiBjdXJyZW50bHkgcmVjb3JkaW5nXG4gKiAgICAgIHJlY29yZGluZzogYm9vbGVhblxuICogICAgICAvLyBzdG9wIHJlY29yZGluZyBhY3Rpb25zXG4gKiAgICAgIHN0b3AoKTogdm9pZFxuICogICAgICAvLyByZXN1bWUgcmVjb3JkaW5nIGFjdGlvbnNcbiAqICAgICAgcmVzdW1lKCk6IHZvaWRcbiAqICAgICAgLy8gYXBwbHkgYWxsIHRoZSByZWNvcmRlZCBhY3Rpb25zIG9uIHRoZSBnaXZlbiBvYmplY3RcbiAqICAgICAgcmVwbGF5KHRhcmdldDogSUFueVN0YXRlVHJlZU5vZGUpOiB2b2lkXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGUgb3B0aW9uYWwgZmlsdGVyIGZ1bmN0aW9uIGFsbG93cyB0byBza2lwIHJlY29yZGluZyBjZXJ0YWluIGFjdGlvbnMuXG4gKlxuICogQHBhcmFtIHN1YmplY3RcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiByZWNvcmRBY3Rpb25zKHN1YmplY3QsIGZpbHRlcikge1xuICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gIGFzc2VydElzU3RhdGVUcmVlTm9kZShzdWJqZWN0LCAxKTtcbiAgdmFyIGFjdGlvbnMgPSBbXTtcblxuICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoY2FsbCkge1xuICAgIHZhciByZWNvcmRUaGlzID0gZmlsdGVyID8gZmlsdGVyKGNhbGwsIGdldFJ1bm5pbmdBY3Rpb25Db250ZXh0KCkpIDogdHJ1ZTtcblxuICAgIGlmIChyZWNvcmRUaGlzKSB7XG4gICAgICBhY3Rpb25zLnB1c2goY2FsbCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkaXNwb3NlcjtcbiAgdmFyIHJlY29yZGVyID0ge1xuICAgIGFjdGlvbnM6IGFjdGlvbnMsXG5cbiAgICBnZXQgcmVjb3JkaW5nKCkge1xuICAgICAgcmV0dXJuICEhZGlzcG9zZXI7XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChkaXNwb3Nlcikge1xuICAgICAgICBkaXNwb3NlcigpO1xuICAgICAgICBkaXNwb3NlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGRpc3Bvc2VyKSByZXR1cm47XG4gICAgICBkaXNwb3NlciA9IG9uQWN0aW9uKHN1YmplY3QsIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIHJlcGxheTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgYXBwbHlBY3Rpb24odGFyZ2V0LCBhY3Rpb25zKTtcbiAgICB9XG4gIH07XG4gIHJlY29yZGVyLnJlc3VtZSgpO1xuICByZXR1cm4gcmVjb3JkZXI7XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIGZvciBlYWNoIGFjdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiB0aGUgcHJvdmlkZWQgbW9kZWwgaW5zdGFuY2UsIG9yIHRvIGFueSBvZiBpdHMgY2hpbGRyZW4uXG4gKiBTZWUgW2FjdGlvbnNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC1zdGF0ZS10cmVlI2FjdGlvbnMpIGZvciBtb3JlIGRldGFpbHMuIG9uQWN0aW9uIGV2ZW50cyBhcmUgZW1pdHRlZCBvbmx5IGZvciB0aGUgb3V0ZXJtb3N0IGNhbGxlZCBhY3Rpb24gaW4gdGhlIHN0YWNrLlxuICogQWN0aW9uIGNhbiBhbHNvIGJlIGludGVyY2VwdGVkIGJ5IG1pZGRsZXdhcmUgdXNpbmcgYWRkTWlkZGxld2FyZSB0byBjaGFuZ2UgdGhlIGZ1bmN0aW9uIGNhbGwgYmVmb3JlIGl0IHdpbGwgYmUgcnVuLlxuICpcbiAqIE5vdCBhbGwgYWN0aW9uIGFyZ3VtZW50cyBtaWdodCBiZSBzZXJpYWxpemFibGUuIEZvciB1bnNlcmlhbGl6YWJsZSBhcmd1bWVudHMsIGEgc3RydWN0IGxpa2UgYHsgJE1TVF9VTlNFUklBTElaQUJMRTogdHJ1ZSwgdHlwZTogXCJzb21lVHlwZVwiIH1gIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICogTVNUIE5vZGVzIGFyZSBjb25zaWRlcmVkIG5vbi1zZXJpYWxpemFibGUgYXMgd2VsbCAodGhleSBjb3VsZCBiZSBzZXJpYWxpemVkIGFzIHRoZXJlIHNuYXBzaG90LCBidXQgaXQgaXMgdW5jZXJ0YWluIHdoZXRoZXIgYW4gcmVwbGF5aW5nIHBhcnR5IHdpbGwgYmUgYWJsZSB0byBoYW5kbGUgc3VjaCBhIG5vbi1pbnN0YW50aWF0ZWQgc25hcHNob3QpLlxuICogUmF0aGVyLCB3aGVuIHVzaW5nIGBvbkFjdGlvbmAgbWlkZGxld2FyZSwgb25lIHNob3VsZCBjb25zaWRlciBpbiBwYXNzaW5nIGFyZ3VtZW50cyB3aGljaCBhcmUgMTogYW4gaWQsIDI6IGEgKHJlbGF0aXZlKSBwYXRoLCBvciAzOiBhIHNuYXBzaG90LiBJbnN0ZWFkIG9mIGEgcmVhbCBNU1Qgbm9kZS5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IFRvZG8gPSB0eXBlcy5tb2RlbCh7XG4gKiAgIHRhc2s6IHR5cGVzLnN0cmluZ1xuICogfSlcbiAqXG4gKiBjb25zdCBUb2RvU3RvcmUgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIHRvZG9zOiB0eXBlcy5hcnJheShUb2RvKVxuICogfSkuYWN0aW9ucyhzZWxmID0+ICh7XG4gKiAgIGFkZCh0b2RvKSB7XG4gKiAgICAgc2VsZi50b2Rvcy5wdXNoKHRvZG8pO1xuICogICB9XG4gKiB9KSlcbiAqXG4gKiBjb25zdCBzID0gVG9kb1N0b3JlLmNyZWF0ZSh7IHRvZG9zOiBbXSB9KVxuICpcbiAqIGxldCBkaXNwb3NlciA9IG9uQWN0aW9uKHMsIChjYWxsKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKGNhbGwpO1xuICogfSlcbiAqXG4gKiBzLmFkZCh7IHRhc2s6IFwiR3JhYiBhIGNvZmZlZVwiIH0pXG4gKiAvLyBMb2dzOiB7IG5hbWU6IFwiYWRkXCIsIHBhdGg6IFwiXCIsIGFyZ3M6IFt7IHRhc2s6IFwiR3JhYiBhIGNvZmZlZVwiIH1dIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEBwYXJhbSBsaXN0ZW5lclxuICogQHBhcmFtIGF0dGFjaEFmdGVyIChkZWZhdWx0IGZhbHNlKSBmaXJlcyB0aGUgbGlzdGVuZXIgKmFmdGVyKiB0aGUgYWN0aW9uIGhhcyBleGVjdXRlZCBpbnN0ZWFkIG9mIGJlZm9yZS5cbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBvbkFjdGlvbih0YXJnZXQsIGxpc3RlbmVyLCBhdHRhY2hBZnRlcikge1xuICBpZiAoYXR0YWNoQWZ0ZXIgPT09IHZvaWQgMCkge1xuICAgIGF0dGFjaEFmdGVyID0gZmFsc2U7XG4gIH0gLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuXG5cbiAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG5cbiAgaWYgKGRldk1vZGUoKSkge1xuICAgIGlmICghaXNSb290KHRhcmdldCkpIHdhcm5FcnJvcihcIldhcm5pbmc6IEF0dGFjaGluZyBvbkFjdGlvbiBsaXN0ZW5lcnMgdG8gbm9uIHJvb3Qgbm9kZXMgaXMgZGFuZ2Vyb3VzOiBObyBldmVudHMgd2lsbCBiZSBlbWl0dGVkIGZvciBhY3Rpb25zIGluaXRpYXRlZCBoaWdoZXIgdXAgaW4gdGhlIHRyZWUuXCIpO1xuICAgIGlmICghaXNQcm90ZWN0ZWQodGFyZ2V0KSkgd2FybkVycm9yKFwiV2FybmluZzogQXR0YWNoaW5nIG9uQWN0aW9uIGxpc3RlbmVycyB0byBub24gcHJvdGVjdGVkIG5vZGVzIGlzIGRhbmdlcm91czogTm8gZXZlbnRzIHdpbGwgYmUgZW1pdHRlZCBmb3IgZGlyZWN0IG1vZGlmaWNhdGlvbnMgd2l0aG91dCBhY3Rpb24uXCIpO1xuICB9XG5cbiAgcmV0dXJuIGFkZE1pZGRsZXdhcmUodGFyZ2V0LCBmdW5jdGlvbiBoYW5kbGVyKHJhd0NhbGwsIG5leHQpIHtcbiAgICBpZiAocmF3Q2FsbC50eXBlID09PSBcImFjdGlvblwiICYmIHJhd0NhbGwuaWQgPT09IHJhd0NhbGwucm9vdElkKSB7XG4gICAgICB2YXIgc291cmNlTm9kZV8xID0gZ2V0U3RhdGVUcmVlTm9kZShyYXdDYWxsLmNvbnRleHQpO1xuICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgIG5hbWU6IHJhd0NhbGwubmFtZSxcbiAgICAgICAgcGF0aDogZ2V0UmVsYXRpdmVQYXRoQmV0d2Vlbk5vZGVzKGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KSwgc291cmNlTm9kZV8xKSxcbiAgICAgICAgYXJnczogcmF3Q2FsbC5hcmdzLm1hcChmdW5jdGlvbiAoYXJnLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVBcmd1bWVudChzb3VyY2VOb2RlXzEsIHJhd0NhbGwubmFtZSwgaW5kZXgsIGFyZyk7XG4gICAgICAgIH0pXG4gICAgICB9O1xuXG4gICAgICBpZiAoYXR0YWNoQWZ0ZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5leHQocmF3Q2FsbCk7XG4gICAgICAgIGxpc3RlbmVyKGluZm8pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdGVuZXIoaW5mbyk7XG4gICAgICAgIHJldHVybiBuZXh0KHJhd0NhbGwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV4dChyYXdDYWxsKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbmV4dEFjdGlvbklkID0gMTtcbnZhciBjdXJyZW50QWN0aW9uQ29udGV4dDtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEFjdGlvbkNvbnRleHQoKSB7XG4gIHJldHVybiBjdXJyZW50QWN0aW9uQ29udGV4dDtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXROZXh0QWN0aW9uSWQoKSB7XG4gIHJldHVybiBuZXh0QWN0aW9uSWQrKztcbn0gLy8gVE9ETzogb3B0aW1pemUgYXdheSBlbnRpcmUgYWN0aW9uIGNvbnRleHQgaWYgdGhlcmUgaXMgbm8gbWlkZGxld2FyZSBpbiB0cmVlP1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxuZnVuY3Rpb24gcnVuV2l0aEFjdGlvbkNvbnRleHQoY29udGV4dCwgZm4pIHtcbiAgdmFyIG5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKGNvbnRleHQuY29udGV4dCk7XG5cbiAgaWYgKGNvbnRleHQudHlwZSA9PT0gXCJhY3Rpb25cIikge1xuICAgIG5vZGUuYXNzZXJ0QWxpdmUoe1xuICAgICAgYWN0aW9uQ29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGJhc2VJc1J1bm5pbmdBY3Rpb24gPSBub2RlLl9pc1J1bm5pbmdBY3Rpb247XG4gIG5vZGUuX2lzUnVubmluZ0FjdGlvbiA9IHRydWU7XG4gIHZhciBwcmV2aW91c0NvbnRleHQgPSBjdXJyZW50QWN0aW9uQ29udGV4dDtcbiAgY3VycmVudEFjdGlvbkNvbnRleHQgPSBjb250ZXh0O1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHJ1bk1pZGRsZVdhcmVzKG5vZGUsIGNvbnRleHQsIGZuKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50QWN0aW9uQ29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICBub2RlLl9pc1J1bm5pbmdBY3Rpb24gPSBiYXNlSXNSdW5uaW5nQWN0aW9uO1xuICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxuZnVuY3Rpb24gZ2V0UGFyZW50QWN0aW9uQ29udGV4dChwYXJlbnRDb250ZXh0KSB7XG4gIGlmICghcGFyZW50Q29udGV4dCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKHBhcmVudENvbnRleHQudHlwZSA9PT0gXCJhY3Rpb25cIikgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0LnBhcmVudEFjdGlvbkV2ZW50O1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkludm9rZXIodGFyZ2V0LCBuYW1lLCBmbikge1xuICB2YXIgcmVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZCA9IGdldE5leHRBY3Rpb25JZCgpO1xuICAgIHZhciBwYXJlbnRDb250ZXh0ID0gY3VycmVudEFjdGlvbkNvbnRleHQ7XG4gICAgdmFyIHBhcmVudEFjdGlvbkNvbnRleHQgPSBnZXRQYXJlbnRBY3Rpb25Db250ZXh0KHBhcmVudENvbnRleHQpO1xuICAgIHJldHVybiBydW5XaXRoQWN0aW9uQ29udGV4dCh7XG4gICAgICB0eXBlOiBcImFjdGlvblwiLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGFyZ3M6IGFyZ3NUb0FycmF5KGFyZ3VtZW50cyksXG4gICAgICBjb250ZXh0OiB0YXJnZXQsXG4gICAgICB0cmVlOiBnZXRSb290KHRhcmdldCksXG4gICAgICByb290SWQ6IHBhcmVudENvbnRleHQgPyBwYXJlbnRDb250ZXh0LnJvb3RJZCA6IGlkLFxuICAgICAgcGFyZW50SWQ6IHBhcmVudENvbnRleHQgPyBwYXJlbnRDb250ZXh0LmlkIDogMCxcbiAgICAgIGFsbFBhcmVudElkczogcGFyZW50Q29udGV4dCA/IF9fc3ByZWFkKHBhcmVudENvbnRleHQuYWxsUGFyZW50SWRzLCBbcGFyZW50Q29udGV4dC5pZF0pIDogW10sXG4gICAgICBwYXJlbnRFdmVudDogcGFyZW50Q29udGV4dCxcbiAgICAgIHBhcmVudEFjdGlvbkV2ZW50OiBwYXJlbnRBY3Rpb25Db250ZXh0XG4gICAgfSwgZm4pO1xuICB9O1xuXG4gIHJlcy5faXNNU1RBY3Rpb24gPSB0cnVlO1xuICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBNaWRkbGV3YXJlIGNhbiBiZSB1c2VkIHRvIGludGVyY2VwdCBhbnkgYWN0aW9uIGlzIGludm9rZWQgb24gdGhlIHN1YnRyZWUgd2hlcmUgaXQgaXMgYXR0YWNoZWQuXG4gKiBJZiBhIHRyZWUgaXMgcHJvdGVjdGVkIChieSBkZWZhdWx0KSwgdGhpcyBtZWFucyB0aGF0IGFueSBtdXRhdGlvbiBvZiB0aGUgdHJlZSB3aWxsIHBhc3MgdGhyb3VnaCB5b3VyIG1pZGRsZXdhcmUuXG4gKlxuICogRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBbbWlkZGxld2FyZSBkb2NzXShjb25jZXB0cy9taWRkbGV3YXJlLm1kKVxuICpcbiAqIEBwYXJhbSB0YXJnZXQgTm9kZSB0byBhcHBseSB0aGUgbWlkZGxld2FyZSB0by5cbiAqIEBwYXJhbSBtaWRkbGV3YXJlIE1pZGRsZXdhcmUgdG8gYXBwbHkuXG4gKiBAcmV0dXJucyBBIGNhbGxhYmxlIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIG1pZGRsZXdhcmUuXG4gKi9cblxuXG5mdW5jdGlvbiBhZGRNaWRkbGV3YXJlKHRhcmdldCwgaGFuZGxlciwgaW5jbHVkZUhvb2tzKSB7XG4gIGlmIChpbmNsdWRlSG9va3MgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVIb29rcyA9IHRydWU7XG4gIH1cblxuICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KTtcblxuICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgaWYgKCFub2RlLmlzUHJvdGVjdGlvbkVuYWJsZWQpIHtcbiAgICAgIHdhcm5FcnJvcihcIkl0IGlzIHJlY29tbWVuZGVkIHRvIHByb3RlY3QgdGhlIHN0YXRlIHRyZWUgYmVmb3JlIGF0dGFjaGluZyBhY3Rpb24gbWlkZGxld2FyZSwgYXMgb3RoZXJ3aXNlIGl0IGNhbm5vdCBiZSBndWFyYW50ZWVkIHRoYXQgYWxsIGNoYW5nZXMgYXJlIHBhc3NlZCB0aHJvdWdoIG1pZGRsZXdhcmUuIFNlZSBgcHJvdGVjdGBcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGUuYWRkTWlkZGxlV2FyZShoYW5kbGVyLCBpbmNsdWRlSG9va3MpO1xufVxuLyoqXG4gKiBCaW5kcyBtaWRkbGV3YXJlIHRvIGEgc3BlY2lmaWMgYWN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogdHlwZS5hY3Rpb25zKHNlbGYgPT4ge1xuICogICBmdW5jdGlvbiB0YWtlQV9fX18oKSB7XG4gKiAgICAgICBzZWxmLnRvaWxldC5kb25hdGUoKVxuICogICAgICAgc2VsZi53aXBlKClcbiAqICAgICAgIHNlbGYud2lwZSgpXG4gKiAgICAgICBzZWxmLnRvaWxldC5mbHVzaCgpXG4gKiAgIH1cbiAqICAgcmV0dXJuIHtcbiAqICAgICB0YWtlQV9fX186IGRlY29yYXRlKGF0b21pYywgdGFrZUFfX19fKVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGhhbmRsZXJcbiAqIEBwYXJhbSBmblxuICogQHBhcmFtIGluY2x1ZGVIb29rc1xuICogQHJldHVybnMgVGhlIG9yaWdpbmFsIGZ1bmN0aW9uXG4gKi9cblxuXG5mdW5jdGlvbiBkZWNvcmF0ZShoYW5kbGVyLCBmbiwgaW5jbHVkZUhvb2tzKSB7XG4gIGlmIChpbmNsdWRlSG9va3MgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVIb29rcyA9IHRydWU7XG4gIH1cblxuICB2YXIgbWlkZGxld2FyZSA9IHtcbiAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgIGluY2x1ZGVIb29rczogaW5jbHVkZUhvb2tzXG4gIH07XG4gIGZuLiRtc3RfbWlkZGxld2FyZSA9IGZuLiRtc3RfbWlkZGxld2FyZSB8fCBbXTtcbiAgZm4uJG1zdF9taWRkbGV3YXJlLnB1c2gobWlkZGxld2FyZSk7XG4gIHJldHVybiBmbjtcbn1cblxudmFyIENvbGxlY3RlZE1pZGRsZXdhcmVzID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29sbGVjdGVkTWlkZGxld2FyZXMobm9kZSwgZm4pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcnJheUluZGV4XCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5BcnJheUluZGV4XCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWlkZGxld2FyZXNcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IFtdXG4gICAgfSk7IC8vIHdlIGp1c3QgcHVzaCBtaWRkbGV3YXJlIGFycmF5cyBpbnRvIGFuIGFycmF5IG9mIGFycmF5cyB0byBhdm9pZCBtYWtpbmcgY29waWVzXG5cbiAgICBpZiAoZm4uJG1zdF9taWRkbGV3YXJlKSB7XG4gICAgICB0aGlzLm1pZGRsZXdhcmVzLnB1c2goZm4uJG1zdF9taWRkbGV3YXJlKTtcbiAgICB9XG5cbiAgICB2YXIgbiA9IG5vZGU7IC8vIEZpbmQgYWxsIG1pZGRsZXdhcmVzLiBPcHRpbWl6YXRpb246IGNhY2hlIHRoaXM/XG5cbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4ubWlkZGxld2FyZXMpIHRoaXMubWlkZGxld2FyZXMucHVzaChuLm1pZGRsZXdhcmVzKTtcbiAgICAgIG4gPSBuLnBhcmVudDtcbiAgICB9XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sbGVjdGVkTWlkZGxld2FyZXMucHJvdG90eXBlLCBcImlzRW1wdHlcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWlkZGxld2FyZXMubGVuZ3RoIDw9IDA7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xsZWN0ZWRNaWRkbGV3YXJlcy5wcm90b3R5cGUsIFwiZ2V0TmV4dE1pZGRsZXdhcmVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5taWRkbGV3YXJlc1t0aGlzLmFycmF5SW5kZXhdO1xuICAgICAgaWYgKCFhcnJheSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbdGhpcy5pbkFycmF5SW5kZXgrK107XG5cbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICB0aGlzLmFycmF5SW5kZXgrKztcbiAgICAgICAgdGhpcy5pbkFycmF5SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROZXh0TWlkZGxld2FyZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gQ29sbGVjdGVkTWlkZGxld2FyZXM7XG59KCk7XG5cbmZ1bmN0aW9uIHJ1bk1pZGRsZVdhcmVzKG5vZGUsIGJhc2VDYWxsLCBvcmlnaW5hbEZuKSB7XG4gIHZhciBtaWRkbGV3YXJlcyA9IG5ldyBDb2xsZWN0ZWRNaWRkbGV3YXJlcyhub2RlLCBvcmlnaW5hbEZuKTsgLy8gU2hvcnQgY2lyY3VpdFxuXG4gIGlmIChtaWRkbGV3YXJlcy5pc0VtcHR5KSByZXR1cm4gYWN0aW9uKG9yaWdpbmFsRm4pLmFwcGx5KG51bGwsIGJhc2VDYWxsLmFyZ3MpO1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBydW5OZXh0TWlkZGxld2FyZShjYWxsKSB7XG4gICAgdmFyIG1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlcy5nZXROZXh0TWlkZGxld2FyZSgpO1xuICAgIHZhciBoYW5kbGVyID0gbWlkZGxld2FyZSAmJiBtaWRkbGV3YXJlLmhhbmRsZXI7XG5cbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBhY3Rpb24ob3JpZ2luYWxGbikuYXBwbHkobnVsbCwgY2FsbC5hcmdzKTtcbiAgICB9IC8vIHNraXAgaG9va3MgaWYgYXNrZWQgdG9cblxuXG4gICAgaWYgKCFtaWRkbGV3YXJlLmluY2x1ZGVIb29rcyAmJiBIb29rW2NhbGwubmFtZV0pIHtcbiAgICAgIHJldHVybiBydW5OZXh0TWlkZGxld2FyZShjYWxsKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEludm9rZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIG5leHQoY2FsbDIsIGNhbGxiYWNrKSB7XG4gICAgICBuZXh0SW52b2tlZCA9IHRydWU7IC8vIHRoZSByZXN1bHQgY2FuIGNvbnRhaW5cbiAgICAgIC8vIC0gdGhlIG5vbiBtYW5pcHVsYXRlZCByZXR1cm4gdmFsdWUgZnJvbSBhbiBhY3Rpb25cbiAgICAgIC8vIC0gdGhlIG5vbiBtYW5pcHVsYXRlZCBhYm9ydCB2YWx1ZVxuICAgICAgLy8gLSBvbmUgb2YgdGhlIGFib3ZlIGJ1dCBtYW5pcHVsYXRlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuXG4gICAgICByZXN1bHQgPSBydW5OZXh0TWlkZGxld2FyZShjYWxsMik7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICByZXN1bHQgPSBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhYm9ydEludm9rZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGFib3J0KHZhbHVlKSB7XG4gICAgICBhYm9ydEludm9rZWQgPSB0cnVlOyAvLyBvdmVyd3JpdGUgdGhlIHJlc3VsdFxuICAgICAgLy8gY2FuIGJlIG1hbmlwdWxhdGVkIHRocm91Z2ggbWlkZGxld2FyZXMgZWFybGllciBpbiB0aGUgcXVldWUgdXNpbmcgdGhlIGNhbGxiYWNrIGZuXG5cbiAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGhhbmRsZXIoY2FsbCwgbmV4dCwgYWJvcnQpO1xuXG4gICAgaWYgKGRldk1vZGUoKSkge1xuICAgICAgaWYgKCFuZXh0SW52b2tlZCAmJiAhYWJvcnRJbnZva2VkKSB7XG4gICAgICAgIHZhciBub2RlMiA9IGdldFN0YXRlVHJlZU5vZGUoY2FsbC50cmVlKTtcbiAgICAgICAgdGhyb3cgZmFpbCQxKFwiTmVpdGhlciB0aGUgbmV4dCgpIG5vciB0aGUgYWJvcnQoKSBjYWxsYmFjayB3aXRoaW4gdGhlIG1pZGRsZXdhcmUgXCIgKyBoYW5kbGVyLm5hbWUgKyBcIiBmb3IgdGhlIGFjdGlvbjogXFxcIlwiICsgY2FsbC5uYW1lICsgXCJcXFwiIG9uIHRoZSBub2RlOiBcIiArIG5vZGUyLnR5cGUubmFtZSArIFwiIHdhcyBpbnZva2VkLlwiKTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dEludm9rZWQgJiYgYWJvcnRJbnZva2VkKSB7XG4gICAgICAgIHZhciBub2RlMiA9IGdldFN0YXRlVHJlZU5vZGUoY2FsbC50cmVlKTtcbiAgICAgICAgdGhyb3cgZmFpbCQxKFwiVGhlIG5leHQoKSBhbmQgYWJvcnQoKSBjYWxsYmFjayB3aXRoaW4gdGhlIG1pZGRsZXdhcmUgXCIgKyBoYW5kbGVyLm5hbWUgKyBcIiBmb3IgdGhlIGFjdGlvbjogXFxcIlwiICsgY2FsbC5uYW1lICsgXCJcXFwiIG9uIHRoZSBub2RlOiBcIiArIG5vZGUyLnR5cGUubmFtZSArIFwiIHdlcmUgaW52b2tlZC5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBydW5OZXh0TWlkZGxld2FyZShiYXNlQ2FsbCk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgTVNUIGFjdGlvbiBjb250ZXh0LCBvciB1bmRlZmluZWQgaWYgbm9uZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFJ1bm5pbmdBY3Rpb25Db250ZXh0KCkge1xuICB2YXIgY3VycmVudCA9IGdldEN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG5cbiAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC50eXBlICE9PSBcImFjdGlvblwiKSB7XG4gICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50QWN0aW9uRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gY3VycmVudDtcbn1cblxuZnVuY3Rpb24gX2lzQWN0aW9uQ29udGV4dFRoaXNPckNoaWxkT2YoYWN0aW9uQ29udGV4dCwgc2FtZU9yUGFyZW50LCBpbmNsdWRlU2FtZSkge1xuICB2YXIgcGFyZW50SWQgPSB0eXBlb2Ygc2FtZU9yUGFyZW50ID09PSBcIm51bWJlclwiID8gc2FtZU9yUGFyZW50IDogc2FtZU9yUGFyZW50LmlkO1xuICB2YXIgY3VycmVudCA9IGluY2x1ZGVTYW1lID8gYWN0aW9uQ29udGV4dCA6IGFjdGlvbkNvbnRleHQucGFyZW50QWN0aW9uRXZlbnQ7XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBpZiAoY3VycmVudC5pZCA9PT0gcGFyZW50SWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudEFjdGlvbkV2ZW50O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIGlmIHRoZSBnaXZlbiBhY3Rpb24gY29udGV4dCBpcyBhIHBhcmVudCBvZiB0aGlzIGFjdGlvbiBjb250ZXh0LlxuICovXG5cblxuZnVuY3Rpb24gaXNBY3Rpb25Db250ZXh0Q2hpbGRPZihhY3Rpb25Db250ZXh0LCBwYXJlbnQpIHtcbiAgcmV0dXJuIF9pc0FjdGlvbkNvbnRleHRUaGlzT3JDaGlsZE9mKGFjdGlvbkNvbnRleHQsIHBhcmVudCwgZmFsc2UpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGlmIHRoZSBnaXZlbiBhY3Rpb24gY29udGV4dCBpcyB0aGlzIG9yIGEgcGFyZW50IG9mIHRoaXMgYWN0aW9uIGNvbnRleHQuXG4gKi9cblxuXG5mdW5jdGlvbiBpc0FjdGlvbkNvbnRleHRUaGlzT3JDaGlsZE9mKGFjdGlvbkNvbnRleHQsIHBhcmVudE9yVGhpcykge1xuICByZXR1cm4gX2lzQWN0aW9uQ29udGV4dFRoaXNPckNoaWxkT2YoYWN0aW9uQ29udGV4dCwgcGFyZW50T3JUaGlzLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gc2FmZVN0cmluZ2lmeSh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIHJldHVybiBcIjxVbnNlcmlhbGl6YWJsZTogXCIgKyBlICsgXCI+XCI7XG4gIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBwcmV0dHlQcmludFZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IFwiPGZ1bmN0aW9uXCIgKyAodmFsdWUubmFtZSA/IFwiIFwiICsgdmFsdWUubmFtZSA6IFwiXCIpICsgXCI+XCIgOiBpc1N0YXRlVHJlZU5vZGUodmFsdWUpID8gXCI8XCIgKyB2YWx1ZSArIFwiPlwiIDogXCJgXCIgKyBzYWZlU3RyaW5naWZ5KHZhbHVlKSArIFwiYFwiO1xufVxuXG5mdW5jdGlvbiBzaG9ydGVuUHJpbnRWYWx1ZSh2YWx1ZUluU3RyaW5nKSB7XG4gIHJldHVybiB2YWx1ZUluU3RyaW5nLmxlbmd0aCA8IDI4MCA/IHZhbHVlSW5TdHJpbmcgOiB2YWx1ZUluU3RyaW5nLnN1YnN0cmluZygwLCAyNzIpICsgXCIuLi4uLi5cIiArIHZhbHVlSW5TdHJpbmcuc3Vic3RyaW5nKHZhbHVlSW5TdHJpbmcubGVuZ3RoIC0gOCk7XG59XG5cbmZ1bmN0aW9uIHRvRXJyb3JTdHJpbmcoZXJyb3IpIHtcbiAgdmFyIHZhbHVlID0gZXJyb3IudmFsdWU7XG4gIHZhciB0eXBlID0gZXJyb3IuY29udGV4dFtlcnJvci5jb250ZXh0Lmxlbmd0aCAtIDFdLnR5cGU7XG4gIHZhciBmdWxsUGF0aCA9IGVycm9yLmNvbnRleHQubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBwYXRoID0gX2EucGF0aDtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMDtcbiAgfSkuam9pbihcIi9cIik7XG4gIHZhciBwYXRoUHJlZml4ID0gZnVsbFBhdGgubGVuZ3RoID4gMCA/IFwiYXQgcGF0aCBcXFwiL1wiICsgZnVsbFBhdGggKyBcIlxcXCIgXCIgOiBcIlwiO1xuICB2YXIgY3VycmVudFR5cGVuYW1lID0gaXNTdGF0ZVRyZWVOb2RlKHZhbHVlKSA/IFwidmFsdWUgb2YgdHlwZSBcIiArIGdldFN0YXRlVHJlZU5vZGUodmFsdWUpLnR5cGUubmFtZSArIFwiOlwiIDogaXNQcmltaXRpdmUodmFsdWUpID8gXCJ2YWx1ZVwiIDogXCJzbmFwc2hvdFwiO1xuICB2YXIgaXNTbmFwc2hvdENvbXBhdGlibGUgPSB0eXBlICYmIGlzU3RhdGVUcmVlTm9kZSh2YWx1ZSkgJiYgdHlwZS5pcyhnZXRTdGF0ZVRyZWVOb2RlKHZhbHVlKS5zbmFwc2hvdCk7XG4gIHJldHVybiBcIlwiICsgcGF0aFByZWZpeCArIGN1cnJlbnRUeXBlbmFtZSArIFwiIFwiICsgcHJldHR5UHJpbnRWYWx1ZSh2YWx1ZSkgKyBcIiBpcyBub3QgYXNzaWduYWJsZSBcIiArICh0eXBlID8gXCJ0byB0eXBlOiBgXCIgKyB0eXBlLm5hbWUgKyBcImBcIiA6IFwiXCIpICsgKGVycm9yLm1lc3NhZ2UgPyBcIiAoXCIgKyBlcnJvci5tZXNzYWdlICsgXCIpXCIgOiBcIlwiKSArICh0eXBlID8gaXNQcmltaXRpdmVUeXBlKHR5cGUpIHx8IGlzUHJpbWl0aXZlKHZhbHVlKSA/IFwiLlwiIDogXCIsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGBcIiArIHR5cGUubmFtZSArIFwiYCBvciBhIHNuYXBzaG90IGxpa2UgYFwiICsgdHlwZS5kZXNjcmliZSgpICsgXCJgIGluc3RlYWQuXCIgKyAoaXNTbmFwc2hvdENvbXBhdGlibGUgPyBcIiAoTm90ZSB0aGF0IGEgc25hcHNob3Qgb2YgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgdGFyZ2V0ZWQgdHlwZSlcIiA6IFwiXCIpIDogXCIuXCIpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JQYXRoKGNvbnRleHQsIHBhdGgsIHR5cGUpIHtcbiAgcmV0dXJuIGNvbnRleHQuY29uY2F0KFt7XG4gICAgcGF0aDogcGF0aCxcbiAgICB0eXBlOiB0eXBlXG4gIH1dKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiB0eXBlQ2hlY2tTdWNjZXNzKCkge1xuICByZXR1cm4gRU1QVFlfQVJSQVk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxuZnVuY3Rpb24gdHlwZUNoZWNrRmFpbHVyZShjb250ZXh0LCB2YWx1ZSwgbWVzc2FnZSkge1xuICByZXR1cm4gW3tcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBtZXNzYWdlOiBtZXNzYWdlXG4gIH1dO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZsYXR0ZW5UeXBlRXJyb3JzKGVycm9ycykge1xuICByZXR1cm4gZXJyb3JzLnJlZHVjZShmdW5jdGlvbiAoYSwgaSkge1xuICAgIHJldHVybiBhLmNvbmNhdChpKTtcbiAgfSwgW10pO1xufSAvLyBUT0RPOyBkb3VibGVjaGVjazogdHlwZWNoZWNrIHNob3VsZCBvbmx5IG5lZWRlZCB0byBiZSBpbnZva2VkIGZyb206IHR5cGUuY3JlYXRlIGFuZCBhcnJheSAvIG1hcCAvIHZhbHVlLnByb3BlcnR5IHdpbGwgY2hhbmdlXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiB0eXBlY2hlY2tJbnRlcm5hbCh0eXBlLCB2YWx1ZSkge1xuICAvLyBydW5zIHR5cGVDaGVja2luZyBpZiBpdCBpcyBpbiBkZXYtbW9kZSBvciB0aHJvdWdoIGEgcHJvY2Vzcy5lbnYuRU5BQkxFX1RZUEVfQ0hFQ0sgZmxhZ1xuICBpZiAoaXNUeXBlQ2hlY2tpbmdFbmFibGVkKCkpIHtcbiAgICB0eXBlY2hlY2sodHlwZSwgdmFsdWUpO1xuICB9XG59XG4vKipcbiAqIFJ1bidzIHRoZSB0eXBlY2hlY2tlciBmb3IgdGhlIGdpdmVuIHR5cGUgb24gdGhlIGdpdmVuIHZhbHVlLCB3aGljaCBjYW4gYmUgYSBzbmFwc2hvdCBvciBhbiBpbnN0YW5jZS5cbiAqIFRocm93cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGFjY29yZGluZyB0aGUgcHJvdmlkZWQgdHlwZSBzcGVjaWZpY2F0aW9uLlxuICogVXNlIHRoaXMgaWYgeW91IG5lZWQgdHlwZWNoZWNrcyBldmVuIGluIGEgcHJvZHVjdGlvbiBidWlsZCAoYnkgZGVmYXVsdCBhbGwgYXV0b21hdGljIHJ1bnRpbWUgdHlwZSBjaGVja3Mgd2lsbCBiZSBza2lwcGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzKVxuICpcbiAqIEBwYXJhbSB0eXBlIFR5cGUgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBiZSBjaGVja2VkLCBlaXRoZXIgYSBzbmFwc2hvdCBvciBhbiBpbnN0YW5jZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHR5cGVjaGVjayh0eXBlLCB2YWx1ZSkge1xuICB2YXIgZXJyb3JzID0gdHlwZS52YWxpZGF0ZSh2YWx1ZSwgW3tcbiAgICBwYXRoOiBcIlwiLFxuICAgIHR5cGU6IHR5cGVcbiAgfV0pO1xuXG4gIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IGZhaWwkMSh2YWxpZGF0aW9uRXJyb3JzVG9TdHJpbmcodHlwZSwgdmFsdWUsIGVycm9ycykpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcnNUb1N0cmluZyh0eXBlLCB2YWx1ZSwgZXJyb3JzKSB7XG4gIGlmIChlcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBcIkVycm9yIHdoaWxlIGNvbnZlcnRpbmcgXCIgKyBzaG9ydGVuUHJpbnRWYWx1ZShwcmV0dHlQcmludFZhbHVlKHZhbHVlKSkgKyBcIiB0byBgXCIgKyB0eXBlLm5hbWUgKyBcImA6XFxuXFxuICAgIFwiICsgZXJyb3JzLm1hcCh0b0Vycm9yU3RyaW5nKS5qb2luKFwiXFxuICAgIFwiKTtcbn1cblxudmFyIGlkZW50aWZpZXJDYWNoZUlkID0gMDtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxudmFyIElkZW50aWZpZXJDYWNoZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIElkZW50aWZpZXJDYWNoZSgpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWNoZUlkXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBpZGVudGlmaWVyQ2FjaGVJZCsrXG4gICAgfSk7IC8vIG4uYi4gaW4gY2FjaGUgYWxsIGlkZW50aWZpZXJzIGFyZSBub3JtYWxpemVkIHRvIHN0cmluZ3NcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhY2hlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBvYnNlcnZhYmxlLm1hcCgpXG4gICAgfSk7IC8vIGxhc3QgdGltZSB0aGUgY2FjaGUgKGFycmF5KSBmb3IgYSBnaXZlbiB0aW1lIGNoYW5nZWRcbiAgICAvLyBuLmIuIGl0IGlzIG5vdCByZWFsbHkgdGhlIHRpbWUsIGJ1dCBqdXN0IGFuIGludGVnZXIgdGhhdCBnZXRzIGluY3JlYXNlZCBhZnRlciBlYWNoIG1vZGlmaWNhdGlvbiB0byB0aGUgYXJyYXlcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhc3RDYWNoZU1vZGlmaWNhdGlvblBlcklkXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBvYnNlcnZhYmxlLm1hcCgpXG4gICAgfSk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSWRlbnRpZmllckNhY2hlLnByb3RvdHlwZSwgXCJ1cGRhdGVMYXN0Q2FjaGVNb2RpZmljYXRpb25QZXJJZFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoaWRlbnRpZmllcikge1xuICAgICAgdmFyIGxjbSA9IHRoaXMubGFzdENhY2hlTW9kaWZpY2F0aW9uUGVySWQuZ2V0KGlkZW50aWZpZXIpOyAvLyB3ZSBzdGFydCBhdCAxIHNpbmNlIDAgbWVhbnMgbm8gdXBkYXRlIHNpbmNlIGNhY2hlIGNyZWF0aW9uXG5cbiAgICAgIHRoaXMubGFzdENhY2hlTW9kaWZpY2F0aW9uUGVySWQuc2V0KGlkZW50aWZpZXIsIGxjbSA9PT0gdW5kZWZpbmVkID8gMSA6IGxjbSArIDEpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJZGVudGlmaWVyQ2FjaGUucHJvdG90eXBlLCBcImdldExhc3RDYWNoZU1vZGlmaWNhdGlvblBlcklkXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChpZGVudGlmaWVyKSB7XG4gICAgICB2YXIgbW9kaWZpY2F0aW9uSWQgPSB0aGlzLmxhc3RDYWNoZU1vZGlmaWNhdGlvblBlcklkLmdldChpZGVudGlmaWVyKSB8fCAwO1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVJZCArIFwiLVwiICsgbW9kaWZpY2F0aW9uSWQ7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aWZpZXJDYWNoZS5wcm90b3R5cGUsIFwiYWRkTm9kZVRvQ2FjaGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIGxhc3RDYWNoZVVwZGF0ZSkge1xuICAgICAgaWYgKGxhc3RDYWNoZVVwZGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RDYWNoZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmlkZW50aWZpZXJBdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBub2RlLmlkZW50aWZpZXI7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlLmhhcyhpZGVudGlmaWVyKSkge1xuICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGlkZW50aWZpZXIsIG9ic2VydmFibGUuYXJyYXkoW10sIG1vYnhTaGFsbG93KSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2V0ID0gdGhpcy5jYWNoZS5nZXQoaWRlbnRpZmllcik7XG4gICAgICAgIGlmIChzZXQuaW5kZXhPZihub2RlKSAhPT0gLTEpIHRocm93IGZhaWwkMShcIkFscmVhZHkgcmVnaXN0ZXJlZFwiKTtcbiAgICAgICAgc2V0LnB1c2gobm9kZSk7XG5cbiAgICAgICAgaWYgKGxhc3RDYWNoZVVwZGF0ZSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlTGFzdENhY2hlTW9kaWZpY2F0aW9uUGVySWQoaWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSWRlbnRpZmllckNhY2hlLnByb3RvdHlwZSwgXCJtZXJnZUNhY2hlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YWx1ZXMobm9kZS5pZGVudGlmaWVyQ2FjaGUuY2FjaGUpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHJldHVybiBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIF90aGlzLmFkZE5vZGVUb0NhY2hlKGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSWRlbnRpZmllckNhY2hlLnByb3RvdHlwZSwgXCJub3RpZnlEaWVkXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAobm9kZS5pZGVudGlmaWVyQXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBpZCA9IG5vZGUuaWRlbnRpZmllcjtcbiAgICAgICAgdmFyIHNldCA9IHRoaXMuY2FjaGUuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgc2V0LnJlbW92ZShub2RlKTsgLy8gcmVtb3ZlIGVtcHR5IHNldHMgZnJvbSBjYWNoZVxuXG4gICAgICAgICAgaWYgKCFzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShpZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy51cGRhdGVMYXN0Q2FjaGVNb2RpZmljYXRpb25QZXJJZChub2RlLmlkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aWZpZXJDYWNoZS5wcm90b3R5cGUsIFwic3BsaXRDYWNoZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHJlcyA9IG5ldyBJZGVudGlmaWVyQ2FjaGUoKTtcbiAgICAgIHZhciBiYXNlUGF0aCA9IG5vZGUucGF0aDtcbiAgICAgIGVudHJpZXModGhpcy5jYWNoZSkuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSxcbiAgICAgICAgICAgIGlkID0gX2JbMF0sXG4gICAgICAgICAgICBub2RlcyA9IF9iWzFdO1xuXG4gICAgICAgIHZhciBtb2RpZmllZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBub2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChub2Rlc1tpXS5wYXRoLmluZGV4T2YoYmFzZVBhdGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXMuYWRkTm9kZVRvQ2FjaGUobm9kZXNbaV0sIGZhbHNlKTsgLy8gbm8gbmVlZCB0byB1cGRhdGUgbGFzdFVwZGF0ZWQgc2luY2UgaXQgaXMgYSB3aG9sZSBuZXcgY2FjaGVcblxuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICAgIF90aGlzLnVwZGF0ZUxhc3RDYWNoZU1vZGlmaWNhdGlvblBlcklkKGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJZGVudGlmaWVyQ2FjaGUucHJvdG90eXBlLCBcImhhc1wiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAodHlwZSwgaWRlbnRpZmllcikge1xuICAgICAgdmFyIHNldCA9IHRoaXMuY2FjaGUuZ2V0KGlkZW50aWZpZXIpO1xuICAgICAgaWYgKCFzZXQpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBzZXQuc29tZShmdW5jdGlvbiAoY2FuZGlkYXRlKSB7XG4gICAgICAgIHJldHVybiB0eXBlLmlzQXNzaWduYWJsZUZyb20oY2FuZGlkYXRlLnR5cGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aWZpZXJDYWNoZS5wcm90b3R5cGUsIFwicmVzb2x2ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAodHlwZSwgaWRlbnRpZmllcikge1xuICAgICAgdmFyIHNldCA9IHRoaXMuY2FjaGUuZ2V0KGlkZW50aWZpZXIpO1xuICAgICAgaWYgKCFzZXQpIHJldHVybiBudWxsO1xuICAgICAgdmFyIG1hdGNoZXMgPSBzZXQuZmlsdGVyKGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUuaXNBc3NpZ25hYmxlRnJvbShjYW5kaWRhdGUudHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgc3dpdGNoIChtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBtYXRjaGVzWzBdO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgZmFpbCQxKFwiQ2Fubm90IHJlc29sdmUgYSByZWZlcmVuY2UgdG8gdHlwZSAnXCIgKyB0eXBlLm5hbWUgKyBcIicgd2l0aCBpZDogJ1wiICsgaWRlbnRpZmllciArIFwiJyB1bmFtYmlnb3VzbHksIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzOiBcIiArIG1hdGNoZXMubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gbi5wYXRoO1xuICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIElkZW50aWZpZXJDYWNoZTtcbn0oKTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3ROb2RlKHR5cGUsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgZXhpc3RpbmdOb2RlID0gZ2V0U3RhdGVUcmVlTm9kZVNhZmUoaW5pdGlhbFZhbHVlKTtcblxuICBpZiAoZXhpc3RpbmdOb2RlKSB7XG4gICAgaWYgKGV4aXN0aW5nTm9kZS5wYXJlbnQpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICB0aHJvdyBmYWlsJDEoXCJDYW5ub3QgYWRkIGFuIG9iamVjdCB0byBhIHN0YXRlIHRyZWUgaWYgaXQgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzYW1lIG9yIGFub3RoZXIgc3RhdGUgdHJlZS4gVHJpZWQgdG8gYXNzaWduIGFuIG9iamVjdCB0byAnXCIgKyAocGFyZW50ID8gcGFyZW50LnBhdGggOiBcIlwiKSArIFwiL1wiICsgc3VicGF0aCArIFwiJywgYnV0IGl0IGxpdmVzIGFscmVhZHkgYXQgJ1wiICsgZXhpc3RpbmdOb2RlLnBhdGggKyBcIidcIik7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgZXhpc3RpbmdOb2RlLnNldFBhcmVudChwYXJlbnQsIHN1YnBhdGgpO1xuICAgIH0gLy8gZWxzZSBpdCBhbHJlYWR5IGhhcyBubyBwYXJlbnQgc2luY2UgaXQgaXMgYSBwcmUtcmVxdWlzaXRlXG5cblxuICAgIHJldHVybiBleGlzdGluZ05vZGU7XG4gIH0gLy8gbm90IGEgbm9kZSwgYSBzbmFwc2hvdFxuXG5cbiAgcmV0dXJuIG5ldyBPYmplY3ROb2RlKHR5cGUsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlU2NhbGFyTm9kZSh0eXBlLCBwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBTY2FsYXJOb2RlKHR5cGUsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxuZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNjYWxhck5vZGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBPYmplY3ROb2RlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbnZhciBOb2RlTGlmZUN5Y2xlO1xuXG4oZnVuY3Rpb24gKE5vZGVMaWZlQ3ljbGUpIHtcbiAgTm9kZUxpZmVDeWNsZVtOb2RlTGlmZUN5Y2xlW1wiSU5JVElBTElaSU5HXCJdID0gMF0gPSBcIklOSVRJQUxJWklOR1wiO1xuICBOb2RlTGlmZUN5Y2xlW05vZGVMaWZlQ3ljbGVbXCJDUkVBVEVEXCJdID0gMV0gPSBcIkNSRUFURURcIjtcbiAgTm9kZUxpZmVDeWNsZVtOb2RlTGlmZUN5Y2xlW1wiRklOQUxJWkVEXCJdID0gMl0gPSBcIkZJTkFMSVpFRFwiO1xuICBOb2RlTGlmZUN5Y2xlW05vZGVMaWZlQ3ljbGVbXCJERVRBQ0hJTkdcIl0gPSAzXSA9IFwiREVUQUNISU5HXCI7XG4gIE5vZGVMaWZlQ3ljbGVbTm9kZUxpZmVDeWNsZVtcIkRFQURcIl0gPSA0XSA9IFwiREVBRFwiOyAvLyBubyBjb21pbmcgYmFjayBmcm9tIHRoaXMgb25lXG59KShOb2RlTGlmZUN5Y2xlIHx8IChOb2RlTGlmZUN5Y2xlID0ge30pKTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG5vZGUgaW4gYSBzdGF0ZSB0cmVlLlxuICogTW9yZSBwcmVjaXNlbHksIHRoYXQgaXMsIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBhXG4gKiBgdHlwZXMubW9kZWxgLCBgdHlwZXMuYXJyYXlgIG9yIGB0eXBlcy5tYXBgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBzdGF0ZSB0cmVlIG5vZGUuXG4gKi9cblxuXG5mdW5jdGlvbiBpc1N0YXRlVHJlZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLiR0cmVlbm9kZSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHZhbHVlLCBhcmdOdW1iZXIpIHtcbiAgYXNzZXJ0QXJnKHZhbHVlLCBpc1N0YXRlVHJlZU5vZGUsIFwibW9ieC1zdGF0ZS10cmVlIG5vZGVcIiwgYXJnTnVtYmVyKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTdGF0ZVRyZWVOb2RlKHZhbHVlKSB7XG4gIGlmICghaXNTdGF0ZVRyZWVOb2RlKHZhbHVlKSkge1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgdGhyb3cgZmFpbCQxKFwiVmFsdWUgXCIgKyB2YWx1ZSArIFwiIGlzIG5vIE1TVCBOb2RlXCIpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlLiR0cmVlbm9kZTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTdGF0ZVRyZWVOb2RlU2FmZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuJHRyZWVub2RlIHx8IG51bGw7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxuZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4gZ2V0U3RhdGVUcmVlTm9kZSh0aGlzKS5zbmFwc2hvdDtcbn1cblxudmFyIGRvdWJsZURvdCA9IGZ1bmN0aW9uIChfKSB7XG4gIHJldHVybiBcIi4uXCI7XG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFJlbGF0aXZlUGF0aEJldHdlZW5Ob2RlcyhiYXNlLCB0YXJnZXQpIHtcbiAgLy8gUFJFIGNvbmRpdGlvbiB0YXJnZXQgaXMgKGEgY2hpbGQgb2YpIGJhc2UhXG4gIGlmIChiYXNlLnJvb3QgIT09IHRhcmdldC5yb290KSB7XG4gICAgdGhyb3cgZmFpbCQxKFwiQ2Fubm90IGNhbGN1bGF0ZSByZWxhdGl2ZSBwYXRoOiBvYmplY3RzICdcIiArIGJhc2UgKyBcIicgYW5kICdcIiArIHRhcmdldCArIFwiJyBhcmUgbm90IHBhcnQgb2YgdGhlIHNhbWUgb2JqZWN0IHRyZWVcIik7XG4gIH1cblxuICB2YXIgYmFzZVBhcnRzID0gc3BsaXRKc29uUGF0aChiYXNlLnBhdGgpO1xuICB2YXIgdGFyZ2V0UGFydHMgPSBzcGxpdEpzb25QYXRoKHRhcmdldC5wYXRoKTtcbiAgdmFyIGNvbW1vbiA9IDA7XG5cbiAgZm9yICg7IGNvbW1vbiA8IGJhc2VQYXJ0cy5sZW5ndGg7IGNvbW1vbisrKSB7XG4gICAgaWYgKGJhc2VQYXJ0c1tjb21tb25dICE9PSB0YXJnZXRQYXJ0c1tjb21tb25dKSBicmVhaztcbiAgfSAvLyBUT0RPOiBhc3NlcnQgdGhhdCBubyB0YXJnZXRQYXJ0cyBwYXRocyBhcmUgXCIuLlwiLCBcIi5cIiBvciBcIlwiIVxuXG5cbiAgcmV0dXJuIGJhc2VQYXJ0cy5zbGljZShjb21tb24pLm1hcChkb3VibGVEb3QpLmpvaW4oXCIvXCIpICsgam9pbkpzb25QYXRoKHRhcmdldFBhcnRzLnNsaWNlKGNvbW1vbikpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVOb2RlQnlQYXRoKGJhc2UsIHBhdGgsIGZhaWxJZlJlc29sdmVGYWlscykge1xuICBpZiAoZmFpbElmUmVzb2x2ZUZhaWxzID09PSB2b2lkIDApIHtcbiAgICBmYWlsSWZSZXNvbHZlRmFpbHMgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc29sdmVOb2RlQnlQYXRoUGFydHMoYmFzZSwgc3BsaXRKc29uUGF0aChwYXRoKSwgZmFpbElmUmVzb2x2ZUZhaWxzKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiByZXNvbHZlTm9kZUJ5UGF0aFBhcnRzKGJhc2UsIHBhdGhQYXJ0cywgZmFpbElmUmVzb2x2ZUZhaWxzKSB7XG4gIGlmIChmYWlsSWZSZXNvbHZlRmFpbHMgPT09IHZvaWQgMCkge1xuICAgIGZhaWxJZlJlc29sdmVGYWlscyA9IHRydWU7XG4gIH1cblxuICB2YXIgY3VycmVudCA9IGJhc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBhdGhQYXJ0c1tpXTtcblxuICAgIGlmIChwYXJ0ID09PSBcIi4uXCIpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgIGlmIChjdXJyZW50KSBjb250aW51ZTsgLy8gbm90IGV2ZXJ5dGhpbmcgaGFzIGEgcGFyZW50XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSBcIi5cIikge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50KSB7XG4gICAgICBpZiAoY3VycmVudCBpbnN0YW5jZW9mIFNjYWxhck5vZGUpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHZhbHVlIG9mIGEgc2NhbGFyIHJlc29sdmVzIHRvIGEgc3RhdGUgdHJlZSBub2RlIChlLmcuIHJlZmVyZW5jZXMpXG4gICAgICAgIC8vIHRoZW4gd2UgY2FuIGNvbnRpbnVlIHJlc29sdmluZy4uLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGN1cnJlbnQudmFsdWU7XG5cbiAgICAgICAgICBpZiAoaXNTdGF0ZVRyZWVOb2RlKHZhbHVlKSkge1xuICAgICAgICAgICAgY3VycmVudCA9IGdldFN0YXRlVHJlZU5vZGUodmFsdWUpOyAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoIWZhaWxJZlJlc29sdmVGYWlscykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50IGluc3RhbmNlb2YgT2JqZWN0Tm9kZSkge1xuICAgICAgICB2YXIgc3ViVHlwZSA9IGN1cnJlbnQuZ2V0Q2hpbGRUeXBlKHBhcnQpO1xuXG4gICAgICAgIGlmIChzdWJUeXBlKSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuZ2V0Q2hpbGROb2RlKHBhcnQpO1xuICAgICAgICAgIGlmIChjdXJyZW50KSBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmYWlsSWZSZXNvbHZlRmFpbHMpIHRocm93IGZhaWwkMShcIkNvdWxkIG5vdCByZXNvbHZlICdcIiArIHBhcnQgKyBcIicgaW4gcGF0aCAnXCIgKyAoam9pbkpzb25QYXRoKHBhdGhQYXJ0cy5zbGljZSgwLCBpKSkgfHwgXCIvXCIpICsgXCInIHdoaWxlIHJlc29sdmluZyAnXCIgKyBqb2luSnNvblBhdGgocGF0aFBhcnRzKSArIFwiJ1wiKTtlbHNlIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gY3VycmVudDtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBjb252ZXJ0Q2hpbGROb2Rlc1RvQXJyYXkoY2hpbGROb2Rlcykge1xuICBpZiAoIWNoaWxkTm9kZXMpIHJldHVybiBFTVBUWV9BUlJBWTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjaGlsZE5vZGVzKTtcbiAgaWYgKCFrZXlzLmxlbmd0aCkgcmV0dXJuIEVNUFRZX0FSUkFZO1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGNoaWxkTm9kZXNba2V5XTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59IC8vIGJhc2VkIG9uOiBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngtdXRpbHMvYmxvYi9tYXN0ZXIvc3JjL2FzeW5jLWFjdGlvbi50c1xuXG4vKlxuICAgIEFsbCBjb250ZW50cyBvZiB0aGlzIGZpbGUgYXJlIGRlcHJlY2F0ZWQuXG5cbiAgICBUaGUgdGVybSBgcHJvY2Vzc2AgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBgZmxvd2AgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggdGhlXG4gICAgZ2xvYmFsIGBwcm9jZXNzYCBvYmplY3QuXG5cbiAgICBSZWZlciB0byBgZmxvdy50c2AgZm9yIGFueSBmdXJ0aGVyIGNoYW5nZXMgdG8gdGhpcyBpbXBsZW1lbnRhdGlvbi5cbiovXG5cblxudmFyIERFUFJFQ0FUSU9OX01FU1NBR0UgPSBcIlNlZSBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngtc3RhdGUtdHJlZS9pc3N1ZXMvMzk5IGZvciBtb3JlIGluZm9ybWF0aW9uLiBcIiArIFwiTm90ZSB0aGF0IHRoZSBtaWRkbGV3YXJlIGV2ZW50IHR5cGVzIHN0YXJ0aW5nIHdpdGggYHByb2Nlc3NgIG5vdyBzdGFydCB3aXRoIGBmbG93YC5cIjtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIEBkZXByZWNhdGVkIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGZsb3coKWAuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4LXN0YXRlLXRyZWUvaXNzdWVzLzM5OSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIE5vdGUgdGhhdCB0aGUgbWlkZGxld2FyZSBldmVudCB0eXBlcyBzdGFydGluZyB3aXRoIGBwcm9jZXNzYCBub3cgc3RhcnQgd2l0aCBgZmxvd2AuXG4gKlxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cblxuZnVuY3Rpb24gcHJvY2VzcyQxKGFzeW5jQWN0aW9uKSB7XG4gIGRlcHJlY2F0ZWQoXCJwcm9jZXNzXCIsIFwiYHByb2Nlc3MoKWAgaGFzIGJlZW4gcmVuYW1lZCB0byBgZmxvdygpYC4gXCIgKyBERVBSRUNBVElPTl9NRVNTQUdFKTtcbiAgcmV0dXJuIGZsb3coYXN5bmNBY3Rpb24pO1xufVxuXG52YXIgcGxhaW5PYmplY3RTdHJpbmcgPSBPYmplY3QudG9TdHJpbmcoKTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxudmFyIEVNUFRZX0FSUkFZID0gT2JqZWN0LmZyZWV6ZShbXSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cbnZhciBFTVBUWV9PQkpFQ1QgPSBPYmplY3QuZnJlZXplKHt9KTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxudmFyIG1vYnhTaGFsbG93ID0gX2dldEdsb2JhbFN0YXRlKCkudXNlUHJveGllcyA/IHtcbiAgZGVlcDogZmFsc2Vcbn0gOiB7XG4gIGRlZXA6IGZhbHNlLFxuICBwcm94eTogZmFsc2Vcbn07XG5PYmplY3QuZnJlZXplKG1vYnhTaGFsbG93KTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuZnVuY3Rpb24gZmFpbCQxKG1lc3NhZ2UpIHtcbiAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkge1xuICAgIG1lc3NhZ2UgPSBcIklsbGVnYWwgc3RhdGVcIjtcbiAgfVxuXG4gIHJldHVybiBuZXcgRXJyb3IoXCJbbW9ieC1zdGF0ZS10cmVlXSBcIiArIG1lc3NhZ2UpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KF8pIHtcbiAgcmV0dXJuIF87XG59XG4vKipcbiAqIHBvbGx5ZmlsbCAoZm9yIElFKSBzdWdnZXN0ZWQgaW4gTUROOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzSW50ZWdlclxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG52YXIgaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpIHx8IGlzT2JzZXJ2YWJsZUFycmF5KHZhbCk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxuZnVuY3Rpb24gYXNBcnJheSh2YWwpIHtcbiAgaWYgKCF2YWwpIHJldHVybiBFTVBUWV9BUlJBWTtcbiAgaWYgKGlzQXJyYXkodmFsKSkgcmV0dXJuIHZhbDtcbiAgcmV0dXJuIFt2YWxdO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dGVuZChhKSB7XG4gIHZhciBiID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBiW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBiW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnQpIGFba2V5XSA9IGN1cnJlbnRba2V5XTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgdmFyIF9hO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgaWYgKHByb3RvID09IG51bGwpIHJldHVybiB0cnVlO1xuICByZXR1cm4gKChfYSA9IHByb3RvLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgPT09IHBsYWluT2JqZWN0U3RyaW5nO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzTXV0YWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSwgaW5jbHVkZURhdGUpIHtcbiAgaWYgKGluY2x1ZGVEYXRlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlRGF0ZSA9IHRydWU7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgaW5jbHVkZURhdGUgJiYgdmFsdWUgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqIEZyZWV6ZSBhIHZhbHVlIGFuZCByZXR1cm4gaXQgKGlmIG5vdCBpbiBwcm9kdWN0aW9uKVxuICovXG5cblxuZnVuY3Rpb24gZnJlZXplKHZhbHVlKSB7XG4gIGlmICghZGV2TW9kZSgpKSByZXR1cm4gdmFsdWU7XG4gIHJldHVybiBpc1ByaW1pdGl2ZSh2YWx1ZSkgfHwgaXNPYnNlcnZhYmxlQXJyYXkodmFsdWUpID8gdmFsdWUgOiBPYmplY3QuZnJlZXplKHZhbHVlKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKiBSZWN1cnNpdmVseSBmcmVlemUgYSB2YWx1ZSAoaWYgbm90IGluIHByb2R1Y3Rpb24pXG4gKi9cblxuXG5mdW5jdGlvbiBkZWVwRnJlZXplKHZhbHVlKSB7XG4gIGlmICghZGV2TW9kZSgpKSByZXR1cm4gdmFsdWU7XG4gIGZyZWV6ZSh2YWx1ZSk7XG5cbiAgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKHByb3BLZXkpIHtcbiAgICAgIGlmICghaXNQcmltaXRpdmUodmFsdWVbcHJvcEtleV0pICYmICFPYmplY3QuaXNGcm96ZW4odmFsdWVbcHJvcEtleV0pKSB7XG4gICAgICAgIGRlZXBGcmVlemUodmFsdWVbcHJvcEtleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU2VyaWFsaXphYmxlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIjtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBhZGRIaWRkZW5GaW5hbFByb3Aob2JqZWN0LCBwcm9wTmFtZSwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcE5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBhZGRIaWRkZW5Xcml0YWJsZVByb3Aob2JqZWN0LCBwcm9wTmFtZSwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcE5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbnZhciBFdmVudEhhbmRsZXIgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIoKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlcnNcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IFtdXG4gICAgfSk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRIYW5kbGVyLnByb3RvdHlwZSwgXCJoYXNTdWJzY3JpYmVyc1wiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggPiAwO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRIYW5kbGVyLnByb3RvdHlwZSwgXCJyZWdpc3RlclwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoZm4sIGF0VGhlQmVnaW5uaW5nKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoYXRUaGVCZWdpbm5pbmcgPT09IHZvaWQgMCkge1xuICAgICAgICBhdFRoZUJlZ2lubmluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXRUaGVCZWdpbm5pbmcpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycy51bnNoaWZ0KGZuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaChmbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnVucmVnaXN0ZXIoZm4pO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRIYW5kbGVyLnByb3RvdHlwZSwgXCJoYXNcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5pbmRleE9mKGZuKSA+PSAwO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEhhbmRsZXIucHJvdG90eXBlLCBcInVucmVnaXN0ZXJcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmhhbmRsZXJzLmluZGV4T2YoZm4pO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50SGFuZGxlci5wcm90b3R5cGUsIFwiY2xlYXJcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5oYW5kbGVycy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEhhbmRsZXIucHJvdG90eXBlLCBcImVtaXRcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgfSAvLyBtYWtlIGEgY29weSBqdXN0IGluIGNhc2UgaXQgY2hhbmdlc1xuXG5cbiAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnMuc2xpY2UoKTtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkodm9pZCAwLCBfX3NwcmVhZChhcmdzKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gRXZlbnRIYW5kbGVyO1xufSgpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbnZhciBFdmVudEhhbmRsZXJzID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVycygpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudEhhbmRsZXJzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEhhbmRsZXJzLnByb3RvdHlwZSwgXCJoYXNTdWJzY3JpYmVyc1wiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5ldmVudEhhbmRsZXJzICYmIHRoaXMuZXZlbnRIYW5kbGVyc1tldmVudF07XG4gICAgICByZXR1cm4gISFoYW5kbGVyICYmIGhhbmRsZXIuaGFzU3Vic2NyaWJlcnM7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50SGFuZGxlcnMucHJvdG90eXBlLCBcInJlZ2lzdGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChldmVudCwgZm4sIGF0VGhlQmVnaW5uaW5nKSB7XG4gICAgICBpZiAoYXRUaGVCZWdpbm5pbmcgPT09IHZvaWQgMCkge1xuICAgICAgICBhdFRoZUJlZ2lubmluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuZXZlbnRIYW5kbGVycykge1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmV2ZW50SGFuZGxlcnNbZXZlbnRdO1xuXG4gICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlciA9IHRoaXMuZXZlbnRIYW5kbGVyc1tldmVudF0gPSBuZXcgRXZlbnRIYW5kbGVyKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYW5kbGVyLnJlZ2lzdGVyKGZuLCBhdFRoZUJlZ2lubmluZyk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50SGFuZGxlcnMucHJvdG90eXBlLCBcImhhc1wiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHRoaXMuZXZlbnRIYW5kbGVycyAmJiB0aGlzLmV2ZW50SGFuZGxlcnNbZXZlbnRdO1xuICAgICAgcmV0dXJuICEhaGFuZGxlciAmJiBoYW5kbGVyLmhhcyhmbik7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50SGFuZGxlcnMucHJvdG90eXBlLCBcInVucmVnaXN0ZXJcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmV2ZW50SGFuZGxlcnMgJiYgdGhpcy5ldmVudEhhbmRsZXJzW2V2ZW50XTtcblxuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlci51bnJlZ2lzdGVyKGZuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRIYW5kbGVycy5wcm90b3R5cGUsIFwiY2xlYXJcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5ldmVudEhhbmRsZXJzKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50SGFuZGxlcnNbZXZlbnRdO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEhhbmRsZXJzLnByb3RvdHlwZSwgXCJjbGVhckFsbFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50SGFuZGxlcnMucHJvdG90eXBlLCBcImVtaXRcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgX2E7XG5cbiAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICB9XG5cbiAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5ldmVudEhhbmRsZXJzICYmIHRoaXMuZXZlbnRIYW5kbGVyc1tldmVudF07XG5cbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIChfYSA9IGhhbmRsZXIpLmVtaXQuYXBwbHkoX2EsIF9fc3ByZWFkKGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gRXZlbnRIYW5kbGVycztcbn0oKTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBhcmdzVG9BcnJheShhcmdzKSB7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykgcmVzW2ldID0gYXJnc1tpXTtcblxuICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cmluZ1N0YXJ0c1dpdGgoc3RyLCBiZWdpbm5pbmcpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKGJlZ2lubmluZykgPT09IDA7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxudmFyIGRlcHJlY2F0ZWQgPSBmdW5jdGlvbiAoaWQsIG1lc3NhZ2UpIHtcbiAgLy8gc2tpcCBpZiBydW5uaW5nIHByb2R1Y3Rpb25cbiAgaWYgKCFkZXZNb2RlKCkpIHJldHVybjsgLy8gd2FybiBpZiBoYXNuJ3QgYmVlbiB3YXJuZWQgYmVmb3JlXG5cbiAgaWYgKGRlcHJlY2F0ZWQuaWRzICYmICFkZXByZWNhdGVkLmlkcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB3YXJuRXJyb3IoXCJEZXByZWNhdGlvbiB3YXJuaW5nOiBcIiArIG1lc3NhZ2UpO1xuICB9IC8vIG1hcmsgYXMgd2FybmVkIHRvIGF2b2lkIGR1cGxpY2F0ZSB3YXJuIG1lc3NhZ2VcblxuXG4gIGlmIChkZXByZWNhdGVkLmlkcykgZGVwcmVjYXRlZC5pZHNbaWRdID0gdHJ1ZTtcbn07XG5cbmRlcHJlY2F0ZWQuaWRzID0ge307XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIHdhcm5FcnJvcihtc2cpIHtcbiAgY29uc29sZS53YXJuKG5ldyBFcnJvcihcIlttb2J4LXN0YXRlLXRyZWVdIFwiICsgbXNnKSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxuZnVuY3Rpb24gaXNUeXBlQ2hlY2tpbmdFbmFibGVkKCkge1xuICByZXR1cm4gZGV2TW9kZSgpIHx8IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52LkVOQUJMRV9UWVBFX0NIRUNLID09PSBcInRydWVcIjtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXZNb2RlKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VydEFyZyh2YWx1ZSwgZm4sIHR5cGVOYW1lLCBhcmdOdW1iZXIpIHtcbiAgaWYgKGRldk1vZGUoKSkge1xuICAgIGlmICghZm4odmFsdWUpKSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgdGhyb3cgZmFpbCQxKFwiZXhwZWN0ZWQgXCIgKyB0eXBlTmFtZSArIFwiIGFzIGFyZ3VtZW50IFwiICsgYXNBcnJheShhcmdOdW1iZXIpLmpvaW4oXCIgb3IgXCIpICsgXCIsIGdvdCBcIiArIHZhbHVlICsgXCIgaW5zdGVhZFwiKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnRJc0Z1bmN0aW9uKHZhbHVlLCBhcmdOdW1iZXIpIHtcbiAgYXNzZXJ0QXJnKHZhbHVlLCBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCI7XG4gIH0sIFwiZnVuY3Rpb25cIiwgYXJnTnVtYmVyKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnRJc051bWJlcih2YWx1ZSwgYXJnTnVtYmVyLCBtaW4sIG1heCkge1xuICBhc3NlcnRBcmcodmFsdWUsIGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09PSBcIm51bWJlclwiO1xuICB9LCBcIm51bWJlclwiLCBhcmdOdW1iZXIpO1xuXG4gIGlmIChtaW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGFzc2VydEFyZyh2YWx1ZSwgZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBuID49IG1pbjtcbiAgICB9LCBcIm51bWJlciBncmVhdGVyIHRoYW4gXCIgKyBtaW4sIGFyZ051bWJlcik7XG4gIH1cblxuICBpZiAobWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NlcnRBcmcodmFsdWUsIGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gbiA8PSBtYXg7XG4gICAgfSwgXCJudW1iZXIgbGVzc2VyIHRoYW4gXCIgKyBtYXgsIGFyZ051bWJlcik7XG4gIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NlcnRJc1N0cmluZyh2YWx1ZSwgYXJnTnVtYmVyLCBjYW5CZUVtcHR5KSB7XG4gIGlmIChjYW5CZUVtcHR5ID09PSB2b2lkIDApIHtcbiAgICBjYW5CZUVtcHR5ID0gdHJ1ZTtcbiAgfVxuXG4gIGFzc2VydEFyZyh2YWx1ZSwgZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHMgPT09IFwic3RyaW5nXCI7XG4gIH0sIFwic3RyaW5nXCIsIGFyZ051bWJlcik7XG5cbiAgaWYgKCFjYW5CZUVtcHR5KSB7XG4gICAgYXNzZXJ0QXJnKHZhbHVlLCBmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMgIT09IFwiXCI7XG4gICAgfSwgXCJub3QgZW1wdHkgc3RyaW5nXCIsIGFyZ051bWJlcik7XG4gIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRJbW1lZGlhdGVXaXRoRmFsbGJhY2soZm4pIHtcbiAgaWYgKHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcXVldWVNaWNyb3Rhc2soZm4pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHNldEltbWVkaWF0ZShmbik7XG4gIH0gZWxzZSB7XG4gICAgc2V0VGltZW91dChmbiwgMSk7XG4gIH1cbn1cbi8qKlxuICogU2VlIFthc3luY2hyb25vdXMgYWN0aW9uc10oY29uY2VwdHMvYXN5bmMtYWN0aW9ucy5tZCkuXG4gKlxuICogQHJldHVybnMgVGhlIGZsb3cgYXMgYSBwcm9taXNlLlxuICovXG5cblxuZnVuY3Rpb24gZmxvdyhnZW5lcmF0b3IpIHtcbiAgcmV0dXJuIGNyZWF0ZUZsb3dTcGF3bmVyKGdlbmVyYXRvci5uYW1lLCBnZW5lcmF0b3IpO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBOb3QgbmVlZGVkIHNpbmNlIFRTMy42LlxuICogVXNlZCBmb3IgVHlwZVNjcmlwdCB0byBtYWtlIGZsb3dzIHRoYXQgcmV0dXJuIGEgcHJvbWlzZSByZXR1cm4gdGhlIGFjdHVhbCBwcm9taXNlIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0gdmFsXG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gY2FzdEZsb3dSZXR1cm4odmFsKSB7XG4gIHJldHVybiB2YWw7XG59XG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqIGV4cGVyaW1lbnRhbCBhcGkgLSBtaWdodCBjaGFuZ2Ugb24gbWlub3IvcGF0Y2ggcmVsZWFzZXNcbiAqXG4gKiBDb252ZXJ0IGEgcHJvbWlzZS1yZXR1cm5pbmcgZnVuY3Rpb24gdG8gYSBnZW5lcmF0b3ItcmV0dXJuaW5nIG9uZS5cbiAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYWxsb3cgZm9yIHVzYWdlIG9mIGB5aWVsZCpgIGluIGFzeW5jIGFjdGlvbnMgdG9cbiAqIHJldGFpbiB0aGUgcHJvbWlzZSByZXR1cm4gdHlwZS5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGZ1bmN0aW9uIGdldERhdGFBc3luYyhpbnB1dDogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHsgLi4uIH1cbiAqIGNvbnN0IGdldERhdGFHZW4gPSB0b0dlbmVyYXRvckZ1bmN0aW9uKGdldERhdGFBc3luYyk7XG4gKlxuICogY29uc3Qgc29tZU1vZGVsLmFjdGlvbnMoc2VsZiA9PiAoe1xuICogICBzb21lQWN0aW9uOiBmbG93KGZ1bmN0aW9uKigpIHtcbiAqICAgICAvLyB2YWx1ZSBpcyB0eXBlZCBhcyBudW1iZXJcbiAqICAgICBjb25zdCB2YWx1ZSA9IHlpZWxkKiBnZXREYXRhR2VuKFwiaW5wdXQgdmFsdWVcIik7XG4gKiAgICAgLi4uXG4gKiAgIH0pXG4gKiB9KSlcbiAqIGBgYFxuICovXG5cblxuZnVuY3Rpb24gdG9HZW5lcmF0b3JGdW5jdGlvbihwKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgIGZvciAoX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG5cbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgICAvKnlpZWxkKi9cbiAgICAgICAgICAsIHAuYXBwbHkodm9pZCAwLCBfX3NwcmVhZChhcmdzKSldO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAvKnJldHVybiovXG4gICAgICAgICAgLCBfYS5zZW50KCldO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBleHBlcmltZW50YWwgYXBpIC0gbWlnaHQgY2hhbmdlIG9uIG1pbm9yL3BhdGNoIHJlbGVhc2VzXG4gKlxuICogQ29udmVydCBhIHByb21pc2UgdG8gYSBnZW5lcmF0b3IgeWllbGRpbmcgdGhhdCBwcm9taXNlXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGFsbG93IGZvciB1c2FnZSBvZiBgeWllbGQqYCBpbiBhc3luYyBhY3Rpb25zIHRvXG4gKiByZXRhaW4gdGhlIHByb21pc2UgcmV0dXJuIHR5cGUuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBmdW5jdGlvbiBnZXREYXRhQXN5bmMoaW5wdXQ6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7IC4uLiB9XG4gKlxuICogY29uc3Qgc29tZU1vZGVsLmFjdGlvbnMoc2VsZiA9PiAoe1xuICogICBzb21lQWN0aW9uOiBmbG93KGZ1bmN0aW9uKigpIHtcbiAqICAgICAvLyB2YWx1ZSBpcyB0eXBlZCBhcyBudW1iZXJcbiAqICAgICBjb25zdCB2YWx1ZSA9IHlpZWxkKiB0b0dlbmVyYXRvcihnZXREYXRhQXN5bmMoXCJpbnB1dCB2YWx1ZVwiKSk7XG4gKiAgICAgLi4uXG4gKiAgIH0pXG4gKiB9KSlcbiAqIGBgYFxuICovXG5cblxuZnVuY3Rpb24gdG9HZW5lcmF0b3IocCkge1xuICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gWzRcbiAgICAgICAgLyp5aWVsZCovXG4gICAgICAgICwgcF07XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgIC8qcmV0dXJuKi9cbiAgICAgICAgLCBfYS5zZW50KCldO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRmxvd1NwYXduZXIobmFtZSwgZ2VuZXJhdG9yKSB7XG4gIHZhciBzcGF3bmVyID0gZnVuY3Rpb24gZmxvd1NwYXduZXIoKSB7XG4gICAgLy8gSW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3RqL2NvL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gICAgdmFyIHJ1bklkID0gZ2V0TmV4dEFjdGlvbklkKCk7XG4gICAgdmFyIHBhcmVudENvbnRleHQgPSBnZXRDdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuXG4gICAgaWYgKCFwYXJlbnRDb250ZXh0KSB7XG4gICAgICB0aHJvdyBmYWlsJDEoXCJhIG1zdCBmbG93IG11c3QgYWx3YXlzIGhhdmUgYSBwYXJlbnQgY29udGV4dFwiKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50QWN0aW9uQ29udGV4dCA9IGdldFBhcmVudEFjdGlvbkNvbnRleHQocGFyZW50Q29udGV4dCk7XG5cbiAgICBpZiAoIXBhcmVudEFjdGlvbkNvbnRleHQpIHtcbiAgICAgIHRocm93IGZhaWwkMShcImEgbXN0IGZsb3cgbXVzdCBhbHdheXMgaGF2ZSBhIHBhcmVudCBhY3Rpb24gY29udGV4dFwiKTtcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dEJhc2UgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaWQ6IHJ1bklkLFxuICAgICAgdHJlZTogcGFyZW50Q29udGV4dC50cmVlLFxuICAgICAgY29udGV4dDogcGFyZW50Q29udGV4dC5jb250ZXh0LFxuICAgICAgcGFyZW50SWQ6IHBhcmVudENvbnRleHQuaWQsXG4gICAgICBhbGxQYXJlbnRJZHM6IF9fc3ByZWFkKHBhcmVudENvbnRleHQuYWxsUGFyZW50SWRzLCBbcGFyZW50Q29udGV4dC5pZF0pLFxuICAgICAgcm9vdElkOiBwYXJlbnRDb250ZXh0LnJvb3RJZCxcbiAgICAgIHBhcmVudEV2ZW50OiBwYXJlbnRDb250ZXh0LFxuICAgICAgcGFyZW50QWN0aW9uRXZlbnQ6IHBhcmVudEFjdGlvbkNvbnRleHRcbiAgICB9O1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgZnVuY3Rpb24gd3JhcChmbiwgdHlwZSwgYXJnKSB7XG4gICAgICBmbi4kbXN0X21pZGRsZXdhcmUgPSBzcGF3bmVyLiRtc3RfbWlkZGxld2FyZTsgLy8gcGljayB1cCBhbnkgbWlkZGxld2FyZSBhdHRhY2hlZCB0byB0aGUgZmxvd1xuXG4gICAgICBydW5XaXRoQWN0aW9uQ29udGV4dChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dEJhc2UpLCB7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGFyZ3M6IFthcmddXG4gICAgICB9KSwgZm4pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuO1xuXG4gICAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uIGFzeW5jQWN0aW9uSW5pdCgpIHtcbiAgICAgICAgZ2VuID0gZ2VuZXJhdG9yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIG9uRnVsZmlsbGVkKHVuZGVmaW5lZCk7IC8vIGtpY2sgb2ZmIHRoZSBmbG93XG4gICAgICB9O1xuXG4gICAgICBpbml0LiRtc3RfbWlkZGxld2FyZSA9IHNwYXduZXIuJG1zdF9taWRkbGV3YXJlO1xuICAgICAgcnVuV2l0aEFjdGlvbkNvbnRleHQoX19hc3NpZ24oX19hc3NpZ24oe30sIGNvbnRleHRCYXNlKSwge1xuICAgICAgICB0eXBlOiBcImZsb3dfc3Bhd25cIixcbiAgICAgICAgYXJnczogYXJnc1RvQXJyYXkoYXJncylcbiAgICAgIH0pLCBpbml0KTtcblxuICAgICAgZnVuY3Rpb24gb25GdWxmaWxsZWQocmVzKSB7XG4gICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICB3cmFwKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXQgPSBnZW4ubmV4dChyKTtcbiAgICAgICAgICB9LCBcImZsb3dfcmVzdW1lXCIsIHJlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICBzZXRJbW1lZGlhdGVXaXRoRmFsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd3JhcChmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9LCBcImZsb3dfdGhyb3dcIiwgZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChyZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0ZWQoZXJyKSB7XG4gICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICB3cmFwKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXQgPSBnZW4udGhyb3cocik7XG4gICAgICAgICAgfSwgXCJmbG93X3Jlc3VtZV9lcnJvclwiLCBlcnIpOyAvLyBvciB5aWVsZEVycm9yP1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgc2V0SW1tZWRpYXRlV2l0aEZhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdyYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfSwgXCJmbG93X3Rocm93XCIsIGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQocmV0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbmV4dChyZXQpIHtcbiAgICAgICAgaWYgKHJldC5kb25lKSB7XG4gICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgc2V0SW1tZWRpYXRlV2l0aEZhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdyYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyKTtcbiAgICAgICAgICAgIH0sIFwiZmxvd19yZXR1cm5cIiwgcmV0LnZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gVE9ETzogc3VwcG9ydCBtb3JlIHR5cGUgb2YgdmFsdWVzPyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3RqL2NvL2Jsb2IvMjQ5YmJkYzcyZGEyNGFlNDQwNzZhZmQ3MTYzNDlkMjA4OWIzMWM0Yy9pbmRleC5qcyNMMTAwXG5cblxuICAgICAgICBpZiAoIXJldC52YWx1ZSB8fCB0eXBlb2YgcmV0LnZhbHVlLnRoZW4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgdGhyb3cgZmFpbCQxKFwiT25seSBwcm9taXNlcyBjYW4gYmUgeWllbGRlZCB0byBgYXN5bmNgLCBnb3Q6IFwiICsgcmV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQudmFsdWUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHNwYXduZXI7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxuZnVuY3Rpb24gc3BsaXRQYXRjaChwYXRjaCkge1xuICBpZiAoIShcIm9sZFZhbHVlXCIgaW4gcGF0Y2gpKSB0aHJvdyBmYWlsJDEoXCJQYXRjaGVzIHdpdGhvdXQgYG9sZFZhbHVlYCBmaWVsZCBjYW5ub3QgYmUgaW52ZXJzZWRcIik7XG4gIHJldHVybiBbc3RyaXBQYXRjaChwYXRjaCksIGludmVydFBhdGNoKHBhdGNoKV07XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxuZnVuY3Rpb24gc3RyaXBQYXRjaChwYXRjaCkge1xuICAvLyBzdHJpcHMgYG9sZHZhbHVlYCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBwYXRjaCwgc28gdGhhdCBpdCBiZWNvbWVzIGEgcGF0Y2ggY29uZm9ybSB0aGUganNvbi1wYXRjaCBzcGVjXG4gIC8vIHRoaXMgcmVtb3ZlcyB0aGUgYWJpbGl0eSB0byB1bmRvIHRoZSBwYXRjaFxuICBzd2l0Y2ggKHBhdGNoLm9wKSB7XG4gICAgY2FzZSBcImFkZFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgIHBhdGg6IHBhdGNoLnBhdGgsXG4gICAgICAgIHZhbHVlOiBwYXRjaC52YWx1ZVxuICAgICAgfTtcblxuICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICBwYXRoOiBwYXRjaC5wYXRoXG4gICAgICB9O1xuXG4gICAgY2FzZSBcInJlcGxhY2VcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgcGF0aDogcGF0Y2gucGF0aCxcbiAgICAgICAgdmFsdWU6IHBhdGNoLnZhbHVlXG4gICAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGludmVydFBhdGNoKHBhdGNoKSB7XG4gIHN3aXRjaCAocGF0Y2gub3ApIHtcbiAgICBjYXNlIFwiYWRkXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgICAgcGF0aDogcGF0Y2gucGF0aFxuICAgICAgfTtcblxuICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICBwYXRoOiBwYXRjaC5wYXRoLFxuICAgICAgICB2YWx1ZTogcGF0Y2gub2xkVmFsdWVcbiAgICAgIH07XG5cbiAgICBjYXNlIFwicmVwbGFjZVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICBwYXRoOiBwYXRjaC5wYXRoLFxuICAgICAgICB2YWx1ZTogcGF0Y2gub2xkVmFsdWVcbiAgICAgIH07XG4gIH1cbn1cbi8qKlxuICogU2ltcGxlIHNpbXBsZSBjaGVjayB0byBjaGVjayBpdCBpcyBhIG51bWJlci5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzTnVtYmVyKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm51bWJlclwiO1xufVxuLyoqXG4gKiBFc2NhcGUgc2xhc2hlcyBhbmQgYmFja3NsYXNoZXMuXG4gKlxuICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMVxuICovXG5cblxuZnVuY3Rpb24gZXNjYXBlSnNvblBhdGgocGF0aCkge1xuICBpZiAoaXNOdW1iZXIocGF0aCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gXCJcIiArIHBhdGg7XG4gIH1cblxuICBpZiAocGF0aC5pbmRleE9mKFwiL1wiKSA9PT0gLTEgJiYgcGF0aC5pbmRleE9mKFwiflwiKSA9PT0gLTEpIHJldHVybiBwYXRoO1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFwvL2csIFwifjFcIik7XG59XG4vKipcbiAqIFVuZXNjYXBlIHNsYXNoZXMgYW5kIGJhY2tzbGFzaGVzLlxuICovXG5cblxuZnVuY3Rpb24gdW5lc2NhcGVKc29uUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL34xL2csIFwiL1wiKS5yZXBsYWNlKC9+MC9nLCBcIn5cIik7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIGpzb24tcGF0aCBjb21wbGlhbnQganNvbiBwYXRoIGZyb20gcGF0aCBwYXJ0cy5cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICogQHJldHVybnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGpvaW5Kc29uUGF0aChwYXRoKSB7XG4gIC8vIGAvYCByZWZlcnMgdG8gcHJvcGVydHkgd2l0aCBhbiBlbXB0eSBuYW1lLCB3aGlsZSBgYCByZWZlcnMgdG8gcm9vdCBpdHNlbGYhXG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwiXCI7XG5cbiAgdmFyIGdldFBhdGhTdHIgPSBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwLm1hcChlc2NhcGVKc29uUGF0aCkuam9pbihcIi9cIik7XG4gIH07XG5cbiAgaWYgKHBhdGhbMF0gPT09IFwiLlwiIHx8IHBhdGhbMF0gPT09IFwiLi5cIikge1xuICAgIC8vIHJlbGF0aXZlXG4gICAgcmV0dXJuIGdldFBhdGhTdHIocGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYWJzb2x1dGVcbiAgICByZXR1cm4gXCIvXCIgKyBnZXRQYXRoU3RyKHBhdGgpO1xuICB9XG59XG4vKipcbiAqIFNwbGl0cyBhbmQgZGVjb2RlcyBhIGpzb24gcGF0aCBpbnRvIHNldmVyYWwgcGFydHMuXG4gKlxuICogQHBhcmFtIHBhdGhcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBzcGxpdEpzb25QYXRoKHBhdGgpIHtcbiAgLy8gYC9gIHJlZmVycyB0byBwcm9wZXJ0eSB3aXRoIGFuIGVtcHR5IG5hbWUsIHdoaWxlIGBgIHJlZmVycyB0byByb290IGl0c2VsZiFcbiAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdChcIi9cIikubWFwKHVuZXNjYXBlSnNvblBhdGgpO1xuICB2YXIgdmFsaWQgPSBwYXRoID09PSBcIlwiIHx8IHBhdGggPT09IFwiLlwiIHx8IHBhdGggPT09IFwiLi5cIiB8fCBzdHJpbmdTdGFydHNXaXRoKHBhdGgsIFwiL1wiKSB8fCBzdHJpbmdTdGFydHNXaXRoKHBhdGgsIFwiLi9cIikgfHwgc3RyaW5nU3RhcnRzV2l0aChwYXRoLCBcIi4uL1wiKTtcblxuICBpZiAoIXZhbGlkKSB7XG4gICAgdGhyb3cgZmFpbCQxKFwiYSBqc29uIHBhdGggbXVzdCBiZSBlaXRoZXIgcm9vdGVkLCBlbXB0eSBvciByZWxhdGl2ZSwgYnV0IGdvdCAnXCIgKyBwYXRoICsgXCInXCIpO1xuICB9IC8vICcvYS9iL2MnIC0+IFtcImFcIiwgXCJiXCIsIFwiY1wiXVxuICAvLyAnLi4vLi4vYi9jJyAtPiBbXCIuLlwiLCBcIi4uXCIsIFwiYlwiLCBcImNcIl1cbiAgLy8gJycgLT4gW11cbiAgLy8gJy8nIC0+IFsnJ11cbiAgLy8gJy4vYScgLT4gW1wiLlwiLCBcImFcIl1cbiAgLy8gLy4vYScgLT4gW1wiLlwiLCBcImFcIl0gZXF1aXZhbGVudCB0byAnLi9hJ1xuXG5cbiAgaWYgKHBhcnRzWzBdID09PSBcIlwiKSB7XG4gICAgcGFydHMuc2hpZnQoKTtcbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxudmFyIFNuYXBzaG90UHJvY2Vzc29yID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNuYXBzaG90UHJvY2Vzc29yLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFNuYXBzaG90UHJvY2Vzc29yKF9zdWJ0eXBlLCBfcHJvY2Vzc29ycywgbmFtZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUgfHwgX3N1YnR5cGUubmFtZSkgfHwgdGhpcztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfc3VidHlwZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogX3N1YnR5cGVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX3Byb2Nlc3NvcnNcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IF9wcm9jZXNzb3JzXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNuYXBzaG90UHJvY2Vzc29yLnByb3RvdHlwZSwgXCJmbGFnc1wiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3VidHlwZS5mbGFncyB8IFR5cGVGbGFncy5TbmFwc2hvdFByb2Nlc3NvcjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNuYXBzaG90UHJvY2Vzc29yLnByb3RvdHlwZSwgXCJkZXNjcmliZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJzbmFwc2hvdFByb2Nlc3NvcihcIiArIHRoaXMuX3N1YnR5cGUuZGVzY3JpYmUoKSArIFwiKVwiO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbmFwc2hvdFByb2Nlc3Nvci5wcm90b3R5cGUsIFwicHJlUHJvY2Vzc1NuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChzbikge1xuICAgICAgaWYgKHRoaXMuX3Byb2Nlc3NvcnMucHJlUHJvY2Vzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzb3JzLnByZVByb2Nlc3Nvci5jYWxsKG51bGwsIHNuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNuO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbmFwc2hvdFByb2Nlc3Nvci5wcm90b3R5cGUsIFwicG9zdFByb2Nlc3NTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoc24pIHtcbiAgICAgIGlmICh0aGlzLl9wcm9jZXNzb3JzLnBvc3RQcm9jZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NvcnMucG9zdFByb2Nlc3Nvci5jYWxsKG51bGwsIHNuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNuO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbmFwc2hvdFByb2Nlc3Nvci5wcm90b3R5cGUsIFwiX2ZpeE5vZGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7IC8vIHRoZSBub2RlIGhhcyB0byB1c2UgdGhlc2UgbWV0aG9kcyByYXRoZXIgdGhhbiB0aGUgb3JpZ2luYWwgdHlwZSBvbmVzXG5cblxuICAgICAgcHJveHlOb2RlVHlwZU1ldGhvZHMobm9kZS50eXBlLCB0aGlzLCBcImNyZWF0ZVwiKTtcbiAgICAgIHZhciBvbGRHZXRTbmFwc2hvdCA9IG5vZGUuZ2V0U25hcHNob3Q7XG5cbiAgICAgIG5vZGUuZ2V0U25hcHNob3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5wb3N0UHJvY2Vzc1NuYXBzaG90KG9sZEdldFNuYXBzaG90LmNhbGwobm9kZSkpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU25hcHNob3RQcm9jZXNzb3IucHJvdG90eXBlLCBcImluc3RhbnRpYXRlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciBwcm9jZXNzZWRJbml0aWFsVmFsdWUgPSBpc1N0YXRlVHJlZU5vZGUoaW5pdGlhbFZhbHVlKSA/IGluaXRpYWxWYWx1ZSA6IHRoaXMucHJlUHJvY2Vzc1NuYXBzaG90KGluaXRpYWxWYWx1ZSk7XG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5fc3VidHlwZS5pbnN0YW50aWF0ZShwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBwcm9jZXNzZWRJbml0aWFsVmFsdWUpO1xuXG4gICAgICB0aGlzLl9maXhOb2RlKG5vZGUpO1xuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU25hcHNob3RQcm9jZXNzb3IucHJvdG90eXBlLCBcInJlY29uY2lsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoY3VycmVudCwgbmV3VmFsdWUsIHBhcmVudCwgc3VicGF0aCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9zdWJ0eXBlLnJlY29uY2lsZShjdXJyZW50LCBpc1N0YXRlVHJlZU5vZGUobmV3VmFsdWUpID8gbmV3VmFsdWUgOiB0aGlzLnByZVByb2Nlc3NTbmFwc2hvdChuZXdWYWx1ZSksIHBhcmVudCwgc3VicGF0aCk7XG5cbiAgICAgIGlmIChub2RlICE9PSBjdXJyZW50KSB7XG4gICAgICAgIHRoaXMuX2ZpeE5vZGUobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbmFwc2hvdFByb2Nlc3Nvci5wcm90b3R5cGUsIFwiZ2V0U25hcHNob3RcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIGFwcGx5UG9zdFByb2Nlc3MpIHtcbiAgICAgIGlmIChhcHBseVBvc3RQcm9jZXNzID09PSB2b2lkIDApIHtcbiAgICAgICAgYXBwbHlQb3N0UHJvY2VzcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzbiA9IHRoaXMuX3N1YnR5cGUuZ2V0U25hcHNob3Qobm9kZSk7XG5cbiAgICAgIHJldHVybiBhcHBseVBvc3RQcm9jZXNzID8gdGhpcy5wb3N0UHJvY2Vzc1NuYXBzaG90KHNuKSA6IHNuO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbmFwc2hvdFByb2Nlc3Nvci5wcm90b3R5cGUsIFwiaXNWYWxpZFNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgdmFyIHByb2Nlc3NlZFNuID0gdGhpcy5wcmVQcm9jZXNzU25hcHNob3QodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnR5cGUudmFsaWRhdGUocHJvY2Vzc2VkU24sIGNvbnRleHQpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbmFwc2hvdFByb2Nlc3Nvci5wcm90b3R5cGUsIFwiZ2V0U3ViVHlwZXNcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnR5cGU7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNuYXBzaG90UHJvY2Vzc29yLnByb3RvdHlwZSwgXCJpc1wiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAodGhpbmcpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlzVHlwZSh0aGluZykgPyB0aGlzLl9zdWJ0eXBlIDogaXNTdGF0ZVRyZWVOb2RlKHRoaW5nKSA/IGdldFNuYXBzaG90KHRoaW5nLCBmYWxzZSkgOiB0aGlzLnByZVByb2Nlc3NTbmFwc2hvdCh0aGluZyk7XG4gICAgICByZXR1cm4gdGhpcy5fc3VidHlwZS52YWxpZGF0ZSh2YWx1ZSwgW3tcbiAgICAgICAgcGF0aDogXCJcIixcbiAgICAgICAgdHlwZTogdGhpcy5fc3VidHlwZVxuICAgICAgfV0pLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU25hcHNob3RQcm9jZXNzb3IucHJvdG90eXBlLCBcImlzQXNzaWduYWJsZUZyb21cIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJ0eXBlLmlzQXNzaWduYWJsZUZyb20odHlwZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFNuYXBzaG90UHJvY2Vzc29yO1xufShCYXNlVHlwZSk7XG5cbmZ1bmN0aW9uIHByb3h5Tm9kZVR5cGVNZXRob2RzKG5vZGVUeXBlLCBzbmFwc2hvdFByb2Nlc3NvclR5cGUpIHtcbiAgdmFyIGVfMSwgX2E7XG5cbiAgdmFyIG1ldGhvZHMgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIG1ldGhvZHNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cblxuICB0cnkge1xuICAgIGZvciAodmFyIG1ldGhvZHNfMSA9IF9fdmFsdWVzKG1ldGhvZHMpLCBtZXRob2RzXzFfMSA9IG1ldGhvZHNfMS5uZXh0KCk7ICFtZXRob2RzXzFfMS5kb25lOyBtZXRob2RzXzFfMSA9IG1ldGhvZHNfMS5uZXh0KCkpIHtcbiAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzXzFfMS52YWx1ZTtcbiAgICAgIG5vZGVUeXBlW21ldGhvZF0gPSBzbmFwc2hvdFByb2Nlc3NvclR5cGVbbWV0aG9kXS5iaW5kKHNuYXBzaG90UHJvY2Vzc29yVHlwZSk7XG4gICAgfVxuICB9IGNhdGNoIChlXzFfMSkge1xuICAgIGVfMSA9IHtcbiAgICAgIGVycm9yOiBlXzFfMVxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChtZXRob2RzXzFfMSAmJiAhbWV0aG9kc18xXzEuZG9uZSAmJiAoX2EgPSBtZXRob2RzXzEucmV0dXJuKSkgX2EuY2FsbChtZXRob2RzXzEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIGB0eXBlcy5zbmFwc2hvdFByb2Nlc3NvcmAgLSBSdW5zIGEgcHJlL3Bvc3Qgc25hcHNob3QgcHJvY2Vzc29yIGJlZm9yZS9hZnRlciBzZXJpYWxpemluZyBhIGdpdmVuIHR5cGUuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBUb2RvMSA9IHR5cGVzLm1vZGVsKHsgdGV4dDogdHlwZXMuc3RyaW5nIH0pXG4gKiAvLyBpbiB0aGUgYmFja2VuZCB0aGUgdGV4dCB0eXBlIG11c3QgYmUgbnVsbCB3aGVuIGVtcHR5XG4gKiBpbnRlcmZhY2UgQmFja2VuZFRvZG8ge1xuICogICAgIHRleHQ6IHN0cmluZyB8IG51bGxcbiAqIH1cbiAqIGNvbnN0IFRvZG8yID0gdHlwZXMuc25hcHNob3RQcm9jZXNzb3IoVG9kbzEsIHtcbiAqICAgICAvLyBmcm9tIHNuYXBzaG90IHRvIGluc3RhbmNlXG4gKiAgICAgcHJlUHJvY2Vzc29yKHNuOiBCYWNrZW5kVG9kbykge1xuICogICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgICAgdGV4dDogc24udGV4dCB8fCBcIlwiO1xuICogICAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICAvLyBmcm9tIGluc3RhbmNlIHRvIHNuYXBzaG90XG4gKiAgICAgcG9zdFByb2Nlc3Nvcihzbik6IEJhY2tlbmRUb2RvIHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICAgIHRleHQ6ICFzbi50ZXh0ID8gbnVsbCA6IHNuLnRleHRcbiAqICAgICAgICAgfVxuICogICAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHlwZSBUeXBlIHRvIHJ1biB0aGUgcHJvY2Vzc29ycyBvdmVyLlxuICogQHBhcmFtIHByb2Nlc3NvcnMgUHJvY2Vzc29ycyB0byBydW4uXG4gKiBAcGFyYW0gbmFtZSBUeXBlIG5hbWUsIG9yIHVuZGVmaW5lZCB0byBpbmhlcml0IHRoZSBpbm5lciB0eXBlIG9uZS5cbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBzbmFwc2hvdFByb2Nlc3Nvcih0eXBlLCBwcm9jZXNzb3JzLCBuYW1lKSB7XG4gIGFzc2VydElzVHlwZSh0eXBlLCAxKTtcblxuICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgaWYgKHByb2Nlc3NvcnMucG9zdFByb2Nlc3NvciAmJiB0eXBlb2YgcHJvY2Vzc29ycy5wb3N0UHJvY2Vzc29yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICB0aHJvdyBmYWlsKFwicG9zdFNuYXBzaG90UHJvY2Vzc29yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzc29ycy5wcmVQcm9jZXNzb3IgJiYgdHlwZW9mIHByb2Nlc3NvcnMucHJlUHJvY2Vzc29yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICB0aHJvdyBmYWlsKFwicHJlU25hcHNob3RQcm9jZXNzb3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU25hcHNob3RQcm9jZXNzb3IodHlwZSwgcHJvY2Vzc29ycywgbmFtZSk7XG59XG5cbnZhciBuZWVkc0lkZW50aWZpZXJFcnJvciA9IFwiTWFwLnB1dCBjYW4gb25seSBiZSB1c2VkIHRvIHN0b3JlIGNvbXBsZXggdmFsdWVzIHRoYXQgaGF2ZSBhbiBpZGVudGlmaWVyIHR5cGUgYXR0cmlidXRlXCI7XG5cbmZ1bmN0aW9uIHRyeUNvbGxlY3RNb2RlbFR5cGVzKHR5cGUsIG1vZGVsVHlwZXMpIHtcbiAgdmFyIGVfMSwgX2E7XG5cbiAgdmFyIHN1YnR5cGVzID0gdHlwZS5nZXRTdWJUeXBlcygpO1xuXG4gIGlmIChzdWJ0eXBlcyA9PT0gY2Fubm90RGV0ZXJtaW5lU3VidHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzdWJ0eXBlcykge1xuICAgIHZhciBzdWJ0eXBlc0FycmF5ID0gYXNBcnJheShzdWJ0eXBlcyk7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgc3VidHlwZXNBcnJheV8xID0gX192YWx1ZXMoc3VidHlwZXNBcnJheSksIHN1YnR5cGVzQXJyYXlfMV8xID0gc3VidHlwZXNBcnJheV8xLm5leHQoKTsgIXN1YnR5cGVzQXJyYXlfMV8xLmRvbmU7IHN1YnR5cGVzQXJyYXlfMV8xID0gc3VidHlwZXNBcnJheV8xLm5leHQoKSkge1xuICAgICAgICB2YXIgc3VidHlwZSA9IHN1YnR5cGVzQXJyYXlfMV8xLnZhbHVlO1xuICAgICAgICBpZiAoIXRyeUNvbGxlY3RNb2RlbFR5cGVzKHN1YnR5cGUsIG1vZGVsVHlwZXMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgIGVfMSA9IHtcbiAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc3VidHlwZXNBcnJheV8xXzEgJiYgIXN1YnR5cGVzQXJyYXlfMV8xLmRvbmUgJiYgKF9hID0gc3VidHlwZXNBcnJheV8xLnJldHVybikpIF9hLmNhbGwoc3VidHlwZXNBcnJheV8xKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSBpbnN0YW5jZW9mIE1vZGVsVHlwZSkge1xuICAgIG1vZGVsVHlwZXMucHVzaCh0eXBlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbnZhciBNYXBJZGVudGlmaWVyTW9kZTtcblxuKGZ1bmN0aW9uIChNYXBJZGVudGlmaWVyTW9kZSkge1xuICBNYXBJZGVudGlmaWVyTW9kZVtNYXBJZGVudGlmaWVyTW9kZVtcIlVOS05PV05cIl0gPSAwXSA9IFwiVU5LTk9XTlwiO1xuICBNYXBJZGVudGlmaWVyTW9kZVtNYXBJZGVudGlmaWVyTW9kZVtcIllFU1wiXSA9IDFdID0gXCJZRVNcIjtcbiAgTWFwSWRlbnRpZmllck1vZGVbTWFwSWRlbnRpZmllck1vZGVbXCJOT1wiXSA9IDJdID0gXCJOT1wiO1xufSkoTWFwSWRlbnRpZmllck1vZGUgfHwgKE1hcElkZW50aWZpZXJNb2RlID0ge30pKTtcblxudmFyIE1TVE1hcCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNU1RNYXAsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTVNUTWFwKGluaXRpYWxEYXRhKSB7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxEYXRhLCBvYnNlcnZhYmxlLnJlZi5lbmhhbmNlcikgfHwgdGhpcztcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNU1RNYXAucHJvdG90eXBlLCBcImdldFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvLyBtYXliZSB0aGlzIGlzIG92ZXItZW50aG91c2lhc3RpYz8gbm9ybWFsaXplIG51bWVyaWMga2V5cyB0byBzdHJpbmdzXG4gICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBcIlwiICsga2V5KTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTVNUTWFwLnByb3RvdHlwZSwgXCJoYXNcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuaGFzLmNhbGwodGhpcywgXCJcIiArIGtleSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1TVE1hcC5wcm90b3R5cGUsIFwiZGVsZXRlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmRlbGV0ZS5jYWxsKHRoaXMsIFwiXCIgKyBrZXkpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNU1RNYXAucHJvdG90eXBlLCBcInNldFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc2V0LmNhbGwodGhpcywgXCJcIiArIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNU1RNYXAucHJvdG90eXBlLCBcInB1dFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHRocm93IGZhaWwkMShcIk1hcC5wdXQgY2Fubm90IGJlIHVzZWQgdG8gc2V0IGVtcHR5IHZhbHVlc1wiKTtcblxuICAgICAgaWYgKGlzU3RhdGVUcmVlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKHZhbHVlKTtcblxuICAgICAgICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgICAgICAgaWYgKCFub2RlLmlkZW50aWZpZXJBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwkMShuZWVkc0lkZW50aWZpZXJFcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUuaWRlbnRpZmllciA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IGZhaWwkMShuZWVkc0lkZW50aWZpZXJFcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldChub2RlLmlkZW50aWZpZXIsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICghaXNNdXRhYmxlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBmYWlsJDEoXCJNYXAucHV0IGNhbiBvbmx5IGJlIHVzZWQgdG8gc3RvcmUgY29tcGxleCB2YWx1ZXNcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWFwTm9kZSA9IGdldFN0YXRlVHJlZU5vZGUodGhpcyk7XG4gICAgICAgIHZhciBtYXBUeXBlID0gbWFwTm9kZS50eXBlO1xuXG4gICAgICAgIGlmIChtYXBUeXBlLmlkZW50aWZpZXJNb2RlICE9PSBNYXBJZGVudGlmaWVyTW9kZS5ZRVMpIHtcbiAgICAgICAgICB0aHJvdyBmYWlsJDEobmVlZHNJZGVudGlmaWVyRXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkQXR0ciA9IG1hcFR5cGUubWFwSWRlbnRpZmllckF0dHJpYnV0ZTtcbiAgICAgICAgdmFyIGlkID0gdmFsdWVbaWRBdHRyXTtcblxuICAgICAgICBpZiAoIWlzVmFsaWRJZGVudGlmaWVyKGlkKSkge1xuICAgICAgICAgIC8vIHRyeSBhZ2FpbiBidXQgdGhpcyB0aW1lIGFmdGVyIGNyZWF0aW5nIGEgbm9kZSBmb3IgdGhlIHZhbHVlXG4gICAgICAgICAgLy8gc2luY2UgaXQgbWlnaHQgYmUgYW4gb3B0aW9uYWwgaWRlbnRpZmllclxuICAgICAgICAgIHZhciBuZXdOb2RlID0gdGhpcy5wdXQobWFwVHlwZS5nZXRDaGlsZFR5cGUoKS5jcmVhdGUodmFsdWUsIG1hcE5vZGUuZW52aXJvbm1lbnQpKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wdXQoZ2V0U25hcHNob3QobmV3Tm9kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleSA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoaWQpO1xuICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIE1TVE1hcDtcbn0oT2JzZXJ2YWJsZU1hcCk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxudmFyIE1hcFR5cGUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTWFwVHlwZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBNYXBUeXBlKG5hbWUsIF9zdWJUeXBlLCBob29rSW5pdGlhbGl6ZXJzKSB7XG4gICAgaWYgKGhvb2tJbml0aWFsaXplcnMgPT09IHZvaWQgMCkge1xuICAgICAgaG9va0luaXRpYWxpemVycyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpIHx8IHRoaXM7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX3N1YlR5cGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IF9zdWJUeXBlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImlkZW50aWZpZXJNb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBNYXBJZGVudGlmaWVyTW9kZS5VTktOT1dOXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIm1hcElkZW50aWZpZXJBdHRyaWJ1dGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJmbGFnc1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogVHlwZUZsYWdzLk1hcFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJob29rSW5pdGlhbGl6ZXJzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbXVxuICAgIH0pO1xuXG4gICAgX3RoaXMuX2RldGVybWluZUlkZW50aWZpZXJNb2RlKCk7XG5cbiAgICBfdGhpcy5ob29rSW5pdGlhbGl6ZXJzID0gaG9va0luaXRpYWxpemVycztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwiaG9va3NcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGhvb2tzKSB7XG4gICAgICB2YXIgaG9va0luaXRpYWxpemVycyA9IHRoaXMuaG9va0luaXRpYWxpemVycy5sZW5ndGggPiAwID8gdGhpcy5ob29rSW5pdGlhbGl6ZXJzLmNvbmNhdChob29rcykgOiBbaG9va3NdO1xuICAgICAgcmV0dXJuIG5ldyBNYXBUeXBlKHRoaXMubmFtZSwgdGhpcy5fc3ViVHlwZSwgaG9va0luaXRpYWxpemVycyk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHRoaXMuX2RldGVybWluZUlkZW50aWZpZXJNb2RlKCk7XG5cbiAgICAgIHJldHVybiBjcmVhdGVPYmplY3ROb2RlKHRoaXMsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcIl9kZXRlcm1pbmVJZGVudGlmaWVyTW9kZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5pZGVudGlmaWVyTW9kZSAhPT0gTWFwSWRlbnRpZmllck1vZGUuVU5LTk9XTikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtb2RlbFR5cGVzID0gW107XG5cbiAgICAgIGlmICh0cnlDb2xsZWN0TW9kZWxUeXBlcyh0aGlzLl9zdWJUeXBlLCBtb2RlbFR5cGVzKSkge1xuICAgICAgICB2YXIgaWRlbnRpZmllckF0dHJpYnV0ZV8xID0gdW5kZWZpbmVkO1xuICAgICAgICBtb2RlbFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZS5pZGVudGlmaWVyQXR0cmlidXRlKSB7XG4gICAgICAgICAgICBpZiAoaWRlbnRpZmllckF0dHJpYnV0ZV8xICYmIGlkZW50aWZpZXJBdHRyaWJ1dGVfMSAhPT0gdHlwZS5pZGVudGlmaWVyQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIlRoZSBvYmplY3RzIGluIGEgbWFwIHNob3VsZCBhbGwgaGF2ZSB0aGUgc2FtZSBpZGVudGlmaWVyIGF0dHJpYnV0ZSwgZXhwZWN0ZWQgJ1wiICsgaWRlbnRpZmllckF0dHJpYnV0ZV8xICsgXCInLCBidXQgY2hpbGQgb2YgdHlwZSAnXCIgKyB0eXBlLm5hbWUgKyBcIicgZGVjbGFyZWQgYXR0cmlidXRlICdcIiArIHR5cGUuaWRlbnRpZmllckF0dHJpYnV0ZSArIFwiJyBhcyBpZGVudGlmaWVyXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZGVudGlmaWVyQXR0cmlidXRlXzEgPSB0eXBlLmlkZW50aWZpZXJBdHRyaWJ1dGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaWRlbnRpZmllckF0dHJpYnV0ZV8xKSB7XG4gICAgICAgICAgdGhpcy5pZGVudGlmaWVyTW9kZSA9IE1hcElkZW50aWZpZXJNb2RlLllFUztcbiAgICAgICAgICB0aGlzLm1hcElkZW50aWZpZXJBdHRyaWJ1dGUgPSBpZGVudGlmaWVyQXR0cmlidXRlXzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pZGVudGlmaWVyTW9kZSA9IE1hcElkZW50aWZpZXJNb2RlLk5PO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcImluaXRpYWxpemVDaGlsZE5vZGVzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmpOb2RlLCBpbml0aWFsU25hcHNob3QpIHtcbiAgICAgIGlmIChpbml0aWFsU25hcHNob3QgPT09IHZvaWQgMCkge1xuICAgICAgICBpbml0aWFsU25hcHNob3QgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN1YlR5cGUgPSBvYmpOb2RlLnR5cGUuX3N1YlR5cGU7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBPYmplY3Qua2V5cyhpbml0aWFsU25hcHNob3QpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmVzdWx0W25hbWVdID0gc3ViVHlwZS5pbnN0YW50aWF0ZShvYmpOb2RlLCBuYW1lLCB1bmRlZmluZWQsIGluaXRpYWxTbmFwc2hvdFtuYW1lXSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcImNyZWF0ZU5ld0luc3RhbmNlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChjaGlsZE5vZGVzKSB7XG4gICAgICByZXR1cm4gbmV3IE1TVE1hcChjaGlsZE5vZGVzKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwiZmluYWxpemVOZXdJbnN0YW5jZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgaW5zdGFuY2UpIHtcbiAgICAgIF9pbnRlcmNlcHRSZWFkcyhpbnN0YW5jZSwgbm9kZS51bmJveCk7XG5cbiAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlO1xuICAgICAgdHlwZS5ob29rSW5pdGlhbGl6ZXJzLmZvckVhY2goZnVuY3Rpb24gKGluaXRpYWxpemVyKSB7XG4gICAgICAgIHZhciBob29rcyA9IGluaXRpYWxpemVyKGluc3RhbmNlKTtcbiAgICAgICAgT2JqZWN0LmtleXMoaG9va3MpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICB2YXIgaG9vayA9IGhvb2tzW25hbWVdO1xuICAgICAgICAgIHZhciBhY3Rpb25JbnZva2VyID0gY3JlYXRlQWN0aW9uSW52b2tlcihpbnN0YW5jZSwgbmFtZSwgaG9vayk7XG4gICAgICAgICAgKCFkZXZNb2RlKCkgPyBhZGRIaWRkZW5GaW5hbFByb3AgOiBhZGRIaWRkZW5Xcml0YWJsZVByb3ApKGluc3RhbmNlLCBuYW1lLCBhY3Rpb25JbnZva2VyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGludGVyY2VwdChpbnN0YW5jZSwgdGhpcy53aWxsQ2hhbmdlKTtcbiAgICAgIG9ic2VydmUoaW5zdGFuY2UsIHRoaXMuZGlkQ2hhbmdlKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwiZGVzY3JpYmVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiTWFwPHN0cmluZywgXCIgKyB0aGlzLl9zdWJUeXBlLmRlc2NyaWJlKCkgKyBcIj5cIjtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwiZ2V0Q2hpbGRyZW5cIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIC8vIHJldHVybiAobm9kZS5zdG9yZWRWYWx1ZSBhcyBPYnNlcnZhYmxlTWFwPGFueT4pLnZhbHVlcygpXG4gICAgICByZXR1cm4gdmFsdWVzKG5vZGUuc3RvcmVkVmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBUeXBlLnByb3RvdHlwZSwgXCJnZXRDaGlsZE5vZGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIGtleSkge1xuICAgICAgdmFyIGNoaWxkTm9kZSA9IG5vZGUuc3RvcmVkVmFsdWUuZ2V0KFwiXCIgKyBrZXkpO1xuICAgICAgaWYgKCFjaGlsZE5vZGUpIHRocm93IGZhaWwkMShcIk5vdCBhIGNoaWxkIFwiICsga2V5KTtcbiAgICAgIHJldHVybiBjaGlsZE5vZGU7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcIndpbGxDaGFuZ2VcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgdmFyIG5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKGNoYW5nZS5vYmplY3QpO1xuICAgICAgdmFyIGtleSA9IGNoYW5nZS5uYW1lO1xuICAgICAgbm9kZS5hc3NlcnRXcml0YWJsZSh7XG4gICAgICAgIHN1YnBhdGg6IGtleVxuICAgICAgfSk7XG4gICAgICB2YXIgbWFwVHlwZSA9IG5vZGUudHlwZTtcbiAgICAgIHZhciBzdWJUeXBlID0gbWFwVHlwZS5fc3ViVHlwZTtcblxuICAgICAgc3dpdGNoIChjaGFuZ2UudHlwZSkge1xuICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gY2hhbmdlLm9iamVjdC5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gb2xkVmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdHlwZWNoZWNrSW50ZXJuYWwoc3ViVHlwZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgY2hhbmdlLm5ld1ZhbHVlID0gc3ViVHlwZS5yZWNvbmNpbGUobm9kZS5nZXRDaGlsZE5vZGUoa2V5KSwgY2hhbmdlLm5ld1ZhbHVlLCBub2RlLCBrZXkpO1xuICAgICAgICAgICAgbWFwVHlwZS5wcm9jZXNzSWRlbnRpZmllcihrZXksIGNoYW5nZS5uZXdWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlY2hlY2tJbnRlcm5hbChzdWJUeXBlLCBjaGFuZ2UubmV3VmFsdWUpO1xuICAgICAgICAgICAgY2hhbmdlLm5ld1ZhbHVlID0gc3ViVHlwZS5pbnN0YW50aWF0ZShub2RlLCBrZXksIHVuZGVmaW5lZCwgY2hhbmdlLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIG1hcFR5cGUucHJvY2Vzc0lkZW50aWZpZXIoa2V5LCBjaGFuZ2UubmV3VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwicHJvY2Vzc0lkZW50aWZpZXJcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGV4cGVjdGVkLCBub2RlKSB7XG4gICAgICBpZiAodGhpcy5pZGVudGlmaWVyTW9kZSA9PT0gTWFwSWRlbnRpZmllck1vZGUuWUVTICYmIG5vZGUgaW5zdGFuY2VvZiBPYmplY3ROb2RlKSB7XG4gICAgICAgIHZhciBpZGVudGlmaWVyID0gbm9kZS5pZGVudGlmaWVyO1xuICAgICAgICBpZiAoaWRlbnRpZmllciAhPT0gZXhwZWN0ZWQpIHRocm93IGZhaWwkMShcIkEgbWFwIG9mIG9iamVjdHMgY29udGFpbmluZyBhbiBpZGVudGlmaWVyIHNob3VsZCBhbHdheXMgc3RvcmUgdGhlIG9iamVjdCB1bmRlciB0aGVpciBvd24gaWRlbnRpZmllci4gVHJ5aW5nIHRvIHN0b3JlIGtleSAnXCIgKyBpZGVudGlmaWVyICsgXCInLCBidXQgZXhwZWN0ZWQ6ICdcIiArIGV4cGVjdGVkICsgXCInXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBUeXBlLnByb3RvdHlwZSwgXCJnZXRTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgbm9kZS5nZXRDaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICByZXNbY2hpbGROb2RlLnN1YnBhdGhdID0gY2hpbGROb2RlLnNuYXBzaG90O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBUeXBlLnByb3RvdHlwZSwgXCJwcm9jZXNzSW5pdGlhbFNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChjaGlsZE5vZGVzKSB7XG4gICAgICB2YXIgcHJvY2Vzc2VkID0ge307XG4gICAgICBPYmplY3Qua2V5cyhjaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcHJvY2Vzc2VkW2tleV0gPSBjaGlsZE5vZGVzW2tleV0uZ2V0U25hcHNob3QoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwiZGlkQ2hhbmdlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgIHZhciBub2RlID0gZ2V0U3RhdGVUcmVlTm9kZShjaGFuZ2Uub2JqZWN0KTtcblxuICAgICAgc3dpdGNoIChjaGFuZ2UudHlwZSkge1xuICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgcmV0dXJuIHZvaWQgbm9kZS5lbWl0UGF0Y2goe1xuICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgcGF0aDogZXNjYXBlSnNvblBhdGgoY2hhbmdlLm5hbWUpLFxuICAgICAgICAgICAgdmFsdWU6IGNoYW5nZS5uZXdWYWx1ZS5zbmFwc2hvdCxcbiAgICAgICAgICAgIG9sZFZhbHVlOiBjaGFuZ2Uub2xkVmFsdWUgPyBjaGFuZ2Uub2xkVmFsdWUuc25hcHNob3QgOiB1bmRlZmluZWRcbiAgICAgICAgICB9LCBub2RlKTtcblxuICAgICAgICBjYXNlIFwiYWRkXCI6XG4gICAgICAgICAgcmV0dXJuIHZvaWQgbm9kZS5lbWl0UGF0Y2goe1xuICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICBwYXRoOiBlc2NhcGVKc29uUGF0aChjaGFuZ2UubmFtZSksXG4gICAgICAgICAgICB2YWx1ZTogY2hhbmdlLm5ld1ZhbHVlLnNuYXBzaG90LFxuICAgICAgICAgICAgb2xkVmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgIH0sIG5vZGUpO1xuXG4gICAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgICAvLyBhIG5vZGUgZ290IGRlbGV0ZWQsIGdldCB0aGUgb2xkIHNuYXBzaG90IGFuZCBtYWtlIHRoZSBub2RlIGRpZVxuICAgICAgICAgIHZhciBvbGRTbmFwc2hvdCA9IGNoYW5nZS5vbGRWYWx1ZS5zbmFwc2hvdDtcbiAgICAgICAgICBjaGFuZ2Uub2xkVmFsdWUuZGllKCk7IC8vIGVtaXQgdGhlIHBhdGNoXG5cbiAgICAgICAgICByZXR1cm4gdm9pZCBub2RlLmVtaXRQYXRjaCh7XG4gICAgICAgICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgICAgICAgIHBhdGg6IGVzY2FwZUpzb25QYXRoKGNoYW5nZS5uYW1lKSxcbiAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRTbmFwc2hvdFxuICAgICAgICAgIH0sIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBUeXBlLnByb3RvdHlwZSwgXCJhcHBseVBhdGNoTG9jYWxseVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgc3VicGF0aCwgcGF0Y2gpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBub2RlLnN0b3JlZFZhbHVlO1xuXG4gICAgICBzd2l0Y2ggKHBhdGNoLm9wKSB7XG4gICAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgY2FzZSBcInJlcGxhY2VcIjpcbiAgICAgICAgICB0YXJnZXQuc2V0KHN1YnBhdGgsIHBhdGNoLnZhbHVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgICAgdGFyZ2V0LmRlbGV0ZShzdWJwYXRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwiYXBwbHlTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgc25hcHNob3QpIHtcbiAgICAgIHR5cGVjaGVja0ludGVybmFsKHRoaXMsIHNuYXBzaG90KTtcbiAgICAgIHZhciB0YXJnZXQgPSBub2RlLnN0b3JlZFZhbHVlO1xuICAgICAgdmFyIGN1cnJlbnRLZXlzID0ge307XG4gICAgICBBcnJheS5mcm9tKHRhcmdldC5rZXlzKCkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBjdXJyZW50S2V5c1trZXldID0gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNuYXBzaG90KSB7XG4gICAgICAgIC8vIERvbid0IHVzZSB0YXJnZXQucmVwbGFjZSwgYXMgaXQgd2lsbCB0aHJvdyBhd2F5IGFsbCBleGlzdGluZyBpdGVtcyBmaXJzdFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc25hcHNob3QpIHtcbiAgICAgICAgICB0YXJnZXQuc2V0KGtleSwgc25hcHNob3Rba2V5XSk7XG4gICAgICAgICAgY3VycmVudEtleXNbXCJcIiArIGtleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5rZXlzKGN1cnJlbnRLZXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRLZXlzW2tleV0gPT09IGZhbHNlKSB0YXJnZXQuZGVsZXRlKGtleSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwiZ2V0Q2hpbGRUeXBlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJUeXBlO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBUeXBlLnByb3RvdHlwZSwgXCJpc1ZhbGlkU25hcHNob3RcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0eXBlQ2hlY2tGYWlsdXJlKGNvbnRleHQsIHZhbHVlLCBcIlZhbHVlIGlzIG5vdCBhIHBsYWluIG9iamVjdFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZsYXR0ZW5UeXBlRXJyb3JzKE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl9zdWJUeXBlLnZhbGlkYXRlKHZhbHVlW3BhdGhdLCBnZXRDb250ZXh0Rm9yUGF0aChjb250ZXh0LCBwYXRoLCBfdGhpcy5fc3ViVHlwZSkpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBUeXBlLnByb3RvdHlwZSwgXCJnZXREZWZhdWx0U25hcHNob3RcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEVNUFRZX09CSkVDVDtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwicmVtb3ZlQ2hpbGRcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIHN1YnBhdGgpIHtcbiAgICAgIG5vZGUuc3RvcmVkVmFsdWUuZGVsZXRlKHN1YnBhdGgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBNYXBUeXBlO1xufShDb21wbGV4VHlwZSk7XG5cbk1hcFR5cGUucHJvdG90eXBlLmFwcGx5U25hcHNob3QgPSBhY3Rpb24oTWFwVHlwZS5wcm90b3R5cGUuYXBwbHlTbmFwc2hvdCk7XG4vKipcbiAqIGB0eXBlcy5tYXBgIC0gQ3JlYXRlcyBhIGtleSBiYXNlZCBjb2xsZWN0aW9uIHR5cGUgd2hvJ3MgY2hpbGRyZW4gYXJlIGFsbCBvZiBhIHVuaWZvcm0gZGVjbGFyZWQgdHlwZS5cbiAqIElmIHRoZSB0eXBlIHN0b3JlZCBpbiBhIG1hcCBoYXMgYW4gaWRlbnRpZmllciwgaXQgaXMgbWFuZGF0b3J5IHRvIHN0b3JlIHRoZSBjaGlsZCB1bmRlciB0aGF0IGlkZW50aWZpZXIgaW4gdGhlIG1hcC5cbiAqXG4gKiBUaGlzIHR5cGUgd2lsbCBhbHdheXMgcHJvZHVjZSBbb2JzZXJ2YWJsZSBtYXBzXShodHRwczovL21vYnguanMub3JnL3JlZmd1aWRlL21hcC5odG1sKVxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogY29uc3QgVG9kbyA9IHR5cGVzLm1vZGVsKHtcbiAqICAgaWQ6IHR5cGVzLmlkZW50aWZpZXIsXG4gKiAgIHRhc2s6IHR5cGVzLnN0cmluZ1xuICogfSlcbiAqXG4gKiBjb25zdCBUb2RvU3RvcmUgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIHRvZG9zOiB0eXBlcy5tYXAoVG9kbylcbiAqIH0pXG4gKlxuICogY29uc3QgcyA9IFRvZG9TdG9yZS5jcmVhdGUoeyB0b2Rvczoge30gfSlcbiAqIHVucHJvdGVjdChzKVxuICogcy50b2Rvcy5zZXQoMTcsIHsgdGFzazogXCJHcmFiIGNvZmZlZVwiLCBpZDogMTcgfSlcbiAqIHMudG9kb3MucHV0KHsgdGFzazogXCJHcmFiIGNvb2tpZVwiLCBpZDogMTggfSkgLy8gcHV0IHdpbGwgaW5mZXIga2V5IGZyb20gdGhlIGlkZW50aWZpZXJcbiAqIGNvbnNvbGUubG9nKHMudG9kb3MuZ2V0KDE3KS50YXNrKSAvLyBwcmludHM6IFwiR3JhYiBjb2ZmZWVcIlxuICogYGBgXG4gKlxuICogQHBhcmFtIHN1YnR5cGVcbiAqIEByZXR1cm5zXG4gKi9cblxuZnVuY3Rpb24gbWFwKHN1YnR5cGUpIHtcbiAgcmV0dXJuIG5ldyBNYXBUeXBlKFwibWFwPHN0cmluZywgXCIgKyBzdWJ0eXBlLm5hbWUgKyBcIj5cIiwgc3VidHlwZSk7XG59XG4vKipcbiAqIFJldHVybnMgaWYgYSBnaXZlbiB2YWx1ZSByZXByZXNlbnRzIGEgbWFwIHR5cGUuXG4gKlxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBpdCBpcyBhIG1hcCB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gaXNNYXBUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGlzVHlwZSh0eXBlKSAmJiAodHlwZS5mbGFncyAmIFR5cGVGbGFncy5NYXApID4gMDtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG52YXIgQXJyYXlUeXBlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEFycmF5VHlwZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBBcnJheVR5cGUobmFtZSwgX3N1YlR5cGUsIGhvb2tJbml0aWFsaXplcnMpIHtcbiAgICBpZiAoaG9va0luaXRpYWxpemVycyA9PT0gdm9pZCAwKSB7XG4gICAgICBob29rSW5pdGlhbGl6ZXJzID0gW107XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSkgfHwgdGhpcztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfc3ViVHlwZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogX3N1YlR5cGVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZmxhZ3NcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IFR5cGVGbGFncy5BcnJheVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJob29rSW5pdGlhbGl6ZXJzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbXVxuICAgIH0pO1xuICAgIF90aGlzLmhvb2tJbml0aWFsaXplcnMgPSBob29rSW5pdGlhbGl6ZXJzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheVR5cGUucHJvdG90eXBlLCBcImhvb2tzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChob29rcykge1xuICAgICAgdmFyIGhvb2tJbml0aWFsaXplcnMgPSB0aGlzLmhvb2tJbml0aWFsaXplcnMubGVuZ3RoID4gMCA/IHRoaXMuaG9va0luaXRpYWxpemVycy5jb25jYXQoaG9va3MpIDogW2hvb2tzXTtcbiAgICAgIHJldHVybiBuZXcgQXJyYXlUeXBlKHRoaXMubmFtZSwgdGhpcy5fc3ViVHlwZSwgaG9va0luaXRpYWxpemVycyk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwiaW5zdGFudGlhdGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdE5vZGUodGhpcywgcGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlUeXBlLnByb3RvdHlwZSwgXCJpbml0aWFsaXplQ2hpbGROb2Rlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqTm9kZSwgc25hcHNob3QpIHtcbiAgICAgIGlmIChzbmFwc2hvdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNuYXBzaG90ID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBzdWJUeXBlID0gb2JqTm9kZS50eXBlLl9zdWJUeXBlO1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgc25hcHNob3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHN1YnBhdGggPSBcIlwiICsgaW5kZXg7XG4gICAgICAgIHJlc3VsdFtzdWJwYXRoXSA9IHN1YlR5cGUuaW5zdGFudGlhdGUob2JqTm9kZSwgc3VicGF0aCwgdW5kZWZpbmVkLCBpdGVtKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlUeXBlLnByb3RvdHlwZSwgXCJjcmVhdGVOZXdJbnN0YW5jZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoY2hpbGROb2Rlcykge1xuICAgICAgcmV0dXJuIG9ic2VydmFibGUuYXJyYXkoY29udmVydENoaWxkTm9kZXNUb0FycmF5KGNoaWxkTm9kZXMpLCBtb2J4U2hhbGxvdyk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwiZmluYWxpemVOZXdJbnN0YW5jZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgaW5zdGFuY2UpIHtcbiAgICAgIF9nZXRBZG1pbmlzdHJhdGlvbihpbnN0YW5jZSkuZGVoYW5jZXIgPSBub2RlLnVuYm94O1xuICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgICB0eXBlLmhvb2tJbml0aWFsaXplcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgdmFyIGhvb2tzID0gaW5pdGlhbGl6ZXIoaW5zdGFuY2UpO1xuICAgICAgICBPYmplY3Qua2V5cyhob29rcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHZhciBob29rID0gaG9va3NbbmFtZV07XG4gICAgICAgICAgdmFyIGFjdGlvbkludm9rZXIgPSBjcmVhdGVBY3Rpb25JbnZva2VyKGluc3RhbmNlLCBuYW1lLCBob29rKTtcbiAgICAgICAgICAoIWRldk1vZGUoKSA/IGFkZEhpZGRlbkZpbmFsUHJvcCA6IGFkZEhpZGRlbldyaXRhYmxlUHJvcCkoaW5zdGFuY2UsIG5hbWUsIGFjdGlvbkludm9rZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaW50ZXJjZXB0KGluc3RhbmNlLCB0aGlzLndpbGxDaGFuZ2UpO1xuICAgICAgb2JzZXJ2ZShpbnN0YW5jZSwgdGhpcy5kaWRDaGFuZ2UpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheVR5cGUucHJvdG90eXBlLCBcImRlc2NyaWJlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJUeXBlLmRlc2NyaWJlKCkgKyBcIltdXCI7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwiZ2V0Q2hpbGRyZW5cIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnN0b3JlZFZhbHVlLnNsaWNlKCk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwiZ2V0Q2hpbGROb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCBrZXkpIHtcbiAgICAgIHZhciBpbmRleCA9IE51bWJlcihrZXkpO1xuICAgICAgaWYgKGluZGV4IDwgbm9kZS5zdG9yZWRWYWx1ZS5sZW5ndGgpIHJldHVybiBub2RlLnN0b3JlZFZhbHVlW2luZGV4XTtcbiAgICAgIHRocm93IGZhaWwkMShcIk5vdCBhIGNoaWxkOiBcIiArIGtleSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwid2lsbENoYW5nZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGUoY2hhbmdlLm9iamVjdCk7XG4gICAgICBub2RlLmFzc2VydFdyaXRhYmxlKHtcbiAgICAgICAgc3VicGF0aDogXCJcIiArIGNoYW5nZS5pbmRleFxuICAgICAgfSk7XG4gICAgICB2YXIgc3ViVHlwZSA9IG5vZGUudHlwZS5fc3ViVHlwZTtcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuXG4gICAgICBzd2l0Y2ggKGNoYW5nZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLm5ld1ZhbHVlID09PSBjaGFuZ2Uub2JqZWN0W2NoYW5nZS5pbmRleF0pIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZWROb2RlcyA9IHJlY29uY2lsZUFycmF5Q2hpbGRyZW4obm9kZSwgc3ViVHlwZSwgW2NoaWxkTm9kZXNbY2hhbmdlLmluZGV4XV0sIFtjaGFuZ2UubmV3VmFsdWVdLCBbY2hhbmdlLmluZGV4XSk7XG5cbiAgICAgICAgICAgIGlmICghdXBkYXRlZE5vZGVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGFuZ2UubmV3VmFsdWUgPSB1cGRhdGVkTm9kZXNbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJzcGxpY2VcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaW5kZXhfMSA9IGNoYW5nZS5pbmRleCxcbiAgICAgICAgICAgICAgICByZW1vdmVkQ291bnQgPSBjaGFuZ2UucmVtb3ZlZENvdW50LFxuICAgICAgICAgICAgICAgIGFkZGVkID0gY2hhbmdlLmFkZGVkO1xuICAgICAgICAgICAgdmFyIGFkZGVkTm9kZXMgPSByZWNvbmNpbGVBcnJheUNoaWxkcmVuKG5vZGUsIHN1YlR5cGUsIGNoaWxkTm9kZXMuc2xpY2UoaW5kZXhfMSwgaW5kZXhfMSArIHJlbW92ZWRDb3VudCksIGFkZGVkLCBhZGRlZC5tYXAoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4XzEgKyBpO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBpZiAoIWFkZGVkTm9kZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoYW5nZS5hZGRlZCA9IGFkZGVkTm9kZXM7IC8vIHVwZGF0ZSBwYXRocyBvZiByZW1haW5pbmcgaXRlbXNcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4XzEgKyByZW1vdmVkQ291bnQ7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNoaWxkTm9kZXNbaV0uc2V0UGFyZW50KG5vZGUsIFwiXCIgKyAoaSArIGFkZGVkLmxlbmd0aCAtIHJlbW92ZWRDb3VudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlUeXBlLnByb3RvdHlwZSwgXCJnZXRTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuZ2V0Q2hpbGRyZW4oKS5tYXAoZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICByZXR1cm4gY2hpbGROb2RlLnNuYXBzaG90O1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwicHJvY2Vzc0luaXRpYWxTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoY2hpbGROb2Rlcykge1xuICAgICAgdmFyIHByb2Nlc3NlZCA9IFtdO1xuICAgICAgT2JqZWN0LmtleXMoY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHByb2Nlc3NlZC5wdXNoKGNoaWxkTm9kZXNba2V5XS5nZXRTbmFwc2hvdCgpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlUeXBlLnByb3RvdHlwZSwgXCJkaWRDaGFuZ2VcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgdmFyIG5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKGNoYW5nZS5vYmplY3QpO1xuXG4gICAgICBzd2l0Y2ggKGNoYW5nZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICByZXR1cm4gdm9pZCBub2RlLmVtaXRQYXRjaCh7XG4gICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICBwYXRoOiBcIlwiICsgY2hhbmdlLmluZGV4LFxuICAgICAgICAgICAgdmFsdWU6IGNoYW5nZS5uZXdWYWx1ZS5zbmFwc2hvdCxcbiAgICAgICAgICAgIG9sZFZhbHVlOiBjaGFuZ2Uub2xkVmFsdWUgPyBjaGFuZ2Uub2xkVmFsdWUuc25hcHNob3QgOiB1bmRlZmluZWRcbiAgICAgICAgICB9LCBub2RlKTtcblxuICAgICAgICBjYXNlIFwic3BsaWNlXCI6XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGNoYW5nZS5yZW1vdmVkQ291bnQgLSAxOyBpID49IDA7IGktLSkgbm9kZS5lbWl0UGF0Y2goe1xuICAgICAgICAgICAgb3A6IFwicmVtb3ZlXCIsXG4gICAgICAgICAgICBwYXRoOiBcIlwiICsgKGNoYW5nZS5pbmRleCArIGkpLFxuICAgICAgICAgICAgb2xkVmFsdWU6IGNoYW5nZS5yZW1vdmVkW2ldLnNuYXBzaG90XG4gICAgICAgICAgfSwgbm9kZSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZS5hZGRlZENvdW50OyBpKyspIG5vZGUuZW1pdFBhdGNoKHtcbiAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgcGF0aDogXCJcIiArIChjaGFuZ2UuaW5kZXggKyBpKSxcbiAgICAgICAgICAgIHZhbHVlOiBub2RlLmdldENoaWxkTm9kZShcIlwiICsgKGNoYW5nZS5pbmRleCArIGkpKS5zbmFwc2hvdCxcbiAgICAgICAgICAgIG9sZFZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9LCBub2RlKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlUeXBlLnByb3RvdHlwZSwgXCJhcHBseVBhdGNoTG9jYWxseVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgc3VicGF0aCwgcGF0Y2gpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBub2RlLnN0b3JlZFZhbHVlO1xuICAgICAgdmFyIGluZGV4ID0gc3VicGF0aCA9PT0gXCItXCIgPyB0YXJnZXQubGVuZ3RoIDogTnVtYmVyKHN1YnBhdGgpO1xuXG4gICAgICBzd2l0Y2ggKHBhdGNoLm9wKSB7XG4gICAgICAgIGNhc2UgXCJyZXBsYWNlXCI6XG4gICAgICAgICAgdGFyZ2V0W2luZGV4XSA9IHBhdGNoLnZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgICB0YXJnZXQuc3BsaWNlKGluZGV4LCAwLCBwYXRjaC52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcInJlbW92ZVwiOlxuICAgICAgICAgIHRhcmdldC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheVR5cGUucHJvdG90eXBlLCBcImFwcGx5U25hcHNob3RcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIHNuYXBzaG90KSB7XG4gICAgICB0eXBlY2hlY2tJbnRlcm5hbCh0aGlzLCBzbmFwc2hvdCk7XG4gICAgICB2YXIgdGFyZ2V0ID0gbm9kZS5zdG9yZWRWYWx1ZTtcbiAgICAgIHRhcmdldC5yZXBsYWNlKHNuYXBzaG90KTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlUeXBlLnByb3RvdHlwZSwgXCJnZXRDaGlsZFR5cGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YlR5cGU7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwiaXNWYWxpZFNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHlwZUNoZWNrRmFpbHVyZShjb250ZXh0LCB2YWx1ZSwgXCJWYWx1ZSBpcyBub3QgYW4gYXJyYXlcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbGF0dGVuVHlwZUVycm9ycyh2YWx1ZS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5fc3ViVHlwZS52YWxpZGF0ZShpdGVtLCBnZXRDb250ZXh0Rm9yUGF0aChjb250ZXh0LCBcIlwiICsgaW5kZXgsIF90aGlzLl9zdWJUeXBlKSk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwiZ2V0RGVmYXVsdFNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBFTVBUWV9BUlJBWTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlUeXBlLnByb3RvdHlwZSwgXCJyZW1vdmVDaGlsZFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgc3VicGF0aCkge1xuICAgICAgbm9kZS5zdG9yZWRWYWx1ZS5zcGxpY2UoTnVtYmVyKHN1YnBhdGgpLCAxKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gQXJyYXlUeXBlO1xufShDb21wbGV4VHlwZSk7XG5cbkFycmF5VHlwZS5wcm90b3R5cGUuYXBwbHlTbmFwc2hvdCA9IGFjdGlvbihBcnJheVR5cGUucHJvdG90eXBlLmFwcGx5U25hcHNob3QpO1xuLyoqXG4gKiBgdHlwZXMuYXJyYXlgIC0gQ3JlYXRlcyBhbiBpbmRleCBiYXNlZCBjb2xsZWN0aW9uIHR5cGUgd2hvJ3MgY2hpbGRyZW4gYXJlIGFsbCBvZiBhIHVuaWZvcm0gZGVjbGFyZWQgdHlwZS5cbiAqXG4gKiBUaGlzIHR5cGUgd2lsbCBhbHdheXMgcHJvZHVjZSBbb2JzZXJ2YWJsZSBhcnJheXNdKGh0dHBzOi8vbW9ieC5qcy5vcmcvcmVmZ3VpZGUvYXJyYXkuaHRtbClcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IFRvZG8gPSB0eXBlcy5tb2RlbCh7XG4gKiAgIHRhc2s6IHR5cGVzLnN0cmluZ1xuICogfSlcbiAqXG4gKiBjb25zdCBUb2RvU3RvcmUgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIHRvZG9zOiB0eXBlcy5hcnJheShUb2RvKVxuICogfSlcbiAqXG4gKiBjb25zdCBzID0gVG9kb1N0b3JlLmNyZWF0ZSh7IHRvZG9zOiBbXSB9KVxuICogdW5wcm90ZWN0KHMpIC8vIG5lZWRlZCB0byBhbGxvdyBtb2RpZnlpbmcgb3V0c2lkZSBvZiBhbiBhY3Rpb25cbiAqIHMudG9kb3MucHVzaCh7IHRhc2s6IFwiR3JhYiBjb2ZmZWVcIiB9KVxuICogY29uc29sZS5sb2cocy50b2Rvc1swXSkgLy8gcHJpbnRzOiBcIkdyYWIgY29mZmVlXCJcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzdWJ0eXBlXG4gKiBAcmV0dXJuc1xuICovXG5cbmZ1bmN0aW9uIGFycmF5KHN1YnR5cGUpIHtcbiAgYXNzZXJ0SXNUeXBlKHN1YnR5cGUsIDEpO1xuICByZXR1cm4gbmV3IEFycmF5VHlwZShzdWJ0eXBlLm5hbWUgKyBcIltdXCIsIHN1YnR5cGUpO1xufVxuXG5mdW5jdGlvbiByZWNvbmNpbGVBcnJheUNoaWxkcmVuKHBhcmVudCwgY2hpbGRUeXBlLCBvbGROb2RlcywgbmV3VmFsdWVzLCBuZXdQYXRocykge1xuICB2YXIgbm90aGluZ0NoYW5nZWQgPSB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOzsgaSsrKSB7XG4gICAgdmFyIGhhc05ld05vZGUgPSBpIDw9IG5ld1ZhbHVlcy5sZW5ndGggLSAxO1xuICAgIHZhciBvbGROb2RlID0gb2xkTm9kZXNbaV07XG4gICAgdmFyIG5ld1ZhbHVlID0gaGFzTmV3Tm9kZSA/IG5ld1ZhbHVlc1tpXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbmV3UGF0aCA9IFwiXCIgKyBuZXdQYXRoc1tpXTsgLy8gZm9yIHNvbWUgcmVhc29uLCBpbnN0ZWFkIG9mIG5ld1ZhbHVlIHdlIGdvdCBhIG5vZGUsIGZhbGxiYWNrIHRvIHRoZSBzdG9yZWRWYWx1ZVxuICAgIC8vIFRPRE86IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC1zdGF0ZS10cmVlL2lzc3Vlcy8zNDAjaXNzdWVjb21tZW50LTMyNTU4MTY4MVxuXG4gICAgaWYgKGlzTm9kZShuZXdWYWx1ZSkpIG5ld1ZhbHVlID0gbmV3VmFsdWUuc3RvcmVkVmFsdWU7XG5cbiAgICBpZiAoIW9sZE5vZGUgJiYgIWhhc05ld05vZGUpIHtcbiAgICAgIC8vIGJvdGggYXJlIGVtcHR5LCBlbmRcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoIWhhc05ld05vZGUpIHtcbiAgICAgIC8vIG5ldyBvbmUgZG9lcyBub3QgZXhpc3RzXG4gICAgICBub3RoaW5nQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgb2xkTm9kZXMuc3BsaWNlKGksIDEpO1xuXG4gICAgICBpZiAob2xkTm9kZSBpbnN0YW5jZW9mIE9iamVjdE5vZGUpIHtcbiAgICAgICAgLy8gc2luY2UgaXQgaXMgZ29pbmcgdG8gYmUgcmV0dXJuZWQgYnkgcG9wL3NwbGljZS9zaGlmdCBiZXR0ZXIgY3JlYXRlIGl0IGJlZm9yZSBraWxsaW5nIGl0XG4gICAgICAgIC8vIHNvIGl0IGRvZXNuJ3QgZW5kIHVwIGluIGFuIHVuZGVhZCBzdGF0ZVxuICAgICAgICBvbGROb2RlLmNyZWF0ZU9ic2VydmFibGVJbnN0YW5jZUlmTmVlZGVkKCk7XG4gICAgICB9XG5cbiAgICAgIG9sZE5vZGUuZGllKCk7XG4gICAgICBpLS07XG4gICAgfSBlbHNlIGlmICghb2xkTm9kZSkge1xuICAgICAgLy8gdGhlcmUgaXMgbm8gb2xkIG5vZGUsIGNyZWF0ZSBpdFxuICAgICAgLy8gY2hlY2sgaWYgYWxyZWFkeSBiZWxvbmdzIHRvIHRoZSBzYW1lIHBhcmVudC4gaWYgc28sIGF2b2lkIHB1c2hpbmcgaXRlbSBpbi4gb25seSBzd2FwcGluZyBjYW4gb2NjdXIuXG4gICAgICBpZiAoaXNTdGF0ZVRyZWVOb2RlKG5ld1ZhbHVlKSAmJiBnZXRTdGF0ZVRyZWVOb2RlKG5ld1ZhbHVlKS5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgICAvLyB0aGlzIG5vZGUgaXMgb3duZWQgYnkgdGhpcyBwYXJlbnQsIGJ1dCBub3QgaW4gdGhlIHJlY29uY2lsYWJsZSBzZXQsIHNvIGl0IG11c3QgYmUgZG91YmxlXG4gICAgICAgIHRocm93IGZhaWwkMShcIkNhbm5vdCBhZGQgYW4gb2JqZWN0IHRvIGEgc3RhdGUgdHJlZSBpZiBpdCBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIHNhbWUgb3IgYW5vdGhlciBzdGF0ZSB0cmVlLiBUcmllZCB0byBhc3NpZ24gYW4gb2JqZWN0IHRvICdcIiArIHBhcmVudC5wYXRoICsgXCIvXCIgKyBuZXdQYXRoICsgXCInLCBidXQgaXQgbGl2ZXMgYWxyZWFkeSBhdCAnXCIgKyBnZXRTdGF0ZVRyZWVOb2RlKG5ld1ZhbHVlKS5wYXRoICsgXCInXCIpO1xuICAgICAgfVxuXG4gICAgICBub3RoaW5nQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgdmFyIG5ld05vZGUgPSB2YWx1ZUFzTm9kZShjaGlsZFR5cGUsIHBhcmVudCwgbmV3UGF0aCwgbmV3VmFsdWUpO1xuICAgICAgb2xkTm9kZXMuc3BsaWNlKGksIDAsIG5ld05vZGUpO1xuICAgIH0gZWxzZSBpZiAoYXJlU2FtZShvbGROb2RlLCBuZXdWYWx1ZSkpIHtcbiAgICAgIC8vIGJvdGggYXJlIHRoZSBzYW1lLCByZWNvbmNpbGVcbiAgICAgIG9sZE5vZGVzW2ldID0gdmFsdWVBc05vZGUoY2hpbGRUeXBlLCBwYXJlbnQsIG5ld1BhdGgsIG5ld1ZhbHVlLCBvbGROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm90aGluZyB0byBkbywgdHJ5IHRvIHJlb3JkZXJcbiAgICAgIHZhciBvbGRNYXRjaCA9IHVuZGVmaW5lZDsgLy8gZmluZCBhIHBvc3NpYmxlIGNhbmRpZGF0ZSB0byByZXVzZVxuXG4gICAgICBmb3IgKHZhciBqID0gaTsgaiA8IG9sZE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChhcmVTYW1lKG9sZE5vZGVzW2pdLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgICBvbGRNYXRjaCA9IG9sZE5vZGVzLnNwbGljZShqLCAxKVswXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub3RoaW5nQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgdmFyIG5ld05vZGUgPSB2YWx1ZUFzTm9kZShjaGlsZFR5cGUsIHBhcmVudCwgbmV3UGF0aCwgbmV3VmFsdWUsIG9sZE1hdGNoKTtcbiAgICAgIG9sZE5vZGVzLnNwbGljZShpLCAwLCBuZXdOb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm90aGluZ0NoYW5nZWQgPyBudWxsIDogb2xkTm9kZXM7XG59XG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIG5vZGUgYXQgZ2l2ZW4gcGFyZW50IGFuZCBzdWJwYXRoLiBBdHRlbXB0cyB0byByZXVzZSBvbGQgbm9kZSBpZiBwb3NzaWJsZSBhbmQgZ2l2ZW4uXG4gKi9cblxuXG5mdW5jdGlvbiB2YWx1ZUFzTm9kZShjaGlsZFR5cGUsIHBhcmVudCwgc3VicGF0aCwgbmV3VmFsdWUsIG9sZE5vZGUpIHtcbiAgLy8gZW5zdXJlIHRoZSB2YWx1ZSBpcyB2YWxpZC1pc2hcbiAgdHlwZWNoZWNrSW50ZXJuYWwoY2hpbGRUeXBlLCBuZXdWYWx1ZSk7XG5cbiAgZnVuY3Rpb24gZ2V0TmV3Tm9kZSgpIHtcbiAgICAvLyB0aGUgbmV3IHZhbHVlIGhhcyBhIE1TVCBub2RlXG4gICAgaWYgKGlzU3RhdGVUcmVlTm9kZShuZXdWYWx1ZSkpIHtcbiAgICAgIHZhciBjaGlsZE5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKG5ld1ZhbHVlKTtcbiAgICAgIGNoaWxkTm9kZS5hc3NlcnRBbGl2ZShFTVBUWV9PQkpFQ1QpOyAvLyB0aGUgbm9kZSBsaXZlcyBoZXJlXG5cbiAgICAgIGlmIChjaGlsZE5vZGUucGFyZW50ICE9PSBudWxsICYmIGNoaWxkTm9kZS5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgICBjaGlsZE5vZGUuc2V0UGFyZW50KHBhcmVudCwgc3VicGF0aCk7XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGU7XG4gICAgICB9XG4gICAgfSAvLyB0aGVyZSBpcyBvbGQgbm9kZSBhbmQgbmV3IG9uZSBpcyBhIHZhbHVlL3NuYXBzaG90XG5cblxuICAgIGlmIChvbGROb2RlKSB7XG4gICAgICByZXR1cm4gY2hpbGRUeXBlLnJlY29uY2lsZShvbGROb2RlLCBuZXdWYWx1ZSwgcGFyZW50LCBzdWJwYXRoKTtcbiAgICB9IC8vIG5vdGhpbmcgdG8gZG8sIGNyZWF0ZSBmcm9tIHNjcmF0Y2hcblxuXG4gICAgcmV0dXJuIGNoaWxkVHlwZS5pbnN0YW50aWF0ZShwYXJlbnQsIHN1YnBhdGgsIHVuZGVmaW5lZCwgbmV3VmFsdWUpO1xuICB9XG5cbiAgdmFyIG5ld05vZGUgPSBnZXROZXdOb2RlKCk7XG5cbiAgaWYgKG9sZE5vZGUgJiYgb2xkTm9kZSAhPT0gbmV3Tm9kZSkge1xuICAgIGlmIChvbGROb2RlIGluc3RhbmNlb2YgT2JqZWN0Tm9kZSkge1xuICAgICAgLy8gc2luY2UgaXQgaXMgZ29pbmcgdG8gYmUgcmV0dXJuZWQgYnkgcG9wL3NwbGljZS9zaGlmdCBiZXR0ZXIgY3JlYXRlIGl0IGJlZm9yZSBraWxsaW5nIGl0XG4gICAgICAvLyBzbyBpdCBkb2Vzbid0IGVuZCB1cCBpbiBhbiB1bmRlYWQgc3RhdGVcbiAgICAgIG9sZE5vZGUuY3JlYXRlT2JzZXJ2YWJsZUluc3RhbmNlSWZOZWVkZWQoKTtcbiAgICB9XG5cbiAgICBvbGROb2RlLmRpZSgpO1xuICB9XG5cbiAgcmV0dXJuIG5ld05vZGU7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBob2xkcyBhIHZhbHVlLlxuICovXG5cblxuZnVuY3Rpb24gYXJlU2FtZShvbGROb2RlLCBuZXdWYWx1ZSkge1xuICAvLyBuZXZlciBjb25zaWRlciBkZWFkIG9sZCBub2RlcyBmb3IgcmVjb25jaWxpYXRpb25cbiAgaWYgKCFvbGROb2RlLmlzQWxpdmUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gdGhlIG5ldyB2YWx1ZSBoYXMgdGhlIHNhbWUgbm9kZVxuXG5cbiAgaWYgKGlzU3RhdGVUcmVlTm9kZShuZXdWYWx1ZSkpIHtcbiAgICB2YXIgbmV3Tm9kZSA9IGdldFN0YXRlVHJlZU5vZGUobmV3VmFsdWUpO1xuICAgIHJldHVybiBuZXdOb2RlLmlzQWxpdmUgJiYgbmV3Tm9kZSA9PT0gb2xkTm9kZTtcbiAgfSAvLyB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgdGhlIHNuYXBzaG90IG9mIHRoZSBvbGQgbm9kZVxuXG5cbiAgaWYgKG9sZE5vZGUuc25hcHNob3QgPT09IG5ld1ZhbHVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gbmV3IHZhbHVlIGlzIGEgc25hcHNob3Qgd2l0aCB0aGUgY29ycmVjdCBpZGVudGlmaWVyXG5cblxuICByZXR1cm4gb2xkTm9kZSBpbnN0YW5jZW9mIE9iamVjdE5vZGUgJiYgb2xkTm9kZS5pZGVudGlmaWVyICE9PSBudWxsICYmIG9sZE5vZGUuaWRlbnRpZmllckF0dHJpYnV0ZSAmJiBpc1BsYWluT2JqZWN0KG5ld1ZhbHVlKSAmJiBvbGROb2RlLmlkZW50aWZpZXIgPT09IG5vcm1hbGl6ZUlkZW50aWZpZXIobmV3VmFsdWVbb2xkTm9kZS5pZGVudGlmaWVyQXR0cmlidXRlXSkgJiYgb2xkTm9kZS50eXBlLmlzKG5ld1ZhbHVlKTtcbn1cbi8qKlxuICogUmV0dXJucyBpZiBhIGdpdmVuIHZhbHVlIHJlcHJlc2VudHMgYW4gYXJyYXkgdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB0eXBlIGlzIGFuIGFycmF5IHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5VHlwZSh0eXBlKSB7XG4gIHJldHVybiBpc1R5cGUodHlwZSkgJiYgKHR5cGUuZmxhZ3MgJiBUeXBlRmxhZ3MuQXJyYXkpID4gMDtcbn1cblxudmFyIFBSRV9QUk9DRVNTX1NOQVBTSE9UID0gXCJwcmVQcm9jZXNzU25hcHNob3RcIjtcbnZhciBQT1NUX1BST0NFU1NfU05BUFNIT1QgPSBcInBvc3RQcm9jZXNzU25hcHNob3RcIjtcblxuZnVuY3Rpb24gb2JqZWN0VHlwZVRvU3RyaW5nKCkge1xuICByZXR1cm4gZ2V0U3RhdGVUcmVlTm9kZSh0aGlzKS50b1N0cmluZygpO1xufVxuXG52YXIgZGVmYXVsdE9iamVjdE9wdGlvbnMgPSB7XG4gIG5hbWU6IFwiQW5vbnltb3VzTW9kZWxcIixcbiAgcHJvcGVydGllczoge30sXG4gIGluaXRpYWxpemVyczogRU1QVFlfQVJSQVlcbn07XG5cbmZ1bmN0aW9uIHRvUHJvcGVydGllc09iamVjdChkZWNsYXJlZFByb3BzKSB7XG4gIC8vIGxvb3AgdGhyb3VnaCBwcm9wZXJ0aWVzIGFuZCBlbnN1cmVzIHRoYXQgYWxsIGl0ZW1zIGFyZSB0eXBlc1xuICByZXR1cm4gT2JqZWN0LmtleXMoZGVjbGFyZWRQcm9wcykucmVkdWNlKGZ1bmN0aW9uIChwcm9wcywga2V5KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7IC8vIHdhcm4gaWYgdXNlciBpbnRlbmRlZCBhIEhPT0tcblxuXG4gICAgaWYgKGtleSBpbiBIb29rKSB0aHJvdyBmYWlsJDEoXCJIb29rICdcIiArIGtleSArIFwiJyB3YXMgZGVmaW5lZCBhcyBwcm9wZXJ0eS4gSG9va3Mgc2hvdWxkIGJlIGRlZmluZWQgYXMgcGFydCBvZiB0aGUgYWN0aW9uc1wiKTsgLy8gdGhlIHVzZXIgaW50ZW5kZWQgdG8gdXNlIGEgdmlld1xuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3BzLCBrZXkpO1xuXG4gICAgaWYgKFwiZ2V0XCIgaW4gZGVzY3JpcHRvcikge1xuICAgICAgdGhyb3cgZmFpbCQxKFwiR2V0dGVycyBhcmUgbm90IHN1cHBvcnRlZCBhcyBwcm9wZXJ0aWVzLiBQbGVhc2UgdXNlIHZpZXdzIGluc3RlYWRcIik7XG4gICAgfSAvLyB1bmRlZmluZWQgYW5kIG51bGwgYXJlIG5vdCB2YWxpZFxuXG5cbiAgICB2YXIgdmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IGZhaWwkMShcIlRoZSBkZWZhdWx0IHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgYXMgdGhlIHR5cGUgY2Fubm90IGJlIGluZmVycmVkLiBEaWQgeW91IG1lYW4gYHR5cGVzLm1heWJlKHNvbWVUeXBlKWA/XCIpOyAvLyBpdHMgYSBwcmltaXRpdmUsIGNvbnZlcnQgdG8gaXRzIHR5cGVcbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCAoX2EgPSB7fSwgX2Fba2V5XSA9IG9wdGlvbmFsKGdldFByaW1pdGl2ZUZhY3RvcnlGcm9tVmFsdWUodmFsdWUpLCB2YWx1ZSksIF9hKSk7IC8vIG1hcCBkZWZhdWx0cyB0byBlbXB0eSBvYmplY3QgYXV0b21hdGljYWxseSBmb3IgbW9kZWxzXG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcFR5cGUpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgKF9iID0ge30sIF9iW2tleV0gPSBvcHRpb25hbCh2YWx1ZSwge30pLCBfYikpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheVR5cGUpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgKF9jID0ge30sIF9jW2tleV0gPSBvcHRpb25hbCh2YWx1ZSwgW10pLCBfYykpOyAvLyBpdHMgYWxyZWFkeSBhIHR5cGVcbiAgICB9IGVsc2UgaWYgKGlzVHlwZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBwcm9wczsgLy8gaXRzIGEgZnVuY3Rpb24sIG1heWJlIHRoZSB1c2VyIHdhbnRlZCBhIHZpZXc/XG4gICAgfSBlbHNlIGlmIChkZXZNb2RlKCkgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IGZhaWwkMShcIkludmFsaWQgdHlwZSBkZWZpbml0aW9uIGZvciBwcm9wZXJ0eSAnXCIgKyBrZXkgKyBcIicsIGl0IGxvb2tzIGxpa2UgeW91IHBhc3NlZCBhIGZ1bmN0aW9uLiBEaWQgeW91IGZvcmdldCB0byBpbnZva2UgaXQsIG9yIGRpZCB5b3UgaW50ZW5kIHRvIGRlY2xhcmUgYSB2aWV3IC8gYWN0aW9uP1wiKTsgLy8gbm8gb3RoZXIgY29tcGxleCB2YWx1ZXNcbiAgICB9IGVsc2UgaWYgKGRldk1vZGUoKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IGZhaWwkMShcIkludmFsaWQgdHlwZSBkZWZpbml0aW9uIGZvciBwcm9wZXJ0eSAnXCIgKyBrZXkgKyBcIicsIGl0IGxvb2tzIGxpa2UgeW91IHBhc3NlZCBhbiBvYmplY3QuIFRyeSBwYXNzaW5nIGFub3RoZXIgbW9kZWwgdHlwZSBvciBhIHR5cGVzLmZyb3plbi5cIik7IC8vIFdURiBkaWQgeW91IHBhc3MgaW4gbWF0ZT9cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZmFpbCQxKFwiSW52YWxpZCB0eXBlIGRlZmluaXRpb24gZm9yIHByb3BlcnR5ICdcIiArIGtleSArIFwiJywgY2Fubm90IGluZmVyIGEgdHlwZSBmcm9tIGEgdmFsdWUgbGlrZSAnXCIgKyB2YWx1ZSArIFwiJyAoXCIgKyB0eXBlb2YgdmFsdWUgKyBcIilcIik7XG4gICAgfVxuICB9LCBkZWNsYXJlZFByb3BzKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG52YXIgTW9kZWxUeXBlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKE1vZGVsVHlwZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBNb2RlbFR5cGUob3B0cykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMubmFtZSB8fCBkZWZhdWx0T2JqZWN0T3B0aW9ucy5uYW1lKSB8fCB0aGlzO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImZsYWdzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBUeXBlRmxhZ3MuT2JqZWN0XG4gICAgfSk7XG4gICAgLypcbiAgICAgKiBUaGUgb3JpZ2luYWwgb2JqZWN0IGRlZmluaXRpb25cbiAgICAgKi9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpbml0aWFsaXplcnNcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJwcm9wZXJ0aWVzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicHJlUHJvY2Vzc29yXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicG9zdFByb2Nlc3NvclwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcInByb3BlcnR5TmFtZXNcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJuYW1lZFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmNsb25lQW5kRW5oYW5jZSh7XG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicHJvcHNcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5jbG9uZUFuZEVuaGFuY2Uoe1xuICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcInByZVByb2Nlc3NTbmFwc2hvdFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHByZVByb2Nlc3Nvcikge1xuICAgICAgICB2YXIgY3VycmVudFByZXByb2Nlc3NvciA9IF90aGlzLnByZVByb2Nlc3NvcjtcbiAgICAgICAgaWYgKCFjdXJyZW50UHJlcHJvY2Vzc29yKSByZXR1cm4gX3RoaXMuY2xvbmVBbmRFbmhhbmNlKHtcbiAgICAgICAgICBwcmVQcm9jZXNzb3I6IHByZVByb2Nlc3NvclxuICAgICAgICB9KTtlbHNlIHJldHVybiBfdGhpcy5jbG9uZUFuZEVuaGFuY2Uoe1xuICAgICAgICAgIHByZVByb2Nlc3NvcjogZnVuY3Rpb24gKHNuYXBzaG90KSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFByZXByb2Nlc3NvcihwcmVQcm9jZXNzb3Ioc25hcHNob3QpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJwb3N0UHJvY2Vzc1NuYXBzaG90XCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAocG9zdFByb2Nlc3Nvcikge1xuICAgICAgICB2YXIgY3VycmVudFBvc3Rwcm9jZXNzb3IgPSBfdGhpcy5wb3N0UHJvY2Vzc29yO1xuICAgICAgICBpZiAoIWN1cnJlbnRQb3N0cHJvY2Vzc29yKSByZXR1cm4gX3RoaXMuY2xvbmVBbmRFbmhhbmNlKHtcbiAgICAgICAgICBwb3N0UHJvY2Vzc29yOiBwb3N0UHJvY2Vzc29yXG4gICAgICAgIH0pO2Vsc2UgcmV0dXJuIF90aGlzLmNsb25lQW5kRW5oYW5jZSh7XG4gICAgICAgICAgcG9zdFByb2Nlc3NvcjogZnVuY3Rpb24gKHNuYXBzaG90KSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3NvcihjdXJyZW50UG9zdHByb2Nlc3NvcihzbmFwc2hvdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihfdGhpcywgZGVmYXVsdE9iamVjdE9wdGlvbnMsIG9wdHMpOyAvLyBlbnN1cmVzIHRoYXQgYW55IGRlZmF1bHQgdmFsdWUgZ2V0cyBjb252ZXJ0ZWQgdG8gaXRzIHJlbGF0ZWQgdHlwZVxuXG4gICAgX3RoaXMucHJvcGVydGllcyA9IHRvUHJvcGVydGllc09iamVjdChfdGhpcy5wcm9wZXJ0aWVzKTtcbiAgICBmcmVlemUoX3RoaXMucHJvcGVydGllcyk7IC8vIG1ha2Ugc3VyZSBub2JvZHkgbWVzc2VzIHdpdGggaXRcblxuICAgIF90aGlzLnByb3BlcnR5TmFtZXMgPSBPYmplY3Qua2V5cyhfdGhpcy5wcm9wZXJ0aWVzKTtcbiAgICBfdGhpcy5pZGVudGlmaWVyQXR0cmlidXRlID0gX3RoaXMuX2dldElkZW50aWZpZXJBdHRyaWJ1dGUoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJfZ2V0SWRlbnRpZmllckF0dHJpYnV0ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWRlbnRpZmllckF0dHJpYnV0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZm9yQWxsUHJvcHMoZnVuY3Rpb24gKHByb3BOYW1lLCBwcm9wVHlwZSkge1xuICAgICAgICBpZiAocHJvcFR5cGUuZmxhZ3MgJiBUeXBlRmxhZ3MuSWRlbnRpZmllcikge1xuICAgICAgICAgIGlmIChpZGVudGlmaWVyQXR0cmlidXRlKSB0aHJvdyBmYWlsJDEoXCJDYW5ub3QgZGVmaW5lIHByb3BlcnR5ICdcIiArIHByb3BOYW1lICsgXCInIGFzIG9iamVjdCBpZGVudGlmaWVyLCBwcm9wZXJ0eSAnXCIgKyBpZGVudGlmaWVyQXR0cmlidXRlICsgXCInIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBpZGVudGlmaWVyIHByb3BlcnR5XCIpO1xuICAgICAgICAgIGlkZW50aWZpZXJBdHRyaWJ1dGUgPSBwcm9wTmFtZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaWRlbnRpZmllckF0dHJpYnV0ZTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJjbG9uZUFuZEVuaGFuY2VcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgIHJldHVybiBuZXcgTW9kZWxUeXBlKHtcbiAgICAgICAgbmFtZTogb3B0cy5uYW1lIHx8IHRoaXMubmFtZSxcbiAgICAgICAgcHJvcGVydGllczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wZXJ0aWVzLCBvcHRzLnByb3BlcnRpZXMpLFxuICAgICAgICBpbml0aWFsaXplcnM6IHRoaXMuaW5pdGlhbGl6ZXJzLmNvbmNhdChvcHRzLmluaXRpYWxpemVycyB8fCBbXSksXG4gICAgICAgIHByZVByb2Nlc3Nvcjogb3B0cy5wcmVQcm9jZXNzb3IgfHwgdGhpcy5wcmVQcm9jZXNzb3IsXG4gICAgICAgIHBvc3RQcm9jZXNzb3I6IG9wdHMucG9zdFByb2Nlc3NvciB8fCB0aGlzLnBvc3RQcm9jZXNzb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImFjdGlvbnNcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgYWN0aW9uSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoc2VsZikge1xuICAgICAgICBfdGhpcy5pbnN0YW50aWF0ZUFjdGlvbnMoc2VsZiwgZm4oc2VsZikpO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRoaXMuY2xvbmVBbmRFbmhhbmNlKHtcbiAgICAgICAgaW5pdGlhbGl6ZXJzOiBbYWN0aW9uSW5pdGlhbGl6ZXJdXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJpbnN0YW50aWF0ZUFjdGlvbnNcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHNlbGYsIGFjdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHJldHVybiBpcyBjb3JyZWN0XG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9ucykpIHRocm93IGZhaWwkMShcImFjdGlvbnMgaW5pdGlhbGl6ZXIgc2hvdWxkIHJldHVybiBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIGFjdGlvbnNcIik7IC8vIGJpbmQgYWN0aW9ucyB0byB0aGUgb2JqZWN0IGNyZWF0ZWRcblxuICAgICAgT2JqZWN0LmtleXMoYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAvLyB3YXJuIGlmIHByZXByb2Nlc3NvciB3YXMgZ2l2ZW5cbiAgICAgICAgaWYgKG5hbWUgPT09IFBSRV9QUk9DRVNTX1NOQVBTSE9UKSB0aHJvdyBmYWlsJDEoXCJDYW5ub3QgZGVmaW5lIGFjdGlvbiAnXCIgKyBQUkVfUFJPQ0VTU19TTkFQU0hPVCArIFwiJywgaXQgc2hvdWxkIGJlIGRlZmluZWQgdXNpbmcgJ3R5cGUucHJlUHJvY2Vzc1NuYXBzaG90KGZuKScgaW5zdGVhZFwiKTsgLy8gd2FybiBpZiBwb3N0cHJvY2Vzc29yIHdhcyBnaXZlblxuXG4gICAgICAgIGlmIChuYW1lID09PSBQT1NUX1BST0NFU1NfU05BUFNIT1QpIHRocm93IGZhaWwkMShcIkNhbm5vdCBkZWZpbmUgYWN0aW9uICdcIiArIFBPU1RfUFJPQ0VTU19TTkFQU0hPVCArIFwiJywgaXQgc2hvdWxkIGJlIGRlZmluZWQgdXNpbmcgJ3R5cGUucG9zdFByb2Nlc3NTbmFwc2hvdChmbiknIGluc3RlYWRcIik7XG4gICAgICAgIHZhciBhY3Rpb24yID0gYWN0aW9uc1tuYW1lXTsgLy8gYXBwbHkgaG9vayBjb21wb3NpdGlvblxuXG4gICAgICAgIHZhciBiYXNlQWN0aW9uID0gc2VsZltuYW1lXTtcblxuICAgICAgICBpZiAobmFtZSBpbiBIb29rICYmIGJhc2VBY3Rpb24pIHtcbiAgICAgICAgICB2YXIgc3BlY2lhbGl6ZWRBY3Rpb25fMSA9IGFjdGlvbjI7XG5cbiAgICAgICAgICBhY3Rpb24yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYmFzZUFjdGlvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgc3BlY2lhbGl6ZWRBY3Rpb25fMS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gdGhlIGdvYWwgb2YgdGhpcyBpcyB0byBtYWtlIHN1cmUgYWN0aW9ucyB1c2luZyBcInRoaXNcIiBjYW4gY2FsbCB0aGVtc2VsdmVzLFxuICAgICAgICAvLyB3aGlsZSBzdGlsbCBhbGxvd2luZyB0aGUgbWlkZGxld2FyZXMgdG8gcmVnaXN0ZXIgdGhlbVxuXG5cbiAgICAgICAgdmFyIG1pZGRsZXdhcmVzID0gYWN0aW9uMi4kbXN0X21pZGRsZXdhcmU7IC8vIG1ha2Ugc3VyZSBtaWRkbGV3YXJlcyBhcmUgbm90IGxvc3RcblxuICAgICAgICB2YXIgYm91bmRBY3Rpb24gPSBhY3Rpb24yLmJpbmQoYWN0aW9ucyk7XG4gICAgICAgIGJvdW5kQWN0aW9uLiRtc3RfbWlkZGxld2FyZSA9IG1pZGRsZXdhcmVzO1xuICAgICAgICB2YXIgYWN0aW9uSW52b2tlciA9IGNyZWF0ZUFjdGlvbkludm9rZXIoc2VsZiwgbmFtZSwgYm91bmRBY3Rpb24pO1xuICAgICAgICBhY3Rpb25zW25hbWVdID0gYWN0aW9uSW52b2tlcjtcbiAgICAgICAgKCFkZXZNb2RlKCkgPyBhZGRIaWRkZW5GaW5hbFByb3AgOiBhZGRIaWRkZW5Xcml0YWJsZVByb3ApKHNlbGYsIG5hbWUsIGFjdGlvbkludm9rZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwidm9sYXRpbGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgZmFpbCQxKFwiWW91IHBhc3NlZCBhbiBcIiArIHR5cGVvZiBmbiArIFwiIHRvIHZvbGF0aWxlIHN0YXRlIGFzIGFuIGFyZ3VtZW50LCB3aGVuIGZ1bmN0aW9uIGlzIGV4cGVjdGVkXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGVJbml0aWFsaXplciA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgIF90aGlzLmluc3RhbnRpYXRlVm9sYXRpbGVTdGF0ZShzZWxmLCBmbihzZWxmKSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcy5jbG9uZUFuZEVuaGFuY2Uoe1xuICAgICAgICBpbml0aWFsaXplcnM6IFtzdGF0ZUluaXRpYWxpemVyXVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwiaW5zdGFudGlhdGVWb2xhdGlsZVN0YXRlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChzZWxmLCBzdGF0ZSkge1xuICAgICAgLy8gY2hlY2sgdmlld3MgcmV0dXJuXG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3Qoc3RhdGUpKSB0aHJvdyBmYWlsJDEoXCJ2b2xhdGlsZSBzdGF0ZSBpbml0aWFsaXplciBzaG91bGQgcmV0dXJuIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgc3RhdGVcIik7XG4gICAgICBzZXQoc2VsZiwgc3RhdGUpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImV4dGVuZFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBpbml0aWFsaXplciA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgIHZhciBfYSA9IGZuKHNlbGYpLFxuICAgICAgICAgICAgYWN0aW9ucyA9IF9hLmFjdGlvbnMsXG4gICAgICAgICAgICB2aWV3cyA9IF9hLnZpZXdzLFxuICAgICAgICAgICAgc3RhdGUgPSBfYS5zdGF0ZSxcbiAgICAgICAgICAgIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImFjdGlvbnNcIiwgXCJ2aWV3c1wiLCBcInN0YXRlXCJdKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmVzdCkgdGhyb3cgZmFpbCQxKFwiVGhlIGBleHRlbmRgIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IHdpdGggYSBzdWJzZXQgb2YgdGhlIGZpZWxkcyAnYWN0aW9ucycsICd2aWV3cycgYW5kICdzdGF0ZScuIEZvdW5kIGludmFsaWQga2V5ICdcIiArIGtleSArIFwiJ1wiKTtcblxuICAgICAgICBpZiAoc3RhdGUpIF90aGlzLmluc3RhbnRpYXRlVm9sYXRpbGVTdGF0ZShzZWxmLCBzdGF0ZSk7XG4gICAgICAgIGlmICh2aWV3cykgX3RoaXMuaW5zdGFudGlhdGVWaWV3cyhzZWxmLCB2aWV3cyk7XG4gICAgICAgIGlmIChhY3Rpb25zKSBfdGhpcy5pbnN0YW50aWF0ZUFjdGlvbnMoc2VsZiwgYWN0aW9ucyk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRoaXMuY2xvbmVBbmRFbmhhbmNlKHtcbiAgICAgICAgaW5pdGlhbGl6ZXJzOiBbaW5pdGlhbGl6ZXJdXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJ2aWV3c1wiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB2aWV3SW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoc2VsZikge1xuICAgICAgICBfdGhpcy5pbnN0YW50aWF0ZVZpZXdzKHNlbGYsIGZuKHNlbGYpKTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzLmNsb25lQW5kRW5oYW5jZSh7XG4gICAgICAgIGluaXRpYWxpemVyczogW3ZpZXdJbml0aWFsaXplcl1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlVmlld3NcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHNlbGYsIHZpZXdzKSB7XG4gICAgICAvLyBjaGVjayB2aWV3cyByZXR1cm5cbiAgICAgIGlmICghaXNQbGFpbk9iamVjdCh2aWV3cykpIHRocm93IGZhaWwkMShcInZpZXdzIGluaXRpYWxpemVyIHNob3VsZCByZXR1cm4gYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB2aWV3c1wiKTtcbiAgICAgIE9iamVjdC5rZXlzKHZpZXdzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF9hOyAvLyBpcyB0aGlzIGEgY29tcHV0ZWQgcHJvcGVydHk/XG5cblxuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iodmlld3MsIGtleSk7XG5cbiAgICAgICAgaWYgKFwiZ2V0XCIgaW4gZGVzY3JpcHRvcikge1xuICAgICAgICAgIGlmIChpc0NvbXB1dGVkUHJvcChzZWxmLCBrZXkpKSB7XG4gICAgICAgICAgICB2YXIgY29tcHV0ZWRWYWx1ZSA9IF9nZXRBZG1pbmlzdHJhdGlvbihzZWxmLCBrZXkpOyAvLyBUT0RPOiBtb2J4IGN1cnJlbnRseSBkb2VzIG5vdCBhbGxvdyByZWRlZmluaW5nIGNvbXB1dGVzIHlldCwgcGVuZGluZyAjMTEyMVxuICAgICAgICAgICAgLy8gRklYTUU6IHRoaXMgYmluZHMgdG8gdGhlIGludGVybmFscyBvZiBtb2J4IVxuXG5cbiAgICAgICAgICAgIGNvbXB1dGVkVmFsdWUuZGVyaXZhdGlvbiA9IGRlc2NyaXB0b3IuZ2V0O1xuICAgICAgICAgICAgY29tcHV0ZWRWYWx1ZS5zY29wZSA9IHNlbGY7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5zZXQpIGNvbXB1dGVkVmFsdWUuc2V0dGVyID0gYWN0aW9uKGNvbXB1dGVkVmFsdWUubmFtZSArIFwiLXNldHRlclwiLCBkZXNjcmlwdG9yLnNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgbWFrZU9ic2VydmFibGUoc2VsZiwgKF9hID0ge30sIF9hW2tleV0gPSBjb21wdXRlZCwgX2EpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICghZGV2TW9kZSgpID8gYWRkSGlkZGVuRmluYWxQcm9wIDogYWRkSGlkZGVuV3JpdGFibGVQcm9wKShzZWxmLCBrZXksIGRlc2NyaXB0b3IudmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGZhaWwkMShcIkEgdmlldyBtZW1iZXIgc2hvdWxkIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGdldHRlciBiYXNlZCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwiaW5zdGFudGlhdGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIHZhbHVlID0gaXNTdGF0ZVRyZWVOb2RlKGluaXRpYWxWYWx1ZSkgPyBpbml0aWFsVmFsdWUgOiB0aGlzLmFwcGx5U25hcHNob3RQcmVQcm9jZXNzb3IoaW5pdGlhbFZhbHVlKTtcbiAgICAgIHJldHVybiBjcmVhdGVPYmplY3ROb2RlKHRoaXMsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIHZhbHVlKTsgLy8gT3B0aW1pemF0aW9uOiByZWNvcmQgYWxsIHByb3AtIHZpZXctIGFuZCBhY3Rpb24gbmFtZXMgYWZ0ZXIgZmlyc3QgY29uc3RydWN0aW9uLCBhbmQgZ2VuZXJhdGUgYW4gb3B0aW1hbCBiYXNlIGNsYXNzXG4gICAgICAvLyB0aGF0IHByZS1yZXNlcnZlcyBhbGwgdGhlc2UgZmllbGRzIGZvciBmYXN0IG9iamVjdC1tZW1iZXIgbG9va3Vwc1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImluaXRpYWxpemVDaGlsZE5vZGVzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmpOb2RlLCBpbml0aWFsU25hcHNob3QpIHtcbiAgICAgIGlmIChpbml0aWFsU25hcHNob3QgPT09IHZvaWQgMCkge1xuICAgICAgICBpbml0aWFsU25hcHNob3QgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGUgPSBvYmpOb2RlLnR5cGU7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICB0eXBlLmZvckFsbFByb3BzKGZ1bmN0aW9uIChuYW1lLCBjaGlsZFR5cGUpIHtcbiAgICAgICAgcmVzdWx0W25hbWVdID0gY2hpbGRUeXBlLmluc3RhbnRpYXRlKG9iak5vZGUsIG5hbWUsIHVuZGVmaW5lZCwgaW5pdGlhbFNuYXBzaG90W25hbWVdKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJjcmVhdGVOZXdJbnN0YW5jZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoY2hpbGROb2Rlcykge1xuICAgICAgcmV0dXJuIG9ic2VydmFibGUub2JqZWN0KGNoaWxkTm9kZXMsIEVNUFRZX09CSkVDVCwgbW9ieFNoYWxsb3cpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImZpbmFsaXplTmV3SW5zdGFuY2VcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIGluc3RhbmNlKSB7XG4gICAgICBhZGRIaWRkZW5GaW5hbFByb3AoaW5zdGFuY2UsIFwidG9TdHJpbmdcIiwgb2JqZWN0VHlwZVRvU3RyaW5nKTtcbiAgICAgIHRoaXMuZm9yQWxsUHJvcHMoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgX2ludGVyY2VwdFJlYWRzKGluc3RhbmNlLCBuYW1lLCBub2RlLnVuYm94KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5pbml0aWFsaXplcnMucmVkdWNlKGZ1bmN0aW9uIChzZWxmLCBmbikge1xuICAgICAgICByZXR1cm4gZm4oc2VsZik7XG4gICAgICB9LCBpbnN0YW5jZSk7XG4gICAgICBpbnRlcmNlcHQoaW5zdGFuY2UsIHRoaXMud2lsbENoYW5nZSk7XG4gICAgICBvYnNlcnZlKGluc3RhbmNlLCB0aGlzLmRpZENoYW5nZSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwid2lsbENoYW5nZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoY2hnKSB7XG4gICAgICAvLyBUT0RPOiBtb2J4IHR5cGluZ3MgZG9uJ3Qgc2VlbSB0byB0YWtlIGludG8gYWNjb3VudCB0aGF0IG5ld1ZhbHVlIGNhbiBiZSBzZXQgZXZlbiB3aGVuIHJlbW92aW5nIGEgcHJvcFxuICAgICAgdmFyIGNoYW5nZSA9IGNoZztcbiAgICAgIHZhciBub2RlID0gZ2V0U3RhdGVUcmVlTm9kZShjaGFuZ2Uub2JqZWN0KTtcbiAgICAgIHZhciBzdWJwYXRoID0gY2hhbmdlLm5hbWU7XG4gICAgICBub2RlLmFzc2VydFdyaXRhYmxlKHtcbiAgICAgICAgc3VicGF0aDogc3VicGF0aFxuICAgICAgfSk7XG4gICAgICB2YXIgY2hpbGRUeXBlID0gbm9kZS50eXBlLnByb3BlcnRpZXNbc3VicGF0aF07IC8vIG9ubHkgcHJvcGVydGllcyBhcmUgdHlwZWQsIHN0YXRlIGFyZSBzdG9yZWQgYXMtaXMgcmVmZXJlbmNlc1xuXG4gICAgICBpZiAoY2hpbGRUeXBlKSB7XG4gICAgICAgIHR5cGVjaGVja0ludGVybmFsKGNoaWxkVHlwZSwgY2hhbmdlLm5ld1ZhbHVlKTtcbiAgICAgICAgY2hhbmdlLm5ld1ZhbHVlID0gY2hpbGRUeXBlLnJlY29uY2lsZShub2RlLmdldENoaWxkTm9kZShzdWJwYXRoKSwgY2hhbmdlLm5ld1ZhbHVlLCBub2RlLCBzdWJwYXRoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJkaWRDaGFuZ2VcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGNoZykge1xuICAgICAgLy8gVE9ETzogbW9ieCB0eXBpbmdzIGRvbid0IHNlZW0gdG8gdGFrZSBpbnRvIGFjY291bnQgdGhhdCBuZXdWYWx1ZSBjYW4gYmUgc2V0IGV2ZW4gd2hlbiByZW1vdmluZyBhIHByb3BcbiAgICAgIHZhciBjaGFuZ2UgPSBjaGc7XG4gICAgICB2YXIgY2hpbGROb2RlID0gZ2V0U3RhdGVUcmVlTm9kZShjaGFuZ2Uub2JqZWN0KTtcbiAgICAgIHZhciBjaGlsZFR5cGUgPSBjaGlsZE5vZGUudHlwZS5wcm9wZXJ0aWVzW2NoYW5nZS5uYW1lXTtcblxuICAgICAgaWYgKCFjaGlsZFR5cGUpIHtcbiAgICAgICAgLy8gZG9uJ3QgZW1pdCBwYXRjaGVzIGZvciB2b2xhdGlsZSBzdGF0ZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvbGRDaGlsZFZhbHVlID0gY2hhbmdlLm9sZFZhbHVlID8gY2hhbmdlLm9sZFZhbHVlLnNuYXBzaG90IDogdW5kZWZpbmVkO1xuICAgICAgY2hpbGROb2RlLmVtaXRQYXRjaCh7XG4gICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgcGF0aDogZXNjYXBlSnNvblBhdGgoY2hhbmdlLm5hbWUpLFxuICAgICAgICB2YWx1ZTogY2hhbmdlLm5ld1ZhbHVlLnNuYXBzaG90LFxuICAgICAgICBvbGRWYWx1ZTogb2xkQ2hpbGRWYWx1ZVxuICAgICAgfSwgY2hpbGROb2RlKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJnZXRDaGlsZHJlblwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgdGhpcy5mb3JBbGxQcm9wcyhmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXMucHVzaChfdGhpcy5nZXRDaGlsZE5vZGUobm9kZSwgbmFtZSkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImdldENoaWxkTm9kZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwga2V5KSB7XG4gICAgICBpZiAoIShrZXkgaW4gdGhpcy5wcm9wZXJ0aWVzKSkgdGhyb3cgZmFpbCQxKFwiTm90IGEgdmFsdWUgcHJvcGVydHk6IFwiICsga2V5KTtcblxuICAgICAgdmFyIGFkbSA9IF9nZXRBZG1pbmlzdHJhdGlvbihub2RlLnN0b3JlZFZhbHVlLCBrZXkpO1xuXG4gICAgICB2YXIgY2hpbGROb2RlID0gYWRtLnJhdygpO1xuICAgICAgaWYgKCFjaGlsZE5vZGUpIHRocm93IGZhaWwkMShcIk5vZGUgbm90IGF2YWlsYWJsZSBmb3IgcHJvcGVydHkgXCIgKyBrZXkpO1xuICAgICAgcmV0dXJuIGNoaWxkTm9kZTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJnZXRTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgYXBwbHlQb3N0UHJvY2Vzcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKGFwcGx5UG9zdFByb2Nlc3MgPT09IHZvaWQgMCkge1xuICAgICAgICBhcHBseVBvc3RQcm9jZXNzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgdGhpcy5mb3JBbGxQcm9wcyhmdW5jdGlvbiAobmFtZSwgdHlwZSkge1xuICAgICAgICBnZXRBdG9tKG5vZGUuc3RvcmVkVmFsdWUsIG5hbWUpLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IF90aGlzLmdldENoaWxkTm9kZShub2RlLCBuYW1lKS5zbmFwc2hvdDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYXBwbHlQb3N0UHJvY2Vzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseVNuYXBzaG90UG9zdFByb2Nlc3NvcihyZXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcInByb2Nlc3NJbml0aWFsU25hcHNob3RcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGNoaWxkTm9kZXMpIHtcbiAgICAgIHZhciBwcm9jZXNzZWQgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBwcm9jZXNzZWRba2V5XSA9IGNoaWxkTm9kZXNba2V5XS5nZXRTbmFwc2hvdCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVNuYXBzaG90UG9zdFByb2Nlc3Nvcihwcm9jZXNzZWQpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImFwcGx5UGF0Y2hMb2NhbGx5XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCBzdWJwYXRoLCBwYXRjaCkge1xuICAgICAgaWYgKCEocGF0Y2gub3AgPT09IFwicmVwbGFjZVwiIHx8IHBhdGNoLm9wID09PSBcImFkZFwiKSkge1xuICAgICAgICB0aHJvdyBmYWlsJDEoXCJvYmplY3QgZG9lcyBub3Qgc3VwcG9ydCBvcGVyYXRpb24gXCIgKyBwYXRjaC5vcCk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc3RvcmVkVmFsdWVbc3VicGF0aF0gPSBwYXRjaC52YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJhcHBseVNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCBzbmFwc2hvdCkge1xuICAgICAgdmFyIHByZVByb2Nlc3NlZFNuYXBzaG90ID0gdGhpcy5hcHBseVNuYXBzaG90UHJlUHJvY2Vzc29yKHNuYXBzaG90KTtcbiAgICAgIHR5cGVjaGVja0ludGVybmFsKHRoaXMsIHByZVByb2Nlc3NlZFNuYXBzaG90KTtcbiAgICAgIHRoaXMuZm9yQWxsUHJvcHMoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgbm9kZS5zdG9yZWRWYWx1ZVtuYW1lXSA9IHByZVByb2Nlc3NlZFNuYXBzaG90W25hbWVdO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwiYXBwbHlTbmFwc2hvdFByZVByb2Nlc3NvclwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoc25hcHNob3QpIHtcbiAgICAgIHZhciBwcm9jZXNzb3IgPSB0aGlzLnByZVByb2Nlc3NvcjtcbiAgICAgIHJldHVybiBwcm9jZXNzb3IgPyBwcm9jZXNzb3IuY2FsbChudWxsLCBzbmFwc2hvdCkgOiBzbmFwc2hvdDtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJhcHBseVNuYXBzaG90UG9zdFByb2Nlc3NvclwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoc25hcHNob3QpIHtcbiAgICAgIHZhciBwb3N0UHJvY2Vzc29yID0gdGhpcy5wb3N0UHJvY2Vzc29yO1xuICAgICAgaWYgKHBvc3RQcm9jZXNzb3IpIHJldHVybiBwb3N0UHJvY2Vzc29yLmNhbGwobnVsbCwgc25hcHNob3QpO1xuICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImdldENoaWxkVHlwZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICBhc3NlcnRJc1N0cmluZyhwcm9wZXJ0eU5hbWUsIDEpO1xuICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImlzVmFsaWRTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzbmFwc2hvdCA9IHRoaXMuYXBwbHlTbmFwc2hvdFByZVByb2Nlc3Nvcih2YWx1ZSk7XG5cbiAgICAgIGlmICghaXNQbGFpbk9iamVjdChzbmFwc2hvdCkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVDaGVja0ZhaWx1cmUoY29udGV4dCwgc25hcHNob3QsIFwiVmFsdWUgaXMgbm90IGEgcGxhaW4gb2JqZWN0XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmxhdHRlblR5cGVFcnJvcnModGhpcy5wcm9wZXJ0eU5hbWVzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5wcm9wZXJ0aWVzW2tleV0udmFsaWRhdGUoc25hcHNob3Rba2V5XSwgZ2V0Q29udGV4dEZvclBhdGgoY29udGV4dCwga2V5LCBfdGhpcy5wcm9wZXJ0aWVzW2tleV0pKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJmb3JBbGxQcm9wc1wiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMucHJvcGVydHlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZuKGtleSwgX3RoaXMucHJvcGVydGllc1trZXldKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImRlc2NyaWJlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7IC8vIG9wdGltaXphdGlvbjogY2FjaGVcblxuXG4gICAgICByZXR1cm4gXCJ7IFwiICsgdGhpcy5wcm9wZXJ0eU5hbWVzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgKyBcIjogXCIgKyBfdGhpcy5wcm9wZXJ0aWVzW2tleV0uZGVzY3JpYmUoKTtcbiAgICAgIH0pLmpvaW4oXCI7IFwiKSArIFwiIH1cIjtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJnZXREZWZhdWx0U25hcHNob3RcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEVNUFRZX09CSkVDVDtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJyZW1vdmVDaGlsZFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgc3VicGF0aCkge1xuICAgICAgbm9kZS5zdG9yZWRWYWx1ZVtzdWJwYXRoXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gTW9kZWxUeXBlO1xufShDb21wbGV4VHlwZSk7XG5cbk1vZGVsVHlwZS5wcm90b3R5cGUuYXBwbHlTbmFwc2hvdCA9IGFjdGlvbihNb2RlbFR5cGUucHJvdG90eXBlLmFwcGx5U25hcHNob3QpO1xuLyoqXG4gKiBgdHlwZXMubW9kZWxgIC0gQ3JlYXRlcyBhIG5ldyBtb2RlbCB0eXBlIGJ5IHByb3ZpZGluZyBhIG5hbWUsIHByb3BlcnRpZXMsIHZvbGF0aWxlIHN0YXRlIGFuZCBhY3Rpb25zLlxuICpcbiAqIFNlZSB0aGUgW21vZGVsIHR5cGVdKC9jb25jZXB0cy90cmVlcyNjcmVhdGluZy1tb2RlbHMpIGRlc2NyaXB0aW9uIG9yIHRoZSBbZ2V0dGluZyBzdGFydGVkXShpbnRyby9nZXR0aW5nLXN0YXJ0ZWQubWQjZ2V0dGluZy1zdGFydGVkLTEpIHR1dG9yaWFsLlxuICovXG5cbmZ1bmN0aW9uIG1vZGVsKCkge1xuICB2YXIgYXJncyA9IFtdO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG5cbiAgdmFyIG5hbWUgPSB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIiA/IGFyZ3Muc2hpZnQoKSA6IFwiQW5vbnltb3VzTW9kZWxcIjtcbiAgdmFyIHByb3BlcnRpZXMgPSBhcmdzLnNoaWZ0KCkgfHwge307XG4gIHJldHVybiBuZXcgTW9kZWxUeXBlKHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgfSk7XG59XG4vKipcbiAqIGB0eXBlcy5jb21wb3NlYCAtIENvbXBvc2VzIGEgbmV3IG1vZGVsIGZyb20gb25lIG9yIG1vcmUgZXhpc3RpbmcgbW9kZWwgdHlwZXMuXG4gKiBUaGlzIG1ldGhvZCBjYW4gYmUgaW52b2tlZCBpbiB0d28gZm9ybXM6XG4gKiBHaXZlbiAyIG9yIG1vcmUgbW9kZWwgdHlwZXMsIHRoZSB0eXBlcyBhcmUgY29tcG9zZWQgaW50byBhIG5ldyBUeXBlLlxuICogR2l2ZW4gZmlyc3QgcGFyYW1ldGVyIGFzIGEgc3RyaW5nIGFuZCAyIG9yIG1vcmUgbW9kZWwgdHlwZXMsXG4gKiB0aGUgdHlwZXMgYXJlIGNvbXBvc2VkIGludG8gYSBuZXcgVHlwZSB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICB2YXIgYXJncyA9IFtdO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICB9IC8vIFRPRE86IGp1c3Qgam9pbiB0aGUgYmFzZSB0eXBlIG5hbWVzIGlmIG5vIG5hbWUgaXMgcHJvdmlkZWRcblxuXG4gIHZhciBoYXNUeXBlbmFtZSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiO1xuICB2YXIgdHlwZU5hbWUgPSBoYXNUeXBlbmFtZSA/IGFyZ3NbMF0gOiBcIkFub255bW91c01vZGVsXCI7XG5cbiAgaWYgKGhhc1R5cGVuYW1lKSB7XG4gICAgYXJncy5zaGlmdCgpO1xuICB9IC8vIGNoZWNrIGFsbCBwYXJhbWV0ZXJzXG5cblxuICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpKSB7XG4gICAgICBhc3NlcnRBcmcodHlwZSwgaXNNb2RlbFR5cGUsIFwibW9ieC1zdGF0ZS10cmVlIG1vZGVsIHR5cGVcIiwgaGFzVHlwZW5hbWUgPyBpICsgMiA6IGkgKyAxKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBhcmdzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgcmV0dXJuIHByZXYuY2xvbmVBbmRFbmhhbmNlKHtcbiAgICAgIG5hbWU6IHByZXYubmFtZSArIFwiX1wiICsgY3VyLm5hbWUsXG4gICAgICBwcm9wZXJ0aWVzOiBjdXIucHJvcGVydGllcyxcbiAgICAgIGluaXRpYWxpemVyczogY3VyLmluaXRpYWxpemVycyxcbiAgICAgIHByZVByb2Nlc3NvcjogZnVuY3Rpb24gKHNuYXBzaG90KSB7XG4gICAgICAgIHJldHVybiBjdXIuYXBwbHlTbmFwc2hvdFByZVByb2Nlc3NvcihwcmV2LmFwcGx5U25hcHNob3RQcmVQcm9jZXNzb3Ioc25hcHNob3QpKTtcbiAgICAgIH0sXG4gICAgICBwb3N0UHJvY2Vzc29yOiBmdW5jdGlvbiAoc25hcHNob3QpIHtcbiAgICAgICAgcmV0dXJuIGN1ci5hcHBseVNuYXBzaG90UG9zdFByb2Nlc3NvcihwcmV2LmFwcGx5U25hcHNob3RQb3N0UHJvY2Vzc29yKHNuYXBzaG90KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLm5hbWVkKHR5cGVOYW1lKTtcbn1cbi8qKlxuICogUmV0dXJucyBpZiBhIGdpdmVuIHZhbHVlIHJlcHJlc2VudHMgYSBtb2RlbCB0eXBlLlxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gaXNNb2RlbFR5cGUodHlwZSkge1xuICByZXR1cm4gaXNUeXBlKHR5cGUpICYmICh0eXBlLmZsYWdzICYgVHlwZUZsYWdzLk9iamVjdCkgPiAwO1xufSAvLyBUT0RPOiBpbXBsZW1lbnQgQ29yZVR5cGUgdXNpbmcgdHlwZXMuY3VzdG9tID9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbnZhciBDb3JlVHlwZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDb3JlVHlwZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDb3JlVHlwZShuYW1lLCBmbGFncywgY2hlY2tlciwgaW5pdGlhbGl6ZXIpIHtcbiAgICBpZiAoaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkge1xuICAgICAgaW5pdGlhbGl6ZXIgPSBpZGVudGl0eTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImZsYWdzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmbGFnc1xuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjaGVja2VyXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBjaGVja2VyXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImluaXRpYWxpemVyXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBpbml0aWFsaXplclxuICAgIH0pO1xuICAgIF90aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvcmVUeXBlLnByb3RvdHlwZSwgXCJkZXNjcmliZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3JlVHlwZS5wcm90b3R5cGUsIFwiaW5zdGFudGlhdGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNjYWxhck5vZGUodGhpcywgcGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29yZVR5cGUucHJvdG90eXBlLCBcImNyZWF0ZU5ld0luc3RhbmNlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChzbmFwc2hvdCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZXIoc25hcHNob3QpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3JlVHlwZS5wcm90b3R5cGUsIFwiaXNWYWxpZFNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgaWYgKGlzUHJpbWl0aXZlKHZhbHVlKSAmJiB0aGlzLmNoZWNrZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0eXBlQ2hlY2tTdWNjZXNzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlTmFtZSA9IHRoaXMubmFtZSA9PT0gXCJEYXRlXCIgPyBcIkRhdGUgb3IgYSB1bml4IG1pbGxpc2Vjb25kcyB0aW1lc3RhbXBcIiA6IHRoaXMubmFtZTtcbiAgICAgIHJldHVybiB0eXBlQ2hlY2tGYWlsdXJlKGNvbnRleHQsIHZhbHVlLCBcIlZhbHVlIGlzIG5vdCBhIFwiICsgdHlwZU5hbWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBDb3JlVHlwZTtcbn0oU2ltcGxlVHlwZSk7XG4vKipcbiAqIGB0eXBlcy5zdHJpbmdgIC0gQ3JlYXRlcyBhIHR5cGUgdGhhdCBjYW4gb25seSBjb250YWluIGEgc3RyaW5nIHZhbHVlLlxuICogVGhpcyB0eXBlIGlzIHVzZWQgZm9yIHN0cmluZyB2YWx1ZXMgYnkgZGVmYXVsdFxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogY29uc3QgUGVyc29uID0gdHlwZXMubW9kZWwoe1xuICogICBmaXJzdE5hbWU6IHR5cGVzLnN0cmluZyxcbiAqICAgbGFzdE5hbWU6IFwiRG9lXCJcbiAqIH0pXG4gKiBgYGBcbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcblxuXG52YXIgc3RyaW5nID0gbmV3IENvcmVUeXBlKFwic3RyaW5nXCIsIFR5cGVGbGFncy5TdHJpbmcsIGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjtcbn0pO1xuLyoqXG4gKiBgdHlwZXMubnVtYmVyYCAtIENyZWF0ZXMgYSB0eXBlIHRoYXQgY2FuIG9ubHkgY29udGFpbiBhIG51bWVyaWMgdmFsdWUuXG4gKiBUaGlzIHR5cGUgaXMgdXNlZCBmb3IgbnVtZXJpYyB2YWx1ZXMgYnkgZGVmYXVsdFxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogY29uc3QgVmVjdG9yID0gdHlwZXMubW9kZWwoe1xuICogICB4OiB0eXBlcy5udW1iZXIsXG4gKiAgIHk6IDEuNVxuICogfSlcbiAqIGBgYFxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuXG52YXIgbnVtYmVyID0gbmV3IENvcmVUeXBlKFwibnVtYmVyXCIsIFR5cGVGbGFncy5OdW1iZXIsIGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIjtcbn0pO1xuLyoqXG4gKiBgdHlwZXMuaW50ZWdlcmAgLSBDcmVhdGVzIGEgdHlwZSB0aGF0IGNhbiBvbmx5IGNvbnRhaW4gYW4gaW50ZWdlciB2YWx1ZS5cbiAqIFRoaXMgdHlwZSBpcyB1c2VkIGZvciBpbnRlZ2VyIHZhbHVlcyBieSBkZWZhdWx0XG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBTaXplID0gdHlwZXMubW9kZWwoe1xuICogICB3aWR0aDogdHlwZXMuaW50ZWdlcixcbiAqICAgaGVpZ2h0OiAxMFxuICogfSlcbiAqIGBgYFxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuXG52YXIgaW50ZWdlciA9IG5ldyBDb3JlVHlwZShcImludGVnZXJcIiwgVHlwZUZsYWdzLkludGVnZXIsIGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiBpc0ludGVnZXIodik7XG59KTtcbi8qKlxuICogYHR5cGVzLmJvb2xlYW5gIC0gQ3JlYXRlcyBhIHR5cGUgdGhhdCBjYW4gb25seSBjb250YWluIGEgYm9vbGVhbiB2YWx1ZS5cbiAqIFRoaXMgdHlwZSBpcyB1c2VkIGZvciBib29sZWFuIHZhbHVlcyBieSBkZWZhdWx0XG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBUaGluZyA9IHR5cGVzLm1vZGVsKHtcbiAqICAgaXNDb29sOiB0eXBlcy5ib29sZWFuLFxuICogICBpc0F3ZXNvbWU6IGZhbHNlXG4gKiB9KVxuICogYGBgXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lXG5cbnZhciBib29sZWFuID0gbmV3IENvcmVUeXBlKFwiYm9vbGVhblwiLCBUeXBlRmxhZ3MuQm9vbGVhbiwgZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIjtcbn0pO1xuLyoqXG4gKiBgdHlwZXMubnVsbGAgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgYG51bGxgXG4gKi9cblxudmFyIG51bGxUeXBlID0gbmV3IENvcmVUeXBlKFwibnVsbFwiLCBUeXBlRmxhZ3MuTnVsbCwgZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIHYgPT09IG51bGw7XG59KTtcbi8qKlxuICogYHR5cGVzLnVuZGVmaW5lZGAgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgYHVuZGVmaW5lZGBcbiAqL1xuXG52YXIgdW5kZWZpbmVkVHlwZSA9IG5ldyBDb3JlVHlwZShcInVuZGVmaW5lZFwiLCBUeXBlRmxhZ3MuVW5kZWZpbmVkLCBmdW5jdGlvbiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkO1xufSk7XG5cbnZhciBfRGF0ZVByaW1pdGl2ZSA9IG5ldyBDb3JlVHlwZShcIkRhdGVcIiwgVHlwZUZsYWdzLkRhdGUsIGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiB8fCB2IGluc3RhbmNlb2YgRGF0ZTtcbn0sIGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiB2IGluc3RhbmNlb2YgRGF0ZSA/IHYgOiBuZXcgRGF0ZSh2KTtcbn0pO1xuXG5fRGF0ZVByaW1pdGl2ZS5nZXRTbmFwc2hvdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlLnN0b3JlZFZhbHVlLmdldFRpbWUoKTtcbn07XG4vKipcbiAqIGB0eXBlcy5EYXRlYCAtIENyZWF0ZXMgYSB0eXBlIHRoYXQgY2FuIG9ubHkgY29udGFpbiBhIGphdmFzY3JpcHQgRGF0ZSB2YWx1ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IExvZ0xpbmUgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIHRpbWVzdGFtcDogdHlwZXMuRGF0ZSxcbiAqIH0pXG4gKlxuICogTG9nTGluZS5jcmVhdGUoeyB0aW1lc3RhbXA6IG5ldyBEYXRlKCkgfSlcbiAqIGBgYFxuICovXG5cblxudmFyIERhdGVQcmltaXRpdmUgPSBfRGF0ZVByaW1pdGl2ZTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuZnVuY3Rpb24gZ2V0UHJpbWl0aXZlRmFjdG9yeUZyb21WYWx1ZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBzdHJpbmc7XG5cbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIC8vIEluIHRoZSBmdXR1cmUsIGlzSW50ZWdlcih2YWx1ZSkgPyBpbnRlZ2VyIDogbnVtYmVyIHdvdWxkIGJlIGludGVyZXN0aW5nLCBidXQgd291bGQgYmUgdG9vIGJyZWFraW5nIGZvciBub3dcblxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gYm9vbGVhbjtcblxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBEYXRlUHJpbWl0aXZlO1xuICB9XG5cbiAgdGhyb3cgZmFpbCQxKFwiQ2Fubm90IGRldGVybWluZSBwcmltaXRpdmUgdHlwZSBmcm9tIHZhbHVlIFwiICsgdmFsdWUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGlmIGEgZ2l2ZW4gdmFsdWUgcmVwcmVzZW50cyBhIHByaW1pdGl2ZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gaXNQcmltaXRpdmVUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGlzVHlwZSh0eXBlKSAmJiAodHlwZS5mbGFncyAmIChUeXBlRmxhZ3MuU3RyaW5nIHwgVHlwZUZsYWdzLk51bWJlciB8IFR5cGVGbGFncy5JbnRlZ2VyIHwgVHlwZUZsYWdzLkJvb2xlYW4gfCBUeXBlRmxhZ3MuRGF0ZSkpID4gMDtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG52YXIgTGl0ZXJhbCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhMaXRlcmFsLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIExpdGVyYWwodmFsdWUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpIHx8IHRoaXM7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwidmFsdWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJmbGFnc1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogVHlwZUZsYWdzLkxpdGVyYWxcbiAgICB9KTtcbiAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXRlcmFsLnByb3RvdHlwZSwgXCJpbnN0YW50aWF0ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAocGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU2NhbGFyTm9kZSh0aGlzLCBwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXRlcmFsLnByb3RvdHlwZSwgXCJkZXNjcmliZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpdGVyYWwucHJvdG90eXBlLCBcImlzVmFsaWRTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkgJiYgdmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVDaGVja1N1Y2Nlc3MoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGVDaGVja0ZhaWx1cmUoY29udGV4dCwgdmFsdWUsIFwiVmFsdWUgaXMgbm90IGEgbGl0ZXJhbCBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gTGl0ZXJhbDtcbn0oU2ltcGxlVHlwZSk7XG4vKipcbiAqIGB0eXBlcy5saXRlcmFsYCAtIFRoZSBsaXRlcmFsIHR5cGUgd2lsbCByZXR1cm4gYSB0eXBlIHRoYXQgd2lsbCBtYXRjaCBvbmx5IHRoZSBleGFjdCBnaXZlbiB0eXBlLlxuICogVGhlIGdpdmVuIHZhbHVlIG11c3QgYmUgYSBwcmltaXRpdmUsIGluIG9yZGVyIHRvIGJlIHNlcmlhbGl6ZWQgdG8gYSBzbmFwc2hvdCBjb3JyZWN0bHkuXG4gKiBZb3UgY2FuIHVzZSBsaXRlcmFsIHRvIG1hdGNoIGV4YWN0IHN0cmluZ3MgZm9yIGV4YW1wbGUgdGhlIGV4YWN0IG1hbGUgb3IgZmVtYWxlIHN0cmluZy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IFBlcnNvbiA9IHR5cGVzLm1vZGVsKHtcbiAqICAgICBuYW1lOiB0eXBlcy5zdHJpbmcsXG4gKiAgICAgZ2VuZGVyOiB0eXBlcy51bmlvbih0eXBlcy5saXRlcmFsKCdtYWxlJyksIHR5cGVzLmxpdGVyYWwoJ2ZlbWFsZScpKVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdXNlIGluIHRoZSBzdHJpY3QgZXF1YWwgY2hlY2tcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBsaXRlcmFsKHZhbHVlKSB7XG4gIC8vIGNoZWNrIHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgcHJpbWl0aXZlXG4gIGFzc2VydEFyZyh2YWx1ZSwgaXNQcmltaXRpdmUsIFwicHJpbWl0aXZlXCIsIDEpO1xuICByZXR1cm4gbmV3IExpdGVyYWwodmFsdWUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGlmIGEgZ2l2ZW4gdmFsdWUgcmVwcmVzZW50cyBhIGxpdGVyYWwgdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzTGl0ZXJhbFR5cGUodHlwZSkge1xuICByZXR1cm4gaXNUeXBlKHR5cGUpICYmICh0eXBlLmZsYWdzICYgVHlwZUZsYWdzLkxpdGVyYWwpID4gMDtcbn1cblxudmFyIFJlZmluZW1lbnQgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUmVmaW5lbWVudCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBSZWZpbmVtZW50KG5hbWUsIF9zdWJ0eXBlLCBfcHJlZGljYXRlLCBfbWVzc2FnZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpIHx8IHRoaXM7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX3N1YnR5cGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IF9zdWJ0eXBlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9wcmVkaWNhdGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IF9wcmVkaWNhdGVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX21lc3NhZ2VcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IF9tZXNzYWdlXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmluZW1lbnQucHJvdG90eXBlLCBcImZsYWdzXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJ0eXBlLmZsYWdzIHwgVHlwZUZsYWdzLlJlZmluZW1lbnQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZpbmVtZW50LnByb3RvdHlwZSwgXCJkZXNjcmliZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZpbmVtZW50LnByb3RvdHlwZSwgXCJpbnN0YW50aWF0ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAocGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAvLyBjcmVhdGUgdGhlIGNoaWxkIHR5cGVcbiAgICAgIHJldHVybiB0aGlzLl9zdWJ0eXBlLmluc3RhbnRpYXRlKHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmluZW1lbnQucHJvdG90eXBlLCBcImlzQXNzaWduYWJsZUZyb21cIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJ0eXBlLmlzQXNzaWduYWJsZUZyb20odHlwZSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmluZW1lbnQucHJvdG90eXBlLCBcImlzVmFsaWRTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBzdWJ0eXBlRXJyb3JzID0gdGhpcy5fc3VidHlwZS52YWxpZGF0ZSh2YWx1ZSwgY29udGV4dCk7XG5cbiAgICAgIGlmIChzdWJ0eXBlRXJyb3JzLmxlbmd0aCA+IDApIHJldHVybiBzdWJ0eXBlRXJyb3JzO1xuICAgICAgdmFyIHNuYXBzaG90ID0gaXNTdGF0ZVRyZWVOb2RlKHZhbHVlKSA/IGdldFN0YXRlVHJlZU5vZGUodmFsdWUpLnNuYXBzaG90IDogdmFsdWU7XG5cbiAgICAgIGlmICghdGhpcy5fcHJlZGljYXRlKHNuYXBzaG90KSkge1xuICAgICAgICByZXR1cm4gdHlwZUNoZWNrRmFpbHVyZShjb250ZXh0LCB2YWx1ZSwgdGhpcy5fbWVzc2FnZSh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZUNoZWNrU3VjY2VzcygpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZpbmVtZW50LnByb3RvdHlwZSwgXCJyZWNvbmNpbGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGN1cnJlbnQsIG5ld1ZhbHVlLCBwYXJlbnQsIHN1YnBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJ0eXBlLnJlY29uY2lsZShjdXJyZW50LCBuZXdWYWx1ZSwgcGFyZW50LCBzdWJwYXRoKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmaW5lbWVudC5wcm90b3R5cGUsIFwiZ2V0U3ViVHlwZXNcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnR5cGU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFJlZmluZW1lbnQ7XG59KEJhc2VUeXBlKTtcbi8qKlxuICogYHR5cGVzLnJlZmluZW1lbnRgIC0gQ3JlYXRlcyBhIHR5cGUgdGhhdCBpcyBtb3JlIHNwZWNpZmljIHRoYW4gdGhlIGJhc2UgdHlwZSwgZS5nLiBgdHlwZXMucmVmaW5lbWVudCh0eXBlcy5zdHJpbmcsIHZhbHVlID0+IHZhbHVlLmxlbmd0aCA+IDUpYCB0byBjcmVhdGUgYSB0eXBlIG9mIHN0cmluZ3MgdGhhdCBjYW4gb25seSBiZSBsb25nZXIgdGhlbiA1LlxuICpcbiAqIEBwYXJhbSBuYW1lXG4gKiBAcGFyYW0gdHlwZVxuICogQHBhcmFtIHByZWRpY2F0ZVxuICogQHJldHVybnNcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZmluZW1lbnQoKSB7XG4gIHZhciBhcmdzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cblxuICB2YXIgbmFtZSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gYXJncy5zaGlmdCgpIDogaXNUeXBlKGFyZ3NbMF0pID8gYXJnc1swXS5uYW1lIDogbnVsbDtcbiAgdmFyIHR5cGUgPSBhcmdzWzBdO1xuICB2YXIgcHJlZGljYXRlID0gYXJnc1sxXTtcbiAgdmFyIG1lc3NhZ2UgPSBhcmdzWzJdID8gYXJnc1syXSA6IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFwiVmFsdWUgZG9lcyBub3QgcmVzcGVjdCB0aGUgcmVmaW5lbWVudCBwcmVkaWNhdGVcIjtcbiAgfTsgLy8gZW5zdXJlcyBhbGwgcGFyYW1ldGVycyBhcmUgY29ycmVjdFxuXG4gIGFzc2VydElzVHlwZSh0eXBlLCBbMSwgMl0pO1xuICBhc3NlcnRJc1N0cmluZyhuYW1lLCAxKTtcbiAgYXNzZXJ0SXNGdW5jdGlvbihwcmVkaWNhdGUsIFsyLCAzXSk7XG4gIGFzc2VydElzRnVuY3Rpb24obWVzc2FnZSwgWzMsIDRdKTtcbiAgcmV0dXJuIG5ldyBSZWZpbmVtZW50KG5hbWUsIHR5cGUsIHByZWRpY2F0ZSwgbWVzc2FnZSk7XG59XG4vKipcbiAqIFJldHVybnMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIHJlZmluZW1lbnQgdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzUmVmaW5lbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gKHR5cGUuZmxhZ3MgJiBUeXBlRmxhZ3MuUmVmaW5lbWVudCkgPiAwO1xufVxuLyoqXG4gKiBgdHlwZXMuZW51bWVyYXRpb25gIC0gQ2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuIHN0cmluZyBiYXNlZCBlbnVtZXJhdGlvbi5cbiAqIChub3RlOiB0aGlzIG1ldGhvZHMgaXMganVzdCBzdWdhciBmb3IgYSB1bmlvbiBvZiBzdHJpbmcgbGl0ZXJhbHMpXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBUcmFmZmljTGlnaHQgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIGNvbG9yOiB0eXBlcy5lbnVtZXJhdGlvbihcIkNvbG9yXCIsIFtcIlJlZFwiLCBcIk9yYW5nZVwiLCBcIkdyZWVuXCJdKVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBuYW1lIGRlc2NyaXB0aXZlIG5hbWUgb2YgdGhlIGVudW1lcmF0aW9uIChvcHRpb25hbClcbiAqIEBwYXJhbSBvcHRpb25zIHBvc3NpYmxlIHZhbHVlcyB0aGlzIGVudW1lcmF0aW9uIGNhbiBoYXZlXG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gZW51bWVyYXRpb24obmFtZSwgb3B0aW9ucykge1xuICB2YXIgcmVhbE9wdGlvbnMgPSB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMgOiBuYW1lOyAvLyBjaGVjayBhbGwgb3B0aW9uc1xuXG4gIGlmIChkZXZNb2RlKCkpIHtcbiAgICByZWFsT3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24sIGkpIHtcbiAgICAgIGFzc2VydElzU3RyaW5nKG9wdGlvbiwgaSArIDEpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHR5cGUgPSB1bmlvbi5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKHJlYWxPcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgcmV0dXJuIGxpdGVyYWwoXCJcIiArIG9wdGlvbik7XG4gIH0pKSk7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikgdHlwZS5uYW1lID0gbmFtZTtcbiAgcmV0dXJuIHR5cGU7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxudmFyIFVuaW9uID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFVuaW9uLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFVuaW9uKG5hbWUsIF90eXBlcywgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpIHx8IHRoaXM7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX3R5cGVzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBfdHlwZXNcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX2Rpc3BhdGNoZXJcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfZWFnZXJcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBvcHRpb25zID0gX19hc3NpZ24oe1xuICAgICAgZWFnZXI6IHRydWUsXG4gICAgICBkaXNwYXRjaGVyOiB1bmRlZmluZWRcbiAgICB9LCBvcHRpb25zKTtcbiAgICBfdGhpcy5fZGlzcGF0Y2hlciA9IG9wdGlvbnMuZGlzcGF0Y2hlcjtcbiAgICBpZiAoIW9wdGlvbnMuZWFnZXIpIF90aGlzLl9lYWdlciA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmlvbi5wcm90b3R5cGUsIFwiZmxhZ3NcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFR5cGVGbGFncy5VbmlvbjtcblxuICAgICAgdGhpcy5fdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXN1bHQgfD0gdHlwZS5mbGFncztcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5pb24ucHJvdG90eXBlLCBcImlzQXNzaWduYWJsZUZyb21cIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90eXBlcy5zb21lKGZ1bmN0aW9uIChzdWJUeXBlKSB7XG4gICAgICAgIHJldHVybiBzdWJUeXBlLmlzQXNzaWduYWJsZUZyb20odHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5pb24ucHJvdG90eXBlLCBcImRlc2NyaWJlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcIihcIiArIHRoaXMuX3R5cGVzLm1hcChmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5kZXNjcmliZSgpO1xuICAgICAgfSkuam9pbihcIiB8IFwiKSArIFwiKVwiO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmlvbi5wcm90b3R5cGUsIFwiaW5zdGFudGlhdGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLmRldGVybWluZVR5cGUoaW5pdGlhbFZhbHVlLCB1bmRlZmluZWQpO1xuICAgICAgaWYgKCF0eXBlKSB0aHJvdyBmYWlsJDEoXCJObyBtYXRjaGluZyB0eXBlIGZvciB1bmlvbiBcIiArIHRoaXMuZGVzY3JpYmUoKSk7IC8vIGNhbiBoYXBwZW4gaW4gcHJvZCBidWlsZHNcblxuICAgICAgcmV0dXJuIHR5cGUuaW5zdGFudGlhdGUocGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5pb24ucHJvdG90eXBlLCBcInJlY29uY2lsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoY3VycmVudCwgbmV3VmFsdWUsIHBhcmVudCwgc3VicGF0aCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLmRldGVybWluZVR5cGUobmV3VmFsdWUsIGN1cnJlbnQudHlwZSk7XG4gICAgICBpZiAoIXR5cGUpIHRocm93IGZhaWwkMShcIk5vIG1hdGNoaW5nIHR5cGUgZm9yIHVuaW9uIFwiICsgdGhpcy5kZXNjcmliZSgpKTsgLy8gY2FuIGhhcHBlbiBpbiBwcm9kIGJ1aWxkc1xuXG4gICAgICByZXR1cm4gdHlwZS5yZWNvbmNpbGUoY3VycmVudCwgbmV3VmFsdWUsIHBhcmVudCwgc3VicGF0aCk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVuaW9uLnByb3RvdHlwZSwgXCJkZXRlcm1pbmVUeXBlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgcmVjb25jaWxlQ3VycmVudFR5cGUpIHtcbiAgICAgIC8vIHRyeSB0aGUgZGlzcGF0Y2hlciwgaWYgZGVmaW5lZFxuICAgICAgaWYgKHRoaXMuX2Rpc3BhdGNoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoZXIodmFsdWUpO1xuICAgICAgfSAvLyBmaW5kIHRoZSBtb3N0IGFjY29tb2RhdGluZyB0eXBlXG4gICAgICAvLyBpZiB3ZSBhcmUgdXNpbmcgcmVjb25jaWxpYXRpb24gdHJ5IHRoZSBjdXJyZW50IG5vZGUgdHlwZSBmaXJzdCAoZml4IGZvciAjMTA0NSlcblxuXG4gICAgICBpZiAocmVjb25jaWxlQ3VycmVudFR5cGUpIHtcbiAgICAgICAgaWYgKHJlY29uY2lsZUN1cnJlbnRUeXBlLmlzKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiByZWNvbmNpbGVDdXJyZW50VHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlcy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCAhPT0gcmVjb25jaWxlQ3VycmVudFR5cGU7XG4gICAgICAgIH0pLmZpbmQoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZS5pcyh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGVzLmZpbmQoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZS5pcyh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmlvbi5wcm90b3R5cGUsIFwiaXNWYWxpZFNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgaWYgKHRoaXMuX2Rpc3BhdGNoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoZXIodmFsdWUpLnZhbGlkYXRlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFsbEVycm9ycyA9IFtdO1xuICAgICAgdmFyIGFwcGxpY2FibGVUeXBlcyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl90eXBlc1tpXTtcbiAgICAgICAgdmFyIGVycm9ycyA9IHR5cGUudmFsaWRhdGUodmFsdWUsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2VhZ2VyKSByZXR1cm4gdHlwZUNoZWNrU3VjY2VzcygpO2Vsc2UgYXBwbGljYWJsZVR5cGVzKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxsRXJyb3JzLnB1c2goZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXBwbGljYWJsZVR5cGVzID09PSAxKSByZXR1cm4gdHlwZUNoZWNrU3VjY2VzcygpO1xuICAgICAgcmV0dXJuIHR5cGVDaGVja0ZhaWx1cmUoY29udGV4dCwgdmFsdWUsIFwiTm8gdHlwZSBpcyBhcHBsaWNhYmxlIGZvciB0aGUgdW5pb25cIikuY29uY2F0KGZsYXR0ZW5UeXBlRXJyb3JzKGFsbEVycm9ycykpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmlvbi5wcm90b3R5cGUsIFwiZ2V0U3ViVHlwZXNcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3R5cGVzO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBVbmlvbjtcbn0oQmFzZVR5cGUpO1xuLyoqXG4gKiBgdHlwZXMudW5pb25gIC0gQ3JlYXRlIGEgdW5pb24gb2YgbXVsdGlwbGUgdHlwZXMuIElmIHRoZSBjb3JyZWN0IHR5cGUgY2Fubm90IGJlIGluZmVycmVkIHVuYW1iaWd1b3VzbHkgZnJvbSBhIHNuYXBzaG90LCBwcm92aWRlIGEgZGlzcGF0Y2hlciBmdW5jdGlvbiBvZiB0aGUgZm9ybSBgKHNuYXBzaG90KSA9PiBUeXBlYC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9uc09yVHlwZVxuICogQHBhcmFtIG90aGVyVHlwZXNcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiB1bmlvbihvcHRpb25zT3JUeXBlKSB7XG4gIHZhciBvdGhlclR5cGVzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBvdGhlclR5cGVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSBpc1R5cGUob3B0aW9uc09yVHlwZSkgPyB1bmRlZmluZWQgOiBvcHRpb25zT3JUeXBlO1xuICB2YXIgdHlwZXMgPSBpc1R5cGUob3B0aW9uc09yVHlwZSkgPyBfX3NwcmVhZChbb3B0aW9uc09yVHlwZV0sIG90aGVyVHlwZXMpIDogb3RoZXJUeXBlcztcbiAgdmFyIG5hbWUgPSBcIihcIiArIHR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiB0eXBlLm5hbWU7XG4gIH0pLmpvaW4oXCIgfCBcIikgKyBcIilcIjsgLy8gY2hlY2sgYWxsIG9wdGlvbnNcblxuICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGFzc2VydEFyZyhvcHRpb25zLCBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gaXNQbGFpbk9iamVjdChvKTtcbiAgICAgIH0sIFwib2JqZWN0IHsgZWFnZXI/OiBib29sZWFuLCBkaXNwYXRjaGVyPzogRnVuY3Rpb24gfVwiLCAxKTtcbiAgICB9XG5cbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpKSB7XG4gICAgICBhc3NlcnRJc1R5cGUodHlwZSwgb3B0aW9ucyA/IGkgKyAyIDogaSArIDEpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVbmlvbihuYW1lLCB0eXBlcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIFJldHVybnMgaWYgYSBnaXZlbiB2YWx1ZSByZXByZXNlbnRzIGEgdW5pb24gdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVW5pb25UeXBlKHR5cGUpIHtcbiAgcmV0dXJuICh0eXBlLmZsYWdzICYgVHlwZUZsYWdzLlVuaW9uKSA+IDA7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIE9wdGlvbmFsVmFsdWUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoT3B0aW9uYWxWYWx1ZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBPcHRpb25hbFZhbHVlKF9zdWJ0eXBlLCBfZGVmYXVsdFZhbHVlLCBvcHRpb25hbFZhbHVlcykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF9zdWJ0eXBlLm5hbWUpIHx8IHRoaXM7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX3N1YnR5cGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IF9zdWJ0eXBlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9kZWZhdWx0VmFsdWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IF9kZWZhdWx0VmFsdWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwib3B0aW9uYWxWYWx1ZXNcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG9wdGlvbmFsVmFsdWVzXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9wdGlvbmFsVmFsdWUucHJvdG90eXBlLCBcImZsYWdzXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJ0eXBlLmZsYWdzIHwgVHlwZUZsYWdzLk9wdGlvbmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3B0aW9uYWxWYWx1ZS5wcm90b3R5cGUsIFwiZGVzY3JpYmVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnR5cGUuZGVzY3JpYmUoKSArIFwiP1wiO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcHRpb25hbFZhbHVlLnByb3RvdHlwZSwgXCJpbnN0YW50aWF0ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAocGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25hbFZhbHVlcy5pbmRleE9mKGluaXRpYWxWYWx1ZSkgPj0gMCkge1xuICAgICAgICB2YXIgZGVmYXVsdEluc3RhbmNlT3JTbmFwc2hvdCA9IHRoaXMuZ2V0RGVmYXVsdEluc3RhbmNlT3JTbmFwc2hvdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VidHlwZS5pbnN0YW50aWF0ZShwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBkZWZhdWx0SW5zdGFuY2VPclNuYXBzaG90KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3N1YnR5cGUuaW5zdGFudGlhdGUocGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3B0aW9uYWxWYWx1ZS5wcm90b3R5cGUsIFwicmVjb25jaWxlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChjdXJyZW50LCBuZXdWYWx1ZSwgcGFyZW50LCBzdWJwYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3VidHlwZS5yZWNvbmNpbGUoY3VycmVudCwgdGhpcy5vcHRpb25hbFZhbHVlcy5pbmRleE9mKG5ld1ZhbHVlKSA8IDAgJiYgdGhpcy5fc3VidHlwZS5pcyhuZXdWYWx1ZSkgPyBuZXdWYWx1ZSA6IHRoaXMuZ2V0RGVmYXVsdEluc3RhbmNlT3JTbmFwc2hvdCgpLCBwYXJlbnQsIHN1YnBhdGgpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcHRpb25hbFZhbHVlLnByb3RvdHlwZSwgXCJnZXREZWZhdWx0SW5zdGFuY2VPclNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZWZhdWx0SW5zdGFuY2VPclNuYXBzaG90ID0gdHlwZW9mIHRoaXMuX2RlZmF1bHRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5fZGVmYXVsdFZhbHVlKCkgOiB0aGlzLl9kZWZhdWx0VmFsdWU7IC8vIHdoaWxlIHN0YXRpYyB2YWx1ZXMgYXJlIGFscmVhZHkgc25hcHNob3RzIGFuZCBjaGVja2VkIG9uIHR5cGVzLm9wdGlvbmFsXG4gICAgICAvLyBnZW5lcmF0b3IgZnVuY3Rpb25zIG11c3QgYWx3YXlzIGJlIHJlY2hlY2tlZCBqdXN0IGluIGNhc2VcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9kZWZhdWx0VmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0eXBlY2hlY2tJbnRlcm5hbCh0aGlzLCBkZWZhdWx0SW5zdGFuY2VPclNuYXBzaG90KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZmF1bHRJbnN0YW5jZU9yU25hcHNob3Q7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9wdGlvbmFsVmFsdWUucHJvdG90eXBlLCBcImlzVmFsaWRTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIC8vIGRlZmF1bHRlZCB2YWx1ZXMgY2FuIGJlIHNraXBwZWRcbiAgICAgIGlmICh0aGlzLm9wdGlvbmFsVmFsdWVzLmluZGV4T2YodmFsdWUpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHR5cGVDaGVja1N1Y2Nlc3MoKTtcbiAgICAgIH0gLy8gYm91bmNlIHZhbGlkYXRpb24gdG8gdGhlIHN1Yi10eXBlXG5cblxuICAgICAgcmV0dXJuIHRoaXMuX3N1YnR5cGUudmFsaWRhdGUodmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcHRpb25hbFZhbHVlLnByb3RvdHlwZSwgXCJpc0Fzc2lnbmFibGVGcm9tXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3VidHlwZS5pc0Fzc2lnbmFibGVGcm9tKHR5cGUpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcHRpb25hbFZhbHVlLnByb3RvdHlwZSwgXCJnZXRTdWJUeXBlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3VidHlwZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gT3B0aW9uYWxWYWx1ZTtcbn0oQmFzZVR5cGUpO1xuXG5mdW5jdGlvbiBjaGVja09wdGlvbmFsUHJlY29uZGl0aW9ucyh0eXBlLCBkZWZhdWx0VmFsdWVPckZ1bmN0aW9uKSB7XG4gIC8vIG1ha2Ugc3VyZSB3ZSBuZXZlciBwYXNzIGRpcmVjdCBpbnN0YW5jZXNcbiAgaWYgKHR5cGVvZiBkZWZhdWx0VmFsdWVPckZ1bmN0aW9uICE9PSBcImZ1bmN0aW9uXCIgJiYgaXNTdGF0ZVRyZWVOb2RlKGRlZmF1bHRWYWx1ZU9yRnVuY3Rpb24pKSB7XG4gICAgdGhyb3cgZmFpbCQxKFwiZGVmYXVsdCB2YWx1ZSBjYW5ub3QgYmUgYW4gaW5zdGFuY2UsIHBhc3MgYSBzbmFwc2hvdCBvciBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhbiBpbnN0YW5jZS9zbmFwc2hvdCBpbnN0ZWFkXCIpO1xuICB9XG5cbiAgYXNzZXJ0SXNUeXBlKHR5cGUsIDEpO1xuXG4gIGlmIChkZXZNb2RlKCkpIHtcbiAgICAvLyB3ZSBvbmx5IGNoZWNrIGRlZmF1bHQgdmFsdWVzIGlmIHRoZXkgYXJlIHBhc3NlZCBkaXJlY3RseVxuICAgIC8vIGlmIHRoZXkgYXJlIGdlbmVyYXRvciBmdW5jdGlvbnMgdGhleSB3aWxsIGJlIGNoZWNrZWQgb25jZSB0aGV5IGFyZSBnZW5lcmF0ZWRcbiAgICAvLyB3ZSBkb24ndCBjaGVjayBnZW5lcmF0b3IgZnVuY3Rpb24gcmVzdWx0cyBoZXJlIHRvIGF2b2lkIGdlbmVyYXRpbmcgYSBub2RlIGp1c3QgZm9yIHR5cGUtY2hlY2tpbmcgcHVycG9zZXNcbiAgICAvLyB3aGljaCBtaWdodCBnZW5lcmF0ZSBzaWRlLWVmZmVjdHNcbiAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZU9yRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdHlwZWNoZWNrSW50ZXJuYWwodHlwZSwgZGVmYXVsdFZhbHVlT3JGdW5jdGlvbik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIGB0eXBlcy5vcHRpb25hbGAgLSBDYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBwcm9wZXJ0eSB3aXRoIGEgZGVmYXVsdCB2YWx1ZS5cbiAqXG4gKiBEZXBlbmRpbmcgb24gdGhlIHRoaXJkIGFyZ3VtZW50IChgb3B0aW9uYWxWYWx1ZXNgKSB0aGVyZSBhcmUgdHdvIHdheXMgb2Ygb3BlcmF0aW9uOlxuICogLSBJZiB0aGUgYXJndW1lbnQgaXMgbm90IHByb3ZpZGVkLCB0aGVuIGlmIGEgdmFsdWUgaXMgbm90IHByb3ZpZGVkIGluIHRoZSBzbmFwc2hvdCAoYHVuZGVmaW5lZGAgb3IgbWlzc2luZyksXG4gKiAgIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgcHJvdmlkZWQgYGRlZmF1bHRWYWx1ZWBcbiAqIC0gSWYgdGhlIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCB0aGVuIGlmIHRoZSB2YWx1ZSBpbiB0aGUgc25hcHNob3QgbWF0Y2hlcyBvbmUgb2YgdGhlIG9wdGlvbmFsIHZhbHVlcyBpbnNpZGUgdGhlIGFycmF5IHRoZW4gaXQgd2lsbFxuICogICBkZWZhdWx0IHRvIHRoZSBwcm92aWRlZCBgZGVmYXVsdFZhbHVlYC4gQWRkaXRpb25hbGx5LCBpZiBvbmUgb2YgdGhlIG9wdGlvbmFsIHZhbHVlcyBpbnNpZGUgdGhlIGFycmF5IGlzIGB1bmRlZmluZWRgIHRoZW4gYSBtaXNzaW5nXG4gKiAgIHByb3BlcnR5IGlzIGFsc28gdmFsaWQuXG4gKlxuICogICBOb3RlIHRoYXQgaXQgaXMgYWxzbyBwb3NzaWJsZSB0byBpbmNsdWRlIHZhbHVlcyBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBpbnRlbmRlZCBzdWJ0eXBlIGFzIG9wdGlvbmFsIHZhbHVlcyxcbiAqICAgaW4gdGhpcyBjYXNlIHRoZSBvcHRpb25hbCB2YWx1ZSB3aWxsIGJlIHRyYW5zZm9ybWVkIGludG8gdGhlIGBkZWZhdWx0VmFsdWVgIChlLmcuIGB0eXBlcy5vcHRpb25hbCh0eXBlcy5zdHJpbmcsIFwidW5uYW1lZFwiLCBbdW5kZWZpbmVkLCBcIlwiXSlgXG4gKiAgIHdpbGwgdHJhbnNmb3JtIHRoZSBzbmFwc2hvdCB2YWx1ZXMgYHVuZGVmaW5lZGAgKGFuZCB0aGVyZWZvcmUgbWlzc2luZykgYW5kIGVtcHR5IHN0cmluZ3MgaW50byB0aGUgc3RyaW5nIGBcInVubmFtZWRcImAgd2hlbiBpdCBnZXRzXG4gKiAgIGluc3RhbnRpYXRlZCkuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgYSBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBmb3IgZXZlcnkgbmV3IGluc3RhbmNlLlxuICogQXBwbHlpbmcgYSBzbmFwc2hvdCBpbiB3aGljaCB0aGUgb3B0aW9uYWwgdmFsdWUgaXMgb25lIG9mIHRoZSBvcHRpb25hbCB2YWx1ZXMgKG9yIGB1bmRlZmluZWRgL19ub3RfIHByZXNlbnQgaWYgbm9uZSBhcmUgcHJvdmlkZWQpIGNhdXNlcyB0aGVcbiAqIHZhbHVlIHRvIGJlIHJlc2V0LlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogY29uc3QgVG9kbyA9IHR5cGVzLm1vZGVsKHtcbiAqICAgdGl0bGU6IHR5cGVzLnN0cmluZyxcbiAqICAgc3VidGl0bGUxOiB0eXBlcy5vcHRpb25hbCh0eXBlcy5zdHJpbmcsIFwiXCIsIFtudWxsXSksXG4gKiAgIHN1YnRpdGxlMjogdHlwZXMub3B0aW9uYWwodHlwZXMuc3RyaW5nLCBcIlwiLCBbbnVsbCwgdW5kZWZpbmVkXSksXG4gKiAgIGRvbmU6IHR5cGVzLm9wdGlvbmFsKHR5cGVzLmJvb2xlYW4sIGZhbHNlKSxcbiAqICAgY3JlYXRlZDogdHlwZXMub3B0aW9uYWwodHlwZXMuRGF0ZSwgKCkgPT4gbmV3IERhdGUoKSksXG4gKiB9KVxuICpcbiAqIC8vIGlmIGRvbmUgaXMgbWlzc2luZyAvIHVuZGVmaW5lZCBpdCB3aWxsIGJlY29tZSBmYWxzZVxuICogLy8gaWYgY3JlYXRlZCBpcyBtaXNzaW5nIC8gdW5kZWZpbmVkIGl0IHdpbGwgZ2V0IGEgZnJlc2hseSBnZW5lcmF0ZWQgdGltZXN0YW1wXG4gKiAvLyBpZiBzdWJ0aXRsZTEgaXMgbnVsbCBpdCB3aWxsIGRlZmF1bHQgdG8gXCJcIiwgYnV0IGl0IGNhbm5vdCBiZSBtaXNzaW5nIG9yIHVuZGVmaW5lZFxuICogLy8gaWYgc3VidGl0bGUyIGlzIG51bGwgb3IgdW5kZWZpbmVkIGl0IHdpbGwgZGVmYXVsdCB0byBcIlwiOyBzaW5jZSBpdCBjYW4gYmUgdW5kZWZpbmVkIGl0IGNhbiBhbHNvIGJlIG1pc3NpbmdcbiAqIGNvbnN0IHRvZG8gPSBUb2RvLmNyZWF0ZSh7IHRpdGxlOiBcIkdldCBjb2ZmZWVcIiwgc3VidGl0bGUxOiBudWxsIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZU9yRnVuY3Rpb25cbiAqIEBwYXJhbSBvcHRpb25hbFZhbHVlcyBhbiBvcHRpb25hbCBhcnJheSB3aXRoIHplcm8gb3IgbW9yZSBwcmltaXRpdmUgdmFsdWVzIChzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgbnVsbCBvciB1bmRlZmluZWQpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhhdCB3aWxsIGJlIGNvbnZlcnRlZCBpbnRvIHRoZSBkZWZhdWx0LiBgWyB1bmRlZmluZWQgXWAgaXMgYXNzdW1lZCB3aGVuIG5vbmUgaXMgcHJvdmlkZWRcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBvcHRpb25hbCh0eXBlLCBkZWZhdWx0VmFsdWVPckZ1bmN0aW9uLCBvcHRpb25hbFZhbHVlcykge1xuICBjaGVja09wdGlvbmFsUHJlY29uZGl0aW9ucyh0eXBlLCBkZWZhdWx0VmFsdWVPckZ1bmN0aW9uKTtcbiAgcmV0dXJuIG5ldyBPcHRpb25hbFZhbHVlKHR5cGUsIGRlZmF1bHRWYWx1ZU9yRnVuY3Rpb24sIG9wdGlvbmFsVmFsdWVzID8gb3B0aW9uYWxWYWx1ZXMgOiB1bmRlZmluZWRBc09wdGlvbmFsVmFsdWVzKTtcbn1cblxudmFyIHVuZGVmaW5lZEFzT3B0aW9uYWxWYWx1ZXMgPSBbdW5kZWZpbmVkXTtcbi8qKlxuICogUmV0dXJucyBpZiBhIHZhbHVlIHJlcHJlc2VudHMgYW4gb3B0aW9uYWwgdHlwZS5cbiAqXG4gKiBAdGVtcGxhdGUgSVRcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuc1xuICovXG5cbmZ1bmN0aW9uIGlzT3B0aW9uYWxUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGlzVHlwZSh0eXBlKSAmJiAodHlwZS5mbGFncyAmIFR5cGVGbGFncy5PcHRpb25hbCkgPiAwO1xufVxuXG52YXIgb3B0aW9uYWxVbmRlZmluZWRUeXBlID0gb3B0aW9uYWwodW5kZWZpbmVkVHlwZSwgdW5kZWZpbmVkKTtcbnZhciBvcHRpb25hbE51bGxUeXBlID0gb3B0aW9uYWwobnVsbFR5cGUsIG51bGwpO1xuLyoqXG4gKiBgdHlwZXMubWF5YmVgIC0gTWF5YmUgd2lsbCBtYWtlIGEgdHlwZSBudWxsYWJsZSwgYW5kIGFsc28gb3B0aW9uYWwuXG4gKiBUaGUgdmFsdWUgYHVuZGVmaW5lZGAgd2lsbCBiZSB1c2VkIHRvIHJlcHJlc2VudCBudWxsYWJpbGl0eS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnNcbiAqL1xuXG5mdW5jdGlvbiBtYXliZSh0eXBlKSB7XG4gIGFzc2VydElzVHlwZSh0eXBlLCAxKTtcbiAgcmV0dXJuIHVuaW9uKHR5cGUsIG9wdGlvbmFsVW5kZWZpbmVkVHlwZSk7XG59XG4vKipcbiAqIGB0eXBlcy5tYXliZU51bGxgIC0gTWF5YmUgd2lsbCBtYWtlIGEgdHlwZSBudWxsYWJsZSwgYW5kIGFsc28gb3B0aW9uYWwuXG4gKiBUaGUgdmFsdWUgYG51bGxgIHdpbGwgYmUgdXNlZCB0byByZXByZXNlbnQgbm8gdmFsdWUuXG4gKlxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBtYXliZU51bGwodHlwZSkge1xuICBhc3NlcnRJc1R5cGUodHlwZSwgMSk7XG4gIHJldHVybiB1bmlvbih0eXBlLCBvcHRpb25hbE51bGxUeXBlKTtcbn1cblxudmFyIExhdGUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTGF0ZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBMYXRlKG5hbWUsIF9kZWZpbml0aW9uKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSkgfHwgdGhpcztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfZGVmaW5pdGlvblwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogX2RlZmluaXRpb25cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX3N1YlR5cGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXRlLnByb3RvdHlwZSwgXCJmbGFnc1wiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX3N1YlR5cGUgPyB0aGlzLl9zdWJUeXBlLmZsYWdzIDogMCkgfCBUeXBlRmxhZ3MuTGF0ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExhdGUucHJvdG90eXBlLCBcImdldFN1YlR5cGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG11c3RTdWNjZWVkKSB7XG4gICAgICBpZiAoIXRoaXMuX3N1YlR5cGUpIHtcbiAgICAgICAgdmFyIHQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0ID0gdGhpcy5fZGVmaW5pdGlvbigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSZWZlcmVuY2VFcnJvcikgLy8gY2FuIGhhcHBlbiBpbiBzdHJpY3QgRVM1IGNvZGUgd2hlbiBhIGRlZmluaXRpb24gaXMgc2VsZiByZWZlcmluZ1xuICAgICAgICAgICAgdCA9IHVuZGVmaW5lZDtlbHNlIHRocm93IGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobXVzdFN1Y2NlZWQgJiYgdCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBmYWlsJDEoXCJMYXRlIHR5cGUgc2VlbXMgdG8gYmUgdXNlZCB0b28gZWFybHksIHRoZSBkZWZpbml0aW9uIChzdGlsbCkgcmV0dXJucyB1bmRlZmluZWRcIik7XG5cbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICBpZiAoZGV2TW9kZSgpICYmICFpc1R5cGUodCkpIHRocm93IGZhaWwkMShcIkZhaWxlZCB0byBkZXRlcm1pbmUgc3VidHlwZSwgbWFrZSBzdXJlIHR5cGVzLmxhdGUgcmV0dXJucyBhIHR5cGUgZGVmaW5pdGlvbi5cIik7XG4gICAgICAgICAgdGhpcy5fc3ViVHlwZSA9IHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3N1YlR5cGU7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExhdGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFN1YlR5cGUodHJ1ZSkuaW5zdGFudGlhdGUocGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF0ZS5wcm90b3R5cGUsIFwicmVjb25jaWxlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChjdXJyZW50LCBuZXdWYWx1ZSwgcGFyZW50LCBzdWJwYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdWJUeXBlKHRydWUpLnJlY29uY2lsZShjdXJyZW50LCBuZXdWYWx1ZSwgcGFyZW50LCBzdWJwYXRoKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF0ZS5wcm90b3R5cGUsIFwiZGVzY3JpYmVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmdldFN1YlR5cGUoZmFsc2UpO1xuICAgICAgcmV0dXJuIHQgPyB0Lm5hbWUgOiBcIjx1a25vd24gbGF0ZSB0eXBlPlwiO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXRlLnByb3RvdHlwZSwgXCJpc1ZhbGlkU25hcHNob3RcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgdCA9IHRoaXMuZ2V0U3ViVHlwZShmYWxzZSk7XG5cbiAgICAgIGlmICghdCkge1xuICAgICAgICAvLyBTZWUgIzkxNjsgdGhlIHZhcmlhYmxlIHRoZSBkZWZpbml0aW9uIGNsb3N1cmUgaXMgcG9pbnRpbmcgdG8gd2Fzbid0IGRlZmluZWQgeWV0LCBzbyBjYW4ndCBiZSBldmFsdXRlZCB5ZXQgaGVyZVxuICAgICAgICByZXR1cm4gdHlwZUNoZWNrU3VjY2VzcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdC52YWxpZGF0ZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExhdGUucHJvdG90eXBlLCBcImlzQXNzaWduYWJsZUZyb21cIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5nZXRTdWJUeXBlKGZhbHNlKTtcbiAgICAgIHJldHVybiB0ID8gdC5pc0Fzc2lnbmFibGVGcm9tKHR5cGUpIDogZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExhdGUucHJvdG90eXBlLCBcImdldFN1YlR5cGVzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdWJ0eXBlID0gdGhpcy5nZXRTdWJUeXBlKGZhbHNlKTtcbiAgICAgIHJldHVybiBzdWJ0eXBlID8gc3VidHlwZSA6IGNhbm5vdERldGVybWluZVN1YnR5cGU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIExhdGU7XG59KEJhc2VUeXBlKTtcbi8qKlxuICogYHR5cGVzLmxhdGVgIC0gRGVmaW5lcyBhIHR5cGUgdGhhdCBnZXRzIGltcGxlbWVudGVkIGxhdGVyLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSBoYXZlIHRvIGRlYWwgd2l0aCBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gKiBQbGVhc2Ugbm90aWNlIHRoYXQgd2hlbiBkZWZpbmluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMgVHlwZVNjcmlwdCBpc24ndCBzbWFydCBlbm91Z2ggdG8gaW5mZXJlbmNlIHRoZW0uXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiAgIC8vIFR5cGVTY3JpcHQgaXNuJ3Qgc21hcnQgZW5vdWdoIHRvIGluZmVyIHNlbGYgcmVmZXJlbmNpbmcgdHlwZXMuXG4gKiAgY29uc3QgTm9kZSA9IHR5cGVzLm1vZGVsKHtcbiAqICAgICAgIGNoaWxkcmVuOiB0eXBlcy5hcnJheSh0eXBlcy5sYXRlKCgpOiBJQW55TW9kZWxUeXBlID0+IE5vZGUpKSAvLyB0aGVuIHR5cGVjYXN0IGVhY2ggYXJyYXkgZWxlbWVudCB0byBJbnN0YW5jZTx0eXBlb2YgTm9kZT5cbiAqICB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgdG8gdXNlIGZvciB0aGUgdHlwZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0gdHlwZSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdHlwZSB0aGF0IHdpbGwgYmUgZGVmaW5lZC5cbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBsYXRlKG5hbWVPclR5cGUsIG1heWJlVHlwZSkge1xuICB2YXIgbmFtZSA9IHR5cGVvZiBuYW1lT3JUeXBlID09PSBcInN0cmluZ1wiID8gbmFtZU9yVHlwZSA6IFwibGF0ZShcIiArIG5hbWVPclR5cGUudG9TdHJpbmcoKSArIFwiKVwiO1xuICB2YXIgdHlwZSA9IHR5cGVvZiBuYW1lT3JUeXBlID09PSBcInN0cmluZ1wiID8gbWF5YmVUeXBlIDogbmFtZU9yVHlwZTsgLy8gY2hlY2tzIHRoYXQgdGhlIHR5cGUgaXMgYWN0dWFsbHkgYSBsYXRlIHR5cGVcblxuICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgaWYgKCEodHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlLmxlbmd0aCA9PT0gMCkpIHRocm93IGZhaWwkMShcIkludmFsaWQgbGF0ZSB0eXBlLCBleHBlY3RlZCBhIGZ1bmN0aW9uIHdpdGggemVybyBhcmd1bWVudHMgdGhhdCByZXR1cm5zIGEgdHlwZSwgZ290OiBcIiArIHR5cGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBMYXRlKG5hbWUsIHR5cGUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGlmIGEgZ2l2ZW4gdmFsdWUgcmVwcmVzZW50cyBhIGxhdGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzTGF0ZVR5cGUodHlwZSkge1xuICByZXR1cm4gaXNUeXBlKHR5cGUpICYmICh0eXBlLmZsYWdzICYgVHlwZUZsYWdzLkxhdGUpID4gMDtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG52YXIgRnJvemVuID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEZyb3plbiwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBGcm96ZW4oc3ViVHlwZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHN1YlR5cGUgPyBcImZyb3plbihcIiArIHN1YlR5cGUubmFtZSArIFwiKVwiIDogXCJmcm96ZW5cIikgfHwgdGhpcztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzdWJUeXBlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBzdWJUeXBlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImZsYWdzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBUeXBlRmxhZ3MuRnJvemVuXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyb3plbi5wcm90b3R5cGUsIFwiZGVzY3JpYmVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiPGFueSBpbW11dGFibGUgdmFsdWU+XCI7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyb3plbi5wcm90b3R5cGUsIFwiaW5zdGFudGlhdGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIHZhbHVlKSB7XG4gICAgICAvLyBjcmVhdGUgdGhlIG5vZGVcbiAgICAgIHJldHVybiBjcmVhdGVTY2FsYXJOb2RlKHRoaXMsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGRlZXBGcmVlemUodmFsdWUpKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJvemVuLnByb3RvdHlwZSwgXCJpc1ZhbGlkU25hcHNob3RcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICBpZiAoIWlzU2VyaWFsaXphYmxlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHlwZUNoZWNrRmFpbHVyZShjb250ZXh0LCB2YWx1ZSwgXCJWYWx1ZSBpcyBub3Qgc2VyaWFsaXphYmxlIGFuZCBjYW5ub3QgYmUgZnJvemVuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdWJUeXBlKSByZXR1cm4gdGhpcy5zdWJUeXBlLnZhbGlkYXRlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiB0eXBlQ2hlY2tTdWNjZXNzKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIEZyb3plbjtcbn0oU2ltcGxlVHlwZSk7XG5cbnZhciB1bnR5cGVkRnJvemVuSW5zdGFuY2UgPSBuZXcgRnJvemVuKCk7XG4vKipcbiAqIGB0eXBlcy5mcm96ZW5gIC0gRnJvemVuIGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFueSB2YWx1ZSB0aGF0IGlzIHNlcmlhbGl6YWJsZSBpbiBpdHNlbGYgKHRoYXQgaXMgdmFsaWQgSlNPTikuXG4gKiBGcm96ZW4gdmFsdWVzIG5lZWQgdG8gYmUgaW1tdXRhYmxlIG9yIHRyZWF0ZWQgYXMgaWYgaW1tdXRhYmxlLiBUaGV5IG5lZWQgYmUgc2VyaWFsaXphYmxlIGFzIHdlbGwuXG4gKiBWYWx1ZXMgc3RvcmVkIGluIGZyb3plbiB3aWxsIHNuYXBzaG90dGVkIGFzLWlzIGJ5IE1TVCwgYW5kIGludGVybmFsIGNoYW5nZXMgd2lsbCBub3QgYmUgdHJhY2tlZC5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCB0byBzdG9yZSBjb21wbGV4LCBidXQgaW1tdXRhYmxlIHZhbHVlcyBsaWtlIHZlY3RvcnMgZXRjLiBJdCBjYW4gZm9ybSBhIHBvd2VyZnVsIGJyaWRnZSB0byBwYXJ0cyBvZiB5b3VyIGFwcGxpY2F0aW9uIHRoYXQgc2hvdWxkIGJlIGltbXV0YWJsZSwgb3IgdGhhdCBhc3N1bWUgZGF0YSB0byBiZSBpbW11dGFibGUuXG4gKlxuICogTm90ZTogaWYgeW91IHdhbnQgdG8gc3RvcmUgZnJlZS1mb3JtIHN0YXRlIHRoYXQgaXMgbXV0YWJsZSwgb3Igbm90IHNlcmlhbGl6ZWFibGUsIGNvbnNpZGVyIHVzaW5nIHZvbGF0aWxlIHN0YXRlIGluc3RlYWQuXG4gKlxuICogRnJvemVuIHByb3BlcnRpZXMgY2FuIGJlIGRlZmluZWQgaW4gdGhyZWUgZGlmZmVyZW50IHdheXNcbiAqIDEuIGB0eXBlcy5mcm96ZW4oU3ViVHlwZSlgIC0gcHJvdmlkZSBhIHZhbGlkIE1TVCB0eXBlIGFuZCBmcm96ZW4gd2lsbCBjaGVjayBpZiB0aGUgcHJvdmlkZWQgZGF0YSBjb25mb3JtcyB0aGUgc25hcHNob3QgZm9yIHRoYXQgdHlwZVxuICogMi4gYHR5cGVzLmZyb3plbih7IHNvbWVEZWZhdWx0VmFsdWU6IHRydWV9KWAgLSBwcm92aWRlIGEgcHJpbWl0aXZlIHZhbHVlLCBvYmplY3Qgb3IgYXJyYXksIGFuZCBNU1Qgd2lsbCBpbmZlciB0aGUgdHlwZSBmcm9tIHRoYXQgb2JqZWN0LCBhbmQgYWxzbyBtYWtlIGl0IHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgZmllbGRcbiAqIDMuIGB0eXBlcy5mcm96ZW48VHlwZVNjcmlwdFR5cGU+KClgIC0gcHJvdmlkZSBhIHR5cGVzY3JpcHQgdHlwZSwgdG8gaGVscCBpbiBzdHJvbmdseSB0eXBpbmcgdGhlIGZpZWxkIChkZXNpZ24gdGltZSBvbmx5KVxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogY29uc3QgR2FtZUNoYXJhY3RlciA9IHR5cGVzLm1vZGVsKHtcbiAqICAgbmFtZTogc3RyaW5nLFxuICogICBsb2NhdGlvbjogdHlwZXMuZnJvemVuKHsgeDogMCwgeTogMH0pXG4gKiB9KVxuICpcbiAqIGNvbnN0IGhlcm8gPSBHYW1lQ2hhcmFjdGVyLmNyZWF0ZSh7XG4gKiAgIG5hbWU6IFwiTWFyaW9cIixcbiAqICAgbG9jYXRpb246IHsgeDogNywgeTogNCB9XG4gKiB9KVxuICpcbiAqIGhlcm8ubG9jYXRpb24gPSB7IHg6IDEwLCB5OiAyIH0gLy8gT0tcbiAqIGhlcm8ubG9jYXRpb24ueCA9IDcgLy8gTm90IG9rIVxuICogYGBgXG4gKlxuICogYGBgdHNcbiAqIHR5cGUgUG9pbnQgPSB7IHg6IG51bWJlciwgeTogbnVtYmVyIH1cbiAqICAgIGNvbnN0IE1vdXNlID0gdHlwZXMubW9kZWwoe1xuICogICAgICAgICBsb2M6IHR5cGVzLmZyb3plbjxQb2ludD4oKVxuICogICAgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWVPclR5cGVcbiAqIEByZXR1cm5zXG4gKi9cblxuZnVuY3Rpb24gZnJvemVuKGFyZykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHVudHlwZWRGcm96ZW5JbnN0YW5jZTtlbHNlIGlmIChpc1R5cGUoYXJnKSkgcmV0dXJuIG5ldyBGcm96ZW4oYXJnKTtlbHNlIHJldHVybiBvcHRpb25hbCh1bnR5cGVkRnJvemVuSW5zdGFuY2UsIGFyZyk7XG59XG4vKipcbiAqIFJldHVybnMgaWYgYSBnaXZlbiB2YWx1ZSByZXByZXNlbnRzIGEgZnJvemVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm5zXG4gKi9cblxuXG5mdW5jdGlvbiBpc0Zyb3plblR5cGUodHlwZSkge1xuICByZXR1cm4gaXNUeXBlKHR5cGUpICYmICh0eXBlLmZsYWdzICYgVHlwZUZsYWdzLkZyb3plbikgPiAwO1xufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkYXRpb25DYXVzZShob29rKSB7XG4gIHN3aXRjaCAoaG9vaykge1xuICAgIGNhc2UgSG9vay5iZWZvcmVEZXN0cm95OlxuICAgICAgcmV0dXJuIFwiZGVzdHJveVwiO1xuXG4gICAgY2FzZSBIb29rLmJlZm9yZURldGFjaDpcbiAgICAgIHJldHVybiBcImRldGFjaFwiO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxudmFyIFN0b3JlZFJlZmVyZW5jZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0b3JlZFJlZmVyZW5jZSh2YWx1ZSwgdGFyZ2V0VHlwZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhcmdldFR5cGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHRhcmdldFR5cGVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZGVudGlmaWVyXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNvbHZlZFJlZmVyZW5jZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG5cbiAgICBpZiAoaXNWYWxpZElkZW50aWZpZXIodmFsdWUpKSB7XG4gICAgICB0aGlzLmlkZW50aWZpZXIgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlzU3RhdGVUcmVlTm9kZSh2YWx1ZSkpIHtcbiAgICAgIHZhciB0YXJnZXROb2RlID0gZ2V0U3RhdGVUcmVlTm9kZSh2YWx1ZSk7XG4gICAgICBpZiAoIXRhcmdldE5vZGUuaWRlbnRpZmllckF0dHJpYnV0ZSkgdGhyb3cgZmFpbCQxKFwiQ2FuIG9ubHkgc3RvcmUgcmVmZXJlbmNlcyB3aXRoIGEgZGVmaW5lZCBpZGVudGlmaWVyIGF0dHJpYnV0ZS5cIik7XG4gICAgICB2YXIgaWQgPSB0YXJnZXROb2RlLnVubm9ybWFsaXplZElkZW50aWZpZXI7XG5cbiAgICAgIGlmIChpZCA9PT0gbnVsbCB8fCBpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IGZhaWwkMShcIkNhbiBvbmx5IHN0b3JlIHJlZmVyZW5jZXMgdG8gdHJlZSBub2RlcyB3aXRoIGEgZGVmaW5lZCBpZGVudGlmaWVyLlwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGZhaWwkMShcIkNhbiBvbmx5IHN0b3JlIHJlZmVyZW5jZXMgdG8gdHJlZSBub2RlcyBvciBpZGVudGlmaWVycywgZ290OiAnXCIgKyB2YWx1ZSArIFwiJ1wiKTtcbiAgICB9XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmVkUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJ1cGRhdGVSZXNvbHZlZFJlZmVyZW5jZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIG5vcm1hbGl6ZWRJZCA9IG5vcm1hbGl6ZUlkZW50aWZpZXIodGhpcy5pZGVudGlmaWVyKTtcbiAgICAgIHZhciByb290ID0gbm9kZS5yb290O1xuICAgICAgdmFyIGxhc3RDYWNoZU1vZGlmaWNhdGlvbiA9IHJvb3QuaWRlbnRpZmllckNhY2hlLmdldExhc3RDYWNoZU1vZGlmaWNhdGlvblBlcklkKG5vcm1hbGl6ZWRJZCk7XG5cbiAgICAgIGlmICghdGhpcy5yZXNvbHZlZFJlZmVyZW5jZSB8fCB0aGlzLnJlc29sdmVkUmVmZXJlbmNlLmxhc3RDYWNoZU1vZGlmaWNhdGlvbiAhPT0gbGFzdENhY2hlTW9kaWZpY2F0aW9uKSB7XG4gICAgICAgIHZhciB0YXJnZXRUeXBlID0gdGhpcy50YXJnZXRUeXBlOyAvLyByZWZlcmVuY2Ugd2FzIGluaXRpYWxpemVkIHdpdGggdGhlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldFxuXG4gICAgICAgIHZhciB0YXJnZXQgPSByb290LmlkZW50aWZpZXJDYWNoZS5yZXNvbHZlKHRhcmdldFR5cGUsIG5vcm1hbGl6ZWRJZCk7XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJlZmVyZW5jZUVycm9yKFwiW21vYngtc3RhdGUtdHJlZV0gRmFpbGVkIHRvIHJlc29sdmUgcmVmZXJlbmNlICdcIiArIHRoaXMuaWRlbnRpZmllciArIFwiJyB0byB0eXBlICdcIiArIHRoaXMudGFyZ2V0VHlwZS5uYW1lICsgXCInIChmcm9tIG5vZGU6IFwiICsgbm9kZS5wYXRoICsgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNvbHZlZFJlZmVyZW5jZSA9IHtcbiAgICAgICAgICBub2RlOiB0YXJnZXQsXG4gICAgICAgICAgbGFzdENhY2hlTW9kaWZpY2F0aW9uOiBsYXN0Q2FjaGVNb2RpZmljYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmVkUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJyZXNvbHZlZFZhbHVlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudXBkYXRlUmVzb2x2ZWRSZWZlcmVuY2UodGhpcy5ub2RlKTtcbiAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkUmVmZXJlbmNlLm5vZGUudmFsdWU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBTdG9yZWRSZWZlcmVuY2U7XG59KCk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxudmFyIEludmFsaWRSZWZlcmVuY2VFcnJvciA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhJbnZhbGlkUmVmZXJlbmNlRXJyb3IsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gSW52YWxpZFJlZmVyZW5jZUVycm9yKG0pIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtKSB8fCB0aGlzO1xuXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBJbnZhbGlkUmVmZXJlbmNlRXJyb3IucHJvdG90eXBlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gSW52YWxpZFJlZmVyZW5jZUVycm9yO1xufShFcnJvcik7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxudmFyIEJhc2VSZWZlcmVuY2VUeXBlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEJhc2VSZWZlcmVuY2VUeXBlLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEJhc2VSZWZlcmVuY2VUeXBlKHRhcmdldFR5cGUsIG9uSW52YWxpZGF0ZWQpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcInJlZmVyZW5jZShcIiArIHRhcmdldFR5cGUubmFtZSArIFwiKVwiKSB8fCB0aGlzO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcInRhcmdldFR5cGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHRhcmdldFR5cGVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwib25JbnZhbGlkYXRlZFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogb25JbnZhbGlkYXRlZFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJmbGFnc1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogVHlwZUZsYWdzLlJlZmVyZW5jZVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUmVmZXJlbmNlVHlwZS5wcm90b3R5cGUsIFwiZGVzY3JpYmVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVJlZmVyZW5jZVR5cGUucHJvdG90eXBlLCBcImlzQXNzaWduYWJsZUZyb21cIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRhcmdldFR5cGUuaXNBc3NpZ25hYmxlRnJvbSh0eXBlKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVJlZmVyZW5jZVR5cGUucHJvdG90eXBlLCBcImlzVmFsaWRTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBpc1ZhbGlkSWRlbnRpZmllcih2YWx1ZSkgPyB0eXBlQ2hlY2tTdWNjZXNzKCkgOiB0eXBlQ2hlY2tGYWlsdXJlKGNvbnRleHQsIHZhbHVlLCBcIlZhbHVlIGlzIG5vdCBhIHZhbGlkIGlkZW50aWZpZXIsIHdoaWNoIGlzIGEgc3RyaW5nIG9yIGEgbnVtYmVyXCIpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUmVmZXJlbmNlVHlwZS5wcm90b3R5cGUsIFwiZmlyZUludmFsaWRhdGVkXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChjYXVzZSwgc3RvcmVkUmVmTm9kZSwgcmVmZXJlbmNlSWQsIHJlZlRhcmdldE5vZGUpIHtcbiAgICAgIC8vIHRvIGFjdHVhbGx5IGludmFsaWRhdGUgYSByZWZlcmVuY2Ugd2UgbmVlZCBhbiBhbGl2ZSBwYXJlbnQsXG4gICAgICAvLyBzaW5jZSBpdCBpcyBhIHNjYWxhciB2YWx1ZSAoaW1tdXRhYmxlLWlzaCkgYW5kIHdlIG5lZWQgdG8gY2hhbmdlIGl0XG4gICAgICAvLyBmcm9tIHRoZSBwYXJlbnRcbiAgICAgIHZhciBzdG9yZWRSZWZQYXJlbnROb2RlID0gc3RvcmVkUmVmTm9kZS5wYXJlbnQ7XG5cbiAgICAgIGlmICghc3RvcmVkUmVmUGFyZW50Tm9kZSB8fCAhc3RvcmVkUmVmUGFyZW50Tm9kZS5pc0FsaXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0b3JlZFJlZlBhcmVudFZhbHVlID0gc3RvcmVkUmVmUGFyZW50Tm9kZS5zdG9yZWRWYWx1ZTtcblxuICAgICAgaWYgKCFzdG9yZWRSZWZQYXJlbnRWYWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMub25JbnZhbGlkYXRlZCh7XG4gICAgICAgIGNhdXNlOiBjYXVzZSxcbiAgICAgICAgcGFyZW50OiBzdG9yZWRSZWZQYXJlbnRWYWx1ZSxcbiAgICAgICAgaW52YWxpZFRhcmdldDogcmVmVGFyZ2V0Tm9kZSA/IHJlZlRhcmdldE5vZGUuc3RvcmVkVmFsdWUgOiB1bmRlZmluZWQsXG4gICAgICAgIGludmFsaWRJZDogcmVmZXJlbmNlSWQsXG4gICAgICAgIHJlcGxhY2VSZWY6IGZ1bmN0aW9uIChuZXdSZWYpIHtcbiAgICAgICAgICBhcHBseVBhdGNoKHN0b3JlZFJlZk5vZGUucm9vdC5zdG9yZWRWYWx1ZSwge1xuICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgdmFsdWU6IG5ld1JlZixcbiAgICAgICAgICAgIHBhdGg6IHN0b3JlZFJlZk5vZGUucGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVSZWY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaXNNb2RlbFR5cGUoc3RvcmVkUmVmUGFyZW50Tm9kZS50eXBlKSkge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUmVmKHVuZGVmaW5lZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFwcGx5UGF0Y2goc3RvcmVkUmVmTm9kZS5yb290LnN0b3JlZFZhbHVlLCB7XG4gICAgICAgICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgICBwYXRoOiBzdG9yZWRSZWZOb2RlLnBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VSZWZlcmVuY2VUeXBlLnByb3RvdHlwZSwgXCJhZGRUYXJnZXROb2RlV2F0Y2hlclwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoc3RvcmVkUmVmTm9kZSwgcmVmZXJlbmNlSWQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7IC8vIHRoaXMgd2lsbCBtYWtlIHN1cmUgdGhlIHRhcmdldCBub2RlIGJlY29tZXMgY3JlYXRlZFxuXG5cbiAgICAgIHZhciByZWZUYXJnZXRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoc3RvcmVkUmVmTm9kZSk7XG5cbiAgICAgIGlmICghcmVmVGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZlRhcmdldE5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKHJlZlRhcmdldFZhbHVlKTtcblxuICAgICAgdmFyIGhvb2tIYW5kbGVyID0gZnVuY3Rpb24gKF8sIHJlZlRhcmdldE5vZGVIb29rKSB7XG4gICAgICAgIHZhciBjYXVzZSA9IGdldEludmFsaWRhdGlvbkNhdXNlKHJlZlRhcmdldE5vZGVIb29rKTtcblxuICAgICAgICBpZiAoIWNhdXNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuZmlyZUludmFsaWRhdGVkKGNhdXNlLCBzdG9yZWRSZWZOb2RlLCByZWZlcmVuY2VJZCwgcmVmVGFyZ2V0Tm9kZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVmVGFyZ2V0RGV0YWNoSG9va0Rpc3Bvc2VyID0gcmVmVGFyZ2V0Tm9kZS5yZWdpc3Rlckhvb2soSG9vay5iZWZvcmVEZXRhY2gsIGhvb2tIYW5kbGVyKTtcbiAgICAgIHZhciByZWZUYXJnZXREZXN0cm95SG9va0Rpc3Bvc2VyID0gcmVmVGFyZ2V0Tm9kZS5yZWdpc3Rlckhvb2soSG9vay5iZWZvcmVEZXN0cm95LCBob29rSGFuZGxlcik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZWZUYXJnZXREZXRhY2hIb29rRGlzcG9zZXIoKTtcbiAgICAgICAgcmVmVGFyZ2V0RGVzdHJveUhvb2tEaXNwb3NlcigpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVJlZmVyZW5jZVR5cGUucHJvdG90eXBlLCBcIndhdGNoVGFyZ2V0Tm9kZUZvckludmFsaWRhdGlvbnNcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHN0b3JlZFJlZk5vZGUsIGlkZW50aWZpZXIsIGN1c3RvbUdldFNldCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLm9uSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb25SZWZUYXJnZXREZXN0cm95ZWRIb29rRGlzcG9zZXI7IC8vIGdldCByaWQgb2YgdGhlIHdhdGNoZXIgaG9vayB3aGVuIHRoZSBzdG9yZWQgcmVmIG5vZGUgaXMgZGVzdHJveWVkXG4gICAgICAvLyBkZXRhY2hlZCBpcyBpZ25vcmVkIHNpbmNlIHNjYWxhciBub2RlcyAod2hlcmUgdGhlIHJlZmVyZW5jZSByZXNpZGVzKSBjYW5ub3QgYmUgZGV0YWNoZWRcblxuICAgICAgc3RvcmVkUmVmTm9kZS5yZWdpc3Rlckhvb2soSG9vay5iZWZvcmVEZXN0cm95LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvblJlZlRhcmdldERlc3Ryb3llZEhvb2tEaXNwb3Nlcikge1xuICAgICAgICAgIG9uUmVmVGFyZ2V0RGVzdHJveWVkSG9va0Rpc3Bvc2VyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc3RhcnRXYXRjaGluZyA9IGZ1bmN0aW9uIChzeW5jKSB7XG4gICAgICAgIC8vIHJlLWNyZWF0ZSBob29rIGluIGNhc2UgdGhlIHN0b3JlZCByZWYgZ2V0cyByZWF0dGFjaGVkXG4gICAgICAgIGlmIChvblJlZlRhcmdldERlc3Ryb3llZEhvb2tEaXNwb3Nlcikge1xuICAgICAgICAgIG9uUmVmVGFyZ2V0RGVzdHJveWVkSG9va0Rpc3Bvc2VyKCk7XG4gICAgICAgIH0gLy8gbWFrZSBzdXJlIHRoZSB0YXJnZXQgbm9kZSBpcyBhY3R1YWxseSB0aGVyZSBhbmQgaW5pdGlhbGl6ZWRcblxuXG4gICAgICAgIHZhciBzdG9yZWRSZWZQYXJlbnROb2RlID0gc3RvcmVkUmVmTm9kZS5wYXJlbnQ7XG4gICAgICAgIHZhciBzdG9yZWRSZWZQYXJlbnRWYWx1ZSA9IHN0b3JlZFJlZlBhcmVudE5vZGUgJiYgc3RvcmVkUmVmUGFyZW50Tm9kZS5zdG9yZWRWYWx1ZTtcblxuICAgICAgICBpZiAoc3RvcmVkUmVmUGFyZW50Tm9kZSAmJiBzdG9yZWRSZWZQYXJlbnROb2RlLmlzQWxpdmUgJiYgc3RvcmVkUmVmUGFyZW50VmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVmVGFyZ2V0Tm9kZUV4aXN0cyA9IHZvaWQgMDtcblxuICAgICAgICAgIGlmIChjdXN0b21HZXRTZXQpIHtcbiAgICAgICAgICAgIHJlZlRhcmdldE5vZGVFeGlzdHMgPSAhIWN1c3RvbUdldFNldC5nZXQoaWRlbnRpZmllciwgc3RvcmVkUmVmUGFyZW50VmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWZUYXJnZXROb2RlRXhpc3RzID0gc3RvcmVkUmVmTm9kZS5yb290LmlkZW50aWZpZXJDYWNoZS5oYXMoX3RoaXMudGFyZ2V0VHlwZSwgbm9ybWFsaXplSWRlbnRpZmllcihpZGVudGlmaWVyKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFyZWZUYXJnZXROb2RlRXhpc3RzKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW5ub3QgY2hhbmdlIHRoZSByZWZlcmVuY2UgaW4gc3luYyBtb2RlXG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBhIHJlY29uY2lsaWF0aW9uL2luc3RhbnRpYXRpb24gYW5kIHRoZSBjaGFuZ2Ugd291bGQgYmUgb3ZlcndyaXR0ZW5cbiAgICAgICAgICAgIC8vIGZvciB0aG9zZSBjYXNlcyBqdXN0IGxldCB0aGUgd3JvbmcgcmVmZXJlbmNlIGJlIGFzc2lnbmVkIGFuZCBmYWlsIHVwb24gdXNhZ2VcbiAgICAgICAgICAgIC8vIChsaWtlIGN1cnJlbnQgcmVmZXJlbmNlcyBkbylcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBlZmZlY3RpdmVseSB0aGlzIGNvZGUgd2lsbCBvbmx5IHJ1biB3aGVuIGl0IGlzIGNyZWF0ZWQgZnJvbSBhIHNuYXBzaG90XG4gICAgICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICAgICAgX3RoaXMuZmlyZUludmFsaWRhdGVkKFwiaW52YWxpZFNuYXBzaG90UmVmZXJlbmNlXCIsIHN0b3JlZFJlZk5vZGUsIGlkZW50aWZpZXIsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvblJlZlRhcmdldERlc3Ryb3llZEhvb2tEaXNwb3NlciA9IF90aGlzLmFkZFRhcmdldE5vZGVXYXRjaGVyKHN0b3JlZFJlZk5vZGUsIGlkZW50aWZpZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHN0b3JlZFJlZk5vZGUuc3RhdGUgPT09IE5vZGVMaWZlQ3ljbGUuRklOQUxJWkVEKSB7XG4gICAgICAgIC8vIGFscmVhZHkgYXR0YWNoZWQsIHNvIHRoZSB3aG9sZSB0cmVlIGlzIHJlYWR5XG4gICAgICAgIHN0YXJ0V2F0Y2hpbmcodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXN0b3JlZFJlZk5vZGUuaXNSb290KSB7XG4gICAgICAgICAgLy8gc3RhcnQgd2F0Y2hpbmcgb25jZSB0aGUgd2hvbGUgdHJlZSBpcyByZWFkeVxuICAgICAgICAgIHN0b3JlZFJlZk5vZGUucm9vdC5yZWdpc3Rlckhvb2soSG9vay5hZnRlckNyZWF0aW9uRmluYWxpemF0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gYXR0YWNoIGl0IHNvIGl0IGNhbiBzdGFydCBsaXN0ZW5pbmdcbiAgICAgICAgICAgIGlmIChzdG9yZWRSZWZOb2RlLnBhcmVudCkge1xuICAgICAgICAgICAgICBzdG9yZWRSZWZOb2RlLnBhcmVudC5jcmVhdGVPYnNlcnZhYmxlSW5zdGFuY2VJZk5lZWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIHN0YXJ0IHdhdGNoaW5nIG9uY2UgdGhlIG5vZGUgaXMgYXR0YWNoZWQgc29tZXdoZXJlIC8gcGFyZW50IGNoYW5nZXNcblxuXG4gICAgICAgIHN0b3JlZFJlZk5vZGUucmVnaXN0ZXJIb29rKEhvb2suYWZ0ZXJBdHRhY2gsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGFydFdhdGNoaW5nKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIEJhc2VSZWZlcmVuY2VUeXBlO1xufShTaW1wbGVUeXBlKTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG52YXIgSWRlbnRpZmllclJlZmVyZW5jZVR5cGUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoSWRlbnRpZmllclJlZmVyZW5jZVR5cGUsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gSWRlbnRpZmllclJlZmVyZW5jZVR5cGUodGFyZ2V0VHlwZSwgb25JbnZhbGlkYXRlZCkge1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB0YXJnZXRUeXBlLCBvbkludmFsaWRhdGVkKSB8fCB0aGlzO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aWZpZXJSZWZlcmVuY2VUeXBlLnByb3RvdHlwZSwgXCJnZXRWYWx1ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoc3RvcmVkUmVmTm9kZSkge1xuICAgICAgaWYgKCFzdG9yZWRSZWZOb2RlLmlzQWxpdmUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc3RvcmVkUmVmID0gc3RvcmVkUmVmTm9kZS5zdG9yZWRWYWx1ZTtcbiAgICAgIHJldHVybiBzdG9yZWRSZWYucmVzb2x2ZWRWYWx1ZTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSWRlbnRpZmllclJlZmVyZW5jZVR5cGUucHJvdG90eXBlLCBcImdldFNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChzdG9yZWRSZWZOb2RlKSB7XG4gICAgICB2YXIgcmVmID0gc3RvcmVkUmVmTm9kZS5zdG9yZWRWYWx1ZTtcbiAgICAgIHJldHVybiByZWYuaWRlbnRpZmllcjtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSWRlbnRpZmllclJlZmVyZW5jZVR5cGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gaXNTdGF0ZVRyZWVOb2RlKGluaXRpYWxWYWx1ZSkgPyBnZXRJZGVudGlmaWVyKGluaXRpYWxWYWx1ZSkgOiBpbml0aWFsVmFsdWU7XG4gICAgICB2YXIgc3RvcmVkUmVmID0gbmV3IFN0b3JlZFJlZmVyZW5jZShpbml0aWFsVmFsdWUsIHRoaXMudGFyZ2V0VHlwZSk7XG4gICAgICB2YXIgc3RvcmVkUmVmTm9kZSA9IGNyZWF0ZVNjYWxhck5vZGUodGhpcywgcGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgc3RvcmVkUmVmKTtcbiAgICAgIHN0b3JlZFJlZi5ub2RlID0gc3RvcmVkUmVmTm9kZTtcbiAgICAgIHRoaXMud2F0Y2hUYXJnZXROb2RlRm9ySW52YWxpZGF0aW9ucyhzdG9yZWRSZWZOb2RlLCBpZGVudGlmaWVyLCB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIHN0b3JlZFJlZk5vZGU7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aWZpZXJSZWZlcmVuY2VUeXBlLnByb3RvdHlwZSwgXCJyZWNvbmNpbGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGN1cnJlbnQsIG5ld1ZhbHVlLCBwYXJlbnQsIHN1YnBhdGgpIHtcbiAgICAgIGlmICghY3VycmVudC5pc0RldGFjaGluZyAmJiBjdXJyZW50LnR5cGUgPT09IHRoaXMpIHtcbiAgICAgICAgdmFyIGNvbXBhcmVCeVZhbHVlID0gaXNTdGF0ZVRyZWVOb2RlKG5ld1ZhbHVlKTtcbiAgICAgICAgdmFyIHJlZiA9IGN1cnJlbnQuc3RvcmVkVmFsdWU7XG5cbiAgICAgICAgaWYgKCFjb21wYXJlQnlWYWx1ZSAmJiByZWYuaWRlbnRpZmllciA9PT0gbmV3VmFsdWUgfHwgY29tcGFyZUJ5VmFsdWUgJiYgcmVmLnJlc29sdmVkVmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgY3VycmVudC5zZXRQYXJlbnQocGFyZW50LCBzdWJwYXRoKTtcbiAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV3Tm9kZSA9IHRoaXMuaW5zdGFudGlhdGUocGFyZW50LCBzdWJwYXRoLCB1bmRlZmluZWQsIG5ld1ZhbHVlKTtcbiAgICAgIGN1cnJlbnQuZGllKCk7IC8vIG5vb3AgaWYgZGV0YWNoaW5nXG5cbiAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBJZGVudGlmaWVyUmVmZXJlbmNlVHlwZTtcbn0oQmFzZVJlZmVyZW5jZVR5cGUpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbnZhciBDdXN0b21SZWZlcmVuY2VUeXBlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEN1c3RvbVJlZmVyZW5jZVR5cGUsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQ3VzdG9tUmVmZXJlbmNlVHlwZSh0YXJnZXRUeXBlLCBvcHRpb25zLCBvbkludmFsaWRhdGVkKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdGFyZ2V0VHlwZSwgb25JbnZhbGlkYXRlZCkgfHwgdGhpcztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJvcHRpb25zXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBvcHRpb25zXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbVJlZmVyZW5jZVR5cGUucHJvdG90eXBlLCBcImdldFZhbHVlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChzdG9yZWRSZWZOb2RlKSB7XG4gICAgICBpZiAoIXN0b3JlZFJlZk5vZGUuaXNBbGl2ZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciByZWZlcmVuY2VkTm9kZSA9IHRoaXMub3B0aW9ucy5nZXQoc3RvcmVkUmVmTm9kZS5zdG9yZWRWYWx1ZSwgc3RvcmVkUmVmTm9kZS5wYXJlbnQgPyBzdG9yZWRSZWZOb2RlLnBhcmVudC5zdG9yZWRWYWx1ZSA6IG51bGwpO1xuICAgICAgcmV0dXJuIHJlZmVyZW5jZWROb2RlO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21SZWZlcmVuY2VUeXBlLnByb3RvdHlwZSwgXCJnZXRTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoc3RvcmVkUmVmTm9kZSkge1xuICAgICAgcmV0dXJuIHN0b3JlZFJlZk5vZGUuc3RvcmVkVmFsdWU7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbVJlZmVyZW5jZVR5cGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBuZXdWYWx1ZSkge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBpc1N0YXRlVHJlZU5vZGUobmV3VmFsdWUpID8gdGhpcy5vcHRpb25zLnNldChuZXdWYWx1ZSwgcGFyZW50ID8gcGFyZW50LnN0b3JlZFZhbHVlIDogbnVsbCkgOiBuZXdWYWx1ZTtcbiAgICAgIHZhciBzdG9yZWRSZWZOb2RlID0gY3JlYXRlU2NhbGFyTm9kZSh0aGlzLCBwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpZGVudGlmaWVyKTtcbiAgICAgIHRoaXMud2F0Y2hUYXJnZXROb2RlRm9ySW52YWxpZGF0aW9ucyhzdG9yZWRSZWZOb2RlLCBpZGVudGlmaWVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHN0b3JlZFJlZk5vZGU7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbVJlZmVyZW5jZVR5cGUucHJvdG90eXBlLCBcInJlY29uY2lsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoY3VycmVudCwgbmV3VmFsdWUsIHBhcmVudCwgc3VicGF0aCkge1xuICAgICAgdmFyIG5ld0lkZW50aWZpZXIgPSBpc1N0YXRlVHJlZU5vZGUobmV3VmFsdWUpID8gdGhpcy5vcHRpb25zLnNldChuZXdWYWx1ZSwgY3VycmVudCA/IGN1cnJlbnQuc3RvcmVkVmFsdWUgOiBudWxsKSA6IG5ld1ZhbHVlO1xuXG4gICAgICBpZiAoIWN1cnJlbnQuaXNEZXRhY2hpbmcgJiYgY3VycmVudC50eXBlID09PSB0aGlzICYmIGN1cnJlbnQuc3RvcmVkVmFsdWUgPT09IG5ld0lkZW50aWZpZXIpIHtcbiAgICAgICAgY3VycmVudC5zZXRQYXJlbnQocGFyZW50LCBzdWJwYXRoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdOb2RlID0gdGhpcy5pbnN0YW50aWF0ZShwYXJlbnQsIHN1YnBhdGgsIHVuZGVmaW5lZCwgbmV3SWRlbnRpZmllcik7XG4gICAgICBjdXJyZW50LmRpZSgpOyAvLyBub29wIGlmIGRldGFjaGluZ1xuXG4gICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gQ3VzdG9tUmVmZXJlbmNlVHlwZTtcbn0oQmFzZVJlZmVyZW5jZVR5cGUpO1xuLyoqXG4gKiBgdHlwZXMucmVmZXJlbmNlYCAtIENyZWF0ZXMgYSByZWZlcmVuY2UgdG8gYW5vdGhlciB0eXBlLCB3aGljaCBzaG91bGQgaGF2ZSBkZWZpbmVkIGFuIGlkZW50aWZpZXIuXG4gKiBTZWUgYWxzbyB0aGUgW3JlZmVyZW5jZSBhbmQgaWRlbnRpZmllcnNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC1zdGF0ZS10cmVlI3JlZmVyZW5jZXMtYW5kLWlkZW50aWZpZXJzKSBzZWN0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gcmVmZXJlbmNlKHN1YlR5cGUsIG9wdGlvbnMpIHtcbiAgYXNzZXJ0SXNUeXBlKHN1YlR5cGUsIDEpO1xuXG4gIGlmIChkZXZNb2RlKCkpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgdGhyb3cgZmFpbCQxKFwiUmVmZXJlbmNlcyB3aXRoIGJhc2UgcGF0aCBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gUGxlYXNlIHJlbW92ZSB0aGUgYmFzZSBwYXRoLlwiKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZ2V0U2V0T3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDogdW5kZWZpbmVkO1xuICB2YXIgb25JbnZhbGlkYXRlZCA9IG9wdGlvbnMgPyBvcHRpb25zLm9uSW52YWxpZGF0ZWQgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGdldFNldE9wdGlvbnMgJiYgKGdldFNldE9wdGlvbnMuZ2V0IHx8IGdldFNldE9wdGlvbnMuc2V0KSkge1xuICAgIGlmIChkZXZNb2RlKCkpIHtcbiAgICAgIGlmICghZ2V0U2V0T3B0aW9ucy5nZXQgfHwgIWdldFNldE9wdGlvbnMuc2V0KSB7XG4gICAgICAgIHRocm93IGZhaWwkMShcInJlZmVyZW5jZSBvcHRpb25zIG11c3QgZWl0aGVyIGNvbnRhaW4gYm90aCBhICdnZXQnIGFuZCBhICdzZXQnIG1ldGhvZCBvciBub25lIG9mIHRoZW1cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDdXN0b21SZWZlcmVuY2VUeXBlKHN1YlR5cGUsIHtcbiAgICAgIGdldDogZ2V0U2V0T3B0aW9ucy5nZXQsXG4gICAgICBzZXQ6IGdldFNldE9wdGlvbnMuc2V0XG4gICAgfSwgb25JbnZhbGlkYXRlZCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBJZGVudGlmaWVyUmVmZXJlbmNlVHlwZShzdWJUeXBlLCBvbkludmFsaWRhdGVkKTtcbiAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGlmIGEgZ2l2ZW4gdmFsdWUgcmVwcmVzZW50cyBhIHJlZmVyZW5jZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuc1xuICovXG5cblxuZnVuY3Rpb24gaXNSZWZlcmVuY2VUeXBlKHR5cGUpIHtcbiAgcmV0dXJuICh0eXBlLmZsYWdzICYgVHlwZUZsYWdzLlJlZmVyZW5jZSkgPiAwO1xufVxuLyoqXG4gKiBgdHlwZXMuc2FmZVJlZmVyZW5jZWAgLSBBIHNhZmUgcmVmZXJlbmNlIGlzIGxpa2UgYSBzdGFuZGFyZCByZWZlcmVuY2UsIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdGhlIHVuZGVmaW5lZCB2YWx1ZSBieSBkZWZhdWx0XG4gKiBhbmQgYXV0b21hdGljYWxseSBzZXRzIGl0c2VsZiB0byB1bmRlZmluZWQgKHdoZW4gdGhlIHBhcmVudCBpcyBhIG1vZGVsKSAvIHJlbW92ZXMgaXRzZWxmIGZyb20gYXJyYXlzIGFuZCBtYXBzXG4gKiB3aGVuIHRoZSByZWZlcmVuY2UgaXQgaXMgcG9pbnRpbmcgdG8gZ2V0cyBkZXRhY2hlZC9kZXN0cm95ZWQuXG4gKlxuICogVGhlIG9wdGlvbmFsIG9wdGlvbnMgcGFyYW1ldGVyIG9iamVjdCBhY2NlcHRzIGEgcGFyYW1ldGVyIG5hbWVkIGBhY2NlcHRzVW5kZWZpbmVkYCwgd2hpY2ggaXMgc2V0IHRvIHRydWUgYnkgZGVmYXVsdCwgc28gaXQgaXMgc3VpdGFibGVcbiAqIGZvciBtb2RlbCBwcm9wZXJ0aWVzLlxuICogV2hlbiB1c2VkIGluc2lkZSBjb2xsZWN0aW9ucyAoYXJyYXlzL21hcHMpLCBpdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgdGhpcyBvcHRpb24gdG8gZmFsc2Ugc28gaXQgY2FuJ3QgdGFrZSB1bmRlZmluZWQgYXMgdmFsdWUsXG4gKiB3aGljaCBpcyB1c3VhbGx5IHRoZSBkZXNpcmVkIGluIHRob3NlIGNhc2VzLlxuICogQWRkaXRpb25hbGx5LCB0aGUgb3B0aW9uYWwgb3B0aW9ucyBwYXJhbWV0ZXIgb2JqZWN0IGFjY2VwdHMgYSBwYXJhbWV0ZXIgbmFtZWQgYG9uSW52YWxpZGF0ZWRgLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSByZWZlcmVuY2UgdGFyZ2V0IG5vZGUgdGhhdCB0aGUgcmVmZXJlbmNlIGlzIHBvaW50aW5nIHRvIGlzIGFib3V0IHRvIGJlIGRldGFjaGVkL2Rlc3Ryb3llZFxuICpcbiAqIFN0cmljdGx5IHNwZWFraW5nIGl0IGlzIGEgYHR5cGVzLm1heWJlKHR5cGVzLnJlZmVyZW5jZShYKSlgICh3aGVuIGBhY2NlcHRzVW5kZWZpbmVkYCBpcyBzZXQgdG8gdHJ1ZSwgdGhlIGRlZmF1bHQpIGFuZFxuICogYHR5cGVzLnJlZmVyZW5jZShYKWAgKHdoZW4gYGFjY2VwdHNVbmRlZmluZWRgIGlzIHNldCB0byBmYWxzZSksIGJvdGggb2YgdGhlbSB3aXRoIGEgY3VzdG9taXplZCBgb25JbnZhbGlkYXRlZGAgb3B0aW9uLlxuICpcbiAqIEBwYXJhbSBzdWJUeXBlXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnNcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhZmVSZWZlcmVuY2Uoc3ViVHlwZSwgb3B0aW9ucykge1xuICB2YXIgcmVmVHlwZSA9IHJlZmVyZW5jZShzdWJUeXBlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICBvbkludmFsaWRhdGVkOiBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub25JbnZhbGlkYXRlZCkge1xuICAgICAgICBvcHRpb25zLm9uSW52YWxpZGF0ZWQoZXYpO1xuICAgICAgfVxuXG4gICAgICBldi5yZW1vdmVSZWYoKTtcbiAgICB9XG4gIH0pKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFjY2VwdHNVbmRlZmluZWQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHJlZlR5cGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1heWJlKHJlZlR5cGUpO1xuICB9XG59XG5cbnZhciBCYXNlSWRlbnRpZmllclR5cGUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQmFzZUlkZW50aWZpZXJUeXBlLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEJhc2VJZGVudGlmaWVyVHlwZShuYW1lLCB2YWxpZFR5cGUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcInZhbGlkVHlwZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdmFsaWRUeXBlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImZsYWdzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBUeXBlRmxhZ3MuSWRlbnRpZmllclxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlSWRlbnRpZmllclR5cGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGlmICghcGFyZW50IHx8ICEocGFyZW50LnR5cGUgaW5zdGFuY2VvZiBNb2RlbFR5cGUpKSB0aHJvdyBmYWlsJDEoXCJJZGVudGlmaWVyIHR5cGVzIGNhbiBvbmx5IGJlIGluc3RhbnRpYXRlZCBhcyBkaXJlY3QgY2hpbGQgb2YgYSBtb2RlbCB0eXBlXCIpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVNjYWxhck5vZGUodGhpcywgcGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUlkZW50aWZpZXJUeXBlLnByb3RvdHlwZSwgXCJyZWNvbmNpbGVcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGN1cnJlbnQsIG5ld1ZhbHVlLCBwYXJlbnQsIHN1YnBhdGgpIHtcbiAgICAgIC8vIHdlIGRvbid0IGNvbnNpZGVyIGRldGFjaGluZyBoZXJlIHNpbmNlIGlkZW50aWZpZXIgYXJlIHNjYWxhciBub2RlcywgYW5kIHNjYWxhciBub2RlcyBjYW5ub3QgYmUgZGV0YWNoZWRcbiAgICAgIGlmIChjdXJyZW50LnN0b3JlZFZhbHVlICE9PSBuZXdWYWx1ZSkgdGhyb3cgZmFpbCQxKFwiVHJpZWQgdG8gY2hhbmdlIGlkZW50aWZpZXIgZnJvbSAnXCIgKyBjdXJyZW50LnN0b3JlZFZhbHVlICsgXCInIHRvICdcIiArIG5ld1ZhbHVlICsgXCInLiBDaGFuZ2luZyBpZGVudGlmaWVycyBpcyBub3QgYWxsb3dlZC5cIik7XG4gICAgICBjdXJyZW50LnNldFBhcmVudChwYXJlbnQsIHN1YnBhdGgpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VJZGVudGlmaWVyVHlwZS5wcm90b3R5cGUsIFwiaXNWYWxpZFNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gdGhpcy52YWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVDaGVja0ZhaWx1cmUoY29udGV4dCwgdmFsdWUsIFwiVmFsdWUgaXMgbm90IGEgdmFsaWQgXCIgKyB0aGlzLmRlc2NyaWJlKCkgKyBcIiwgZXhwZWN0ZWQgYSBcIiArIHRoaXMudmFsaWRUeXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGVDaGVja1N1Y2Nlc3MoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gQmFzZUlkZW50aWZpZXJUeXBlO1xufShTaW1wbGVUeXBlKTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG52YXIgSWRlbnRpZmllclR5cGUgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoSWRlbnRpZmllclR5cGUsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gSWRlbnRpZmllclR5cGUoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJpZGVudGlmaWVyXCIsIFwic3RyaW5nXCIpIHx8IHRoaXM7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZmxhZ3NcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IFR5cGVGbGFncy5JZGVudGlmaWVyXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aWZpZXJUeXBlLnByb3RvdHlwZSwgXCJkZXNjcmliZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJpZGVudGlmaWVyXCI7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIElkZW50aWZpZXJUeXBlO1xufShCYXNlSWRlbnRpZmllclR5cGUpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbnZhciBJZGVudGlmaWVyTnVtYmVyVHlwZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhJZGVudGlmaWVyTnVtYmVyVHlwZSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBJZGVudGlmaWVyTnVtYmVyVHlwZSgpIHtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJpZGVudGlmaWVyTnVtYmVyXCIsIFwibnVtYmVyXCIpIHx8IHRoaXM7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSWRlbnRpZmllck51bWJlclR5cGUucHJvdG90eXBlLCBcImdldFNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5zdG9yZWRWYWx1ZTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSWRlbnRpZmllck51bWJlclR5cGUucHJvdG90eXBlLCBcImRlc2NyaWJlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcImlkZW50aWZpZXJOdW1iZXJcIjtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gSWRlbnRpZmllck51bWJlclR5cGU7XG59KEJhc2VJZGVudGlmaWVyVHlwZSk7XG4vKipcbiAqIGB0eXBlcy5pZGVudGlmaWVyYCAtIElkZW50aWZpZXJzIGFyZSB1c2VkIHRvIG1ha2UgcmVmZXJlbmNlcywgbGlmZWN5Y2xlIGV2ZW50cyBhbmQgcmVjb25jaWxpbmcgd29ya3MuXG4gKiBJbnNpZGUgYSBzdGF0ZSB0cmVlLCBmb3IgZWFjaCB0eXBlIGNhbiBleGlzdCBvbmx5IG9uZSBpbnN0YW5jZSBmb3IgZWFjaCBnaXZlbiBpZGVudGlmaWVyLlxuICogRm9yIGV4YW1wbGUgdGhlcmUgY291bGRuJ3QgYmUgMiBpbnN0YW5jZXMgb2YgdXNlciB3aXRoIGlkIDEuIElmIHlvdSBuZWVkIG1vcmUsIGNvbnNpZGVyIHVzaW5nIHJlZmVyZW5jZXMuXG4gKiBJZGVudGlmaWVyIGNhbiBiZSB1c2VkIG9ubHkgYXMgdHlwZSBwcm9wZXJ0eSBvZiBhIG1vZGVsLlxuICogVGhpcyB0eXBlIGFjY2VwdHMgYXMgcGFyYW1ldGVyIHRoZSB2YWx1ZSB0eXBlIG9mIHRoZSBpZGVudGlmaWVyIGZpZWxkIHRoYXQgY2FuIGJlIGVpdGhlciBzdHJpbmcgb3IgbnVtYmVyLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogIGNvbnN0IFRvZG8gPSB0eXBlcy5tb2RlbChcIlRvZG9cIiwge1xuICogICAgICBpZDogdHlwZXMuaWRlbnRpZmllcixcbiAqICAgICAgdGl0bGU6IHR5cGVzLnN0cmluZ1xuICogIH0pXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJuc1xuICovXG5cblxudmFyIGlkZW50aWZpZXIgPSBuZXcgSWRlbnRpZmllclR5cGUoKTtcbi8qKlxuICogYHR5cGVzLmlkZW50aWZpZXJOdW1iZXJgIC0gU2ltaWxhciB0byBgdHlwZXMuaWRlbnRpZmllcmAuIFRoaXMgb25lIHdpbGwgc2VyaWFsaXplIGZyb20gLyB0byBhIG51bWJlciB3aGVuIGFwcGx5aW5nIHNuYXBzaG90c1xuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogIGNvbnN0IFRvZG8gPSB0eXBlcy5tb2RlbChcIlRvZG9cIiwge1xuICogICAgICBpZDogdHlwZXMuaWRlbnRpZmllck51bWJlcixcbiAqICAgICAgdGl0bGU6IHR5cGVzLnN0cmluZ1xuICogIH0pXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJuc1xuICovXG5cbnZhciBpZGVudGlmaWVyTnVtYmVyID0gbmV3IElkZW50aWZpZXJOdW1iZXJUeXBlKCk7XG4vKipcbiAqIFJldHVybnMgaWYgYSBnaXZlbiB2YWx1ZSByZXByZXNlbnRzIGFuIGlkZW50aWZpZXIgdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnNcbiAqL1xuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGlzVHlwZSh0eXBlKSAmJiAodHlwZS5mbGFncyAmIFR5cGVGbGFncy5JZGVudGlmaWVyKSA+IDA7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplSWRlbnRpZmllcihpZCkge1xuICByZXR1cm4gXCJcIiArIGlkO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRJZGVudGlmaWVyKGlkKSB7XG4gIHJldHVybiB0eXBlb2YgaWQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGlkID09PSBcIm51bWJlclwiO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFzc2VydElzVmFsaWRJZGVudGlmaWVyKGlkLCBhcmdOdW1iZXIpIHtcbiAgYXNzZXJ0QXJnKGlkLCBpc1ZhbGlkSWRlbnRpZmllciwgXCJzdHJpbmcgb3IgbnVtYmVyIChpZGVudGlmaWVyKVwiLCBhcmdOdW1iZXIpO1xufVxuLyoqXG4gKiBgdHlwZXMuY3VzdG9tYCAtIENyZWF0ZXMgYSBjdXN0b20gdHlwZS4gQ3VzdG9tIHR5cGVzIGNhbiBiZSB1c2VkIGZvciBhcmJpdHJhcnkgaW1tdXRhYmxlIHZhbHVlcywgdGhhdCBoYXZlIGEgc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uLiBGb3IgZXhhbXBsZSwgdG8gY3JlYXRlIHlvdXIgb3duIERhdGUgcmVwcmVzZW50YXRpb24sIERlY2ltYWwgdHlwZSBldGMuXG4gKlxuICogVGhlIHNpZ25hdHVyZSBvZiB0aGUgb3B0aW9ucyBpczpcbiAqIGBgYHRzXG4gKiBleHBvcnQgaW50ZXJmYWNlIEN1c3RvbVR5cGVPcHRpb25zPFMsIFQ+IHtcbiAqICAgICAvLyBGcmllbmRseSBuYW1lXG4gKiAgICAgbmFtZTogc3RyaW5nXG4gKiAgICAgLy8gZ2l2ZW4gYSBzZXJpYWxpemVkIHZhbHVlIGFuZCBlbnZpcm9ubWVudCwgaG93IHRvIHR1cm4gaXQgaW50byB0aGUgdGFyZ2V0IHR5cGVcbiAqICAgICBmcm9tU25hcHNob3Qoc25hcHNob3Q6IFMsIGVudjogYW55KTogVFxuICogICAgIC8vIHJldHVybiB0aGUgc2VyaWFsaXphdGlvbiBvZiB0aGUgY3VycmVudCB2YWx1ZVxuICogICAgIHRvU25hcHNob3QodmFsdWU6IFQpOiBTXG4gKiAgICAgLy8gaWYgdHJ1ZSwgdGhpcyBpcyBhIGNvbnZlcnRlZCB2YWx1ZSwgaWYgZmFsc2UsIGl0J3MgYSBzbmFwc2hvdFxuICogICAgIGlzVGFyZ2V0VHlwZSh2YWx1ZTogVCB8IFMpOiB2YWx1ZSBpcyBUXG4gKiAgICAgLy8gYSBub24gZW1wdHkgc3RyaW5nIGlzIGFzc3VtZWQgdG8gYmUgYSB2YWxpZGF0aW9uIGVycm9yXG4gKiAgICAgZ2V0VmFsaWRhdGlvbk1lc3NhZ2U/KHNuYXBzaG90OiBTKTogc3RyaW5nXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IERlY2ltYWxQcmltaXRpdmUgPSB0eXBlcy5jdXN0b208c3RyaW5nLCBEZWNpbWFsPih7XG4gKiAgICAgbmFtZTogXCJEZWNpbWFsXCIsXG4gKiAgICAgZnJvbVNuYXBzaG90KHZhbHVlOiBzdHJpbmcpIHtcbiAqICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsKHZhbHVlKVxuICogICAgIH0sXG4gKiAgICAgdG9TbmFwc2hvdCh2YWx1ZTogRGVjaW1hbCkge1xuICogICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKVxuICogICAgIH0sXG4gKiAgICAgaXNUYXJnZXRUeXBlKHZhbHVlOiBzdHJpbmcgfCBEZWNpbWFsKTogYm9vbGVhbiB7XG4gKiAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERlY2ltYWxcbiAqICAgICB9LFxuICogICAgIGdldFZhbGlkYXRpb25NZXNzYWdlKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICogICAgICAgICBpZiAoL14tP1xcZCtcXC5cXGQrJC8udGVzdCh2YWx1ZSkpIHJldHVybiBcIlwiIC8vIE9LXG4gKiAgICAgICAgIHJldHVybiBgJyR7dmFsdWV9JyBkb2Vzbid0IGxvb2sgbGlrZSBhIHZhbGlkIGRlY2ltYWwgbnVtYmVyYFxuICogICAgIH1cbiAqIH0pXG4gKlxuICogY29uc3QgV2FsbGV0ID0gdHlwZXMubW9kZWwoe1xuICogICAgIGJhbGFuY2U6IERlY2ltYWxQcmltaXRpdmVcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGN1c3RvbShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgQ3VzdG9tVHlwZShvcHRpb25zKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cblxuXG52YXIgQ3VzdG9tVHlwZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDdXN0b21UeXBlLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEN1c3RvbVR5cGUob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMubmFtZSkgfHwgdGhpcztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJvcHRpb25zXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBvcHRpb25zXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImZsYWdzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBUeXBlRmxhZ3MuQ3VzdG9tXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbVR5cGUucHJvdG90eXBlLCBcImRlc2NyaWJlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbVR5cGUucHJvdG90eXBlLCBcImlzVmFsaWRTbmFwc2hvdFwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNUYXJnZXRUeXBlKHZhbHVlKSkgcmV0dXJuIHR5cGVDaGVja1N1Y2Nlc3MoKTtcbiAgICAgIHZhciB0eXBlRXJyb3IgPSB0aGlzLm9wdGlvbnMuZ2V0VmFsaWRhdGlvbk1lc3NhZ2UodmFsdWUpO1xuXG4gICAgICBpZiAodHlwZUVycm9yKSB7XG4gICAgICAgIHJldHVybiB0eXBlQ2hlY2tGYWlsdXJlKGNvbnRleHQsIHZhbHVlLCBcIkludmFsaWQgdmFsdWUgZm9yIHR5cGUgJ1wiICsgdGhpcy5uYW1lICsgXCInOiBcIiArIHR5cGVFcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlQ2hlY2tTdWNjZXNzKCk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbVR5cGUucHJvdG90eXBlLCBcImdldFNuYXBzaG90XCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRvU25hcHNob3Qobm9kZS5zdG9yZWRWYWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbVR5cGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZVRvU3RvcmUgPSB0aGlzLm9wdGlvbnMuaXNUYXJnZXRUeXBlKGluaXRpYWxWYWx1ZSkgPyBpbml0aWFsVmFsdWUgOiB0aGlzLm9wdGlvbnMuZnJvbVNuYXBzaG90KGluaXRpYWxWYWx1ZSwgcGFyZW50ICYmIHBhcmVudC5yb290LmVudmlyb25tZW50KTtcbiAgICAgIHJldHVybiBjcmVhdGVTY2FsYXJOb2RlKHRoaXMsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIHZhbHVlVG9TdG9yZSk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbVR5cGUucHJvdG90eXBlLCBcInJlY29uY2lsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoY3VycmVudCwgdmFsdWUsIHBhcmVudCwgc3VicGF0aCkge1xuICAgICAgdmFyIGlzU25hcHNob3QgPSAhdGhpcy5vcHRpb25zLmlzVGFyZ2V0VHlwZSh2YWx1ZSk7IC8vIGluIHRoZW9yeSBjdXN0b21zIHVzZSBzY2FsYXIgbm9kZXMgd2hpY2ggY2Fubm90IGJlIGRldGFjaGVkLCBidXQgc3RpbGwuLi5cblxuICAgICAgaWYgKCFjdXJyZW50LmlzRGV0YWNoaW5nKSB7XG4gICAgICAgIHZhciB1bmNoYW5nZWQgPSBjdXJyZW50LnR5cGUgPT09IHRoaXMgJiYgKGlzU25hcHNob3QgPyB2YWx1ZSA9PT0gY3VycmVudC5zbmFwc2hvdCA6IHZhbHVlID09PSBjdXJyZW50LnN0b3JlZFZhbHVlKTtcblxuICAgICAgICBpZiAodW5jaGFuZ2VkKSB7XG4gICAgICAgICAgY3VycmVudC5zZXRQYXJlbnQocGFyZW50LCBzdWJwYXRoKTtcbiAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVUb1N0b3JlID0gaXNTbmFwc2hvdCA/IHRoaXMub3B0aW9ucy5mcm9tU25hcHNob3QodmFsdWUsIHBhcmVudC5yb290LmVudmlyb25tZW50KSA6IHZhbHVlO1xuICAgICAgdmFyIG5ld05vZGUgPSB0aGlzLmluc3RhbnRpYXRlKHBhcmVudCwgc3VicGF0aCwgdW5kZWZpbmVkLCB2YWx1ZVRvU3RvcmUpO1xuICAgICAgY3VycmVudC5kaWUoKTsgLy8gbm9vcCBpZiBkZXRhY2hpbmdcblxuICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIEN1c3RvbVR5cGU7XG59KFNpbXBsZVR5cGUpOyAvLyB3ZSBpbXBvcnQgdGhlIHR5cGVzIHRvIHJlLWV4cG9ydCB0aGVtIGluc2lkZSB0eXBlcy5cblxuXG52YXIgdHlwZXMgPSB7XG4gIGVudW1lcmF0aW9uOiBlbnVtZXJhdGlvbixcbiAgbW9kZWw6IG1vZGVsLFxuICBjb21wb3NlOiBjb21wb3NlLFxuICBjdXN0b206IGN1c3RvbSxcbiAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gIHNhZmVSZWZlcmVuY2U6IHNhZmVSZWZlcmVuY2UsXG4gIHVuaW9uOiB1bmlvbixcbiAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICBsaXRlcmFsOiBsaXRlcmFsLFxuICBtYXliZTogbWF5YmUsXG4gIG1heWJlTnVsbDogbWF5YmVOdWxsLFxuICByZWZpbmVtZW50OiByZWZpbmVtZW50LFxuICBzdHJpbmc6IHN0cmluZyxcbiAgYm9vbGVhbjogYm9vbGVhbixcbiAgbnVtYmVyOiBudW1iZXIsXG4gIGludGVnZXI6IGludGVnZXIsXG4gIERhdGU6IERhdGVQcmltaXRpdmUsXG4gIG1hcDogbWFwLFxuICBhcnJheTogYXJyYXksXG4gIGZyb3plbjogZnJvemVuLFxuICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICBpZGVudGlmaWVyTnVtYmVyOiBpZGVudGlmaWVyTnVtYmVyLFxuICBsYXRlOiBsYXRlLFxuICB1bmRlZmluZWQ6IHVuZGVmaW5lZFR5cGUsXG4gIG51bGw6IG51bGxUeXBlLFxuICBzbmFwc2hvdFByb2Nlc3Nvcjogc25hcHNob3RQcm9jZXNzb3Jcbn07XG5leHBvcnQgeyBhZGREaXNwb3NlciwgYWRkTWlkZGxld2FyZSwgYXBwbHlBY3Rpb24sIGFwcGx5UGF0Y2gsIGFwcGx5U25hcHNob3QsIGNhc3QsIGNhc3RGbG93UmV0dXJuLCBjYXN0VG9SZWZlcmVuY2VTbmFwc2hvdCwgY2FzdFRvU25hcHNob3QsIGNsb25lLCBjcmVhdGVBY3Rpb25UcmFja2luZ01pZGRsZXdhcmUsIGNyZWF0ZUFjdGlvblRyYWNraW5nTWlkZGxld2FyZTIsIGRlY29yYXRlLCBkZXN0cm95LCBkZXRhY2gsIGVzY2FwZUpzb25QYXRoLCBmbG93LCBnZXRDaGlsZFR5cGUsIGdldEVudiwgZ2V0SWRlbnRpZmllciwgZ2V0TGl2ZWxpbmVzc0NoZWNraW5nLCBnZXRNZW1iZXJzLCBnZXROb2RlSWQsIGdldFBhcmVudCwgZ2V0UGFyZW50T2ZUeXBlLCBnZXRQYXRoLCBnZXRQYXRoUGFydHMsIGdldFByb3BlcnR5TWVtYmVycywgZ2V0UmVsYXRpdmVQYXRoLCBnZXRSb290LCBnZXRSdW5uaW5nQWN0aW9uQ29udGV4dCwgZ2V0U25hcHNob3QsIGdldFR5cGUsIGhhc1BhcmVudCwgaGFzUGFyZW50T2ZUeXBlLCBpc0FjdGlvbkNvbnRleHRDaGlsZE9mLCBpc0FjdGlvbkNvbnRleHRUaGlzT3JDaGlsZE9mLCBpc0FsaXZlLCBpc0FycmF5VHlwZSwgaXNGcm96ZW5UeXBlLCBpc0lkZW50aWZpZXJUeXBlLCBpc0xhdGVUeXBlLCBpc0xpdGVyYWxUeXBlLCBpc01hcFR5cGUsIGlzTW9kZWxUeXBlLCBpc09wdGlvbmFsVHlwZSwgaXNQcmltaXRpdmVUeXBlLCBpc1Byb3RlY3RlZCwgaXNSZWZlcmVuY2VUeXBlLCBpc1JlZmluZW1lbnRUeXBlLCBpc1Jvb3QsIGlzU3RhdGVUcmVlTm9kZSwgaXNUeXBlLCBpc1VuaW9uVHlwZSwgaXNWYWxpZFJlZmVyZW5jZSwgam9pbkpzb25QYXRoLCBvbkFjdGlvbiwgb25QYXRjaCwgb25TbmFwc2hvdCwgcHJvY2VzcyQxIGFzIHByb2Nlc3MsIHByb3RlY3QsIHJlY29yZEFjdGlvbnMsIHJlY29yZFBhdGNoZXMsIHJlc29sdmVJZGVudGlmaWVyLCByZXNvbHZlUGF0aCwgc2V0TGl2ZWxpbmVzc0NoZWNraW5nLCBzZXRMaXZlbHluZXNzQ2hlY2tpbmcsIHNwbGl0SnNvblBhdGgsIHRvR2VuZXJhdG9yLCB0b0dlbmVyYXRvckZ1bmN0aW9uLCB0cnlSZWZlcmVuY2UsIHRyeVJlc29sdmUsIHR5cGVjaGVjaywgdHlwZXMsIHVuZXNjYXBlSnNvblBhdGgsIHVucHJvdGVjdCwgd2FsayB9OyIsInZhciBuaWNlRXJyb3JzID0ge1xuICAwOiBcIkludmFsaWQgdmFsdWUgZm9yIGNvbmZpZ3VyYXRpb24gJ2VuZm9yY2VBY3Rpb25zJywgZXhwZWN0ZWQgJ25ldmVyJywgJ2Fsd2F5cycgb3IgJ29ic2VydmVkJ1wiLFxuICAxOiBmdW5jdGlvbiBfKGFubm90YXRpb25UeXBlLCBrZXkpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGUgKyBcIicgdG8gJ1wiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6IEZpZWxkIG5vdCBmb3VuZC5cIjtcbiAgfSxcbiAgNTogXCIna2V5cygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzLCBzZXRzIGFuZCBtYXBzXCIsXG4gIDY6IFwiJ3ZhbHVlcygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzLCBzZXRzIGFuZCBtYXBzXCIsXG4gIDc6IFwiJ2VudHJpZXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICA4OiBcIidzZXQoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICA5OiBcIidyZW1vdmUoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICAxMDogXCInaGFzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgMTE6IFwiJ2dldCgpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDEyOiBcIkludmFsaWQgYW5ub3RhdGlvblwiLFxuICAxMzogXCJEeW5hbWljIG9ic2VydmFibGUgb2JqZWN0cyBjYW5ub3QgYmUgZnJvemVuXCIsXG4gIDE0OiBcIkludGVyY2VwdCBoYW5kbGVycyBzaG91bGQgcmV0dXJuIG5vdGhpbmcgb3IgYSBjaGFuZ2Ugb2JqZWN0XCIsXG4gIDE1OiBcIk9ic2VydmFibGUgYXJyYXlzIGNhbm5vdCBiZSBmcm96ZW5cIixcbiAgMTY6IFwiTW9kaWZpY2F0aW9uIGV4Y2VwdGlvbjogdGhlIGludGVybmFsIHN0cnVjdHVyZSBvZiBhbiBvYnNlcnZhYmxlIGFycmF5IHdhcyBjaGFuZ2VkLlwiLFxuICAxNzogZnVuY3Rpb24gXyhpbmRleCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFwiW21vYnguYXJyYXldIEluZGV4IG91dCBvZiBib3VuZHMsIFwiICsgaW5kZXggKyBcIiBpcyBsYXJnZXIgdGhhbiBcIiArIGxlbmd0aDtcbiAgfSxcbiAgMTg6IFwibW9ieC5tYXAgcmVxdWlyZXMgTWFwIHBvbHlmaWxsIGZvciB0aGUgY3VycmVudCBicm93c2VyLiBDaGVjayBiYWJlbC1wb2x5ZmlsbCBvciBjb3JlLWpzL2VzNi9tYXAuanNcIixcbiAgMTk6IGZ1bmN0aW9uIF8ob3RoZXIpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgaW5pdGlhbGl6ZSBmcm9tIGNsYXNzZXMgdGhhdCBpbmhlcml0IGZyb20gTWFwOiBcIiArIG90aGVyLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH0sXG4gIDIwOiBmdW5jdGlvbiBfKG90aGVyKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IGluaXRpYWxpemUgbWFwIGZyb20gXCIgKyBvdGhlcjtcbiAgfSxcbiAgMjE6IGZ1bmN0aW9uIF8oZGF0YVN0cnVjdHVyZSkge1xuICAgIHJldHVybiBcIkNhbm5vdCBjb252ZXJ0IHRvIG1hcCBmcm9tICdcIiArIGRhdGFTdHJ1Y3R1cmUgKyBcIidcIjtcbiAgfSxcbiAgMjI6IFwibW9ieC5zZXQgcmVxdWlyZXMgU2V0IHBvbHlmaWxsIGZvciB0aGUgY3VycmVudCBicm93c2VyLiBDaGVjayBiYWJlbC1wb2x5ZmlsbCBvciBjb3JlLWpzL2VzNi9zZXQuanNcIixcbiAgMjM6IFwiSXQgaXMgbm90IHBvc3NpYmxlIHRvIGdldCBpbmRleCBhdG9tcyBmcm9tIGFycmF5c1wiLFxuICAyNDogZnVuY3Rpb24gXyh0aGluZykge1xuICAgIHJldHVybiBcIkNhbm5vdCBvYnRhaW4gYWRtaW5pc3RyYXRpb24gZnJvbSBcIiArIHRoaW5nO1xuICB9LFxuICAyNTogZnVuY3Rpb24gXyhwcm9wZXJ0eSwgbmFtZSkge1xuICAgIHJldHVybiBcInRoZSBlbnRyeSAnXCIgKyBwcm9wZXJ0eSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgb2JzZXJ2YWJsZSBtYXAgJ1wiICsgbmFtZSArIFwiJ1wiO1xuICB9LFxuICAyNjogXCJwbGVhc2Ugc3BlY2lmeSBhIHByb3BlcnR5XCIsXG4gIDI3OiBmdW5jdGlvbiBfKHByb3BlcnR5LCBuYW1lKSB7XG4gICAgcmV0dXJuIFwibm8gb2JzZXJ2YWJsZSBwcm9wZXJ0eSAnXCIgKyBwcm9wZXJ0eS50b1N0cmluZygpICsgXCInIGZvdW5kIG9uIHRoZSBvYnNlcnZhYmxlIG9iamVjdCAnXCIgKyBuYW1lICsgXCInXCI7XG4gIH0sXG4gIDI4OiBmdW5jdGlvbiBfKHRoaW5nKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IG9idGFpbiBhdG9tIGZyb20gXCIgKyB0aGluZztcbiAgfSxcbiAgMjk6IFwiRXhwZWN0aW5nIHNvbWUgb2JqZWN0XCIsXG4gIDMwOiBcImludmFsaWQgYWN0aW9uIHN0YWNrLiBkaWQgeW91IGZvcmdldCB0byBmaW5pc2ggYW4gYWN0aW9uP1wiLFxuICAzMTogXCJtaXNzaW5nIG9wdGlvbiBmb3IgY29tcHV0ZWQ6IGdldFwiLFxuICAzMjogZnVuY3Rpb24gXyhuYW1lLCBkZXJpdmF0aW9uKSB7XG4gICAgcmV0dXJuIFwiQ3ljbGUgZGV0ZWN0ZWQgaW4gY29tcHV0YXRpb24gXCIgKyBuYW1lICsgXCI6IFwiICsgZGVyaXZhdGlvbjtcbiAgfSxcbiAgMzM6IGZ1bmN0aW9uIF8obmFtZSkge1xuICAgIHJldHVybiBcIlRoZSBzZXR0ZXIgb2YgY29tcHV0ZWQgdmFsdWUgJ1wiICsgbmFtZSArIFwiJyBpcyB0cnlpbmcgdG8gdXBkYXRlIGl0c2VsZi4gRGlkIHlvdSBpbnRlbmQgdG8gdXBkYXRlIGFuIF9vYnNlcnZhYmxlXyB2YWx1ZSwgaW5zdGVhZCBvZiB0aGUgY29tcHV0ZWQgcHJvcGVydHk/XCI7XG4gIH0sXG4gIDM0OiBmdW5jdGlvbiBfKG5hbWUpIHtcbiAgICByZXR1cm4gXCJbQ29tcHV0ZWRWYWx1ZSAnXCIgKyBuYW1lICsgXCInXSBJdCBpcyBub3QgcG9zc2libGUgdG8gYXNzaWduIGEgbmV3IHZhbHVlIHRvIGEgY29tcHV0ZWQgdmFsdWUuXCI7XG4gIH0sXG4gIDM1OiBcIlRoZXJlIGFyZSBtdWx0aXBsZSwgZGlmZmVyZW50IHZlcnNpb25zIG9mIE1vYlggYWN0aXZlLiBNYWtlIHN1cmUgTW9iWCBpcyBsb2FkZWQgb25seSBvbmNlIG9yIHVzZSBgY29uZmlndXJlKHsgaXNvbGF0ZUdsb2JhbFN0YXRlOiB0cnVlIH0pYFwiLFxuICAzNjogXCJpc29sYXRlR2xvYmFsU3RhdGUgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgTW9iWCBpcyBydW5uaW5nIGFueSByZWFjdGlvbnNcIixcbiAgMzc6IGZ1bmN0aW9uIF8obWV0aG9kKSB7XG4gICAgcmV0dXJuIFwiW21vYnhdIGBvYnNlcnZhYmxlQXJyYXkuXCIgKyBtZXRob2QgKyBcIigpYCBtdXRhdGVzIHRoZSBhcnJheSBpbi1wbGFjZSwgd2hpY2ggaXMgbm90IGFsbG93ZWQgaW5zaWRlIGEgZGVyaXZhdGlvbi4gVXNlIGBhcnJheS5zbGljZSgpLlwiICsgbWV0aG9kICsgXCIoKWAgaW5zdGVhZFwiO1xuICB9XG59O1xudmFyIGVycm9ycyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IG5pY2VFcnJvcnMgOiB7fTtcblxuZnVuY3Rpb24gZGllKGVycm9yKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgZSA9IHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIiA/IGVycm9yIDogZXJyb3JzW2Vycm9yXTtcbiAgICBpZiAodHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIikgZSA9IGUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW01vYlhdIFwiICsgZSk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IodHlwZW9mIGVycm9yID09PSBcIm51bWJlclwiID8gXCJbTW9iWF0gbWluaWZpZWQgZXJyb3IgbnI6IFwiICsgZXJyb3IgKyAoYXJncy5sZW5ndGggPyBcIiBcIiArIGFyZ3MubWFwKFN0cmluZykuam9pbihcIixcIikgOiBcIlwiKSArIFwiLiBGaW5kIHRoZSBmdWxsIGVycm9yIGF0OiBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvYmxvYi9tYWluL3BhY2thZ2VzL21vYngvc3JjL2Vycm9ycy50c1wiIDogXCJbTW9iWF0gXCIgKyBlcnJvcik7XG59XG5cbnZhciBtb2NrR2xvYmFsID0ge307XG5cbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIHJldHVybiBtb2NrR2xvYmFsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbnZhciBnZXREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEVNUFRZX0FSUkFZID0gW107XG5PYmplY3QuZnJlZXplKEVNUFRZX0FSUkFZKTtcbnZhciBFTVBUWV9PQkpFQ1QgPSB7fTtcbk9iamVjdC5mcmVlemUoRU1QVFlfT0JKRUNUKTtcbnZhciBoYXNQcm94eSA9IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBwbGFpbk9iamVjdFN0cmluZyA9IC8qI19fUFVSRV9fKi9PYmplY3QudG9TdHJpbmcoKTtcblxuZnVuY3Rpb24gYXNzZXJ0UHJveGllcygpIHtcbiAgaWYgKCFoYXNQcm94eSkge1xuICAgIGRpZShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcImBQcm94eWAgb2JqZWN0cyBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gUGxlYXNlIGNvbmZpZ3VyZSBNb2JYIHRvIGVuYWJsZSBhIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uLmBcIiA6IFwiUHJveHkgbm90IGF2YWlsYWJsZVwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KG1zZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGdsb2JhbFN0YXRlLnZlcmlmeVByb3hpZXMpIHtcbiAgICBkaWUoXCJNb2JYIGlzIGN1cnJlbnRseSBjb25maWd1cmVkIHRvIGJlIGFibGUgdG8gcnVuIGluIEVTNSBtb2RlLCBidXQgaW4gRVM1IE1vYlggd29uJ3QgYmUgYWJsZSB0byBcIiArIG1zZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmV4dElkKCkge1xuICByZXR1cm4gKytnbG9iYWxTdGF0ZS5tb2J4R3VpZDtcbn1cbi8qKlxyXG4gKiBNYWtlcyBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGlzIGludm9rZWQgYXQgbW9zdCBvbmNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgdmFyIGludm9rZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaW52b2tlZCkgcmV0dXJuO1xuICAgIGludm9rZWQgPSB0cnVlO1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdpc2godmFsdWUpIHtcbiAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG5cbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICB2YXIgX3Byb3RvJGNvbnN0cnVjdG9yO1xuXG4gIGlmICghaXNPYmplY3QodmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIGlmIChwcm90byA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuICgoX3Byb3RvJGNvbnN0cnVjdG9yID0gcHJvdG8uY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfcHJvdG8kY29uc3RydWN0b3IudG9TdHJpbmcoKSkgPT09IHBsYWluT2JqZWN0U3RyaW5nO1xufSAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzc4NjUxNzBcblxuXG5mdW5jdGlvbiBpc0dlbmVyYXRvcihvYmopIHtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmouY29uc3RydWN0b3I7XG4gIGlmICghY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcbiAgaWYgKFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gY29uc3RydWN0b3IubmFtZSB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRIaWRkZW5Qcm9wKG9iamVjdCwgcHJvcE5hbWUsIHZhbHVlKSB7XG4gIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcE5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRIaWRkZW5GaW5hbFByb3Aob2JqZWN0LCBwcm9wTmFtZSwgdmFsdWUpIHtcbiAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wTmFtZSwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKG5hbWUsIHRoZUNsYXNzKSB7XG4gIHZhciBwcm9wTmFtZSA9IFwiaXNNb2JYXCIgKyBuYW1lO1xuICB0aGVDbGFzcy5wcm90b3R5cGVbcHJvcE5hbWVdID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIHhbcHJvcE5hbWVdID09PSB0cnVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc0VTNk1hcCh0aGluZykge1xuICByZXR1cm4gdGhpbmcgaW5zdGFuY2VvZiBNYXA7XG59XG5cbmZ1bmN0aW9uIGlzRVM2U2V0KHRoaW5nKSB7XG4gIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIFNldDtcbn1cblxudmFyIGhhc0dldE93blByb3BlcnR5U3ltYm9scyA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSBcInVuZGVmaW5lZFwiO1xuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZvbGxvd2luZzogb3duIGVudW1lcmFibGUga2V5cyBhbmQgc3ltYm9scy5cclxuICovXG5cbmZ1bmN0aW9uIGdldFBsYWluT2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyAvLyBOb3Qgc3VwcG9ydGVkIGluIElFLCBzbyB0aGVyZSBhcmUgbm90IGdvaW5nIHRvIGJlIHN5bWJvbCBwcm9wcyBhbnl3YXkuLi5cblxuICBpZiAoIWhhc0dldE93blByb3BlcnR5U3ltYm9scykgcmV0dXJuIGtleXM7XG4gIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICBpZiAoIXN5bWJvbHMubGVuZ3RoKSByZXR1cm4ga2V5cztcbiAgcmV0dXJuIFtdLmNvbmNhdChrZXlzLCBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBvYmplY3RQcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHMpO1xuICB9KSk7XG59IC8vIEZyb20gSW1tZXIgdXRpbHNcbi8vIFJldHVybnMgYWxsIG93biBrZXlzLCBpbmNsdWRpbmcgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbGljXG5cblxudmFyIG93bktleXMgPSB0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0Lm93bktleXMgPyBSZWZsZWN0Lm93bktleXMgOiBoYXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikpO1xufSA6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUtleShrZXkpIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHJldHVybiBrZXk7XG4gIGlmICh0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiKSByZXR1cm4ga2V5LnRvU3RyaW5nKCk7XG4gIHJldHVybiBuZXcgU3RyaW5nKGtleSkudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gdG9QcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gbnVsbCA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiA/IFwiXCIgKyB2YWx1ZSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBoYXNQcm9wKHRhcmdldCwgcHJvcCkge1xuICByZXR1cm4gb2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKTtcbn0gLy8gRnJvbSBJbW1lciB1dGlsc1xuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0YXJnZXQpIHtcbiAgLy8gUG9seWZpbGwgbmVlZGVkIGZvciBIZXJtZXMgYW5kIElFLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2hlcm1lcy9pc3N1ZXMvMjc0XG4gIHZhciByZXMgPSB7fTsgLy8gTm90ZTogd2l0aG91dCBwb2x5ZmlsbCBmb3Igb3duS2V5cywgc3ltYm9scyB3b24ndCBiZSBwaWNrZWQgdXBcblxuICBvd25LZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmVzW2tleV0gPSBnZXREZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgfSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gaXQubmV4dC5iaW5kKGl0KTtcbn1cblxudmFyIHN0b3JlZEFubm90YXRpb25zU3ltYm9sID0gLyojX19QVVJFX18qL1N5bWJvbChcIm1vYngtc3RvcmVkLWFubm90YXRpb25zXCIpO1xuLyoqXHJcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjdHMgYXNcclxuICogLSBkZWNvcmF0b3JcclxuICogLSBhbm5vdGF0aW9uIG9iamVjdFxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihhbm5vdGF0aW9uKSB7XG4gIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgc3RvcmVBbm5vdGF0aW9uKHRhcmdldCwgcHJvcGVydHksIGFubm90YXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVjb3JhdG9yLCBhbm5vdGF0aW9uKTtcbn1cbi8qKlxyXG4gKiBTdG9yZXMgYW5ub3RhdGlvbiB0byBwcm90b3R5cGUsXHJcbiAqIHNvIGl0IGNhbiBiZSBpbnNwZWN0ZWQgbGF0ZXIgYnkgYG1ha2VPYnNlcnZhYmxlYCBjYWxsZWQgZnJvbSBjb25zdHJ1Y3RvclxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdG9yZUFubm90YXRpb24ocHJvdG90eXBlLCBrZXksIGFubm90YXRpb24pIHtcbiAgaWYgKCFoYXNQcm9wKHByb3RvdHlwZSwgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wpKSB7XG4gICAgYWRkSGlkZGVuUHJvcChwcm90b3R5cGUsIHN0b3JlZEFubm90YXRpb25zU3ltYm9sLCBfZXh0ZW5kcyh7fSwgcHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkpO1xuICB9IC8vIEBvdmVycmlkZSBtdXN0IG92ZXJyaWRlIHNvbWV0aGluZ1xuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc092ZXJyaWRlKGFubm90YXRpb24pICYmICFoYXNQcm9wKHByb3RvdHlwZVtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0sIGtleSkpIHtcbiAgICB2YXIgZmllbGROYW1lID0gcHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWUgKyBcIi5wcm90b3R5cGUuXCIgKyBrZXkudG9TdHJpbmcoKTtcbiAgICBkaWUoXCInXCIgKyBmaWVsZE5hbWUgKyBcIicgaXMgZGVjb3JhdGVkIHdpdGggJ292ZXJyaWRlJywgXCIgKyBcImJ1dCBubyBzdWNoIGRlY29yYXRlZCBtZW1iZXIgd2FzIGZvdW5kIG9uIHByb3RvdHlwZS5cIik7XG4gIH0gLy8gQ2Fubm90IHJlLWRlY29yYXRlXG5cblxuICBhc3NlcnROb3REZWNvcmF0ZWQocHJvdG90eXBlLCBhbm5vdGF0aW9uLCBrZXkpOyAvLyBJZ25vcmUgb3ZlcnJpZGVcblxuICBpZiAoIWlzT3ZlcnJpZGUoYW5ub3RhdGlvbikpIHtcbiAgICBwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdW2tleV0gPSBhbm5vdGF0aW9uO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5vdERlY29yYXRlZChwcm90b3R5cGUsIGFubm90YXRpb24sIGtleSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc092ZXJyaWRlKGFubm90YXRpb24pICYmIGhhc1Byb3AocHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSwga2V5KSkge1xuICAgIHZhciBmaWVsZE5hbWUgPSBwcm90b3R5cGUuY29uc3RydWN0b3IubmFtZSArIFwiLnByb3RvdHlwZS5cIiArIGtleS50b1N0cmluZygpO1xuICAgIHZhciBjdXJyZW50QW5ub3RhdGlvblR5cGUgPSBwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdW2tleV0uYW5ub3RhdGlvblR5cGVfO1xuICAgIHZhciByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSA9IGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfO1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnQFwiICsgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgKyBcIicgdG8gJ1wiICsgZmllbGROYW1lICsgXCInOlwiICsgKFwiXFxuVGhlIGZpZWxkIGlzIGFscmVhZHkgZGVjb3JhdGVkIHdpdGggJ0BcIiArIGN1cnJlbnRBbm5vdGF0aW9uVHlwZSArIFwiJy5cIikgKyBcIlxcblJlLWRlY29yYXRpbmcgZmllbGRzIGlzIG5vdCBhbGxvd2VkLlwiICsgXCJcXG5Vc2UgJ0BvdmVycmlkZScgZGVjb3JhdG9yIGZvciBtZXRob2RzIG92ZXJyaWRlbiBieSBzdWJjbGFzcy5cIik7XG4gIH1cbn1cbi8qKlxyXG4gKiBDb2xsZWN0cyBhbm5vdGF0aW9ucyBmcm9tIHByb3RvdHlwZXMgYW5kIHN0b3JlcyB0aGVtIG9uIHRhcmdldCAoaW5zdGFuY2UpXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbGxlY3RTdG9yZWRBbm5vdGF0aW9ucyh0YXJnZXQpIHtcbiAgaWYgKCFoYXNQcm9wKHRhcmdldCwgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhdGFyZ2V0W3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkge1xuICAgICAgZGllKFwiTm8gYW5ub3RhdGlvbnMgd2VyZSBwYXNzZWQgdG8gbWFrZU9ic2VydmFibGUsIGJ1dCBubyBkZWNvcmF0ZWQgbWVtYmVycyBoYXZlIGJlZW4gZm91bmQgZWl0aGVyXCIpO1xuICAgIH0gLy8gV2UgbmVlZCBhIGNvcHkgYXMgd2Ugd2lsbCByZW1vdmUgYW5ub3RhdGlvbiBmcm9tIHRoZSBsaXN0IG9uY2UgaXQncyBhcHBsaWVkLlxuXG5cbiAgICBhZGRIaWRkZW5Qcm9wKHRhcmdldCwgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wsIF9leHRlbmRzKHt9LCB0YXJnZXRbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0W3N0b3JlZEFubm90YXRpb25zU3ltYm9sXTtcbn1cblxudmFyICRtb2J4ID0gLyojX19QVVJFX18qL1N5bWJvbChcIm1vYnggYWRtaW5pc3RyYXRpb25cIik7XG5cbnZhciBBdG9tID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gZm9yIGVmZmVjdGl2ZSB1bm9ic2VydmluZy4gQmFzZUF0b20gaGFzIHRydWUsIGZvciBleHRyYSBvcHRpbWl6YXRpb24sIHNvIGl0cyBvbkJlY29tZVVub2JzZXJ2ZWQgbmV2ZXIgZ2V0cyBjYWxsZWQsIGJlY2F1c2UgaXQncyBub3QgbmVlZGVkXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGF0b20uIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgaXQgaXMgcmVjb21tZW5kZWQgdG8gZ2l2ZSBpdCBhIG5hbWUuXHJcbiAgICogVGhlIG9uQmVjb21lT2JzZXJ2ZWQgYW5kIG9uQmVjb21lVW5vYnNlcnZlZCBjYWxsYmFja3MgY2FuIGJlIHVzZWQgZm9yIHJlc291cmNlIG1hbmFnZW1lbnQuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEF0b20obmFtZV8pIHtcbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIkF0b21AXCIgKyBnZXROZXh0SWQoKSA6IFwiQXRvbVwiO1xuICAgIH1cblxuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc1BlbmRpbmdVbm9ic2VydmF0aW9uXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNCZWluZ09ic2VydmVkXyA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXJzXyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmRpZmZWYWx1ZV8gPSAwO1xuICAgIHRoaXMubGFzdEFjY2Vzc2VkQnlfID0gMDtcbiAgICB0aGlzLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB0aGlzLm9uQk9MID0gdm9pZCAwO1xuICAgIHRoaXMub25CVU9MID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgfSAvLyBvbkJlY29tZU9ic2VydmVkTGlzdGVuZXJzXG5cblxuICB2YXIgX3Byb3RvID0gQXRvbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9uQk8gPSBmdW5jdGlvbiBvbkJPKCkge1xuICAgIGlmICh0aGlzLm9uQk9MKSB7XG4gICAgICB0aGlzLm9uQk9MLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkJVTyA9IGZ1bmN0aW9uIG9uQlVPKCkge1xuICAgIGlmICh0aGlzLm9uQlVPTCkge1xuICAgICAgdGhpcy5vbkJVT0wuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogSW52b2tlIHRoaXMgbWV0aG9kIHRvIG5vdGlmeSBtb2J4IHRoYXQgeW91ciBhdG9tIGhhcyBiZWVuIHVzZWQgc29tZWhvdy5cclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgY3VycmVudGx5IGEgcmVhY3RpdmUgY29udGV4dC5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBvcnRPYnNlcnZlZCA9IGZ1bmN0aW9uIHJlcG9ydE9ic2VydmVkJDEoKSB7XG4gICAgcmV0dXJuIHJlcG9ydE9ic2VydmVkKHRoaXMpO1xuICB9XG4gIC8qKlxyXG4gICAqIEludm9rZSB0aGlzIG1ldGhvZCBfYWZ0ZXJfIHRoaXMgbWV0aG9kIGhhcyBjaGFuZ2VkIHRvIHNpZ25hbCBtb2J4IHRoYXQgYWxsIGl0cyBvYnNlcnZlcnMgc2hvdWxkIGludmFsaWRhdGUuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVwb3J0Q2hhbmdlZCA9IGZ1bmN0aW9uIHJlcG9ydENoYW5nZWQoKSB7XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHByb3BhZ2F0ZUNoYW5nZWQodGhpcyk7XG4gICAgZW5kQmF0Y2goKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXztcbiAgfTtcblxuICByZXR1cm4gQXRvbTtcbn0oKTtcblxudmFyIGlzQXRvbSA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiQXRvbVwiLCBBdG9tKTtcblxuZnVuY3Rpb24gY3JlYXRlQXRvbShuYW1lLCBvbkJlY29tZU9ic2VydmVkSGFuZGxlciwgb25CZWNvbWVVbm9ic2VydmVkSGFuZGxlcikge1xuICBpZiAob25CZWNvbWVPYnNlcnZlZEhhbmRsZXIgPT09IHZvaWQgMCkge1xuICAgIG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyID0gbm9vcDtcbiAgfVxuXG4gIGlmIChvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyID09PSB2b2lkIDApIHtcbiAgICBvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyID0gbm9vcDtcbiAgfVxuXG4gIHZhciBhdG9tID0gbmV3IEF0b20obmFtZSk7IC8vIGRlZmF1bHQgYG5vb3BgIGxpc3RlbmVyIHdpbGwgbm90IGluaXRpYWxpemUgdGhlIGhvb2sgU2V0XG5cbiAgaWYgKG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyICE9PSBub29wKSB7XG4gICAgb25CZWNvbWVPYnNlcnZlZChhdG9tLCBvbkJlY29tZU9ic2VydmVkSGFuZGxlcik7XG4gIH1cblxuICBpZiAob25CZWNvbWVVbm9ic2VydmVkSGFuZGxlciAhPT0gbm9vcCkge1xuICAgIG9uQmVjb21lVW5vYnNlcnZlZChhdG9tLCBvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyKTtcbiAgfVxuXG4gIHJldHVybiBhdG9tO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eUNvbXBhcmVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG5cbmZ1bmN0aW9uIHN0cnVjdHVyYWxDb21wYXJlcihhLCBiKSB7XG4gIHJldHVybiBkZWVwRXF1YWwoYSwgYik7XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlcihhLCBiKSB7XG4gIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgMSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlcihhLCBiKSB7XG4gIHJldHVybiBPYmplY3QuaXMoYSwgYik7XG59XG5cbnZhciBjb21wYXJlciA9IHtcbiAgaWRlbnRpdHk6IGlkZW50aXR5Q29tcGFyZXIsXG4gIHN0cnVjdHVyYWw6IHN0cnVjdHVyYWxDb21wYXJlcixcbiAgXCJkZWZhdWx0XCI6IGRlZmF1bHRDb21wYXJlcixcbiAgc2hhbGxvdzogc2hhbGxvd0NvbXBhcmVyXG59O1xuXG5mdW5jdGlvbiBkZWVwRW5oYW5jZXIodiwgXywgbmFtZSkge1xuICAvLyBpdCBpcyBhbiBvYnNlcnZhYmxlIGFscmVhZHksIGRvbmVcbiAgaWYgKGlzT2JzZXJ2YWJsZSh2KSkgcmV0dXJuIHY7IC8vIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBjb252ZXJ0ZWQgYW5kIG11dGF0ZWQ/XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHJldHVybiBvYnNlcnZhYmxlLmFycmF5KHYsIHtcbiAgICBuYW1lOiBuYW1lXG4gIH0pO1xuICBpZiAoaXNQbGFpbk9iamVjdCh2KSkgcmV0dXJuIG9ic2VydmFibGUub2JqZWN0KHYsIHVuZGVmaW5lZCwge1xuICAgIG5hbWU6IG5hbWVcbiAgfSk7XG4gIGlmIChpc0VTNk1hcCh2KSkgcmV0dXJuIG9ic2VydmFibGUubWFwKHYsIHtcbiAgICBuYW1lOiBuYW1lXG4gIH0pO1xuICBpZiAoaXNFUzZTZXQodikpIHJldHVybiBvYnNlcnZhYmxlLnNldCh2LCB7XG4gICAgbmFtZTogbmFtZVxuICB9KTtcbiAgcmV0dXJuIHY7XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dFbmhhbmNlcih2LCBfLCBuYW1lKSB7XG4gIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCkgcmV0dXJuIHY7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3QodikgfHwgaXNPYnNlcnZhYmxlQXJyYXkodikgfHwgaXNPYnNlcnZhYmxlTWFwKHYpIHx8IGlzT2JzZXJ2YWJsZVNldCh2KSkgcmV0dXJuIHY7XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5hcnJheSh2LCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBkZWVwOiBmYWxzZVxuICB9KTtcbiAgaWYgKGlzUGxhaW5PYmplY3QodikpIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCB1bmRlZmluZWQsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGRlZXA6IGZhbHNlXG4gIH0pO1xuICBpZiAoaXNFUzZNYXAodikpIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBkZWVwOiBmYWxzZVxuICB9KTtcbiAgaWYgKGlzRVM2U2V0KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5zZXQodiwge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgZGVlcDogZmFsc2VcbiAgfSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIGRpZShcIlRoZSBzaGFsbG93IG1vZGlmaWVyIC8gZGVjb3JhdG9yIGNhbiBvbmx5IHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBhcnJheXMsIG9iamVjdHMsIG1hcHMgYW5kIHNldHNcIik7XG59XG5cbmZ1bmN0aW9uIHJlZmVyZW5jZUVuaGFuY2VyKG5ld1ZhbHVlKSB7XG4gIC8vIG5ldmVyIHR1cm4gaW50byBhbiBvYnNlcnZhYmxlXG4gIHJldHVybiBuZXdWYWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVmU3RydWN0RW5oYW5jZXIodiwgb2xkVmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc09ic2VydmFibGUodikpIGRpZShcIm9ic2VydmFibGUuc3RydWN0IHNob3VsZCBub3QgYmUgdXNlZCB3aXRoIG9ic2VydmFibGUgdmFsdWVzXCIpO1xuICBpZiAoZGVlcEVxdWFsKHYsIG9sZFZhbHVlKSkgcmV0dXJuIG9sZFZhbHVlO1xuICByZXR1cm4gdjtcbn1cblxudmFyIE9WRVJSSURFID0gXCJvdmVycmlkZVwiO1xudmFyIG92ZXJyaWRlID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oe1xuICBhbm5vdGF0aW9uVHlwZV86IE9WRVJSSURFLFxuICBtYWtlXzogbWFrZV8sXG4gIGV4dGVuZF86IGV4dGVuZF9cbn0pO1xuXG5mdW5jdGlvbiBpc092ZXJyaWRlKGFubm90YXRpb24pIHtcbiAgcmV0dXJuIGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfID09PSBPVkVSUklERTtcbn1cblxuZnVuY3Rpb24gbWFrZV8oYWRtLCBrZXkpIHtcbiAgLy8gTXVzdCBub3QgYmUgcGxhaW4gb2JqZWN0XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgYWRtLmlzUGxhaW5PYmplY3RfKSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyB0aGlzLmFubm90YXRpb25UeXBlXyArIFwiJyBjYW5ub3QgYmUgdXNlZCBvbiBwbGFpbiBvYmplY3RzLlwiKSk7XG4gIH0gLy8gTXVzdCBvdmVycmlkZSBzb21ldGhpbmdcblxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWhhc1Byb3AoYWRtLmFwcGxpZWRBbm5vdGF0aW9uc18sIGtleSkpIHtcbiAgICBkaWUoXCInXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInIGlzIGFubm90YXRlZCB3aXRoICdcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInLCBcIiArIFwiYnV0IG5vIHN1Y2ggYW5ub3RhdGVkIG1lbWJlciB3YXMgZm91bmQgb24gcHJvdG90eXBlLlwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgZGllKFwiJ1wiICsgdGhpcy5hbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCB3aXRoICdtYWtlT2JzZXJ2YWJsZSdcIik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkFubm90YXRpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogbmFtZSxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kMSxcbiAgICBleHRlbmRfOiBleHRlbmRfJDFcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZV8kMShhZG0sIGtleSkge1xuICB2YXIgX3RoaXMkb3B0aW9uc18kYm91bmQsIF90aGlzJG9wdGlvbnNfLCBfYWRtJHRhcmdldF8kc3RvcmVkQW47XG5cbiAgdmFyIGFubm90YXRlZCA9IGZhbHNlO1xuICB2YXIgc291cmNlID0gYWRtLnRhcmdldF87XG4gIHZhciBib3VuZCA9IChfdGhpcyRvcHRpb25zXyRib3VuZCA9IChfdGhpcyRvcHRpb25zXyA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXy5ib3VuZCkgIT0gbnVsbCA/IF90aGlzJG9wdGlvbnNfJGJvdW5kIDogZmFsc2U7XG5cbiAgd2hpbGUgKHNvdXJjZSAmJiBzb3VyY2UgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0RGVzY3JpcHRvcihzb3VyY2UsIGtleSk7XG5cbiAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgLy8gSW5zdGFuY2Ugb3IgYm91bmRcbiAgICAgIC8vIEtlZXAgZmlyc3QgYmVjYXVzZSB0aGUgb3BlcmF0aW9uIGNhbiBiZSBpbnRlcmNlcHRlZFxuICAgICAgLy8gYW5kIHdlIGRvbid0IHdhbnQgdG8gZW5kIHVwIHdpdGggcGFydGlhbGx5IGFubm90YXRlZCBwcm90byBjaGFpblxuICAgICAgaWYgKHNvdXJjZSA9PT0gYWRtLnRhcmdldF8gfHwgYm91bmQpIHtcbiAgICAgICAgdmFyIGFjdGlvbkRlc2NyaXB0b3IgPSBjcmVhdGVBY3Rpb25EZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgdmFyIGRlZmluZVByb3BlcnR5T3V0Y29tZSA9IGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCBhY3Rpb25EZXNjcmlwdG9yKTtcblxuICAgICAgICBpZiAoIWRlZmluZVByb3BlcnR5T3V0Y29tZSkge1xuICAgICAgICAgIC8vIEludGVyY2VwdGVkXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5ub3RhdGVkID0gdHJ1ZTsgLy8gRG9uJ3QgYW5ub3RhdGUgcHJvdG9zIGlmIGJvdW5kXG5cbiAgICAgICAgaWYgKGJvdW5kKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJvdG90eXBlXG5cblxuICAgICAgaWYgKHNvdXJjZSAhPT0gYWRtLnRhcmdldF8pIHtcbiAgICAgICAgaWYgKGlzQWN0aW9uKGRlc2NyaXB0b3IudmFsdWUpKSB7XG4gICAgICAgICAgLy8gQSBwcm90b3R5cGUgY291bGQgaGF2ZSBiZWVuIGFubm90YXRlZCBhbHJlYWR5IGJ5IG90aGVyIGNvbnN0cnVjdG9yLFxuICAgICAgICAgIC8vIHJlc3Qgb2YgdGhlIHByb3RvIGNoYWluIG11c3QgYmUgYW5ub3RhdGVkIGFscmVhZHlcbiAgICAgICAgICBhbm5vdGF0ZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9hY3Rpb25EZXNjcmlwdG9yID0gY3JlYXRlQWN0aW9uRGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpO1xuXG4gICAgICAgIGRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCBfYWN0aW9uRGVzY3JpcHRvcik7XG4gICAgICAgIGFubm90YXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc291cmNlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSk7XG4gIH1cblxuICBpZiAoYW5ub3RhdGVkKSB7XG4gICAgcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQoYWRtLCB0aGlzLCBrZXkpO1xuICB9IGVsc2UgaWYgKCEoKF9hZG0kdGFyZ2V0XyRzdG9yZWRBbiA9IGFkbS50YXJnZXRfW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hZG0kdGFyZ2V0XyRzdG9yZWRBbltrZXldKSkge1xuICAgIC8vIFRocm93IG9uIG1pc3Npbmcga2V5LCBleGNlcHQgZm9yIGRlY29yYXRvcnM6XG4gICAgLy8gRGVjb3JhdG9yIGFubm90YXRpb25zIGFyZSBjb2xsZWN0ZWQgZnJvbSB3aG9sZSBwcm90b3R5cGUgY2hhaW4uXG4gICAgLy8gV2hlbiBjYWxsZWQgZnJvbSBzdXBlcigpIHNvbWUgcHJvcHMgbWF5IG5vdCBleGlzdCB5ZXQuXG4gICAgLy8gSG93ZXZlciB3ZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IG1pc3NpbmcgcHJvcCxcbiAgICAvLyBiZWNhdXNlIHRoZSBkZWNvcmF0b3IgbXVzdCBoYXZlIGJlZW4gYXBwbGllZCB0byBzb21ldGhpbmcuXG4gICAgZGllKDEsIHRoaXMuYW5ub3RhdGlvblR5cGVfLCBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRlbmRfJDEoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICB2YXIgYWN0aW9uRGVzY3JpcHRvciA9IGNyZWF0ZUFjdGlvbkRlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IpO1xuICByZXR1cm4gYWRtLmRlZmluZVByb3BlcnR5XyhrZXksIGFjdGlvbkRlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFjdGlvbkRlc2NyaXB0b3IoYWRtLCBfcmVmLCBrZXksIF9yZWYyKSB7XG4gIHZhciBhbm5vdGF0aW9uVHlwZV8gPSBfcmVmLmFubm90YXRpb25UeXBlXztcbiAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCBvbiBwcm9wZXJ0aWVzIHdpdGggYSBmdW5jdGlvbiB2YWx1ZS5cIikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkRlc2NyaXB0b3IoYWRtLCBhbm5vdGF0aW9uLCBrZXksIGRlc2NyaXB0b3IsIC8vIHByb3ZpZGVzIGFiaWxpdHkgdG8gZGlzYWJsZSBzYWZlRGVzY3JpcHRvcnMgZm9yIHByb3RvdHlwZXNcbnNhZmVEZXNjcmlwdG9ycykge1xuICB2YXIgX2Fubm90YXRpb24kb3B0aW9uc18sIF9hbm5vdGF0aW9uJG9wdGlvbnNfJCwgX2Fubm90YXRpb24kb3B0aW9uc18yLCBfYW5ub3RhdGlvbiRvcHRpb25zXyQyLCBfYW5ub3RhdGlvbiRvcHRpb25zXzM7XG5cbiAgaWYgKHNhZmVEZXNjcmlwdG9ycyA9PT0gdm9pZCAwKSB7XG4gICAgc2FmZURlc2NyaXB0b3JzID0gZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzO1xuICB9XG5cbiAgYXNzZXJ0QWN0aW9uRGVzY3JpcHRvcihhZG0sIGFubm90YXRpb24sIGtleSwgZGVzY3JpcHRvcik7XG4gIHZhciB2YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWU7XG5cbiAgaWYgKChfYW5ub3RhdGlvbiRvcHRpb25zXyA9IGFubm90YXRpb24ub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfYW5ub3RhdGlvbiRvcHRpb25zXy5ib3VuZCkge1xuICAgIHZhciBfYWRtJHByb3h5XztcblxuICAgIHZhbHVlID0gdmFsdWUuYmluZCgoX2FkbSRwcm94eV8gPSBhZG0ucHJveHlfKSAhPSBudWxsID8gX2FkbSRwcm94eV8gOiBhZG0udGFyZ2V0Xyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBjcmVhdGVBY3Rpb24oKF9hbm5vdGF0aW9uJG9wdGlvbnNfJCA9IChfYW5ub3RhdGlvbiRvcHRpb25zXzIgPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX2Fubm90YXRpb24kb3B0aW9uc18yLm5hbWUpICE9IG51bGwgPyBfYW5ub3RhdGlvbiRvcHRpb25zXyQgOiBrZXkudG9TdHJpbmcoKSwgdmFsdWUsIChfYW5ub3RhdGlvbiRvcHRpb25zXyQyID0gKF9hbm5vdGF0aW9uJG9wdGlvbnNfMyA9IGFubm90YXRpb24ub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfYW5ub3RhdGlvbiRvcHRpb25zXzMuYXV0b0FjdGlvbikgIT0gbnVsbCA/IF9hbm5vdGF0aW9uJG9wdGlvbnNfJDIgOiBmYWxzZSksXG4gICAgLy8gTm9uLWNvbmZpZ3VyYWJsZSBmb3IgY2xhc3Nlc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWwgZmllbGQgcmVkZWZpbml0aW9uIGluIHN1YmNsYXNzXG4gICAgY29uZmlndXJhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBhZG0uaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9wdWxsLzI2NDEjaXNzdWVjb21tZW50LTczNzI5MjA1OFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIC8vIE5vbi1vYnNldmFibGUsIHRoZXJlZm9yZSBub24td3JpdGFibGVcbiAgICAvLyBBbHNvIHByZXZlbnRzIHJld3JpdGluZyBpbiBzdWJjbGFzcyBjb25zdHJ1Y3RvclxuICAgIHdyaXRhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBmYWxzZSA6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmxvd0Fubm90YXRpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogbmFtZSxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kMixcbiAgICBleHRlbmRfOiBleHRlbmRfJDJcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZV8kMihhZG0sIGtleSkge1xuICB2YXIgX2FkbSR0YXJnZXRfJHN0b3JlZEFuO1xuXG4gIHZhciBhbm5vdGF0ZWQgPSBmYWxzZTtcbiAgdmFyIHNvdXJjZSA9IGFkbS50YXJnZXRfO1xuXG4gIHdoaWxlIChzb3VyY2UgJiYgc291cmNlICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGdldERlc2NyaXB0b3Ioc291cmNlLCBrZXkpO1xuXG4gICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgIGlmIChzb3VyY2UgIT09IGFkbS50YXJnZXRfKSB7XG4gICAgICAgIC8vIFByb3RvdHlwZVxuICAgICAgICBpZiAoaXNGbG93KGRlc2NyaXB0b3IudmFsdWUpKSB7XG4gICAgICAgICAgLy8gQSBwcm90b3R5cGUgY291bGQgaGF2ZSBiZWVuIGFubm90YXRlZCBhbHJlYWR5IGJ5IG90aGVyIGNvbnN0cnVjdG9yLFxuICAgICAgICAgIC8vIHJlc3Qgb2YgdGhlIHByb3RvIGNoYWluIG11c3QgYmUgYW5ub3RhdGVkIGFscmVhZHlcbiAgICAgICAgICBhbm5vdGF0ZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZsb3dEZXNjcmlwdG9yID0gY3JlYXRlRmxvd0Rlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkoc291cmNlLCBrZXksIGZsb3dEZXNjcmlwdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfZmxvd0Rlc2NyaXB0b3IgPSBjcmVhdGVGbG93RGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvcik7XG5cbiAgICAgICAgdmFyIGRlZmluZVByb3BlcnR5T3V0Y29tZSA9IGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCBfZmxvd0Rlc2NyaXB0b3IpO1xuXG4gICAgICAgIGlmICghZGVmaW5lUHJvcGVydHlPdXRjb21lKSB7XG4gICAgICAgICAgLy8gSW50ZXJjZXB0ZWRcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYW5ub3RhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBzb3VyY2UgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKTtcbiAgfVxuXG4gIGlmIChhbm5vdGF0ZWQpIHtcbiAgICByZWNvcmRBbm5vdGF0aW9uQXBwbGllZChhZG0sIHRoaXMsIGtleSk7XG4gIH0gZWxzZSBpZiAoISgoX2FkbSR0YXJnZXRfJHN0b3JlZEFuID0gYWRtLnRhcmdldF9bc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSA9PSBudWxsID8gdm9pZCAwIDogX2FkbSR0YXJnZXRfJHN0b3JlZEFuW2tleV0pKSB7XG4gICAgLy8gVGhyb3cgb24gbWlzc2luZyBrZXksIGV4Y2VwdCBmb3IgZGVjb3JhdG9yczpcbiAgICAvLyBEZWNvcmF0b3IgYW5ub3RhdGlvbnMgYXJlIGNvbGxlY3RlZCBmcm9tIHdob2xlIHByb3RvdHlwZSBjaGFpbi5cbiAgICAvLyBXaGVuIGNhbGxlZCBmcm9tIHN1cGVyKCkgc29tZSBwcm9wcyBtYXkgbm90IGV4aXN0IHlldC5cbiAgICAvLyBIb3dldmVyIHdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgbWlzc2luZyBwcm9wLFxuICAgIC8vIGJlY2F1c2UgdGhlIGRlY29yYXRvciBtdXN0IGhhdmUgYmVlbiBhcHBsaWVkIHRvIHNvbWV0aGluZy5cbiAgICBkaWUoMSwgdGhpcy5hbm5vdGF0aW9uVHlwZV8sIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dGVuZF8kMihhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIHZhciBmbG93RGVzY3JpcHRvciA9IGNyZWF0ZUZsb3dEZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCBmbG93RGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Rmxvd0Rlc2NyaXB0b3IoYWRtLCBfcmVmLCBrZXksIF9yZWYyKSB7XG4gIHZhciBhbm5vdGF0aW9uVHlwZV8gPSBfcmVmLmFubm90YXRpb25UeXBlXztcbiAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCBvbiBwcm9wZXJ0aWVzIHdpdGggYSBnZW5lcmF0b3IgZnVuY3Rpb24gdmFsdWUuXCIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGbG93RGVzY3JpcHRvcihhZG0sIGFubm90YXRpb24sIGtleSwgZGVzY3JpcHRvciwgLy8gcHJvdmlkZXMgYWJpbGl0eSB0byBkaXNhYmxlIHNhZmVEZXNjcmlwdG9ycyBmb3IgcHJvdG90eXBlc1xuc2FmZURlc2NyaXB0b3JzKSB7XG4gIGlmIChzYWZlRGVzY3JpcHRvcnMgPT09IHZvaWQgMCkge1xuICAgIHNhZmVEZXNjcmlwdG9ycyA9IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycztcbiAgfVxuXG4gIGFzc2VydEZsb3dEZXNjcmlwdG9yKGFkbSwgYW5ub3RhdGlvbiwga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogZmxvdyhkZXNjcmlwdG9yLnZhbHVlKSxcbiAgICAvLyBOb24tY29uZmlndXJhYmxlIGZvciBjbGFzc2VzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbCBmaWVsZCByZWRlZmluaXRpb24gaW4gc3ViY2xhc3NcbiAgICBjb25maWd1cmFibGU6IHNhZmVEZXNjcmlwdG9ycyA/IGFkbS5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L3B1bGwvMjY0MSNpc3N1ZWNvbW1lbnQtNzM3MjkyMDU4XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgLy8gTm9uLW9ic2V2YWJsZSwgdGhlcmVmb3JlIG5vbi13cml0YWJsZVxuICAgIC8vIEFsc28gcHJldmVudHMgcmV3cml0aW5nIGluIHN1YmNsYXNzIGNvbnN0cnVjdG9yXG4gICAgd3JpdGFibGU6IHNhZmVEZXNjcmlwdG9ycyA/IGZhbHNlIDogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEFubm90YXRpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogbmFtZSxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kMyxcbiAgICBleHRlbmRfOiBleHRlbmRfJDNcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZV8kMyhhZG0sIGtleSkge1xuICB2YXIgX2FkbSR0YXJnZXRfJHN0b3JlZEFuO1xuXG4gIHZhciBzb3VyY2UgPSBhZG0udGFyZ2V0XztcblxuICB3aGlsZSAoc291cmNlICYmIHNvdXJjZSAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBnZXREZXNjcmlwdG9yKHNvdXJjZSwga2V5KTtcblxuICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICBhc3NlcnRDb21wdXRlZERlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgdmFyIGRlZmluZVByb3BlcnR5T3V0Y29tZSA9IGFkbS5kZWZpbmVDb21wdXRlZFByb3BlcnR5XyhrZXksIF9leHRlbmRzKHt9LCB0aGlzLm9wdGlvbnNfLCB7XG4gICAgICAgIGdldDogZGVzY3JpcHRvci5nZXQsXG4gICAgICAgIHNldDogZGVzY3JpcHRvci5zZXRcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKCFkZWZpbmVQcm9wZXJ0eU91dGNvbWUpIHtcbiAgICAgICAgLy8gSW50ZXJjZXB0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWNvcmRBbm5vdGF0aW9uQXBwbGllZChhZG0sIHRoaXMsIGtleSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc291cmNlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSk7XG4gIH1cblxuICBpZiAoISgoX2FkbSR0YXJnZXRfJHN0b3JlZEFuID0gYWRtLnRhcmdldF9bc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSA9PSBudWxsID8gdm9pZCAwIDogX2FkbSR0YXJnZXRfJHN0b3JlZEFuW2tleV0pKSB7XG4gICAgLy8gVGhyb3cgb24gbWlzc2luZyBrZXksIGV4Y2VwdCBmb3IgZGVjb3JhdG9yczpcbiAgICAvLyBEZWNvcmF0b3IgYW5ub3RhdGlvbnMgYXJlIGNvbGxlY3RlZCBmcm9tIHdob2xlIHByb3RvdHlwZSBjaGFpbi5cbiAgICAvLyBXaGVuIGNhbGxlZCBmcm9tIHN1cGVyKCkgc29tZSBwcm9wcyBtYXkgbm90IGV4aXN0IHlldC5cbiAgICAvLyBIb3dldmVyIHdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgbWlzc2luZyBwcm9wLFxuICAgIC8vIGJlY2F1c2UgdGhlIGRlY29yYXRvciBtdXN0IGhhdmUgYmVlbiBhcHBsaWVkIHRvIHNvbWV0aGluZy5cbiAgICBkaWUoMSwgdGhpcy5hbm5vdGF0aW9uVHlwZV8sIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dGVuZF8kMyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIGFzc2VydENvbXB1dGVkRGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvcik7XG4gIHJldHVybiBhZG0uZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eV8oa2V5LCBfZXh0ZW5kcyh7fSwgdGhpcy5vcHRpb25zXywge1xuICAgIGdldDogZGVzY3JpcHRvci5nZXQsXG4gICAgc2V0OiBkZXNjcmlwdG9yLnNldFxuICB9KSwgcHJveHlUcmFwKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q29tcHV0ZWREZXNjcmlwdG9yKGFkbSwgX3JlZiwga2V5LCBfcmVmMikge1xuICB2YXIgYW5ub3RhdGlvblR5cGVfID0gX3JlZi5hbm5vdGF0aW9uVHlwZV87XG4gIHZhciBnZXQgPSBfcmVmMi5nZXQ7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhZ2V0KSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyB0byAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOlwiICsgKFwiXFxuJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbiBvbmx5IGJlIHVzZWQgb24gZ2V0dGVyKCtzZXR0ZXIpIHByb3BlcnRpZXMuXCIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGlvblR5cGVfOiBuYW1lLFxuICAgIG9wdGlvbnNfOiBvcHRpb25zLFxuICAgIG1ha2VfOiBtYWtlXyQ0LFxuICAgIGV4dGVuZF86IGV4dGVuZF8kNFxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlXyQ0KGFkbSwga2V5KSB7XG4gIHZhciBfYWRtJHRhcmdldF8kc3RvcmVkQW47XG5cbiAgdmFyIHNvdXJjZSA9IGFkbS50YXJnZXRfOyAvLyBDb3B5IHByb3BzIGZyb20gcHJvdG8gYXMgd2VsbCwgc2VlIHRlc3Q6XG4gIC8vIFwiZGVjb3JhdGUgc2hvdWxkIHdvcmsgd2l0aCBPYmplY3QuY3JlYXRlXCJcblxuICB3aGlsZSAoc291cmNlICYmIHNvdXJjZSAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBnZXREZXNjcmlwdG9yKHNvdXJjZSwga2V5KTtcblxuICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICB2YXIgX3RoaXMkb3B0aW9uc18kZW5oYW5jLCBfdGhpcyRvcHRpb25zXztcblxuICAgICAgYXNzZXJ0T2JzZXJ2YWJsZURlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgdmFyIGRlZmluZVByb3BlcnR5T3V0Y29tZSA9IGFkbS5kZWZpbmVPYnNlcnZhYmxlUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvci52YWx1ZSwgKF90aGlzJG9wdGlvbnNfJGVuaGFuYyA9IChfdGhpcyRvcHRpb25zXyA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXy5lbmhhbmNlcikgIT0gbnVsbCA/IF90aGlzJG9wdGlvbnNfJGVuaGFuYyA6IGRlZXBFbmhhbmNlcik7XG5cbiAgICAgIGlmICghZGVmaW5lUHJvcGVydHlPdXRjb21lKSB7XG4gICAgICAgIC8vIEludGVyY2VwdGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQoYWRtLCB0aGlzLCBrZXkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNvdXJjZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpO1xuICB9XG5cbiAgaWYgKCEoKF9hZG0kdGFyZ2V0XyRzdG9yZWRBbiA9IGFkbS50YXJnZXRfW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hZG0kdGFyZ2V0XyRzdG9yZWRBbltrZXldKSkge1xuICAgIC8vIFRocm93IG9uIG1pc3Npbmcga2V5LCBleGNlcHQgZm9yIGRlY29yYXRvcnM6XG4gICAgLy8gRGVjb3JhdG9yIGFubm90YXRpb25zIGFyZSBjb2xsZWN0ZWQgZnJvbSB3aG9sZSBwcm90b3R5cGUgY2hhaW4uXG4gICAgLy8gV2hlbiBjYWxsZWQgZnJvbSBzdXBlcigpIHNvbWUgcHJvcHMgbWF5IG5vdCBleGlzdCB5ZXQuXG4gICAgLy8gSG93ZXZlciB3ZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IG1pc3NpbmcgcHJvcCxcbiAgICAvLyBiZWNhdXNlIHRoZSBkZWNvcmF0b3IgbXVzdCBoYXZlIGJlZW4gYXBwbGllZCB0byBzb21ldGhpbmcuXG4gICAgZGllKDEsIHRoaXMuYW5ub3RhdGlvblR5cGVfLCBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRlbmRfJDQoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICB2YXIgX3RoaXMkb3B0aW9uc18kZW5oYW5jMiwgX3RoaXMkb3B0aW9uc18yO1xuXG4gIGFzc2VydE9ic2VydmFibGVEZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVPYnNlcnZhYmxlUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvci52YWx1ZSwgKF90aGlzJG9wdGlvbnNfJGVuaGFuYzIgPSAoX3RoaXMkb3B0aW9uc18yID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfMi5lbmhhbmNlcikgIT0gbnVsbCA/IF90aGlzJG9wdGlvbnNfJGVuaGFuYzIgOiBkZWVwRW5oYW5jZXIsIHByb3h5VHJhcCk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9ic2VydmFibGVEZXNjcmlwdG9yKGFkbSwgX3JlZiwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIHZhciBhbm5vdGF0aW9uVHlwZV8gPSBfcmVmLmFubm90YXRpb25UeXBlXztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICEoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpKSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyB0byAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOlwiICsgKFwiXFxuJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbm5vdCBiZSB1c2VkIG9uIGdldHRlci9zZXR0ZXIgcHJvcGVydGllc1wiKSk7XG4gIH1cbn0gLy8gaW4gdGhlIG1ham9yaXR5IG9mIGNhc2VzXG5cblxudmFyIGRlZmF1bHRDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyA9IHtcbiAgZGVlcDogdHJ1ZSxcbiAgbmFtZTogdW5kZWZpbmVkLFxuICBkZWZhdWx0RGVjb3JhdG9yOiB1bmRlZmluZWQsXG4gIHByb3h5OiB0cnVlXG59O1xuT2JqZWN0LmZyZWV6ZShkZWZhdWx0Q3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMpO1xuXG5mdW5jdGlvbiBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKHRoaW5nKSB7XG4gIHJldHVybiB0aGluZyB8fCBkZWZhdWx0Q3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnM7XG59XG5cbnZhciBvYnNlcnZhYmxlQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihcIm9ic2VydmFibGVcIik7XG52YXIgb2JzZXJ2YWJsZVJlZkFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oXCJvYnNlcnZhYmxlLnJlZlwiLCB7XG4gIGVuaGFuY2VyOiByZWZlcmVuY2VFbmhhbmNlclxufSk7XG52YXIgb2JzZXJ2YWJsZVNoYWxsb3dBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVBbm5vdGF0aW9uKFwib2JzZXJ2YWJsZS5zaGFsbG93XCIsIHtcbiAgZW5oYW5jZXI6IHNoYWxsb3dFbmhhbmNlclxufSk7XG52YXIgb2JzZXJ2YWJsZVN0cnVjdEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oXCJvYnNlcnZhYmxlLnN0cnVjdFwiLCB7XG4gIGVuaGFuY2VyOiByZWZTdHJ1Y3RFbmhhbmNlclxufSk7XG52YXIgb2JzZXJ2YWJsZURlY29yYXRvckFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlQW5ub3RhdGlvbik7XG5cbmZ1bmN0aW9uIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5kZWVwID09PSB0cnVlID8gZGVlcEVuaGFuY2VyIDogb3B0aW9ucy5kZWVwID09PSBmYWxzZSA/IHJlZmVyZW5jZUVuaGFuY2VyIDogZ2V0RW5oYW5jZXJGcm9tQW5ub3RhdGlvbihvcHRpb25zLmRlZmF1bHREZWNvcmF0b3IpO1xufVxuXG5mdW5jdGlvbiBnZXRBbm5vdGF0aW9uRnJvbU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA/IG9wdGlvbnMuZGVlcCA9PT0gdHJ1ZSA/IG9ic2VydmFibGVBbm5vdGF0aW9uIDogb3B0aW9ucy5kZWVwID09PSBmYWxzZSA/IG9ic2VydmFibGVSZWZBbm5vdGF0aW9uIDogb3B0aW9ucy5kZWZhdWx0RGVjb3JhdG9yIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXRFbmhhbmNlckZyb21Bbm5vdGF0aW9uKGFubm90YXRpb24pIHtcbiAgdmFyIF9hbm5vdGF0aW9uJG9wdGlvbnNfJCwgX2Fubm90YXRpb24kb3B0aW9uc187XG5cbiAgcmV0dXJuICFhbm5vdGF0aW9uID8gZGVlcEVuaGFuY2VyIDogKF9hbm5vdGF0aW9uJG9wdGlvbnNfJCA9IChfYW5ub3RhdGlvbiRvcHRpb25zXyA9IGFubm90YXRpb24ub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfYW5ub3RhdGlvbiRvcHRpb25zXy5lbmhhbmNlcikgIT0gbnVsbCA/IF9hbm5vdGF0aW9uJG9wdGlvbnNfJCA6IGRlZXBFbmhhbmNlcjtcbn1cbi8qKlxyXG4gKiBUdXJucyBhbiBvYmplY3QsIGFycmF5IG9yIGZ1bmN0aW9uIGludG8gYSByZWFjdGl2ZSBzdHJ1Y3R1cmUuXHJcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB3aGljaCBzaG91bGQgYmVjb21lIG9ic2VydmFibGUuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGUodiwgYXJnMiwgYXJnMykge1xuICAvLyBAb2JzZXJ2YWJsZSBzb21lUHJvcDtcbiAgaWYgKGlzU3RyaW5naXNoKGFyZzIpKSB7XG4gICAgc3RvcmVBbm5vdGF0aW9uKHYsIGFyZzIsIG9ic2VydmFibGVBbm5vdGF0aW9uKTtcbiAgICByZXR1cm47XG4gIH0gLy8gYWxyZWFkeSBvYnNlcnZhYmxlIC0gaWdub3JlXG5cblxuICBpZiAoaXNPYnNlcnZhYmxlKHYpKSByZXR1cm4gdjsgLy8gcGxhaW4gb2JqZWN0XG5cbiAgaWYgKGlzUGxhaW5PYmplY3QodikpIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCBhcmcyLCBhcmczKTsgLy8gQXJyYXlcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkgcmV0dXJuIG9ic2VydmFibGUuYXJyYXkodiwgYXJnMik7IC8vIE1hcFxuXG4gIGlmIChpc0VTNk1hcCh2KSkgcmV0dXJuIG9ic2VydmFibGUubWFwKHYsIGFyZzIpOyAvLyBTZXRcblxuICBpZiAoaXNFUzZTZXQodikpIHJldHVybiBvYnNlcnZhYmxlLnNldCh2LCBhcmcyKTsgLy8gb3RoZXIgb2JqZWN0IC0gaWdub3JlXG5cbiAgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT09IG51bGwpIHJldHVybiB2OyAvLyBhbnl0aGluZyBlbHNlXG5cbiAgcmV0dXJuIG9ic2VydmFibGUuYm94KHYsIGFyZzIpO1xufVxuXG5PYmplY3QuYXNzaWduKGNyZWF0ZU9ic2VydmFibGUsIG9ic2VydmFibGVEZWNvcmF0b3JBbm5vdGF0aW9uKTtcbnZhciBvYnNlcnZhYmxlRmFjdG9yaWVzID0ge1xuICBib3g6IGZ1bmN0aW9uIGJveCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lLCB0cnVlLCBvLmVxdWFscyk7XG4gIH0sXG4gIGFycmF5OiBmdW5jdGlvbiBhcnJheShpbml0aWFsVmFsdWVzLCBvcHRpb25zKSB7XG4gICAgdmFyIG8gPSBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiAoZ2xvYmFsU3RhdGUudXNlUHJveGllcyA9PT0gZmFsc2UgfHwgby5wcm94eSA9PT0gZmFsc2UgPyBjcmVhdGVMZWdhY3lBcnJheSA6IGNyZWF0ZU9ic2VydmFibGVBcnJheSkoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgbWFwOiBmdW5jdGlvbiBtYXAoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVNYXAoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTZXQoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3QocHJvcHMsIGRlY29yYXRvcnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZXh0ZW5kT2JzZXJ2YWJsZShnbG9iYWxTdGF0ZS51c2VQcm94aWVzID09PSBmYWxzZSB8fCAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wcm94eSkgPT09IGZhbHNlID8gYXNPYnNlcnZhYmxlT2JqZWN0KHt9LCBvcHRpb25zKSA6IGFzRHluYW1pY09ic2VydmFibGVPYmplY3Qoe30sIG9wdGlvbnMpLCBwcm9wcywgZGVjb3JhdG9ycyk7XG4gIH0sXG4gIHJlZjogLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24ob2JzZXJ2YWJsZVJlZkFubm90YXRpb24pLFxuICBzaGFsbG93OiAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlU2hhbGxvd0Fubm90YXRpb24pLFxuICBkZWVwOiBvYnNlcnZhYmxlRGVjb3JhdG9yQW5ub3RhdGlvbixcbiAgc3RydWN0OiAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlU3RydWN0QW5ub3RhdGlvbilcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG52YXIgb2JzZXJ2YWJsZSA9IC8qI19fUFVSRV9fKi9hc3NpZ24oY3JlYXRlT2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZUZhY3Rvcmllcyk7XG52YXIgQ09NUFVURUQgPSBcImNvbXB1dGVkXCI7XG52YXIgQ09NUFVURURfU1RSVUNUID0gXCJjb21wdXRlZC5zdHJ1Y3RcIjtcbnZhciBjb21wdXRlZEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKENPTVBVVEVEKTtcbnZhciBjb21wdXRlZFN0cnVjdEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKENPTVBVVEVEX1NUUlVDVCwge1xuICBlcXVhbHM6IGNvbXBhcmVyLnN0cnVjdHVyYWxcbn0pO1xuLyoqXHJcbiAqIERlY29yYXRvciBmb3IgY2xhc3MgcHJvcGVydGllczogQGNvbXB1dGVkIGdldCB2YWx1ZSgpIHsgcmV0dXJuIGV4cHI7IH0uXHJcbiAqIEZvciBsZWdhY3kgcHVycG9zZXMgYWxzbyBpbnZva2FibGUgYXMgRVM1IG9ic2VydmFibGUgY3JlYXRlZDogYGNvbXB1dGVkKCgpID0+IGV4cHIpYDtcclxuICovXG5cbnZhciBjb21wdXRlZCA9IGZ1bmN0aW9uIGNvbXB1dGVkKGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzU3RyaW5naXNoKGFyZzIpKSB7XG4gICAgLy8gQGNvbXB1dGVkXG4gICAgcmV0dXJuIHN0b3JlQW5ub3RhdGlvbihhcmcxLCBhcmcyLCBjb21wdXRlZEFubm90YXRpb24pO1xuICB9XG5cbiAgaWYgKGlzUGxhaW5PYmplY3QoYXJnMSkpIHtcbiAgICAvLyBAY29tcHV0ZWQoeyBvcHRpb25zIH0pXG4gICAgcmV0dXJuIGNyZWF0ZURlY29yYXRvckFubm90YXRpb24oY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKENPTVBVVEVELCBhcmcxKSk7XG4gIH0gLy8gY29tcHV0ZWQoZXhwciwgb3B0aW9ucz8pXG5cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGFyZzEpKSBkaWUoXCJGaXJzdCBhcmd1bWVudCB0byBgY29tcHV0ZWRgIHNob3VsZCBiZSBhbiBleHByZXNzaW9uLlwiKTtcbiAgICBpZiAoaXNGdW5jdGlvbihhcmcyKSkgZGllKFwiQSBzZXR0ZXIgYXMgc2Vjb25kIGFyZ3VtZW50IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHVzZSBgeyBzZXQ6IGZuIH1gIG9wdGlvbiBpbnN0ZWFkXCIpO1xuICB9XG5cbiAgdmFyIG9wdHMgPSBpc1BsYWluT2JqZWN0KGFyZzIpID8gYXJnMiA6IHt9O1xuICBvcHRzLmdldCA9IGFyZzE7XG4gIG9wdHMubmFtZSB8fCAob3B0cy5uYW1lID0gYXJnMS5uYW1lIHx8IFwiXCIpO1xuICAvKiBmb3IgZ2VuZXJhdGVkIG5hbWUgKi9cblxuICByZXR1cm4gbmV3IENvbXB1dGVkVmFsdWUob3B0cyk7XG59O1xuXG5PYmplY3QuYXNzaWduKGNvbXB1dGVkLCBjb21wdXRlZEFubm90YXRpb24pO1xuY29tcHV0ZWQuc3RydWN0ID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oY29tcHV0ZWRTdHJ1Y3RBbm5vdGF0aW9uKTtcblxudmFyIF9nZXREZXNjcmlwdG9yJGNvbmZpZywgX2dldERlc2NyaXB0b3I7IC8vIG1vYnggdmVyc2lvbnNcblxuXG52YXIgY3VycmVudEFjdGlvbklkID0gMDtcbnZhciBuZXh0QWN0aW9uSWQgPSAxO1xudmFyIGlzRnVuY3Rpb25OYW1lQ29uZmlndXJhYmxlID0gKF9nZXREZXNjcmlwdG9yJGNvbmZpZyA9IChfZ2V0RGVzY3JpcHRvciA9IC8qI19fUFVSRV9fKi9nZXREZXNjcmlwdG9yKGZ1bmN0aW9uICgpIHt9LCBcIm5hbWVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0RGVzY3JpcHRvci5jb25maWd1cmFibGUpICE9IG51bGwgPyBfZ2V0RGVzY3JpcHRvciRjb25maWcgOiBmYWxzZTsgLy8gd2UgY2FuIHNhZmVseSByZWN5Y2xlIHRoaXMgb2JqZWN0XG5cbnZhciB0bXBOYW1lRGVzY3JpcHRvciA9IHtcbiAgdmFsdWU6IFwiYWN0aW9uXCIsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKGFjdGlvbk5hbWUsIGZuLCBhdXRvQWN0aW9uLCByZWYpIHtcbiAgaWYgKGF1dG9BY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIGF1dG9BY3Rpb24gPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oZm4pKSBkaWUoXCJgYWN0aW9uYCBjYW4gb25seSBiZSBpbnZva2VkIG9uIGZ1bmN0aW9uc1wiKTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbk5hbWUgIT09IFwic3RyaW5nXCIgfHwgIWFjdGlvbk5hbWUpIGRpZShcImFjdGlvbnMgc2hvdWxkIGhhdmUgdmFsaWQgbmFtZXMsIGdvdDogJ1wiICsgYWN0aW9uTmFtZSArIFwiJ1wiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcygpIHtcbiAgICByZXR1cm4gZXhlY3V0ZUFjdGlvbihhY3Rpb25OYW1lLCBhdXRvQWN0aW9uLCBmbiwgcmVmIHx8IHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXMuaXNNb2J4QWN0aW9uID0gdHJ1ZTtcblxuICBpZiAoaXNGdW5jdGlvbk5hbWVDb25maWd1cmFibGUpIHtcbiAgICB0bXBOYW1lRGVzY3JpcHRvci52YWx1ZSA9IGFjdGlvbk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcywgXCJuYW1lXCIsIHRtcE5hbWVEZXNjcmlwdG9yKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVBY3Rpb24oYWN0aW9uTmFtZSwgY2FuUnVuQXNEZXJpdmF0aW9uLCBmbiwgc2NvcGUsIGFyZ3MpIHtcbiAgdmFyIHJ1bkluZm8gPSBfc3RhcnRBY3Rpb24oYWN0aW9uTmFtZSwgY2FuUnVuQXNEZXJpdmF0aW9uLCBzY29wZSwgYXJncyk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4uYXBwbHkoc2NvcGUsIGFyZ3MpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBydW5JbmZvLmVycm9yXyA9IGVycjtcbiAgICB0aHJvdyBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgX2VuZEFjdGlvbihydW5JbmZvKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfc3RhcnRBY3Rpb24oYWN0aW9uTmFtZSwgY2FuUnVuQXNEZXJpdmF0aW9uLCAvLyB0cnVlIGZvciBhdXRvQWN0aW9uXG5zY29wZSwgYXJncykge1xuICB2YXIgbm90aWZ5U3B5XyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1NweUVuYWJsZWQoKSAmJiAhIWFjdGlvbk5hbWU7XG4gIHZhciBzdGFydFRpbWVfID0gMDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweV8pIHtcbiAgICBzdGFydFRpbWVfID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgZmxhdHRlbmVkQXJncyA9IGFyZ3MgPyBBcnJheS5mcm9tKGFyZ3MpIDogRU1QVFlfQVJSQVk7XG4gICAgc3B5UmVwb3J0U3RhcnQoe1xuICAgICAgdHlwZTogQUNUSU9OLFxuICAgICAgbmFtZTogYWN0aW9uTmFtZSxcbiAgICAgIG9iamVjdDogc2NvcGUsXG4gICAgICBhcmd1bWVudHM6IGZsYXR0ZW5lZEFyZ3NcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwcmV2RGVyaXZhdGlvbl8gPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gIHZhciBydW5Bc0FjdGlvbiA9ICFjYW5SdW5Bc0Rlcml2YXRpb24gfHwgIXByZXZEZXJpdmF0aW9uXztcbiAgc3RhcnRCYXRjaCgpO1xuICB2YXIgcHJldkFsbG93U3RhdGVDaGFuZ2VzXyA9IGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzOyAvLyBieSBkZWZhdWx0IHByZXNlcnZlIHByZXZpb3VzIGFsbG93XG5cbiAgaWYgKHJ1bkFzQWN0aW9uKSB7XG4gICAgdW50cmFja2VkU3RhcnQoKTtcbiAgICBwcmV2QWxsb3dTdGF0ZUNoYW5nZXNfID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydCh0cnVlKTtcbiAgfVxuXG4gIHZhciBwcmV2QWxsb3dTdGF0ZVJlYWRzXyA9IGFsbG93U3RhdGVSZWFkc1N0YXJ0KHRydWUpO1xuICB2YXIgcnVuSW5mbyA9IHtcbiAgICBydW5Bc0FjdGlvbl86IHJ1bkFzQWN0aW9uLFxuICAgIHByZXZEZXJpdmF0aW9uXzogcHJldkRlcml2YXRpb25fLFxuICAgIHByZXZBbGxvd1N0YXRlQ2hhbmdlc186IHByZXZBbGxvd1N0YXRlQ2hhbmdlc18sXG4gICAgcHJldkFsbG93U3RhdGVSZWFkc186IHByZXZBbGxvd1N0YXRlUmVhZHNfLFxuICAgIG5vdGlmeVNweV86IG5vdGlmeVNweV8sXG4gICAgc3RhcnRUaW1lXzogc3RhcnRUaW1lXyxcbiAgICBhY3Rpb25JZF86IG5leHRBY3Rpb25JZCsrLFxuICAgIHBhcmVudEFjdGlvbklkXzogY3VycmVudEFjdGlvbklkXG4gIH07XG4gIGN1cnJlbnRBY3Rpb25JZCA9IHJ1bkluZm8uYWN0aW9uSWRfO1xuICByZXR1cm4gcnVuSW5mbztcbn1cblxuZnVuY3Rpb24gX2VuZEFjdGlvbihydW5JbmZvKSB7XG4gIGlmIChjdXJyZW50QWN0aW9uSWQgIT09IHJ1bkluZm8uYWN0aW9uSWRfKSB7XG4gICAgZGllKDMwKTtcbiAgfVxuXG4gIGN1cnJlbnRBY3Rpb25JZCA9IHJ1bkluZm8ucGFyZW50QWN0aW9uSWRfO1xuXG4gIGlmIChydW5JbmZvLmVycm9yXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2xvYmFsU3RhdGUuc3VwcHJlc3NSZWFjdGlvbkVycm9ycyA9IHRydWU7XG4gIH1cblxuICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChydW5JbmZvLnByZXZBbGxvd1N0YXRlQ2hhbmdlc18pO1xuICBhbGxvd1N0YXRlUmVhZHNFbmQocnVuSW5mby5wcmV2QWxsb3dTdGF0ZVJlYWRzXyk7XG4gIGVuZEJhdGNoKCk7XG4gIGlmIChydW5JbmZvLnJ1bkFzQWN0aW9uXykgdW50cmFja2VkRW5kKHJ1bkluZm8ucHJldkRlcml2YXRpb25fKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHJ1bkluZm8ubm90aWZ5U3B5Xykge1xuICAgIHNweVJlcG9ydEVuZCh7XG4gICAgICB0aW1lOiBEYXRlLm5vdygpIC0gcnVuSW5mby5zdGFydFRpbWVfXG4gICAgfSk7XG4gIH1cblxuICBnbG9iYWxTdGF0ZS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFsbG93U3RhdGVDaGFuZ2VzKGFsbG93U3RhdGVDaGFuZ2VzLCBmdW5jKSB7XG4gIHZhciBwcmV2ID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydChhbGxvd1N0YXRlQ2hhbmdlcyk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZnVuYygpO1xuICB9IGZpbmFsbHkge1xuICAgIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHByZXYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQoYWxsb3dTdGF0ZUNoYW5nZXMpIHtcbiAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcztcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSBhbGxvd1N0YXRlQ2hhbmdlcztcbiAgcmV0dXJuIHByZXY7XG59XG5cbmZ1bmN0aW9uIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHByZXYpIHtcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSBwcmV2O1xufVxuXG52YXIgX1N5bWJvbCR0b1ByaW1pdGl2ZTtcblxudmFyIENSRUFURSA9IFwiY3JlYXRlXCI7XG5fU3ltYm9sJHRvUHJpbWl0aXZlID0gU3ltYm9sLnRvUHJpbWl0aXZlO1xuXG52YXIgT2JzZXJ2YWJsZVZhbHVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXRvbSkge1xuICBfaW5oZXJpdHNMb29zZShPYnNlcnZhYmxlVmFsdWUsIF9BdG9tKTtcblxuICBmdW5jdGlvbiBPYnNlcnZhYmxlVmFsdWUodmFsdWUsIGVuaGFuY2VyLCBuYW1lXywgbm90aWZ5U3B5LCBlcXVhbHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk9ic2VydmFibGVWYWx1ZUBcIiArIGdldE5leHRJZCgpIDogXCJPYnNlcnZhYmxlVmFsdWVcIjtcbiAgICB9XG5cbiAgICBpZiAobm90aWZ5U3B5ID09PSB2b2lkIDApIHtcbiAgICAgIG5vdGlmeVNweSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVxdWFscyA9PT0gdm9pZCAwKSB7XG4gICAgICBlcXVhbHMgPSBjb21wYXJlcltcImRlZmF1bHRcIl07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQXRvbS5jYWxsKHRoaXMsIG5hbWVfKSB8fCB0aGlzO1xuICAgIF90aGlzLmVuaGFuY2VyID0gdm9pZCAwO1xuICAgIF90aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIF90aGlzLmVxdWFscyA9IHZvaWQgMDtcbiAgICBfdGhpcy5oYXNVbnJlcG9ydGVkQ2hhbmdlXyA9IGZhbHNlO1xuICAgIF90aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgX3RoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICBfdGhpcy52YWx1ZV8gPSB2b2lkIDA7XG4gICAgX3RoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMuZW5oYW5jZXIgPSBlbmhhbmNlcjtcbiAgICBfdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIF90aGlzLmVxdWFscyA9IGVxdWFscztcbiAgICBfdGhpcy52YWx1ZV8gPSBlbmhhbmNlcih2YWx1ZSwgdW5kZWZpbmVkLCBuYW1lXyk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSAmJiBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgLy8gb25seSBub3RpZnkgc3B5IGlmIHRoaXMgaXMgYSBzdGFuZC1hbG9uZSBvYnNlcnZhYmxlXG4gICAgICBzcHlSZXBvcnQoe1xuICAgICAgICB0eXBlOiBDUkVBVEUsXG4gICAgICAgIG9iamVjdDogX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInZhbHVlXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogX3RoaXMubmFtZV8sXG4gICAgICAgIG5ld1ZhbHVlOiBcIlwiICsgX3RoaXMudmFsdWVfXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVoYW5jZVZhbHVlID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgbmV3VmFsdWUgPSB0aGlzLnByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpO1xuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoe1xuICAgICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwidmFsdWVcIixcbiAgICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucHJlcGFyZU5ld1ZhbHVlXyA9IGZ1bmN0aW9uIHByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpIHtcbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzKTtcblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEO1xuICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgfSAvLyBhcHBseSBtb2RpZmllclxuXG5cbiAgICBuZXdWYWx1ZSA9IHRoaXMuZW5oYW5jZXIobmV3VmFsdWUsIHRoaXMudmFsdWVfLCB0aGlzLm5hbWVfKTtcbiAgICByZXR1cm4gdGhpcy5lcXVhbHModGhpcy52YWx1ZV8sIG5ld1ZhbHVlKSA/IGdsb2JhbFN0YXRlLlVOQ0hBTkdFRCA6IG5ld1ZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5zZXROZXdWYWx1ZV8gPSBmdW5jdGlvbiBzZXROZXdWYWx1ZV8obmV3VmFsdWUpIHtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICB0aGlzLnZhbHVlXyA9IG5ld1ZhbHVlO1xuICAgIHRoaXMucmVwb3J0Q2hhbmdlZCgpO1xuXG4gICAgaWYgKGhhc0xpc3RlbmVycyh0aGlzKSkge1xuICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIHtcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB0aGlzLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlKHRoaXMudmFsdWVfKTtcbiAgfTtcblxuICBfcHJvdG8uaW50ZXJjZXB0XyA9IGZ1bmN0aW9uIGludGVyY2VwdF8oaGFuZGxlcikge1xuICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICB9O1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICBpZiAoZmlyZUltbWVkaWF0ZWx5KSBsaXN0ZW5lcih7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJ2YWx1ZVwiLFxuICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgbmV3VmFsdWU6IHRoaXMudmFsdWVfLFxuICAgICAgb2xkVmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcblxuICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KCkge1xuICAgIC8vIHVzZWQgYnkgTVNUIG90IGdldCB1bmRlaGFuY2VkIHZhbHVlXG4gICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICB9O1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV8gKyBcIltcIiArIHRoaXMudmFsdWVfICsgXCJdXCI7XG4gIH07XG5cbiAgX3Byb3RvLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0b1ByaW1pdGl2ZSh0aGlzLmdldCgpKTtcbiAgfTtcblxuICBfcHJvdG9bX1N5bWJvbCR0b1ByaW1pdGl2ZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuICB9O1xuXG4gIHJldHVybiBPYnNlcnZhYmxlVmFsdWU7XG59KEF0b20pO1xuXG52YXIgaXNPYnNlcnZhYmxlVmFsdWUgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVWYWx1ZVwiLCBPYnNlcnZhYmxlVmFsdWUpO1xuXG52YXIgX1N5bWJvbCR0b1ByaW1pdGl2ZSQxO1xuLyoqXHJcbiAqIEEgbm9kZSBpbiB0aGUgc3RhdGUgZGVwZW5kZW5jeSByb290IHRoYXQgb2JzZXJ2ZXMgb3RoZXIgbm9kZXMsIGFuZCBjYW4gYmUgb2JzZXJ2ZWQgaXRzZWxmLlxyXG4gKlxyXG4gKiBDb21wdXRlZFZhbHVlIHdpbGwgcmVtZW1iZXIgdGhlIHJlc3VsdCBvZiB0aGUgY29tcHV0YXRpb24gZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYmF0Y2gsIG9yXHJcbiAqIHdoaWxlIGJlaW5nIG9ic2VydmVkLlxyXG4gKlxyXG4gKiBEdXJpbmcgdGhpcyB0aW1lIGl0IHdpbGwgcmVjb21wdXRlIG9ubHkgd2hlbiBvbmUgb2YgaXRzIGRpcmVjdCBkZXBlbmRlbmNpZXMgY2hhbmdlZCxcclxuICogYnV0IG9ubHkgd2hlbiBpdCBpcyBiZWluZyBhY2Nlc3NlZCB3aXRoIGBDb21wdXRlZFZhbHVlLmdldCgpYC5cclxuICpcclxuICogSW1wbGVtZW50YXRpb24gZGVzY3JpcHRpb246XHJcbiAqIDEuIEZpcnN0IHRpbWUgaXQncyBiZWluZyBhY2Nlc3NlZCBpdCB3aWxsIGNvbXB1dGUgYW5kIHJlbWVtYmVyIHJlc3VsdFxyXG4gKiAgICBnaXZlIGJhY2sgcmVtZW1iZXJlZCByZXN1bHQgdW50aWwgMi4gaGFwcGVuc1xyXG4gKiAyLiBGaXJzdCB0aW1lIGFueSBkZWVwIGRlcGVuZGVuY3kgY2hhbmdlLCBwcm9wYWdhdGUgUE9TU0lCTFlfU1RBTEUgdG8gYWxsIG9ic2VydmVycywgd2FpdCBmb3IgMy5cclxuICogMy4gV2hlbiBpdCdzIGJlaW5nIGFjY2Vzc2VkLCByZWNvbXB1dGUgaWYgYW55IHNoYWxsb3cgZGVwZW5kZW5jeSBjaGFuZ2VkLlxyXG4gKiAgICBpZiByZXN1bHQgY2hhbmdlZDogcHJvcGFnYXRlIFNUQUxFIHRvIGFsbCBvYnNlcnZlcnMsIHRoYXQgd2VyZSBQT1NTSUJMWV9TVEFMRSBmcm9tIHRoZSBsYXN0IHN0ZXAuXHJcbiAqICAgIGdvIHRvIHN0ZXAgMi4gZWl0aGVyIHdheVxyXG4gKlxyXG4gKiBJZiBhdCBhbnkgcG9pbnQgaXQncyBvdXRzaWRlIGJhdGNoIGFuZCBpdCBpc24ndCBvYnNlcnZlZDogcmVzZXQgZXZlcnl0aGluZyBhbmQgZ28gdG8gMS5cclxuICovXG5cblxuX1N5bWJvbCR0b1ByaW1pdGl2ZSQxID0gU3ltYm9sLnRvUHJpbWl0aXZlO1xuXG52YXIgQ29tcHV0ZWRWYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIG5vZGVzIHdlIGFyZSBsb29raW5nIGF0LiBPdXIgdmFsdWUgZGVwZW5kcyBvbiB0aGVzZSBub2Rlc1xuICAvLyBkdXJpbmcgdHJhY2tpbmcgaXQncyBhbiBhcnJheSB3aXRoIG5ldyBvYnNlcnZlZCBvYnNlcnZlcnNcbiAgLy8gdG8gY2hlY2sgZm9yIGN5Y2xlc1xuICAvLyBOLkI6IHVubWluaWZpZWQgYXMgaXQgaXMgdXNlZCBieSBNU1RcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgY29tcHV0ZWQgdmFsdWUgYmFzZWQgb24gYSBmdW5jdGlvbiBleHByZXNzaW9uLlxyXG4gICAqXHJcbiAgICogVGhlIGBuYW1lYCBwcm9wZXJ0eSBpcyBmb3IgZGVidWcgcHVycG9zZXMgb25seS5cclxuICAgKlxyXG4gICAqIFRoZSBgZXF1YWxzYCBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIGNvbXBhcmVyIGZ1bmN0aW9uIHRvIHVzZSB0byBkZXRlcm1pbmUgaWYgYSBuZXdseSBwcm9kdWNlZFxyXG4gICAqIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgcHJldmlvdXMgdmFsdWUuIFR3byBjb21wYXJlcnMgYXJlIHByb3ZpZGVkIGluIHRoZSBsaWJyYXJ5OyBgZGVmYXVsdENvbXBhcmVyYFxyXG4gICAqIGNvbXBhcmVzIGJhc2VkIG9uIGlkZW50aXR5IGNvbXBhcmlzb24gKD09PSksIGFuZCBgc3RydWN0dXJhbENvbXBhcmVyYCBkZWVwbHkgY29tcGFyZXMgdGhlIHN0cnVjdHVyZS5cclxuICAgKiBTdHJ1Y3R1cmFsIGNvbXBhcmlzb24gY2FuIGJlIGNvbnZlbmllbnQgaWYgeW91IGFsd2F5cyBwcm9kdWNlIGEgbmV3IGFnZ3JlZ2F0ZWQgb2JqZWN0IGFuZFxyXG4gICAqIGRvbid0IHdhbnQgdG8gbm90aWZ5IG9ic2VydmVycyBpZiBpdCBpcyBzdHJ1Y3R1cmFsbHkgdGhlIHNhbWUuXHJcbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIHdvcmtpbmcgd2l0aCB2ZWN0b3JzLCBtb3VzZSBjb29yZGluYXRlcyBldGMuXHJcbiAgICovXG4gIGZ1bmN0aW9uIENvbXB1dGVkVmFsdWUob3B0aW9ucykge1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB0aGlzLm9ic2VydmluZ18gPSBbXTtcbiAgICB0aGlzLm5ld09ic2VydmluZ18gPSBudWxsO1xuICAgIHRoaXMuaXNCZWluZ09ic2VydmVkXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbl8gPSBmYWxzZTtcbiAgICB0aGlzLm9ic2VydmVyc18gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5kaWZmVmFsdWVfID0gMDtcbiAgICB0aGlzLnJ1bklkXyA9IDA7XG4gICAgdGhpcy5sYXN0QWNjZXNzZWRCeV8gPSAwO1xuICAgIHRoaXMubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXztcbiAgICB0aGlzLnVuYm91bmREZXBzQ291bnRfID0gMDtcbiAgICB0aGlzLnZhbHVlXyA9IG5ldyBDYXVnaHRFeGNlcHRpb24obnVsbCk7XG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRyaWdnZXJlZEJ5XyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ29tcHV0aW5nXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNSdW5uaW5nU2V0dGVyXyA9IGZhbHNlO1xuICAgIHRoaXMuZGVyaXZhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLnNldHRlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc1RyYWNpbmdfID0gVHJhY2VNb2RlLk5PTkU7XG4gICAgdGhpcy5zY29wZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5lcXVhbHNfID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWlyZXNSZWFjdGlvbl8gPSB2b2lkIDA7XG4gICAgdGhpcy5rZWVwQWxpdmVfID0gdm9pZCAwO1xuICAgIHRoaXMub25CT0wgPSB2b2lkIDA7XG4gICAgdGhpcy5vbkJVT0wgPSB2b2lkIDA7XG4gICAgaWYgKCFvcHRpb25zLmdldCkgZGllKDMxKTtcbiAgICB0aGlzLmRlcml2YXRpb24gPSBvcHRpb25zLmdldDtcbiAgICB0aGlzLm5hbWVfID0gb3B0aW9ucy5uYW1lIHx8IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIkNvbXB1dGVkVmFsdWVAXCIgKyBnZXROZXh0SWQoKSA6IFwiQ29tcHV0ZWRWYWx1ZVwiKTtcblxuICAgIGlmIChvcHRpb25zLnNldCkge1xuICAgICAgdGhpcy5zZXR0ZXJfID0gY3JlYXRlQWN0aW9uKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi1zZXR0ZXJcIiA6IFwiQ29tcHV0ZWRWYWx1ZS1zZXR0ZXJcIiwgb3B0aW9ucy5zZXQpO1xuICAgIH1cblxuICAgIHRoaXMuZXF1YWxzXyA9IG9wdGlvbnMuZXF1YWxzIHx8IChvcHRpb25zLmNvbXBhcmVTdHJ1Y3R1cmFsIHx8IG9wdGlvbnMuc3RydWN0ID8gY29tcGFyZXIuc3RydWN0dXJhbCA6IGNvbXBhcmVyW1wiZGVmYXVsdFwiXSk7XG4gICAgdGhpcy5zY29wZV8gPSBvcHRpb25zLmNvbnRleHQ7XG4gICAgdGhpcy5yZXF1aXJlc1JlYWN0aW9uXyA9ICEhb3B0aW9ucy5yZXF1aXJlc1JlYWN0aW9uO1xuICAgIHRoaXMua2VlcEFsaXZlXyA9ICEhb3B0aW9ucy5rZWVwQWxpdmU7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ29tcHV0ZWRWYWx1ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9uQmVjb21lU3RhbGVfID0gZnVuY3Rpb24gb25CZWNvbWVTdGFsZV8oKSB7XG4gICAgcHJvcGFnYXRlTWF5YmVDaGFuZ2VkKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vbkJPID0gZnVuY3Rpb24gb25CTygpIHtcbiAgICBpZiAodGhpcy5vbkJPTCkge1xuICAgICAgdGhpcy5vbkJPTC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25CVU8gPSBmdW5jdGlvbiBvbkJVTygpIHtcbiAgICBpZiAodGhpcy5vbkJVT0wpIHtcbiAgICAgIHRoaXMub25CVU9MLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcyBjb21wdXRlZCB2YWx1ZS5cclxuICAgKiBXaWxsIGV2YWx1YXRlIGl0cyBjb21wdXRhdGlvbiBmaXJzdCBpZiBuZWVkZWQuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLmlzQ29tcHV0aW5nXykgZGllKDMyLCB0aGlzLm5hbWVfLCB0aGlzLmRlcml2YXRpb24pO1xuXG4gICAgaWYgKGdsb2JhbFN0YXRlLmluQmF0Y2ggPT09IDAgJiYgLy8gIWdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdHBpb24gJiZcbiAgICB0aGlzLm9ic2VydmVyc18uc2l6ZSA9PT0gMCAmJiAhdGhpcy5rZWVwQWxpdmVfKSB7XG4gICAgICBpZiAoc2hvdWxkQ29tcHV0ZSh0aGlzKSkge1xuICAgICAgICB0aGlzLndhcm5BYm91dFVudHJhY2tlZFJlYWRfKCk7XG4gICAgICAgIHN0YXJ0QmF0Y2goKTsgLy8gU2VlIHBlcmYgdGVzdCAnY29tcHV0ZWQgbWVtb2l6YXRpb24nXG5cbiAgICAgICAgdGhpcy52YWx1ZV8gPSB0aGlzLmNvbXB1dGVWYWx1ZV8oZmFsc2UpO1xuICAgICAgICBlbmRCYXRjaCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXBvcnRPYnNlcnZlZCh0aGlzKTtcblxuICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpIHtcbiAgICAgICAgdmFyIHByZXZUcmFja2luZ0NvbnRleHQgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQ7XG4gICAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZV8gJiYgIXByZXZUcmFja2luZ0NvbnRleHQpIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrQW5kQ29tcHV0ZSgpKSBwcm9wYWdhdGVDaGFuZ2VDb25maXJtZWQodGhpcyk7XG4gICAgICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHByZXZUcmFja2luZ0NvbnRleHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMudmFsdWVfO1xuICAgIGlmIChpc0NhdWdodEV4Y2VwdGlvbihyZXN1bHQpKSB0aHJvdyByZXN1bHQuY2F1c2U7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc2V0dGVyXykge1xuICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nU2V0dGVyXykgZGllKDMzLCB0aGlzLm5hbWVfKTtcbiAgICAgIHRoaXMuaXNSdW5uaW5nU2V0dGVyXyA9IHRydWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2V0dGVyXy5jYWxsKHRoaXMuc2NvcGVfLCB2YWx1ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmlzUnVubmluZ1NldHRlcl8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgZGllKDM0LCB0aGlzLm5hbWVfKTtcbiAgfTtcblxuICBfcHJvdG8udHJhY2tBbmRDb21wdXRlID0gZnVuY3Rpb24gdHJhY2tBbmRDb21wdXRlKCkge1xuICAgIC8vIE4uQjogdW5taW5pZmllZCBhcyBpdCBpcyB1c2VkIGJ5IE1TVFxuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgIHZhciB3YXNTdXNwZW5kZWQgPVxuICAgIC8qIHNlZSAjMTIwOCAqL1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfO1xuICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuY29tcHV0ZVZhbHVlXyh0cnVlKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgIHNweVJlcG9ydCh7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcImNvbXB1dGVkXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgb2JqZWN0OiB0aGlzLnNjb3BlXyxcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgb2xkVmFsdWU6IHRoaXMudmFsdWVfLFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBjaGFuZ2VkID0gd2FzU3VzcGVuZGVkIHx8IGlzQ2F1Z2h0RXhjZXB0aW9uKG9sZFZhbHVlKSB8fCBpc0NhdWdodEV4Y2VwdGlvbihuZXdWYWx1ZSkgfHwgIXRoaXMuZXF1YWxzXyhvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMudmFsdWVfID0gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXB1dGVWYWx1ZV8gPSBmdW5jdGlvbiBjb21wdXRlVmFsdWVfKHRyYWNrKSB7XG4gICAgdGhpcy5pc0NvbXB1dGluZ18gPSB0cnVlOyAvLyBkb24ndCBhbGxvdyBzdGF0ZSBjaGFuZ2VzIGR1cmluZyBjb21wdXRhdGlvblxuXG4gICAgdmFyIHByZXYgPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KGZhbHNlKTtcbiAgICB2YXIgcmVzO1xuXG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXMgPSB0cmFja0Rlcml2ZWRGdW5jdGlvbih0aGlzLCB0aGlzLmRlcml2YXRpb24sIHRoaXMuc2NvcGVfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMgPT09IHRydWUpIHtcbiAgICAgICAgcmVzID0gdGhpcy5kZXJpdmF0aW9uLmNhbGwodGhpcy5zY29wZV8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSB0aGlzLmRlcml2YXRpb24uY2FsbCh0aGlzLnNjb3BlXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXMgPSBuZXcgQ2F1Z2h0RXhjZXB0aW9uKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XG4gICAgdGhpcy5pc0NvbXB1dGluZ18gPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIF9wcm90by5zdXNwZW5kXyA9IGZ1bmN0aW9uIHN1c3BlbmRfKCkge1xuICAgIGlmICghdGhpcy5rZWVwQWxpdmVfKSB7XG4gICAgICBjbGVhck9ic2VydmluZyh0aGlzKTtcbiAgICAgIHRoaXMudmFsdWVfID0gdW5kZWZpbmVkOyAvLyBkb24ndCBob2xkIG9uIHRvIGNvbXB1dGVkIHZhbHVlIVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuICAgIHZhciBwcmV2VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGF1dG9ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogd2h5IGlzIHRoaXMgaW4gYSBkaWZmZXJlbnQgcGxhY2UgdGhhbiB0aGUgc3B5UmVwb3J0KCkgZnVuY3Rpb24/IGluIGFsbCBvdGhlciBvYnNlcnZhYmxlcyBpdCdzIGNhbGxlZCBpbiB0aGUgc2FtZSBwbGFjZVxuICAgICAgdmFyIG5ld1ZhbHVlID0gX3RoaXMuZ2V0KCk7XG5cbiAgICAgIGlmICghZmlyc3RUaW1lIHx8IGZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgICB2YXIgcHJldlUgPSB1bnRyYWNrZWRTdGFydCgpO1xuICAgICAgICBsaXN0ZW5lcih7XG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwiY29tcHV0ZWRcIixcbiAgICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IF90aGlzLm5hbWVfLFxuICAgICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgICBvYmplY3Q6IF90aGlzLFxuICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICBvbGRWYWx1ZTogcHJldlZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB1bnRyYWNrZWRFbmQocHJldlUpO1xuICAgICAgfVxuXG4gICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgIHByZXZWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by53YXJuQWJvdXRVbnRyYWNrZWRSZWFkXyA9IGZ1bmN0aW9uIHdhcm5BYm91dFVudHJhY2tlZFJlYWRfKCkge1xuICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHJldHVybjtcblxuICAgIGlmICh0aGlzLnJlcXVpcmVzUmVhY3Rpb25fID09PSB0cnVlKSB7XG4gICAgICBkaWUoXCJbbW9ieF0gQ29tcHV0ZWQgdmFsdWUgXCIgKyB0aGlzLm5hbWVfICsgXCIgaXMgcmVhZCBvdXRzaWRlIGEgcmVhY3RpdmUgY29udGV4dFwiKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgY29uc29sZS5sb2coXCJbbW9ieC50cmFjZV0gJ1wiICsgdGhpcy5uYW1lXyArIFwiJyBpcyBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0LiBEb2luZyBhIGZ1bGwgcmVjb21wdXRlXCIpO1xuICAgIH1cblxuICAgIGlmIChnbG9iYWxTdGF0ZS5jb21wdXRlZFJlcXVpcmVzUmVhY3Rpb24pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlttb2J4XSBDb21wdXRlZCB2YWx1ZSBcIiArIHRoaXMubmFtZV8gKyBcIiBpcyBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0LiBEb2luZyBhIGZ1bGwgcmVjb21wdXRlXCIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXyArIFwiW1wiICsgdGhpcy5kZXJpdmF0aW9uLnRvU3RyaW5nKCkgKyBcIl1cIjtcbiAgfTtcblxuICBfcHJvdG8udmFsdWVPZiA9IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRvUHJpbWl0aXZlKHRoaXMuZ2V0KCkpO1xuICB9O1xuXG4gIF9wcm90b1tfU3ltYm9sJHRvUHJpbWl0aXZlJDFdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcbiAgfTtcblxuICByZXR1cm4gQ29tcHV0ZWRWYWx1ZTtcbn0oKTtcblxudmFyIGlzQ29tcHV0ZWRWYWx1ZSA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiQ29tcHV0ZWRWYWx1ZVwiLCBDb21wdXRlZFZhbHVlKTtcbnZhciBJRGVyaXZhdGlvblN0YXRlXztcblxuKGZ1bmN0aW9uIChJRGVyaXZhdGlvblN0YXRlXykge1xuICAvLyBiZWZvcmUgYmVpbmcgcnVuIG9yIChvdXRzaWRlIGJhdGNoIGFuZCBub3QgYmVpbmcgb2JzZXJ2ZWQpXG4gIC8vIGF0IHRoaXMgcG9pbnQgZGVyaXZhdGlvbiBpcyBub3QgaG9sZGluZyBhbnkgZGF0YSBhYm91dCBkZXBlbmRlbmN5IHRyZWVcbiAgSURlcml2YXRpb25TdGF0ZV9bSURlcml2YXRpb25TdGF0ZV9bXCJOT1RfVFJBQ0tJTkdfXCJdID0gLTFdID0gXCJOT1RfVFJBQ0tJTkdfXCI7IC8vIG5vIHNoYWxsb3cgZGVwZW5kZW5jeSBjaGFuZ2VkIHNpbmNlIGxhc3QgY29tcHV0YXRpb25cbiAgLy8gd29uJ3QgcmVjYWxjdWxhdGUgZGVyaXZhdGlvblxuICAvLyB0aGlzIGlzIHdoYXQgbWFrZXMgbW9ieCBmYXN0XG5cbiAgSURlcml2YXRpb25TdGF0ZV9bSURlcml2YXRpb25TdGF0ZV9bXCJVUF9UT19EQVRFX1wiXSA9IDBdID0gXCJVUF9UT19EQVRFX1wiOyAvLyBzb21lIGRlZXAgZGVwZW5kZW5jeSBjaGFuZ2VkLCBidXQgZG9uJ3Qga25vdyBpZiBzaGFsbG93IGRlcGVuZGVuY3kgY2hhbmdlZFxuICAvLyB3aWxsIHJlcXVpcmUgdG8gY2hlY2sgZmlyc3QgaWYgVVBfVE9fREFURSBvciBQT1NTSUJMWV9TVEFMRVxuICAvLyBjdXJyZW50bHkgb25seSBDb21wdXRlZFZhbHVlIHdpbGwgcHJvcGFnYXRlIFBPU1NJQkxZX1NUQUxFXG4gIC8vXG4gIC8vIGhhdmluZyB0aGlzIHN0YXRlIGlzIHNlY29uZCBiaWcgb3B0aW1pemF0aW9uOlxuICAvLyBkb24ndCBoYXZlIHRvIHJlY29tcHV0ZSBvbiBldmVyeSBkZXBlbmRlbmN5IGNoYW5nZSwgYnV0IG9ubHkgd2hlbiBpdCdzIG5lZWRlZFxuXG4gIElEZXJpdmF0aW9uU3RhdGVfW0lEZXJpdmF0aW9uU3RhdGVfW1wiUE9TU0lCTFlfU1RBTEVfXCJdID0gMV0gPSBcIlBPU1NJQkxZX1NUQUxFX1wiOyAvLyBBIHNoYWxsb3cgZGVwZW5kZW5jeSBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IGNvbXB1dGF0aW9uIGFuZCB0aGUgZGVyaXZhdGlvblxuICAvLyB3aWxsIG5lZWQgdG8gcmVjb21wdXRlIHdoZW4gaXQncyBuZWVkZWQgbmV4dC5cblxuICBJRGVyaXZhdGlvblN0YXRlX1tJRGVyaXZhdGlvblN0YXRlX1tcIlNUQUxFX1wiXSA9IDJdID0gXCJTVEFMRV9cIjtcbn0pKElEZXJpdmF0aW9uU3RhdGVfIHx8IChJRGVyaXZhdGlvblN0YXRlXyA9IHt9KSk7XG5cbnZhciBUcmFjZU1vZGU7XG5cbihmdW5jdGlvbiAoVHJhY2VNb2RlKSB7XG4gIFRyYWNlTW9kZVtUcmFjZU1vZGVbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgVHJhY2VNb2RlW1RyYWNlTW9kZVtcIkxPR1wiXSA9IDFdID0gXCJMT0dcIjtcbiAgVHJhY2VNb2RlW1RyYWNlTW9kZVtcIkJSRUFLXCJdID0gMl0gPSBcIkJSRUFLXCI7XG59KShUcmFjZU1vZGUgfHwgKFRyYWNlTW9kZSA9IHt9KSk7XG5cbnZhciBDYXVnaHRFeGNlcHRpb24gPSBmdW5jdGlvbiBDYXVnaHRFeGNlcHRpb24oY2F1c2UpIHtcbiAgdGhpcy5jYXVzZSA9IHZvaWQgMDtcbiAgdGhpcy5jYXVzZSA9IGNhdXNlOyAvLyBFbXB0eVxufTtcblxuZnVuY3Rpb24gaXNDYXVnaHRFeGNlcHRpb24oZSkge1xuICByZXR1cm4gZSBpbnN0YW5jZW9mIENhdWdodEV4Y2VwdGlvbjtcbn1cbi8qKlxyXG4gKiBGaW5kcyBvdXQgd2hldGhlciBhbnkgZGVwZW5kZW5jeSBvZiB0aGUgZGVyaXZhdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cclxuICogSWYgZGVwZW5kZW5jaWVzU3RhdGUgaXMgMSB0aGVuIGl0IHdpbGwgcmVjYWxjdWxhdGUgZGVwZW5kZW5jaWVzLFxyXG4gKiBpZiBhbnkgZGVwZW5kZW5jeSBjaGFuZ2VkIGl0IHdpbGwgcHJvcGFnYXRlIGl0IGJ5IGNoYW5naW5nIGRlcGVuZGVuY2llc1N0YXRlIHRvIDIuXHJcbiAqXHJcbiAqIEJ5IGl0ZXJhdGluZyBvdmVyIHRoZSBkZXBlbmRlbmNpZXMgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IHdlcmUgcmVwb3J0ZWQgYW5kXHJcbiAqIHN0b3BwaW5nIG9uIHRoZSBmaXJzdCBjaGFuZ2UsIGFsbCB0aGUgcmVjYWxjdWxhdGlvbnMgYXJlIG9ubHkgY2FsbGVkIGZvciBDb21wdXRlZFZhbHVlc1xyXG4gKiB0aGF0IHdpbGwgYmUgdHJhY2tlZCBieSBkZXJpdmF0aW9uLiBUaGF0IGlzIGJlY2F1c2Ugd2UgYXNzdW1lIHRoYXQgaWYgdGhlIGZpcnN0IHhcclxuICogZGVwZW5kZW5jaWVzIG9mIHRoZSBkZXJpdmF0aW9uIGRvZXNuJ3QgY2hhbmdlIHRoZW4gdGhlIGRlcml2YXRpb24gc2hvdWxkIHJ1biB0aGUgc2FtZSB3YXlcclxuICogdXAgdW50aWwgYWNjZXNzaW5nIHgtdGggZGVwZW5kZW5jeS5cclxuICovXG5cblxuZnVuY3Rpb24gc2hvdWxkQ29tcHV0ZShkZXJpdmF0aW9uKSB7XG4gIHN3aXRjaCAoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8pIHtcbiAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfOlxuICAgIGNhc2UgSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfOlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXzpcbiAgICAgIHtcbiAgICAgICAgLy8gc3RhdGUgcHJvcGFnYXRpb24gY2FuIG9jY3VyIG91dHNpZGUgb2YgYWN0aW9uL3JlYWN0aXZlIGNvbnRleHQgIzIxOTVcbiAgICAgICAgdmFyIHByZXZBbGxvd1N0YXRlUmVhZHMgPSBhbGxvd1N0YXRlUmVhZHNTdGFydCh0cnVlKTtcbiAgICAgICAgdmFyIHByZXZVbnRyYWNrZWQgPSB1bnRyYWNrZWRTdGFydCgpOyAvLyBubyBuZWVkIGZvciB0aG9zZSBjb21wdXRlZHMgdG8gYmUgcmVwb3J0ZWQsIHRoZXkgd2lsbCBiZSBwaWNrZWQgdXAgaW4gdHJhY2tEZXJpdmVkRnVuY3Rpb24uXG5cbiAgICAgICAgdmFyIG9icyA9IGRlcml2YXRpb24ub2JzZXJ2aW5nXyxcbiAgICAgICAgICAgIGwgPSBvYnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IG9ic1tpXTtcblxuICAgICAgICAgIGlmIChpc0NvbXB1dGVkVmFsdWUob2JqKSkge1xuICAgICAgICAgICAgaWYgKGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMpIHtcbiAgICAgICAgICAgICAgb2JqLmdldCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvYmouZ2V0KCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgbm90IGludGVyZXN0ZWQgaW4gdGhlIHZhbHVlICpvciogZXhjZXB0aW9uIGF0IHRoaXMgbW9tZW50LCBidXQgaWYgdGhlcmUgaXMgb25lLCBub3RpZnkgYWxsXG4gICAgICAgICAgICAgICAgdW50cmFja2VkRW5kKHByZXZVbnRyYWNrZWQpO1xuICAgICAgICAgICAgICAgIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2QWxsb3dTdGF0ZVJlYWRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBpZiBDb21wdXRlZFZhbHVlIGBvYmpgIGFjdHVhbGx5IGNoYW5nZWQgaXQgd2lsbCBiZSBjb21wdXRlZCBhbmQgcHJvcGFnYXRlZCB0byBpdHMgb2JzZXJ2ZXJzLlxuICAgICAgICAgICAgLy8gYW5kIGBkZXJpdmF0aW9uYCBpcyBhbiBvYnNlcnZlciBvZiBgb2JqYFxuICAgICAgICAgICAgLy8gaW52YXJpYW50U2hvdWxkQ29tcHV0ZShkZXJpdmF0aW9uKVxuXG5cbiAgICAgICAgICAgIGlmIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfKSB7XG4gICAgICAgICAgICAgIHVudHJhY2tlZEVuZChwcmV2VW50cmFja2VkKTtcbiAgICAgICAgICAgICAgYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXZBbGxvd1N0YXRlUmVhZHMpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VEZXBlbmRlbmNpZXNTdGF0ZVRvMChkZXJpdmF0aW9uKTtcbiAgICAgICAgdW50cmFja2VkRW5kKHByZXZVbnRyYWNrZWQpO1xuICAgICAgICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbXB1dGluZ0Rlcml2YXRpb24oKSB7XG4gIHJldHVybiBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gIT09IG51bGw7IC8vIGZpbHRlciBvdXQgYWN0aW9ucyBpbnNpZGUgY29tcHV0YXRpb25zXG59XG5cbmZ1bmN0aW9uIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKGF0b20pIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBoYXNPYnNlcnZlcnMgPSBhdG9tLm9ic2VydmVyc18uc2l6ZSA+IDA7IC8vIFNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gY2hhbmdlIG9ic2VydmVkIHN0YXRlIG91dHNpZGUgc3RyaWN0IG1vZGUsIGV4Y2VwdCBkdXJpbmcgaW5pdGlhbGl6YXRpb24sIHNlZSAjNTYzXG5cbiAgaWYgKCFnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyAmJiAoaGFzT2JzZXJ2ZXJzIHx8IGdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zID09PSBcImFsd2F5c1wiKSkgY29uc29sZS53YXJuKFwiW01vYlhdIFwiICsgKGdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zID8gXCJTaW5jZSBzdHJpY3QtbW9kZSBpcyBlbmFibGVkLCBjaGFuZ2luZyAob2JzZXJ2ZWQpIG9ic2VydmFibGUgdmFsdWVzIHdpdGhvdXQgdXNpbmcgYW4gYWN0aW9uIGlzIG5vdCBhbGxvd2VkLiBUcmllZCB0byBtb2RpZnk6IFwiIDogXCJTaWRlIGVmZmVjdHMgbGlrZSBjaGFuZ2luZyBzdGF0ZSBhcmUgbm90IGFsbG93ZWQgYXQgdGhpcyBwb2ludC4gQXJlIHlvdSB0cnlpbmcgdG8gbW9kaWZ5IHN0YXRlIGZyb20sIGZvciBleGFtcGxlLCBhIGNvbXB1dGVkIHZhbHVlIG9yIHRoZSByZW5kZXIgZnVuY3Rpb24gb2YgYSBSZWFjdCBjb21wb25lbnQ/IFlvdSBjYW4gd3JhcCBzaWRlIGVmZmVjdHMgaW4gJ3J1bkluQWN0aW9uJyAob3IgZGVjb3JhdGUgZnVuY3Rpb25zIHdpdGggJ2FjdGlvbicpIGlmIG5lZWRlZC4gVHJpZWQgdG8gbW9kaWZ5OiBcIikgKyBhdG9tLm5hbWVfKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZlN0YXRlUmVhZHNBcmVBbGxvd2VkKG9ic2VydmFibGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzICYmIGdsb2JhbFN0YXRlLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKFwiW21vYnhdIE9ic2VydmFibGUgXCIgKyBvYnNlcnZhYmxlLm5hbWVfICsgXCIgYmVpbmcgcmVhZCBvdXRzaWRlIGEgcmVhY3RpdmUgY29udGV4dFwiKTtcbiAgfVxufVxuLyoqXHJcbiAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBgZmAgYW5kIHRyYWNrcyB3aGljaCBvYnNlcnZhYmxlcyBhcmUgYmVpbmcgYWNjZXNzZWQuXHJcbiAqIFRoZSB0cmFja2luZyBpbmZvcm1hdGlvbiBpcyBzdG9yZWQgb24gdGhlIGBkZXJpdmF0aW9uYCBvYmplY3QgYW5kIHRoZSBkZXJpdmF0aW9uIGlzIHJlZ2lzdGVyZWRcclxuICogYXMgb2JzZXJ2ZXIgb2YgYW55IG9mIHRoZSBhY2Nlc3NlZCBvYnNlcnZhYmxlcy5cclxuICovXG5cblxuZnVuY3Rpb24gdHJhY2tEZXJpdmVkRnVuY3Rpb24oZGVyaXZhdGlvbiwgZiwgY29udGV4dCkge1xuICB2YXIgcHJldkFsbG93U3RhdGVSZWFkcyA9IGFsbG93U3RhdGVSZWFkc1N0YXJ0KHRydWUpOyAvLyBwcmUgYWxsb2NhdGUgYXJyYXkgYWxsb2NhdGlvbiArIHJvb20gZm9yIHZhcmlhdGlvbiBpbiBkZXBzXG4gIC8vIGFycmF5IHdpbGwgYmUgdHJpbW1lZCBieSBiaW5kRGVwZW5kZW5jaWVzXG5cbiAgY2hhbmdlRGVwZW5kZW5jaWVzU3RhdGVUbzAoZGVyaXZhdGlvbik7XG4gIGRlcml2YXRpb24ubmV3T2JzZXJ2aW5nXyA9IG5ldyBBcnJheShkZXJpdmF0aW9uLm9ic2VydmluZ18ubGVuZ3RoICsgMTAwKTtcbiAgZGVyaXZhdGlvbi51bmJvdW5kRGVwc0NvdW50XyA9IDA7XG4gIGRlcml2YXRpb24ucnVuSWRfID0gKytnbG9iYWxTdGF0ZS5ydW5JZDtcbiAgdmFyIHByZXZUcmFja2luZyA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uID0gZGVyaXZhdGlvbjtcbiAgZ2xvYmFsU3RhdGUuaW5CYXRjaCsrO1xuICB2YXIgcmVzdWx0O1xuXG4gIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID09PSB0cnVlKSB7XG4gICAgcmVzdWx0ID0gZi5jYWxsKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmLmNhbGwoY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVzdWx0ID0gbmV3IENhdWdodEV4Y2VwdGlvbihlKTtcbiAgICB9XG4gIH1cblxuICBnbG9iYWxTdGF0ZS5pbkJhdGNoLS07XG4gIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IHByZXZUcmFja2luZztcbiAgYmluZERlcGVuZGVuY2llcyhkZXJpdmF0aW9uKTtcbiAgd2FybkFib3V0RGVyaXZhdGlvbldpdGhvdXREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbik7XG4gIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2QWxsb3dTdGF0ZVJlYWRzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0RGVyaXZhdGlvbldpdGhvdXREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbikge1xuICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSByZXR1cm47XG4gIGlmIChkZXJpdmF0aW9uLm9ic2VydmluZ18ubGVuZ3RoICE9PSAwKSByZXR1cm47XG5cbiAgaWYgKGdsb2JhbFN0YXRlLnJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlIHx8IGRlcml2YXRpb24ucmVxdWlyZXNPYnNlcnZhYmxlXykge1xuICAgIGNvbnNvbGUud2FybihcIlttb2J4XSBEZXJpdmF0aW9uIFwiICsgZGVyaXZhdGlvbi5uYW1lXyArIFwiIGlzIGNyZWF0ZWQvdXBkYXRlZCB3aXRob3V0IHJlYWRpbmcgYW55IG9ic2VydmFibGUgdmFsdWVcIik7XG4gIH1cbn1cbi8qKlxyXG4gKiBkaWZmcyBuZXdPYnNlcnZpbmcgd2l0aCBvYnNlcnZpbmcuXHJcbiAqIHVwZGF0ZSBvYnNlcnZpbmcgdG8gYmUgbmV3T2JzZXJ2aW5nIHdpdGggdW5pcXVlIG9ic2VydmFibGVzXHJcbiAqIG5vdGlmeSBvYnNlcnZlcnMgdGhhdCBiZWNvbWUgb2JzZXJ2ZWQvdW5vYnNlcnZlZFxyXG4gKi9cblxuXG5mdW5jdGlvbiBiaW5kRGVwZW5kZW5jaWVzKGRlcml2YXRpb24pIHtcbiAgLy8gaW52YXJpYW50KGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGUgIT09IElEZXJpdmF0aW9uU3RhdGUuTk9UX1RSQUNLSU5HLCBcIklOVEVSTkFMIEVSUk9SIGJpbmREZXBlbmRlbmNpZXMgZXhwZWN0cyBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlICE9PSAtMVwiKTtcbiAgdmFyIHByZXZPYnNlcnZpbmcgPSBkZXJpdmF0aW9uLm9ic2VydmluZ187XG4gIHZhciBvYnNlcnZpbmcgPSBkZXJpdmF0aW9uLm9ic2VydmluZ18gPSBkZXJpdmF0aW9uLm5ld09ic2VydmluZ187XG4gIHZhciBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUgPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXzsgLy8gR28gdGhyb3VnaCBhbGwgbmV3IG9ic2VydmFibGVzIGFuZCBjaGVjayBkaWZmVmFsdWU6ICh0aGlzIGxpc3QgY2FuIGNvbnRhaW4gZHVwbGljYXRlcyk6XG4gIC8vICAgMDogZmlyc3Qgb2NjdXJyZW5jZSwgY2hhbmdlIHRvIDEgYW5kIGtlZXAgaXRcbiAgLy8gICAxOiBleHRyYSBvY2N1cnJlbmNlLCBkcm9wIGl0XG5cbiAgdmFyIGkwID0gMCxcbiAgICAgIGwgPSBkZXJpdmF0aW9uLnVuYm91bmREZXBzQ291bnRfO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGRlcCA9IG9ic2VydmluZ1tpXTtcblxuICAgIGlmIChkZXAuZGlmZlZhbHVlXyA9PT0gMCkge1xuICAgICAgZGVwLmRpZmZWYWx1ZV8gPSAxO1xuICAgICAgaWYgKGkwICE9PSBpKSBvYnNlcnZpbmdbaTBdID0gZGVwO1xuICAgICAgaTArKztcbiAgICB9IC8vIFVwY2FzdCBpcyAnc2FmZScgaGVyZSwgYmVjYXVzZSBpZiBkZXAgaXMgSU9ic2VydmFibGUsIGBkZXBlbmRlbmNpZXNTdGF0ZWAgd2lsbCBiZSB1bmRlZmluZWQsXG4gICAgLy8gbm90IGhpdHRpbmcgdGhlIGNvbmRpdGlvblxuXG5cbiAgICBpZiAoZGVwLmRlcGVuZGVuY2llc1N0YXRlXyA+IGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSkge1xuICAgICAgbG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlID0gZGVwLmRlcGVuZGVuY2llc1N0YXRlXztcbiAgICB9XG4gIH1cblxuICBvYnNlcnZpbmcubGVuZ3RoID0gaTA7XG4gIGRlcml2YXRpb24ubmV3T2JzZXJ2aW5nXyA9IG51bGw7IC8vIG5ld09ic2VydmluZyBzaG91bGRuJ3QgYmUgbmVlZGVkIG91dHNpZGUgdHJhY2tpbmcgKHN0YXRlbWVudCBtb3ZlZCBkb3duIHRvIHdvcmsgYXJvdW5kIEZGIGJ1Zywgc2VlICM2MTQpXG4gIC8vIEdvIHRocm91Z2ggYWxsIG9sZCBvYnNlcnZhYmxlcyBhbmQgY2hlY2sgZGlmZlZhbHVlOiAoaXQgaXMgdW5pcXVlIGFmdGVyIGxhc3QgYmluZERlcGVuZGVuY2llcylcbiAgLy8gICAwOiBpdCdzIG5vdCBpbiBuZXcgb2JzZXJ2YWJsZXMsIHVub2JzZXJ2ZSBpdFxuICAvLyAgIDE6IGl0IGtlZXBzIGJlaW5nIG9ic2VydmVkLCBkb24ndCB3YW50IHRvIG5vdGlmeSBpdC4gY2hhbmdlIHRvIDBcblxuICBsID0gcHJldk9ic2VydmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKGwtLSkge1xuICAgIHZhciBfZGVwID0gcHJldk9ic2VydmluZ1tsXTtcblxuICAgIGlmIChfZGVwLmRpZmZWYWx1ZV8gPT09IDApIHtcbiAgICAgIHJlbW92ZU9ic2VydmVyKF9kZXAsIGRlcml2YXRpb24pO1xuICAgIH1cblxuICAgIF9kZXAuZGlmZlZhbHVlXyA9IDA7XG4gIH0gLy8gR28gdGhyb3VnaCBhbGwgbmV3IG9ic2VydmFibGVzIGFuZCBjaGVjayBkaWZmVmFsdWU6IChub3cgaXQgc2hvdWxkIGJlIHVuaXF1ZSlcbiAgLy8gICAwOiBpdCB3YXMgc2V0IHRvIDAgaW4gbGFzdCBsb29wLiBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAvLyAgIDE6IGl0IHdhc24ndCBvYnNlcnZlZCwgbGV0J3Mgb2JzZXJ2ZSBpdC4gc2V0IGJhY2sgdG8gMFxuXG5cbiAgd2hpbGUgKGkwLS0pIHtcbiAgICB2YXIgX2RlcDIgPSBvYnNlcnZpbmdbaTBdO1xuXG4gICAgaWYgKF9kZXAyLmRpZmZWYWx1ZV8gPT09IDEpIHtcbiAgICAgIF9kZXAyLmRpZmZWYWx1ZV8gPSAwO1xuICAgICAgYWRkT2JzZXJ2ZXIoX2RlcDIsIGRlcml2YXRpb24pO1xuICAgIH1cbiAgfSAvLyBTb21lIG5ldyBvYnNlcnZlZCBkZXJpdmF0aW9ucyBtYXkgYmVjb21lIHN0YWxlIGR1cmluZyB0aGlzIGRlcml2YXRpb24gY29tcHV0YXRpb25cbiAgLy8gc28gdGhleSBoYXZlIGhhZCBubyBjaGFuY2UgdG8gcHJvcGFnYXRlIHN0YWxlbmVzcyAoIzkxNilcblxuXG4gIGlmIChsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUgIT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSB7XG4gICAgZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGU7XG4gICAgZGVyaXZhdGlvbi5vbkJlY29tZVN0YWxlXygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFyT2JzZXJ2aW5nKGRlcml2YXRpb24pIHtcbiAgLy8gaW52YXJpYW50KGdsb2JhbFN0YXRlLmluQmF0Y2ggPiAwLCBcIklOVEVSTkFMIEVSUk9SIGNsZWFyT2JzZXJ2aW5nIHNob3VsZCBiZSBjYWxsZWQgb25seSBpbnNpZGUgYmF0Y2hcIik7XG4gIHZhciBvYnMgPSBkZXJpdmF0aW9uLm9ic2VydmluZ187XG4gIGRlcml2YXRpb24ub2JzZXJ2aW5nXyA9IFtdO1xuICB2YXIgaSA9IG9icy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHJlbW92ZU9ic2VydmVyKG9ic1tpXSwgZGVyaXZhdGlvbik7XG4gIH1cblxuICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG59XG5cbmZ1bmN0aW9uIHVudHJhY2tlZChhY3Rpb24pIHtcbiAgdmFyIHByZXYgPSB1bnRyYWNrZWRTdGFydCgpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGFjdGlvbigpO1xuICB9IGZpbmFsbHkge1xuICAgIHVudHJhY2tlZEVuZChwcmV2KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnRyYWNrZWRTdGFydCgpIHtcbiAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IG51bGw7XG4gIHJldHVybiBwcmV2O1xufVxuXG5mdW5jdGlvbiB1bnRyYWNrZWRFbmQocHJldikge1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBwcmV2O1xufVxuXG5mdW5jdGlvbiBhbGxvd1N0YXRlUmVhZHNTdGFydChhbGxvd1N0YXRlUmVhZHMpIHtcbiAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHM7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyA9IGFsbG93U3RhdGVSZWFkcztcbiAgcmV0dXJuIHByZXY7XG59XG5cbmZ1bmN0aW9uIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2KSB7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyA9IHByZXY7XG59XG4vKipcclxuICogbmVlZGVkIHRvIGtlZXAgYGxvd2VzdE9ic2VydmVyU3RhdGVgIGNvcnJlY3QuIHdoZW4gY2hhbmdpbmcgZnJvbSAoMiBvciAxKSB0byAwXHJcbiAqXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNoYW5nZURlcGVuZGVuY2llc1N0YXRlVG8wKGRlcml2YXRpb24pIHtcbiAgaWYgKGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXykgcmV0dXJuO1xuICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfO1xuICB2YXIgb2JzID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfO1xuICB2YXIgaSA9IG9icy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIG9ic1tpXS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfO1xuICB9XG59XG4vKipcclxuICogVGhlc2UgdmFsdWVzIHdpbGwgcGVyc2lzdCBpZiBnbG9iYWwgc3RhdGUgaXMgcmVzZXRcclxuICovXG5cblxudmFyIHBlcnNpc3RlbnRLZXlzID0gW1wibW9ieEd1aWRcIiwgXCJzcHlMaXN0ZW5lcnNcIiwgXCJlbmZvcmNlQWN0aW9uc1wiLCBcImNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvblwiLCBcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsIFwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25cIiwgXCJhbGxvd1N0YXRlUmVhZHNcIiwgXCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzXCIsIFwicnVuSWRcIiwgXCJVTkNIQU5HRURcIiwgXCJ1c2VQcm94aWVzXCJdO1xuXG52YXIgTW9iWEdsb2JhbHMgPSBmdW5jdGlvbiBNb2JYR2xvYmFscygpIHtcbiAgdGhpcy52ZXJzaW9uID0gNjtcbiAgdGhpcy5VTkNIQU5HRUQgPSB7fTtcbiAgdGhpcy50cmFja2luZ0Rlcml2YXRpb24gPSBudWxsO1xuICB0aGlzLnRyYWNraW5nQ29udGV4dCA9IG51bGw7XG4gIHRoaXMucnVuSWQgPSAwO1xuICB0aGlzLm1vYnhHdWlkID0gMDtcbiAgdGhpcy5pbkJhdGNoID0gMDtcbiAgdGhpcy5wZW5kaW5nVW5vYnNlcnZhdGlvbnMgPSBbXTtcbiAgdGhpcy5wZW5kaW5nUmVhY3Rpb25zID0gW107XG4gIHRoaXMuaXNSdW5uaW5nUmVhY3Rpb25zID0gZmFsc2U7XG4gIHRoaXMuYWxsb3dTdGF0ZUNoYW5nZXMgPSBmYWxzZTtcbiAgdGhpcy5hbGxvd1N0YXRlUmVhZHMgPSB0cnVlO1xuICB0aGlzLmVuZm9yY2VBY3Rpb25zID0gdHJ1ZTtcbiAgdGhpcy5zcHlMaXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMgPSBbXTtcbiAgdGhpcy5jb21wdXRlZFJlcXVpcmVzUmVhY3Rpb24gPSBmYWxzZTtcbiAgdGhpcy5yZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZSA9IGZhbHNlO1xuICB0aGlzLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uID0gZmFsc2U7XG4gIHRoaXMuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9IGZhbHNlO1xuICB0aGlzLnN1cHByZXNzUmVhY3Rpb25FcnJvcnMgPSBmYWxzZTtcbiAgdGhpcy51c2VQcm94aWVzID0gdHJ1ZTtcbiAgdGhpcy52ZXJpZnlQcm94aWVzID0gZmFsc2U7XG4gIHRoaXMuc2FmZURlc2NyaXB0b3JzID0gdHJ1ZTtcbn07XG5cbnZhciBjYW5NZXJnZUdsb2JhbFN0YXRlID0gdHJ1ZTtcbnZhciBpc29sYXRlQ2FsbGVkID0gZmFsc2U7XG5cbnZhciBnbG9iYWxTdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBnbG9iYWwgPSAvKiNfX1BVUkVfXyovZ2V0R2xvYmFsKCk7XG4gIGlmIChnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCA+IDAgJiYgIWdsb2JhbC5fX21vYnhHbG9iYWxzKSBjYW5NZXJnZUdsb2JhbFN0YXRlID0gZmFsc2U7XG4gIGlmIChnbG9iYWwuX19tb2J4R2xvYmFscyAmJiBnbG9iYWwuX19tb2J4R2xvYmFscy52ZXJzaW9uICE9PSBuZXcgTW9iWEdsb2JhbHMoKS52ZXJzaW9uKSBjYW5NZXJnZUdsb2JhbFN0YXRlID0gZmFsc2U7XG5cbiAgaWYgKCFjYW5NZXJnZUdsb2JhbFN0YXRlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWlzb2xhdGVDYWxsZWQpIHtcbiAgICAgICAgZGllKDM1KTtcbiAgICAgIH1cbiAgICB9LCAxKTtcbiAgICByZXR1cm4gbmV3IE1vYlhHbG9iYWxzKCk7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLl9fbW9ieEdsb2JhbHMpIHtcbiAgICBnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCArPSAxO1xuICAgIGlmICghZ2xvYmFsLl9fbW9ieEdsb2JhbHMuVU5DSEFOR0VEKSBnbG9iYWwuX19tb2J4R2xvYmFscy5VTkNIQU5HRUQgPSB7fTsgLy8gbWFrZSBtZXJnZSBiYWNrd2FyZCBjb21wYXRpYmxlXG5cbiAgICByZXR1cm4gZ2xvYmFsLl9fbW9ieEdsb2JhbHM7XG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsLl9fbW9ieEluc3RhbmNlQ291bnQgPSAxO1xuICAgIHJldHVybiBnbG9iYWwuX19tb2J4R2xvYmFscyA9IC8qI19fUFVSRV9fKi9uZXcgTW9iWEdsb2JhbHMoKTtcbiAgfVxufSgpO1xuXG5mdW5jdGlvbiBpc29sYXRlR2xvYmFsU3RhdGUoKSB7XG4gIGlmIChnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zLmxlbmd0aCB8fCBnbG9iYWxTdGF0ZS5pbkJhdGNoIHx8IGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucykgZGllKDM2KTtcbiAgaXNvbGF0ZUNhbGxlZCA9IHRydWU7XG5cbiAgaWYgKGNhbk1lcmdlR2xvYmFsU3RhdGUpIHtcbiAgICB2YXIgZ2xvYmFsID0gZ2V0R2xvYmFsKCk7XG4gICAgaWYgKC0tZ2xvYmFsLl9fbW9ieEluc3RhbmNlQ291bnQgPT09IDApIGdsb2JhbC5fX21vYnhHbG9iYWxzID0gdW5kZWZpbmVkO1xuICAgIGdsb2JhbFN0YXRlID0gbmV3IE1vYlhHbG9iYWxzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0R2xvYmFsU3RhdGUoKSB7XG4gIHJldHVybiBnbG9iYWxTdGF0ZTtcbn1cbi8qKlxyXG4gKiBGb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5OyB0aGlzIHdpbGwgYnJlYWsgdGhlIGludGVybmFsIHN0YXRlIG9mIGV4aXN0aW5nIG9ic2VydmFibGVzLFxyXG4gKiBidXQgY2FuIGJlIHVzZWQgdG8gZ2V0IGJhY2sgYXQgYSBzdGFibGUgc3RhdGUgYWZ0ZXIgdGhyb3dpbmcgZXJyb3JzXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHJlc2V0R2xvYmFsU3RhdGUoKSB7XG4gIHZhciBkZWZhdWx0R2xvYmFscyA9IG5ldyBNb2JYR2xvYmFscygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0R2xvYmFscykge1xuICAgIGlmIChwZXJzaXN0ZW50S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSBnbG9iYWxTdGF0ZVtrZXldID0gZGVmYXVsdEdsb2JhbHNba2V5XTtcbiAgfVxuXG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gIWdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBoYXNPYnNlcnZlcnMob2JzZXJ2YWJsZSkge1xuICByZXR1cm4gb2JzZXJ2YWJsZS5vYnNlcnZlcnNfICYmIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5zaXplID4gMDtcbn1cblxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJzKG9ic2VydmFibGUpIHtcbiAgcmV0dXJuIG9ic2VydmFibGUub2JzZXJ2ZXJzXztcbn0gLy8gZnVuY3Rpb24gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGU6IElPYnNlcnZhYmxlKSB7XG4vLyAgICAgY29uc3QgbGlzdCA9IG9ic2VydmFibGUub2JzZXJ2ZXJzXG4vLyAgICAgY29uc3QgbWFwID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnNJbmRleGVzXG4vLyAgICAgY29uc3QgbCA9IGxpc3QubGVuZ3RoXG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbi8vICAgICAgICAgY29uc3QgaWQgPSBsaXN0W2ldLl9fbWFwaWRcbi8vICAgICAgICAgaWYgKGkpIHtcbi8vICAgICAgICAgICAgIGludmFyaWFudChtYXBbaWRdID09PSBpLCBcIklOVEVSTkFMIEVSUk9SIG1hcHMgZGVyaXZhdGlvbi5fX21hcGlkIHRvIGluZGV4IGluIGxpc3RcIikgLy8gZm9yIHBlcmZvcm1hbmNlXG4vLyAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgICBpbnZhcmlhbnQoIShpZCBpbiBtYXApLCBcIklOVEVSTkFMIEVSUk9SIG9ic2VydmVyIG9uIGluZGV4IDAgc2hvdWxkbid0IGJlIGhlbGQgaW4gbWFwLlwiKSAvLyBmb3IgcGVyZm9ybWFuY2Vcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vICAgICBpbnZhcmlhbnQoXG4vLyAgICAgICAgIGxpc3QubGVuZ3RoID09PSAwIHx8IE9iamVjdC5rZXlzKG1hcCkubGVuZ3RoID09PSBsaXN0Lmxlbmd0aCAtIDEsXG4vLyAgICAgICAgIFwiSU5URVJOQUwgRVJST1IgdGhlcmUgaXMgbm8ganVuayBpbiBtYXBcIlxuLy8gICAgIClcbi8vIH1cblxuXG5mdW5jdGlvbiBhZGRPYnNlcnZlcihvYnNlcnZhYmxlLCBub2RlKSB7XG4gIC8vIGludmFyaWFudChub2RlLmRlcGVuZGVuY2llc1N0YXRlICE9PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiwgY2FuIGFkZCBvbmx5IGRlcGVuZGVuY2llc1N0YXRlICE9PSAtMVwiKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpID09PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiBhZGQgYWxyZWFkeSBhZGRlZCBub2RlXCIpO1xuICAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5hZGQobm9kZSk7XG4gIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID4gbm9kZS5kZXBlbmRlbmNpZXNTdGF0ZV8pIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBub2RlLmRlcGVuZGVuY2llc1N0YXRlXzsgLy8gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGUpO1xuICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgIT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIGRpZG4ndCBhZGQgbm9kZVwiKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2YWJsZSwgbm9kZSkge1xuICAvLyBpbnZhcmlhbnQoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAsIFwiSU5URVJOQUwgRVJST1IsIHJlbW92ZSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgaW5zaWRlIGJhdGNoXCIpO1xuICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgIT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIHJlbW92ZSBhbHJlYWR5IHJlbW92ZWQgbm9kZVwiKTtcbiAgLy8gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGUpO1xuICBvYnNlcnZhYmxlLm9ic2VydmVyc19bXCJkZWxldGVcIl0obm9kZSk7XG5cbiAgaWYgKG9ic2VydmFibGUub2JzZXJ2ZXJzXy5zaXplID09PSAwKSB7XG4gICAgLy8gZGVsZXRpbmcgbGFzdCBvYnNlcnZlclxuICAgIHF1ZXVlRm9yVW5vYnNlcnZhdGlvbihvYnNlcnZhYmxlKTtcbiAgfSAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSA9PT0gLTEsIFwiSU5URVJOQUwgRVJST1IgcmVtb3ZlIGFscmVhZHkgcmVtb3ZlZCBub2RlMlwiKTtcblxufVxuXG5mdW5jdGlvbiBxdWV1ZUZvclVub2JzZXJ2YXRpb24ob2JzZXJ2YWJsZSkge1xuICBpZiAob2JzZXJ2YWJsZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uXyA9PT0gZmFsc2UpIHtcbiAgICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCwgXCJJTlRFUk5BTCBFUlJPUiwgc2hvdWxkIG9ubHkgcXVldWUgZm9yIHVub2JzZXJ2YXRpb24gdW5vYnNlcnZlZCBvYnNlcnZhYmxlc1wiKTtcbiAgICBvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb25fID0gdHJ1ZTtcbiAgICBnbG9iYWxTdGF0ZS5wZW5kaW5nVW5vYnNlcnZhdGlvbnMucHVzaChvYnNlcnZhYmxlKTtcbiAgfVxufVxuLyoqXHJcbiAqIEJhdGNoIHN0YXJ0cyBhIHRyYW5zYWN0aW9uLCBhdCBsZWFzdCBmb3IgcHVycG9zZXMgb2YgbWVtb2l6aW5nIENvbXB1dGVkVmFsdWVzIHdoZW4gbm90aGluZyBlbHNlIGRvZXMuXHJcbiAqIER1cmluZyBhIGJhdGNoIGBvbkJlY29tZVVub2JzZXJ2ZWRgIHdpbGwgYmUgY2FsbGVkIGF0IG1vc3Qgb25jZSBwZXIgb2JzZXJ2YWJsZS5cclxuICogQXZvaWRzIHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25zLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICBnbG9iYWxTdGF0ZS5pbkJhdGNoKys7XG59XG5cbmZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICBpZiAoLS1nbG9iYWxTdGF0ZS5pbkJhdGNoID09PSAwKSB7XG4gICAgcnVuUmVhY3Rpb25zKCk7IC8vIHRoZSBiYXRjaCBpcyBhY3R1YWxseSBhYm91dCB0byBmaW5pc2gsIGFsbCB1bm9ic2VydmluZyBzaG91bGQgaGFwcGVuIGhlcmUuXG5cbiAgICB2YXIgbGlzdCA9IGdsb2JhbFN0YXRlLnBlbmRpbmdVbm9ic2VydmF0aW9ucztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBsaXN0W2ldO1xuICAgICAgb2JzZXJ2YWJsZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uXyA9IGZhbHNlO1xuXG4gICAgICBpZiAob2JzZXJ2YWJsZS5vYnNlcnZlcnNfLnNpemUgPT09IDApIHtcbiAgICAgICAgaWYgKG9ic2VydmFibGUuaXNCZWluZ09ic2VydmVkXykge1xuICAgICAgICAgIC8vIGlmIHRoaXMgb2JzZXJ2YWJsZSBoYWQgcmVhY3RpdmUgb2JzZXJ2ZXJzLCB0cmlnZ2VyIHRoZSBob29rc1xuICAgICAgICAgIG9ic2VydmFibGUuaXNCZWluZ09ic2VydmVkXyA9IGZhbHNlO1xuICAgICAgICAgIG9ic2VydmFibGUub25CVU8oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYnNlcnZhYmxlIGluc3RhbmNlb2YgQ29tcHV0ZWRWYWx1ZSkge1xuICAgICAgICAgIC8vIGNvbXB1dGVkIHZhbHVlcyBhcmUgYXV0b21hdGljYWxseSB0ZWFyZWQgZG93biB3aGVuIHRoZSBsYXN0IG9ic2VydmVyIGxlYXZlc1xuICAgICAgICAgIC8vIHRoaXMgcHJvY2VzcyBoYXBwZW5zIHJlY3Vyc2l2ZWx5LCB0aGlzIGNvbXB1dGVkIG1pZ2h0IGJlIHRoZSBsYXN0IG9ic2VydmFiZSBvZiBhbm90aGVyLCBldGMuLlxuICAgICAgICAgIG9ic2VydmFibGUuc3VzcGVuZF8oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGdsb2JhbFN0YXRlLnBlbmRpbmdVbm9ic2VydmF0aW9ucyA9IFtdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcG9ydE9ic2VydmVkKG9ic2VydmFibGUpIHtcbiAgY2hlY2tJZlN0YXRlUmVhZHNBcmVBbGxvd2VkKG9ic2VydmFibGUpO1xuICB2YXIgZGVyaXZhdGlvbiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcblxuICBpZiAoZGVyaXZhdGlvbiAhPT0gbnVsbCkge1xuICAgIC8qKlxyXG4gICAgICogU2ltcGxlIG9wdGltaXphdGlvbiwgZ2l2ZSBlYWNoIGRlcml2YXRpb24gcnVuIGFuIHVuaXF1ZSBpZCAocnVuSWQpXHJcbiAgICAgKiBDaGVjayBpZiBsYXN0IHRpbWUgdGhpcyBvYnNlcnZhYmxlIHdhcyBhY2Nlc3NlZCB0aGUgc2FtZSBydW5JZCBpcyB1c2VkXHJcbiAgICAgKiBpZiB0aGlzIGlzIHRoZSBjYXNlLCB0aGUgcmVsYXRpb24gaXMgYWxyZWFkeSBrbm93blxyXG4gICAgICovXG4gICAgaWYgKGRlcml2YXRpb24ucnVuSWRfICE9PSBvYnNlcnZhYmxlLmxhc3RBY2Nlc3NlZEJ5Xykge1xuICAgICAgb2JzZXJ2YWJsZS5sYXN0QWNjZXNzZWRCeV8gPSBkZXJpdmF0aW9uLnJ1bklkXzsgLy8gVHJpZWQgc3RvcmluZyBuZXdPYnNlcnZpbmcsIG9yIG9ic2VydmluZywgb3IgYm90aCBhcyBTZXQsIGJ1dCBwZXJmb3JtYW5jZSBkaWRuJ3QgY29tZSBjbG9zZS4uLlxuXG4gICAgICBkZXJpdmF0aW9uLm5ld09ic2VydmluZ19bZGVyaXZhdGlvbi51bmJvdW5kRGVwc0NvdW50XysrXSA9IG9ic2VydmFibGU7XG5cbiAgICAgIGlmICghb2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWRfICYmIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCkge1xuICAgICAgICBvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZF8gPSB0cnVlO1xuICAgICAgICBvYnNlcnZhYmxlLm9uQk8oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChvYnNlcnZhYmxlLm9ic2VydmVyc18uc2l6ZSA9PT0gMCAmJiBnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCkge1xuICAgIHF1ZXVlRm9yVW5vYnNlcnZhdGlvbihvYnNlcnZhYmxlKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gZnVuY3Rpb24gaW52YXJpYW50TE9TKG9ic2VydmFibGU6IElPYnNlcnZhYmxlLCBtc2c6IHN0cmluZykge1xuLy8gICAgIC8vIGl0J3MgZXhwZW5zaXZlIHNvIGJldHRlciBub3QgcnVuIGl0IGluIHByb2R1Y2l0b24uIGJ1dCB0ZW1wb3JhcmlseSBoZWxwZnVsIGZvciB0ZXN0aW5nXG4vLyAgICAgY29uc3QgbWluID0gZ2V0T2JzZXJ2ZXJzKG9ic2VydmFibGUpLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5taW4oYSwgYi5kZXBlbmRlbmNpZXNTdGF0ZSksIDIpXG4vLyAgICAgaWYgKG1pbiA+PSBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUpIHJldHVybiAvLyA8LSB0aGUgb25seSBhc3N1bXB0aW9uIGFib3V0IGBsb3dlc3RPYnNlcnZlclN0YXRlYFxuLy8gICAgIHRocm93IG5ldyBFcnJvcihcbi8vICAgICAgICAgXCJsb3dlc3RPYnNlcnZlclN0YXRlIGlzIHdyb25nIGZvciBcIiArXG4vLyAgICAgICAgICAgICBtc2cgK1xuLy8gICAgICAgICAgICAgXCIgYmVjYXVzZSBcIiArXG4vLyAgICAgICAgICAgICBtaW4gK1xuLy8gICAgICAgICAgICAgXCIgPCBcIiArXG4vLyAgICAgICAgICAgICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVcbi8vICAgICApXG4vLyB9XG5cbi8qKlxyXG4gKiBOT1RFOiBjdXJyZW50IHByb3BhZ2F0aW9uIG1lY2hhbmlzbSB3aWxsIGluIGNhc2Ugb2Ygc2VsZiByZXJ1bmluZyBhdXRvcnVucyBiZWhhdmUgdW5leHBlY3RlZGx5XHJcbiAqIEl0IHdpbGwgcHJvcGFnYXRlIGNoYW5nZXMgdG8gb2JzZXJ2ZXJzIGZyb20gcHJldmlvdXMgcnVuXHJcbiAqIEl0J3MgaGFyZCBvciBtYXliZSBpbXBvc3NpYmxlICh3aXRoIHJlYXNvbmFibGUgcGVyZikgdG8gZ2V0IGl0IHJpZ2h0IHdpdGggY3VycmVudCBhcHByb2FjaFxyXG4gKiBIb3BlZnVsbHkgc2VsZiByZXJ1bmluZyBhdXRvcnVucyBhcmVuJ3QgYSBmZWF0dXJlIHBlb3BsZSBzaG91bGQgZGVwZW5kIG9uXHJcbiAqIEFsc28gbW9zdCBiYXNpYyB1c2UgY2FzZXMgc2hvdWxkIGJlIG9rXHJcbiAqL1xuLy8gQ2FsbGVkIGJ5IEF0b20gd2hlbiBpdHMgdmFsdWUgY2hhbmdlc1xuXG5cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNoYW5nZWQob2JzZXJ2YWJsZSkge1xuICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJjaGFuZ2VkIHN0YXJ0XCIpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfKSByZXR1cm47XG4gIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV87IC8vIElkZWFsbHkgd2UgdXNlIGZvci4ub2YgaGVyZSwgYnV0IHRoZSBkb3duY29tcGlsZWQgdmVyc2lvbiBpcyByZWFsbHkgc2xvdy4uLlxuXG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGQuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBkLmlzVHJhY2luZ18gIT09IFRyYWNlTW9kZS5OT05FKSB7XG4gICAgICAgIGxvZ1RyYWNlSW5mbyhkLCBvYnNlcnZhYmxlKTtcbiAgICAgIH1cblxuICAgICAgZC5vbkJlY29tZVN0YWxlXygpO1xuICAgIH1cblxuICAgIGQuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfO1xuICB9KTsgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY2hhbmdlZCBlbmRcIik7XG59IC8vIENhbGxlZCBieSBDb21wdXRlZFZhbHVlIHdoZW4gaXQgcmVjYWxjdWxhdGUgYW5kIGl0cyB2YWx1ZSBjaGFuZ2VkXG5cblxuZnVuY3Rpb24gcHJvcGFnYXRlQ2hhbmdlQ29uZmlybWVkKG9ic2VydmFibGUpIHtcbiAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY29uZmlybWVkIHN0YXJ0XCIpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfKSByZXR1cm47XG4gIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV87XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGQuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5QT1NTSUJMWV9TVEFMRV8pIGQuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfO2Vsc2UgaWYgKGQuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXyAvLyB0aGlzIGhhcHBlbnMgZHVyaW5nIGNvbXB1dGluZyBvZiBgZGAsIGp1c3Qga2VlcCBsb3dlc3RPYnNlcnZlclN0YXRlIHVwIHRvIGRhdGUuXG4gICAgKSBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gIH0pOyAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJjb25maXJtZWQgZW5kXCIpO1xufSAvLyBVc2VkIGJ5IGNvbXB1dGVkIHdoZW4gaXRzIGRlcGVuZGVuY3kgY2hhbmdlZCwgYnV0IHdlIGRvbid0IHdhbid0IHRvIGltbWVkaWF0ZWx5IHJlY29tcHV0ZS5cblxuXG5mdW5jdGlvbiBwcm9wYWdhdGVNYXliZUNoYW5nZWQob2JzZXJ2YWJsZSkge1xuICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJtYXliZSBzdGFydFwiKTtcbiAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gIT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSByZXR1cm47XG4gIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5QT1NTSUJMWV9TVEFMRV87XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGQuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXykge1xuICAgICAgZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5QT1NTSUJMWV9TVEFMRV87XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZC5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBsb2dUcmFjZUluZm8oZCwgb2JzZXJ2YWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGQub25CZWNvbWVTdGFsZV8oKTtcbiAgICB9XG4gIH0pOyAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJtYXliZSBlbmRcIik7XG59XG5cbmZ1bmN0aW9uIGxvZ1RyYWNlSW5mbyhkZXJpdmF0aW9uLCBvYnNlcnZhYmxlKSB7XG4gIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIicgaXMgaW52YWxpZGF0ZWQgZHVlIHRvIGEgY2hhbmdlIGluOiAnXCIgKyBvYnNlcnZhYmxlLm5hbWVfICsgXCInXCIpO1xuXG4gIGlmIChkZXJpdmF0aW9uLmlzVHJhY2luZ18gPT09IFRyYWNlTW9kZS5CUkVBSykge1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHByaW50RGVwVHJlZShnZXREZXBlbmRlbmN5VHJlZShkZXJpdmF0aW9uKSwgbGluZXMsIDEpOyAvLyBwcmV0dGllci1pZ25vcmVcblxuICAgIG5ldyBGdW5jdGlvbihcImRlYnVnZ2VyO1xcbi8qXFxuVHJhY2luZyAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInXFxuXFxuWW91IGFyZSBlbnRlcmluZyB0aGlzIGJyZWFrIHBvaW50IGJlY2F1c2UgZGVyaXZhdGlvbiAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIGlzIGJlaW5nIHRyYWNlZCBhbmQgJ1wiICsgb2JzZXJ2YWJsZS5uYW1lXyArIFwiJyBpcyBub3cgZm9yY2luZyBpdCB0byB1cGRhdGUuXFxuSnVzdCBmb2xsb3cgdGhlIHN0YWNrdHJhY2UgeW91IHNob3VsZCBub3cgc2VlIGluIHRoZSBkZXZ0b29scyB0byBzZWUgcHJlY2lzZWx5IHdoYXQgcGllY2Ugb2YgeW91ciBjb2RlIGlzIGNhdXNpbmcgdGhpcyB1cGRhdGVcXG5UaGUgc3RhY2tmcmFtZSB5b3UgYXJlIGxvb2tpbmcgZm9yIGlzIGF0IGxlYXN0IH42LTggc3RhY2stZnJhbWVzIHVwLlxcblxcblwiICsgKGRlcml2YXRpb24gaW5zdGFuY2VvZiBDb21wdXRlZFZhbHVlID8gZGVyaXZhdGlvbi5kZXJpdmF0aW9uLnRvU3RyaW5nKCkucmVwbGFjZSgvWypdXFwvL2csIFwiL1wiKSA6IFwiXCIpICsgXCJcXG5cXG5UaGUgZGVwZW5kZW5jaWVzIGZvciB0aGlzIGRlcml2YXRpb24gYXJlOlxcblxcblwiICsgbGluZXMuam9pbihcIlxcblwiKSArIFwiXFxuKi9cXG4gICAgXCIpKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnREZXBUcmVlKHRyZWUsIGxpbmVzLCBkZXB0aCkge1xuICBpZiAobGluZXMubGVuZ3RoID49IDEwMDApIHtcbiAgICBsaW5lcy5wdXNoKFwiKGFuZCBtYW55IG1vcmUpXCIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxpbmVzLnB1c2goXCJcIiArIG5ldyBBcnJheShkZXB0aCkuam9pbihcIlxcdFwiKSArIHRyZWUubmFtZSk7IC8vIE1XRTogbm90IHRoZSBmYXN0ZXN0LCBidXQgdGhlIGVhc2llc3Qgd2F5IDopXG5cbiAgaWYgKHRyZWUuZGVwZW5kZW5jaWVzKSB0cmVlLmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBwcmludERlcFRyZWUoY2hpbGQsIGxpbmVzLCBkZXB0aCArIDEpO1xuICB9KTtcbn1cblxudmFyIFJlYWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gbm9kZXMgd2UgYXJlIGxvb2tpbmcgYXQuIE91ciB2YWx1ZSBkZXBlbmRzIG9uIHRoZXNlIG5vZGVzXG4gIGZ1bmN0aW9uIFJlYWN0aW9uKG5hbWVfLCBvbkludmFsaWRhdGVfLCBlcnJvckhhbmRsZXJfLCByZXF1aXJlc09ic2VydmFibGVfKSB7XG4gICAgaWYgKG5hbWVfID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWVfID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJSZWFjdGlvbkBcIiArIGdldE5leHRJZCgpIDogXCJSZWFjdGlvblwiO1xuICAgIH1cblxuICAgIGlmIChyZXF1aXJlc09ic2VydmFibGVfID09PSB2b2lkIDApIHtcbiAgICAgIHJlcXVpcmVzT2JzZXJ2YWJsZV8gPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXMub25JbnZhbGlkYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ySGFuZGxlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1aXJlc09ic2VydmFibGVfID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2aW5nXyA9IFtdO1xuICAgIHRoaXMubmV3T2JzZXJ2aW5nXyA9IFtdO1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB0aGlzLmRpZmZWYWx1ZV8gPSAwO1xuICAgIHRoaXMucnVuSWRfID0gMDtcbiAgICB0aGlzLnVuYm91bmREZXBzQ291bnRfID0gMDtcbiAgICB0aGlzLmlzRGlzcG9zZWRfID0gZmFsc2U7XG4gICAgdGhpcy5pc1NjaGVkdWxlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmlzVHJhY2tQZW5kaW5nXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNSdW5uaW5nXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNUcmFjaW5nXyA9IFRyYWNlTW9kZS5OT05FO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgICB0aGlzLm9uSW52YWxpZGF0ZV8gPSBvbkludmFsaWRhdGVfO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyXyA9IGVycm9ySGFuZGxlcl87XG4gICAgdGhpcy5yZXF1aXJlc09ic2VydmFibGVfID0gcmVxdWlyZXNPYnNlcnZhYmxlXztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSZWFjdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9uQmVjb21lU3RhbGVfID0gZnVuY3Rpb24gb25CZWNvbWVTdGFsZV8oKSB7XG4gICAgdGhpcy5zY2hlZHVsZV8oKTtcbiAgfTtcblxuICBfcHJvdG8uc2NoZWR1bGVfID0gZnVuY3Rpb24gc2NoZWR1bGVfKCkge1xuICAgIGlmICghdGhpcy5pc1NjaGVkdWxlZF8pIHtcbiAgICAgIHRoaXMuaXNTY2hlZHVsZWRfID0gdHJ1ZTtcbiAgICAgIGdsb2JhbFN0YXRlLnBlbmRpbmdSZWFjdGlvbnMucHVzaCh0aGlzKTtcbiAgICAgIHJ1blJlYWN0aW9ucygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaXNTY2hlZHVsZWQgPSBmdW5jdGlvbiBpc1NjaGVkdWxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NjaGVkdWxlZF87XG4gIH1cbiAgLyoqXHJcbiAgICogaW50ZXJuYWwsIHVzZSBzY2hlZHVsZSgpIGlmIHlvdSBpbnRlbmQgdG8ga2ljayBvZmYgYSByZWFjdGlvblxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJ1blJlYWN0aW9uXyA9IGZ1bmN0aW9uIHJ1blJlYWN0aW9uXygpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZF8pIHtcbiAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgIHRoaXMuaXNTY2hlZHVsZWRfID0gZmFsc2U7XG4gICAgICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dDtcbiAgICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHRoaXM7XG5cbiAgICAgIGlmIChzaG91bGRDb21wdXRlKHRoaXMpKSB7XG4gICAgICAgIHRoaXMuaXNUcmFja1BlbmRpbmdfID0gdHJ1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMub25JbnZhbGlkYXRlXygpO1xuXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmlzVHJhY2tQZW5kaW5nXyAmJiBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgLy8gb25JbnZhbGlkYXRlIGRpZG4ndCB0cmlnZ2VyIHRyYWNrIHJpZ2h0IGF3YXkuLlxuICAgICAgICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgICAgICAgdHlwZTogXCJzY2hlZHVsZWQtcmVhY3Rpb25cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5yZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHByZXY7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udHJhY2sgPSBmdW5jdGlvbiB0cmFjayhmbikge1xuICAgIGlmICh0aGlzLmlzRGlzcG9zZWRfKSB7XG4gICAgICByZXR1cm47IC8vIGNvbnNvbGUud2FybihcIlJlYWN0aW9uIGFscmVhZHkgZGlzcG9zZWRcIikgLy8gTm90ZTogTm90IGEgd2FybmluZyAvIGVycm9yIGluIG1vYnggNCBlaXRoZXJcbiAgICB9XG5cbiAgICBzdGFydEJhdGNoKCk7XG4gICAgdmFyIG5vdGlmeSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBzdGFydFRpbWU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeSkge1xuICAgICAgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIHNweVJlcG9ydFN0YXJ0KHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogXCJyZWFjdGlvblwiXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUnVubmluZ18gPSB0cnVlO1xuICAgIHZhciBwcmV2UmVhY3Rpb24gPSBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQ7IC8vIHJlYWN0aW9ucyBjb3VsZCBjcmVhdGUgcmVhY3Rpb25zLi4uXG5cbiAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSB0cmFja0Rlcml2ZWRGdW5jdGlvbih0aGlzLCBmbiwgdW5kZWZpbmVkKTtcbiAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSBwcmV2UmVhY3Rpb247XG4gICAgdGhpcy5pc1J1bm5pbmdfID0gZmFsc2U7XG4gICAgdGhpcy5pc1RyYWNrUGVuZGluZ18gPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmlzRGlzcG9zZWRfKSB7XG4gICAgICAvLyBkaXNwb3NlZCBkdXJpbmcgbGFzdCBydW4uIENsZWFuIHVwIGV2ZXJ5dGhpbmcgdGhhdCB3YXMgYm91bmQgYWZ0ZXIgdGhlIGRpc3Bvc2UgY2FsbC5cbiAgICAgIGNsZWFyT2JzZXJ2aW5nKHRoaXMpO1xuICAgIH1cblxuICAgIGlmIChpc0NhdWdodEV4Y2VwdGlvbihyZXN1bHQpKSB0aGlzLnJlcG9ydEV4Y2VwdGlvbkluRGVyaXZhdGlvbl8ocmVzdWx0LmNhdXNlKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5KSB7XG4gICAgICBzcHlSZXBvcnRFbmQoe1xuICAgICAgICB0aW1lOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBlbmRCYXRjaCgpO1xuICB9O1xuXG4gIF9wcm90by5yZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fID0gZnVuY3Rpb24gcmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uXyhlcnJvcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5lcnJvckhhbmRsZXJfKSB7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcl8oZXJyb3IsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzKSB0aHJvdyBlcnJvcjtcbiAgICB2YXIgbWVzc2FnZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiW21vYnhdIEVuY291bnRlcmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbiB0aGF0IHdhcyB0aHJvd24gYnkgYSByZWFjdGlvbiBvciBvYnNlcnZlciBjb21wb25lbnQsIGluOiAnXCIgKyB0aGlzICsgXCInXCIgOiBcIlttb2J4XSB1bmNhdWdodCBlcnJvciBpbiAnXCIgKyB0aGlzICsgXCInXCI7XG5cbiAgICBpZiAoIWdsb2JhbFN0YXRlLnN1cHByZXNzUmVhY3Rpb25FcnJvcnMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgZXJyb3IpO1xuICAgICAgLyoqIElmIGRlYnVnZ2luZyBicm91Z2h0IHlvdSBoZXJlLCBwbGVhc2UsIHJlYWQgdGhlIGFib3ZlIG1lc3NhZ2UgOi0pLiBUbnghICovXG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIGNvbnNvbGUud2FybihcIlttb2J4XSAoZXJyb3IgaW4gcmVhY3Rpb24gJ1wiICsgdGhpcy5uYW1lXyArIFwiJyBzdXBwcmVzc2VkLCBmaXggZXJyb3Igb2YgY2F1c2luZyBhY3Rpb24gYmVsb3cpXCIpOyAvLyBwcmV0dGllci1pZ25vcmVcblxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICBuYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBlcnJvcjogXCJcIiArIGVycm9yXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIGYoZXJyb3IsIF90aGlzKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWRfKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWRfID0gdHJ1ZTtcblxuICAgICAgaWYgKCF0aGlzLmlzUnVubmluZ18pIHtcbiAgICAgICAgLy8gaWYgZGlzcG9zZWQgd2hpbGUgcnVubmluZywgY2xlYW4gdXAgbGF0ZXIuIE1heWJlIG5vdCBvcHRpbWFsLCBidXQgcmFyZSBjYXNlXG4gICAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgICAgY2xlYXJPYnNlcnZpbmcodGhpcyk7XG4gICAgICAgIGVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXREaXNwb3Nlcl8gPSBmdW5jdGlvbiBnZXREaXNwb3Nlcl8oKSB7XG4gICAgdmFyIHIgPSB0aGlzLmRpc3Bvc2UuYmluZCh0aGlzKTtcbiAgICByWyRtb2J4XSA9IHRoaXM7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiUmVhY3Rpb25bXCIgKyB0aGlzLm5hbWVfICsgXCJdXCI7XG4gIH07XG5cbiAgX3Byb3RvLnRyYWNlID0gZnVuY3Rpb24gdHJhY2UkMShlbnRlckJyZWFrUG9pbnQpIHtcbiAgICBpZiAoZW50ZXJCcmVha1BvaW50ID09PSB2b2lkIDApIHtcbiAgICAgIGVudGVyQnJlYWtQb2ludCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRyYWNlKHRoaXMsIGVudGVyQnJlYWtQb2ludCk7XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0aW9uO1xufSgpO1xuXG5mdW5jdGlvbiBvblJlYWN0aW9uRXJyb3IoaGFuZGxlcikge1xuICBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgaWYgKGlkeCA+PSAwKSBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gIH07XG59XG4vKipcclxuICogTWFnaWMgbnVtYmVyIGFsZXJ0IVxyXG4gKiBEZWZpbmVzIHdpdGhpbiBob3cgbWFueSB0aW1lcyBhIHJlYWN0aW9uIGlzIGFsbG93ZWQgdG8gcmUtdHJpZ2dlciBpdHNlbGZcclxuICogdW50aWwgaXQgaXMgYXNzdW1lZCB0aGF0IHRoaXMgaXMgZ29ubmEgYmUgYSBuZXZlciBlbmRpbmcgbG9vcC4uLlxyXG4gKi9cblxuXG52YXIgTUFYX1JFQUNUSU9OX0lURVJBVElPTlMgPSAxMDA7XG5cbnZhciByZWFjdGlvblNjaGVkdWxlciA9IGZ1bmN0aW9uIHJlYWN0aW9uU2NoZWR1bGVyKGYpIHtcbiAgcmV0dXJuIGYoKTtcbn07XG5cbmZ1bmN0aW9uIHJ1blJlYWN0aW9ucygpIHtcbiAgLy8gVHJhbXBvbGluaW5nLCBpZiBydW5SZWFjdGlvbnMgYXJlIGFscmVhZHkgcnVubmluZywgbmV3IHJlYWN0aW9ucyB3aWxsIGJlIHBpY2tlZCB1cFxuICBpZiAoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAgfHwgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zKSByZXR1cm47XG4gIHJlYWN0aW9uU2NoZWR1bGVyKHJ1blJlYWN0aW9uc0hlbHBlcik7XG59XG5cbmZ1bmN0aW9uIHJ1blJlYWN0aW9uc0hlbHBlcigpIHtcbiAgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zID0gdHJ1ZTtcbiAgdmFyIGFsbFJlYWN0aW9ucyA9IGdsb2JhbFN0YXRlLnBlbmRpbmdSZWFjdGlvbnM7XG4gIHZhciBpdGVyYXRpb25zID0gMDsgLy8gV2hpbGUgcnVubmluZyByZWFjdGlvbnMsIG5ldyByZWFjdGlvbnMgbWlnaHQgYmUgdHJpZ2dlcmVkLlxuICAvLyBIZW5jZSB3ZSB3b3JrIHdpdGggdHdvIHZhcmlhYmxlcyBhbmQgY2hlY2sgd2hldGhlclxuICAvLyB3ZSBjb252ZXJnZSB0byBubyByZW1haW5pbmcgcmVhY3Rpb25zIGFmdGVyIGEgd2hpbGUuXG5cbiAgd2hpbGUgKGFsbFJlYWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKCsraXRlcmF0aW9ucyA9PT0gTUFYX1JFQUNUSU9OX0lURVJBVElPTlMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJSZWFjdGlvbiBkb2Vzbid0IGNvbnZlcmdlIHRvIGEgc3RhYmxlIHN0YXRlIGFmdGVyIFwiICsgTUFYX1JFQUNUSU9OX0lURVJBVElPTlMgKyBcIiBpdGVyYXRpb25zLlwiICsgKFwiIFByb2JhYmx5IHRoZXJlIGlzIGEgY3ljbGUgaW4gdGhlIHJlYWN0aXZlIGZ1bmN0aW9uOiBcIiArIGFsbFJlYWN0aW9uc1swXSkgOiBcIlttb2J4XSBjeWNsZSBpbiByZWFjdGlvbjogXCIgKyBhbGxSZWFjdGlvbnNbMF0pO1xuICAgICAgYWxsUmVhY3Rpb25zLnNwbGljZSgwKTsgLy8gY2xlYXIgcmVhY3Rpb25zXG4gICAgfVxuXG4gICAgdmFyIHJlbWFpbmluZ1JlYWN0aW9ucyA9IGFsbFJlYWN0aW9ucy5zcGxpY2UoMCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlbWFpbmluZ1JlYWN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlbWFpbmluZ1JlYWN0aW9uc1tpXS5ydW5SZWFjdGlvbl8oKTtcbiAgICB9XG4gIH1cblxuICBnbG9iYWxTdGF0ZS5pc1J1bm5pbmdSZWFjdGlvbnMgPSBmYWxzZTtcbn1cblxudmFyIGlzUmVhY3Rpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIlJlYWN0aW9uXCIsIFJlYWN0aW9uKTtcblxuZnVuY3Rpb24gc2V0UmVhY3Rpb25TY2hlZHVsZXIoZm4pIHtcbiAgdmFyIGJhc2VTY2hlZHVsZXIgPSByZWFjdGlvblNjaGVkdWxlcjtcblxuICByZWFjdGlvblNjaGVkdWxlciA9IGZ1bmN0aW9uIHJlYWN0aW9uU2NoZWR1bGVyKGYpIHtcbiAgICByZXR1cm4gZm4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJhc2VTY2hlZHVsZXIoZik7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU3B5RW5hYmxlZCgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhIWdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHNweVJlcG9ydChldmVudCkge1xuICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSByZXR1cm47IC8vIGRlYWQgY29kZSBlbGltaW5hdGlvbiBjYW4gZG8gdGhlIHJlc3RcblxuICBpZiAoIWdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGxpc3RlbmVycyA9IGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0oZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNweVJlcG9ydFN0YXJ0KGV2ZW50KSB7XG4gIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHJldHVybjtcblxuICB2YXIgY2hhbmdlID0gX2V4dGVuZHMoe30sIGV2ZW50LCB7XG4gICAgc3B5UmVwb3J0U3RhcnQ6IHRydWVcbiAgfSk7XG5cbiAgc3B5UmVwb3J0KGNoYW5nZSk7XG59XG5cbnZhciBFTkRfRVZFTlQgPSB7XG4gIHR5cGU6IFwicmVwb3J0LWVuZFwiLFxuICBzcHlSZXBvcnRFbmQ6IHRydWVcbn07XG5cbmZ1bmN0aW9uIHNweVJlcG9ydEVuZChjaGFuZ2UpIHtcbiAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkgcmV0dXJuO1xuICBpZiAoY2hhbmdlKSBzcHlSZXBvcnQoX2V4dGVuZHMoe30sIGNoYW5nZSwge1xuICAgIHR5cGU6IFwicmVwb3J0LWVuZFwiLFxuICAgIHNweVJlcG9ydEVuZDogdHJ1ZVxuICB9KSk7ZWxzZSBzcHlSZXBvcnQoRU5EX0VWRU5UKTtcbn1cblxuZnVuY3Rpb24gc3B5KGxpc3RlbmVyKSB7XG4gIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbbW9ieC5zcHldIElzIGEgbm8tb3AgaW4gcHJvZHVjdGlvbiBidWlsZHNcIik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICB9IGVsc2Uge1xuICAgIGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgICBnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMgPSBnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHJldHVybiBsICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBBQ1RJT04gPSBcImFjdGlvblwiO1xudmFyIEFDVElPTl9CT1VORCA9IFwiYWN0aW9uLmJvdW5kXCI7XG52YXIgQVVUT0FDVElPTiA9IFwiYXV0b0FjdGlvblwiO1xudmFyIEFVVE9BQ1RJT05fQk9VTkQgPSBcImF1dG9BY3Rpb24uYm91bmRcIjtcbnZhciBERUZBVUxUX0FDVElPTl9OQU1FID0gXCI8dW5uYW1lZCBhY3Rpb24+XCI7XG52YXIgYWN0aW9uQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKEFDVElPTik7XG52YXIgYWN0aW9uQm91bmRBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQUNUSU9OX0JPVU5ELCB7XG4gIGJvdW5kOiB0cnVlXG59KTtcbnZhciBhdXRvQWN0aW9uQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKEFVVE9BQ1RJT04sIHtcbiAgYXV0b0FjdGlvbjogdHJ1ZVxufSk7XG52YXIgYXV0b0FjdGlvbkJvdW5kQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKEFVVE9BQ1RJT05fQk9VTkQsIHtcbiAgYXV0b0FjdGlvbjogdHJ1ZSxcbiAgYm91bmQ6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25GYWN0b3J5KGF1dG9BY3Rpb24pIHtcbiAgdmFyIHJlcyA9IGZ1bmN0aW9uIGFjdGlvbihhcmcxLCBhcmcyKSB7XG4gICAgLy8gYWN0aW9uKGZuKCkge30pXG4gICAgaWYgKGlzRnVuY3Rpb24oYXJnMSkpIHJldHVybiBjcmVhdGVBY3Rpb24oYXJnMS5uYW1lIHx8IERFRkFVTFRfQUNUSU9OX05BTUUsIGFyZzEsIGF1dG9BY3Rpb24pOyAvLyBhY3Rpb24oXCJuYW1lXCIsIGZuKCkge30pXG5cbiAgICBpZiAoaXNGdW5jdGlvbihhcmcyKSkgcmV0dXJuIGNyZWF0ZUFjdGlvbihhcmcxLCBhcmcyLCBhdXRvQWN0aW9uKTsgLy8gQGFjdGlvblxuXG4gICAgaWYgKGlzU3RyaW5naXNoKGFyZzIpKSB7XG4gICAgICByZXR1cm4gc3RvcmVBbm5vdGF0aW9uKGFyZzEsIGFyZzIsIGF1dG9BY3Rpb24gPyBhdXRvQWN0aW9uQW5ub3RhdGlvbiA6IGFjdGlvbkFubm90YXRpb24pO1xuICAgIH0gLy8gYWN0aW9uKFwibmFtZVwiKSAmIEBhY3Rpb24oXCJuYW1lXCIpXG5cblxuICAgIGlmIChpc1N0cmluZ2lzaChhcmcxKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZURlY29yYXRvckFubm90YXRpb24oY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihhdXRvQWN0aW9uID8gQVVUT0FDVElPTiA6IEFDVElPTiwge1xuICAgICAgICBuYW1lOiBhcmcxLFxuICAgICAgICBhdXRvQWN0aW9uOiBhdXRvQWN0aW9uXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgZGllKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yIGBhY3Rpb25gXCIpO1xuICB9O1xuXG4gIHJldHVybiByZXM7XG59XG5cbnZhciBhY3Rpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uRmFjdG9yeShmYWxzZSk7XG5PYmplY3QuYXNzaWduKGFjdGlvbiwgYWN0aW9uQW5ub3RhdGlvbik7XG52YXIgYXV0b0FjdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25GYWN0b3J5KHRydWUpO1xuT2JqZWN0LmFzc2lnbihhdXRvQWN0aW9uLCBhdXRvQWN0aW9uQW5ub3RhdGlvbik7XG5hY3Rpb24uYm91bmQgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihhY3Rpb25Cb3VuZEFubm90YXRpb24pO1xuYXV0b0FjdGlvbi5ib3VuZCA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGF1dG9BY3Rpb25Cb3VuZEFubm90YXRpb24pO1xuXG5mdW5jdGlvbiBydW5JbkFjdGlvbihmbikge1xuICByZXR1cm4gZXhlY3V0ZUFjdGlvbihmbi5uYW1lIHx8IERFRkFVTFRfQUNUSU9OX05BTUUsIGZhbHNlLCBmbiwgdGhpcywgdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gaXNBY3Rpb24odGhpbmcpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odGhpbmcpICYmIHRoaW5nLmlzTW9ieEFjdGlvbiA9PT0gdHJ1ZTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmFtZWQgcmVhY3RpdmUgdmlldyBhbmQga2VlcHMgaXQgYWxpdmUsIHNvIHRoYXQgdGhlIHZpZXcgaXMgYWx3YXlzXHJcbiAqIHVwZGF0ZWQgaWYgb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcywgZXZlbiB3aGVuIHRoZSB2aWV3IGlzIG5vdCBmdXJ0aGVyIHVzZWQgYnkgc29tZXRoaW5nIGVsc2UuXHJcbiAqIEBwYXJhbSB2aWV3IFRoZSByZWFjdGl2ZSB2aWV3XHJcbiAqIEByZXR1cm5zIGRpc3Bvc2VyIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCB0byBzdG9wIHRoZSB2aWV3IGZyb20gYmVpbmcgdXBkYXRlZCBpbiB0aGUgZnV0dXJlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBhdXRvcnVuKHZpZXcsIG9wdHMpIHtcbiAgdmFyIF9vcHRzJG5hbWUsIF9vcHRzO1xuXG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0gRU1QVFlfT0JKRUNUO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNGdW5jdGlvbih2aWV3KSkgZGllKFwiQXV0b3J1biBleHBlY3RzIGEgZnVuY3Rpb24gYXMgZmlyc3QgYXJndW1lbnRcIik7XG4gICAgaWYgKGlzQWN0aW9uKHZpZXcpKSBkaWUoXCJBdXRvcnVuIGRvZXMgbm90IGFjY2VwdCBhY3Rpb25zIHNpbmNlIGFjdGlvbnMgYXJlIHVudHJhY2thYmxlXCIpO1xuICB9XG5cbiAgdmFyIG5hbWUgPSAoX29wdHMkbmFtZSA9IChfb3B0cyA9IG9wdHMpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0cy5uYW1lKSAhPSBudWxsID8gX29wdHMkbmFtZSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHZpZXcubmFtZSB8fCBcIkF1dG9ydW5AXCIgKyBnZXROZXh0SWQoKSA6IFwiQXV0b3J1blwiO1xuICB2YXIgcnVuU3luYyA9ICFvcHRzLnNjaGVkdWxlciAmJiAhb3B0cy5kZWxheTtcbiAgdmFyIHJlYWN0aW9uO1xuXG4gIGlmIChydW5TeW5jKSB7XG4gICAgLy8gbm9ybWFsIGF1dG9ydW5cbiAgICByZWFjdGlvbiA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyYWNrKHJlYWN0aW9uUnVubmVyKTtcbiAgICB9LCBvcHRzLm9uRXJyb3IsIG9wdHMucmVxdWlyZXNPYnNlcnZhYmxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyID0gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cyk7IC8vIGRlYm91bmNlZCBhdXRvcnVuXG5cbiAgICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICByZWFjdGlvbiA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgc2NoZWR1bGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmICghcmVhY3Rpb24uaXNEaXNwb3NlZF8pIHJlYWN0aW9uLnRyYWNrKHJlYWN0aW9uUnVubmVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgb3B0cy5vbkVycm9yLCBvcHRzLnJlcXVpcmVzT2JzZXJ2YWJsZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGlvblJ1bm5lcigpIHtcbiAgICB2aWV3KHJlYWN0aW9uKTtcbiAgfVxuXG4gIHJlYWN0aW9uLnNjaGVkdWxlXygpO1xuICByZXR1cm4gcmVhY3Rpb24uZ2V0RGlzcG9zZXJfKCk7XG59XG5cbnZhciBydW4gPSBmdW5jdGlvbiBydW4oZikge1xuICByZXR1cm4gZigpO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cykge1xuICByZXR1cm4gb3B0cy5zY2hlZHVsZXIgPyBvcHRzLnNjaGVkdWxlciA6IG9wdHMuZGVsYXkgPyBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGYsIG9wdHMuZGVsYXkpO1xuICB9IDogcnVuO1xufVxuXG5mdW5jdGlvbiByZWFjdGlvbihleHByZXNzaW9uLCBlZmZlY3QsIG9wdHMpIHtcbiAgdmFyIF9vcHRzJG5hbWUyO1xuXG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0gRU1QVFlfT0JKRUNUO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNGdW5jdGlvbihleHByZXNzaW9uKSB8fCAhaXNGdW5jdGlvbihlZmZlY3QpKSBkaWUoXCJGaXJzdCBhbmQgc2Vjb25kIGFyZ3VtZW50IHRvIHJlYWN0aW9uIHNob3VsZCBiZSBmdW5jdGlvbnNcIik7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KG9wdHMpKSBkaWUoXCJUaGlyZCBhcmd1bWVudCBvZiByZWFjdGlvbnMgc2hvdWxkIGJlIGFuIG9iamVjdFwiKTtcbiAgfVxuXG4gIHZhciBuYW1lID0gKF9vcHRzJG5hbWUyID0gb3B0cy5uYW1lKSAhPSBudWxsID8gX29wdHMkbmFtZTIgOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIlJlYWN0aW9uQFwiICsgZ2V0TmV4dElkKCkgOiBcIlJlYWN0aW9uXCI7XG4gIHZhciBlZmZlY3RBY3Rpb24gPSBhY3Rpb24obmFtZSwgb3B0cy5vbkVycm9yID8gd3JhcEVycm9ySGFuZGxlcihvcHRzLm9uRXJyb3IsIGVmZmVjdCkgOiBlZmZlY3QpO1xuICB2YXIgcnVuU3luYyA9ICFvcHRzLnNjaGVkdWxlciAmJiAhb3B0cy5kZWxheTtcbiAgdmFyIHNjaGVkdWxlciA9IGNyZWF0ZVNjaGVkdWxlckZyb21PcHRpb25zKG9wdHMpO1xuICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcbiAgdmFyIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIG9sZFZhbHVlID0gdW5kZWZpbmVkOyAvLyBvbmx5IGFuIGlzc3VlIHdpdGggZmlyZUltbWVkaWF0ZWx5XG5cbiAgdmFyIGVxdWFscyA9IG9wdHMuY29tcGFyZVN0cnVjdHVyYWwgPyBjb21wYXJlci5zdHJ1Y3R1cmFsIDogb3B0cy5lcXVhbHMgfHwgY29tcGFyZXJbXCJkZWZhdWx0XCJdO1xuICB2YXIgciA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZpcnN0VGltZSB8fCBydW5TeW5jKSB7XG4gICAgICByZWFjdGlvblJ1bm5lcigpO1xuICAgIH0gZWxzZSBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzY2hlZHVsZXIocmVhY3Rpb25SdW5uZXIpO1xuICAgIH1cbiAgfSwgb3B0cy5vbkVycm9yLCBvcHRzLnJlcXVpcmVzT2JzZXJ2YWJsZSk7XG5cbiAgZnVuY3Rpb24gcmVhY3Rpb25SdW5uZXIoKSB7XG4gICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBpZiAoci5pc0Rpc3Bvc2VkXykgcmV0dXJuO1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgci50cmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmV4dFZhbHVlID0gYWxsb3dTdGF0ZUNoYW5nZXMoZmFsc2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24ocik7XG4gICAgICB9KTtcbiAgICAgIGNoYW5nZWQgPSBmaXJzdFRpbWUgfHwgIWVxdWFscyh2YWx1ZSwgbmV4dFZhbHVlKTtcbiAgICAgIG9sZFZhbHVlID0gdmFsdWU7XG4gICAgICB2YWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9KTtcbiAgICBpZiAoZmlyc3RUaW1lICYmIG9wdHMuZmlyZUltbWVkaWF0ZWx5KSBlZmZlY3RBY3Rpb24odmFsdWUsIG9sZFZhbHVlLCByKTtlbHNlIGlmICghZmlyc3RUaW1lICYmIGNoYW5nZWQpIGVmZmVjdEFjdGlvbih2YWx1ZSwgb2xkVmFsdWUsIHIpO1xuICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICB9XG5cbiAgci5zY2hlZHVsZV8oKTtcbiAgcmV0dXJuIHIuZ2V0RGlzcG9zZXJfKCk7XG59XG5cbmZ1bmN0aW9uIHdyYXBFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyLCBiYXNlRm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJhc2VGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ySGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIE9OX0JFQ09NRV9PQlNFUlZFRCA9IFwib25CT1wiO1xudmFyIE9OX0JFQ09NRV9VTk9CU0VSVkVEID0gXCJvbkJVT1wiO1xuXG5mdW5jdGlvbiBvbkJlY29tZU9ic2VydmVkKHRoaW5nLCBhcmcyLCBhcmczKSB7XG4gIHJldHVybiBpbnRlcmNlcHRIb29rKE9OX0JFQ09NRV9PQlNFUlZFRCwgdGhpbmcsIGFyZzIsIGFyZzMpO1xufVxuXG5mdW5jdGlvbiBvbkJlY29tZVVub2JzZXJ2ZWQodGhpbmcsIGFyZzIsIGFyZzMpIHtcbiAgcmV0dXJuIGludGVyY2VwdEhvb2soT05fQkVDT01FX1VOT0JTRVJWRUQsIHRoaW5nLCBhcmcyLCBhcmczKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0SG9vayhob29rLCB0aGluZywgYXJnMiwgYXJnMykge1xuICB2YXIgYXRvbSA9IHR5cGVvZiBhcmczID09PSBcImZ1bmN0aW9uXCIgPyBnZXRBdG9tKHRoaW5nLCBhcmcyKSA6IGdldEF0b20odGhpbmcpO1xuICB2YXIgY2IgPSBpc0Z1bmN0aW9uKGFyZzMpID8gYXJnMyA6IGFyZzI7XG4gIHZhciBsaXN0ZW5lcnNLZXkgPSBob29rICsgXCJMXCI7XG5cbiAgaWYgKGF0b21bbGlzdGVuZXJzS2V5XSkge1xuICAgIGF0b21bbGlzdGVuZXJzS2V5XS5hZGQoY2IpO1xuICB9IGVsc2Uge1xuICAgIGF0b21bbGlzdGVuZXJzS2V5XSA9IG5ldyBTZXQoW2NiXSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBob29rTGlzdGVuZXJzID0gYXRvbVtsaXN0ZW5lcnNLZXldO1xuXG4gICAgaWYgKGhvb2tMaXN0ZW5lcnMpIHtcbiAgICAgIGhvb2tMaXN0ZW5lcnNbXCJkZWxldGVcIl0oY2IpO1xuXG4gICAgICBpZiAoaG9va0xpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBhdG9tW2xpc3RlbmVyc0tleV07XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgTkVWRVIgPSBcIm5ldmVyXCI7XG52YXIgQUxXQVlTID0gXCJhbHdheXNcIjtcbnZhciBPQlNFUlZFRCA9IFwib2JzZXJ2ZWRcIjsgLy8gY29uc3QgSUZfQVZBSUxBQkxFID0gXCJpZmF2YWlsYWJsZVwiXG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmlzb2xhdGVHbG9iYWxTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgIGlzb2xhdGVHbG9iYWxTdGF0ZSgpO1xuICB9XG5cbiAgdmFyIHVzZVByb3hpZXMgPSBvcHRpb25zLnVzZVByb3hpZXMsXG4gICAgICBlbmZvcmNlQWN0aW9ucyA9IG9wdGlvbnMuZW5mb3JjZUFjdGlvbnM7XG5cbiAgaWYgKHVzZVByb3hpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGdsb2JhbFN0YXRlLnVzZVByb3hpZXMgPSB1c2VQcm94aWVzID09PSBBTFdBWVMgPyB0cnVlIDogdXNlUHJveGllcyA9PT0gTkVWRVIgPyBmYWxzZSA6IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgfVxuXG4gIGlmICh1c2VQcm94aWVzID09PSBcImlmYXZhaWxhYmxlXCIpIGdsb2JhbFN0YXRlLnZlcmlmeVByb3hpZXMgPSB0cnVlO1xuXG4gIGlmIChlbmZvcmNlQWN0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGVhID0gZW5mb3JjZUFjdGlvbnMgPT09IEFMV0FZUyA/IEFMV0FZUyA6IGVuZm9yY2VBY3Rpb25zID09PSBPQlNFUlZFRDtcbiAgICBnbG9iYWxTdGF0ZS5lbmZvcmNlQWN0aW9ucyA9IGVhO1xuICAgIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gZWEgPT09IHRydWUgfHwgZWEgPT09IEFMV0FZUyA/IGZhbHNlIDogdHJ1ZTtcbiAgfVxuXG4gIFtcImNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvblwiLCBcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsIFwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25cIiwgXCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzXCIsIFwic2FmZURlc2NyaXB0b3JzXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgaW4gb3B0aW9ucykgZ2xvYmFsU3RhdGVba2V5XSA9ICEhb3B0aW9uc1trZXldO1xuICB9KTtcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzID0gIWdsb2JhbFN0YXRlLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9PT0gdHJ1ZSkge1xuICAgIGNvbnNvbGUud2FybihcIldBUk5JTkc6IERlYnVnIGZlYXR1cmUgb25seS4gTW9iWCB3aWxsIE5PVCByZWNvdmVyIGZyb20gZXJyb3JzIHdoZW4gYGRpc2FibGVFcnJvckJvdW5kYXJpZXNgIGlzIGVuYWJsZWQuXCIpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVhY3Rpb25TY2hlZHVsZXIpIHtcbiAgICBzZXRSZWFjdGlvblNjaGVkdWxlcihvcHRpb25zLnJlYWN0aW9uU2NoZWR1bGVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRlbmRPYnNlcnZhYmxlKHRhcmdldCwgcHJvcGVydGllcywgYW5ub3RhdGlvbnMsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gNCkgZGllKFwiJ2V4dGVuZE9ic2VydmFibGUnIGV4cGVjdGVkIDItNCBhcmd1bWVudHNcIik7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIpIGRpZShcIidleHRlbmRPYnNlcnZhYmxlJyBleHBlY3RzIGFuIG9iamVjdCBhcyBmaXJzdCBhcmd1bWVudFwiKTtcbiAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKHRhcmdldCkpIGRpZShcIidleHRlbmRPYnNlcnZhYmxlJyBzaG91bGQgbm90IGJlIHVzZWQgb24gbWFwcywgdXNlIG1hcC5tZXJnZSBpbnN0ZWFkXCIpO1xuICAgIGlmICghaXNQbGFpbk9iamVjdChwcm9wZXJ0aWVzKSkgZGllKFwiJ2V4dGVuZE9ic2VydmFiZScgb25seSBhY2NlcHRzIHBsYWluIG9iamVjdHMgYXMgc2Vjb25kIGFyZ3VtZW50XCIpO1xuICAgIGlmIChpc09ic2VydmFibGUocHJvcGVydGllcykgfHwgaXNPYnNlcnZhYmxlKGFubm90YXRpb25zKSkgZGllKFwiRXh0ZW5kaW5nIGFuIG9iamVjdCB3aXRoIGFub3RoZXIgb2JzZXJ2YWJsZSAob2JqZWN0KSBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICB9IC8vIFB1bGwgZGVzY3JpcHRvcnMgZmlyc3QsIHNvIHdlIGRvbid0IGhhdmUgdG8gZGVhbCB3aXRoIHByb3BzIGFkZGVkIGJ5IGFkbWluaXN0cmF0aW9uICgkbW9ieClcblxuXG4gIHZhciBkZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocHJvcGVydGllcyk7XG4gIHZhciBhZG0gPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKVskbW9ieF07XG4gIHN0YXJ0QmF0Y2goKTtcblxuICB0cnkge1xuICAgIG93bktleXMoZGVzY3JpcHRvcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgYWRtLmV4dGVuZF8oa2V5LCBkZXNjcmlwdG9yc1trZXldLCAvLyBtdXN0IHBhc3MgXCJ1bmRlZmluZWRcIiBmb3IgeyBrZXk6IHVuZGVmaW5lZCB9XG4gICAgICAhYW5ub3RhdGlvbnMgPyB0cnVlIDoga2V5IGluIGFubm90YXRpb25zID8gYW5ub3RhdGlvbnNba2V5XSA6IHRydWUpO1xuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmN5VHJlZSh0aGluZywgcHJvcGVydHkpIHtcbiAgcmV0dXJuIG5vZGVUb0RlcGVuZGVuY3lUcmVlKGdldEF0b20odGhpbmcsIHByb3BlcnR5KSk7XG59XG5cbmZ1bmN0aW9uIG5vZGVUb0RlcGVuZGVuY3lUcmVlKG5vZGUpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBuYW1lOiBub2RlLm5hbWVfXG4gIH07XG4gIGlmIChub2RlLm9ic2VydmluZ18gJiYgbm9kZS5vYnNlcnZpbmdfLmxlbmd0aCA+IDApIHJlc3VsdC5kZXBlbmRlbmNpZXMgPSB1bmlxdWUobm9kZS5vYnNlcnZpbmdfKS5tYXAobm9kZVRvRGVwZW5kZW5jeVRyZWUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRPYnNlcnZlclRyZWUodGhpbmcsIHByb3BlcnR5KSB7XG4gIHJldHVybiBub2RlVG9PYnNlcnZlclRyZWUoZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpKTtcbn1cblxuZnVuY3Rpb24gbm9kZVRvT2JzZXJ2ZXJUcmVlKG5vZGUpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBuYW1lOiBub2RlLm5hbWVfXG4gIH07XG4gIGlmIChoYXNPYnNlcnZlcnMobm9kZSkpIHJlc3VsdC5vYnNlcnZlcnMgPSBBcnJheS5mcm9tKGdldE9ic2VydmVycyhub2RlKSkubWFwKG5vZGVUb09ic2VydmVyVHJlZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZShsaXN0KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQobGlzdCkpO1xufVxuXG52YXIgZ2VuZXJhdG9ySWQgPSAwO1xuXG5mdW5jdGlvbiBGbG93Q2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gIHRoaXMubWVzc2FnZSA9IFwiRkxPV19DQU5DRUxMRURcIjtcbn1cblxuRmxvd0NhbmNlbGxhdGlvbkVycm9yLnByb3RvdHlwZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIGlzRmxvd0NhbmNlbGxhdGlvbkVycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEZsb3dDYW5jZWxsYXRpb25FcnJvcjtcbn1cblxudmFyIGZsb3dBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUZsb3dBbm5vdGF0aW9uKFwiZmxvd1wiKTtcbnZhciBmbG93ID0gLyojX19QVVJFX18qL09iamVjdC5hc3NpZ24oZnVuY3Rpb24gZmxvdyhhcmcxLCBhcmcyKSB7XG4gIC8vIEBmbG93XG4gIGlmIChpc1N0cmluZ2lzaChhcmcyKSkge1xuICAgIHJldHVybiBzdG9yZUFubm90YXRpb24oYXJnMSwgYXJnMiwgZmxvd0Fubm90YXRpb24pO1xuICB9IC8vIGZsb3coZm4pXG5cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIGRpZShcIkZsb3cgZXhwZWN0cyBzaW5nbGUgYXJndW1lbnQgd2l0aCBnZW5lcmF0b3IgZnVuY3Rpb25cIik7XG4gIHZhciBnZW5lcmF0b3IgPSBhcmcxO1xuICB2YXIgbmFtZSA9IGdlbmVyYXRvci5uYW1lIHx8IFwiPHVubmFtZWQgZmxvdz5cIjsgLy8gSW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3RqL2NvL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5cbiAgdmFyIHJlcyA9IGZ1bmN0aW9uIHJlcygpIHtcbiAgICB2YXIgY3R4ID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcnVuSWQgPSArK2dlbmVyYXRvcklkO1xuICAgIHZhciBnZW4gPSBhY3Rpb24obmFtZSArIFwiIC0gcnVuaWQ6IFwiICsgcnVuSWQgKyBcIiAtIGluaXRcIiwgZ2VuZXJhdG9yKS5hcHBseShjdHgsIGFyZ3MpO1xuICAgIHZhciByZWplY3RvcjtcbiAgICB2YXIgcGVuZGluZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgc3RlcElkID0gMDtcbiAgICAgIHJlamVjdG9yID0gcmVqZWN0O1xuXG4gICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxlZChyZXMpIHtcbiAgICAgICAgcGVuZGluZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBhY3Rpb24obmFtZSArIFwiIC0gcnVuaWQ6IFwiICsgcnVuSWQgKyBcIiAtIHlpZWxkIFwiICsgc3RlcElkKyssIGdlbi5uZXh0KS5jYWxsKGdlbiwgcmVzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KHJldCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0ZWQoZXJyKSB7XG4gICAgICAgIHBlbmRpbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0ID0gYWN0aW9uKG5hbWUgKyBcIiAtIHJ1bmlkOiBcIiArIHJ1bklkICsgXCIgLSB5aWVsZCBcIiArIHN0ZXBJZCsrLCBnZW5bXCJ0aHJvd1wiXSkuY2FsbChnZW4sIGVycik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChyZXQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZXh0KHJldCkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHJldC50aGVuKSkge1xuICAgICAgICAgIC8vIGFuIGFzeW5jIGl0ZXJhdG9yXG4gICAgICAgICAgcmV0LnRoZW4obmV4dCwgcmVqZWN0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0LmRvbmUpIHJldHVybiByZXNvbHZlKHJldC52YWx1ZSk7XG4gICAgICAgIHBlbmRpbmdQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHJldC52YWx1ZSk7XG4gICAgICAgIHJldHVybiBwZW5kaW5nUHJvbWlzZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgb25GdWxmaWxsZWQodW5kZWZpbmVkKTsgLy8ga2ljayBvZmYgdGhlIHByb2Nlc3NcbiAgICB9KTtcbiAgICBwcm9taXNlLmNhbmNlbCA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0gY2FuY2VsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwZW5kaW5nUHJvbWlzZSkgY2FuY2VsUHJvbWlzZShwZW5kaW5nUHJvbWlzZSk7IC8vIEZpbmFsbHkgYmxvY2sgY2FuIHJldHVybiAob3IgeWllbGQpIHN0dWZmLi5cblxuICAgICAgICB2YXIgX3JlcyA9IGdlbltcInJldHVyblwiXSh1bmRlZmluZWQpOyAvLyBlYXQgYW55dGhpbmcgdGhhdCBwcm9taXNlIHdvdWxkIGRvLCBpdCdzIGNhbmNlbGxlZCFcblxuXG4gICAgICAgIHZhciB5aWVsZGVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShfcmVzLnZhbHVlKTtcbiAgICAgICAgeWllbGRlZFByb21pc2UudGhlbihub29wLCBub29wKTtcbiAgICAgICAgY2FuY2VsUHJvbWlzZSh5aWVsZGVkUHJvbWlzZSk7IC8vIG1heWJlIGl0IGNhbiBiZSBjYW5jZWxsZWQgOilcbiAgICAgICAgLy8gcmVqZWN0IG91ciBvcmlnaW5hbCBwcm9taXNlXG5cbiAgICAgICAgcmVqZWN0b3IobmV3IEZsb3dDYW5jZWxsYXRpb25FcnJvcigpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0b3IoZSk7IC8vIHRoZXJlIGNvdWxkIGJlIGEgdGhyb3dpbmcgZmluYWxseSBibG9ja1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJlcy5pc01vYlhGbG93ID0gdHJ1ZTtcbiAgcmV0dXJuIHJlcztcbn0sIGZsb3dBbm5vdGF0aW9uKTtcblxuZnVuY3Rpb24gY2FuY2VsUHJvbWlzZShwcm9taXNlKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHByb21pc2UuY2FuY2VsKSkgcHJvbWlzZS5jYW5jZWwoKTtcbn1cblxuZnVuY3Rpb24gZmxvd1Jlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdDsgLy8ganVzdCB0cmlja2luZyBUeXBlU2NyaXB0IDopXG59XG5cbmZ1bmN0aW9uIGlzRmxvdyhmbikge1xuICByZXR1cm4gKGZuID09IG51bGwgPyB2b2lkIDAgOiBmbi5pc01vYlhGbG93KSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0UmVhZHModGhpbmcsIHByb3BPckhhbmRsZXIsIGhhbmRsZXIpIHtcbiAgdmFyIHRhcmdldDtcblxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSB8fCBpc09ic2VydmFibGVBcnJheSh0aGluZykgfHwgaXNPYnNlcnZhYmxlVmFsdWUodGhpbmcpKSB7XG4gICAgdGFyZ2V0ID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFpc1N0cmluZ2lzaChwcm9wT3JIYW5kbGVyKSkgcmV0dXJuIGRpZShcIkludGVyY2VwdFJlYWRzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBhIHNwZWNpZmljIHByb3BlcnR5LCBub3Qgd2l0aCBhbiBvYmplY3QgaW4gZ2VuZXJhbFwiKTtcbiAgICB0YXJnZXQgPSBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcE9ySGFuZGxlcik7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuIGRpZShcIkV4cGVjdGVkIG9ic2VydmFibGUgbWFwLCBvYmplY3Qgb3IgYXJyYXkgYXMgZmlyc3QgYXJyYXlcIik7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRhcmdldC5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZGllKFwiQW4gaW50ZXJjZXB0IHJlYWRlciB3YXMgYWxyZWFkeSBlc3RhYmxpc2hlZFwiKTtcbiAgdGFyZ2V0LmRlaGFuY2VyID0gdHlwZW9mIHByb3BPckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiA/IHByb3BPckhhbmRsZXIgOiBoYW5kbGVyO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRhcmdldC5kZWhhbmNlciA9IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0KHRoaW5nLCBwcm9wT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSByZXR1cm4gaW50ZXJjZXB0UHJvcGVydHkodGhpbmcsIHByb3BPckhhbmRsZXIsIGhhbmRsZXIpO2Vsc2UgcmV0dXJuIGludGVyY2VwdEludGVyY2VwdGFibGUodGhpbmcsIHByb3BPckhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBpbnRlcmNlcHRJbnRlcmNlcHRhYmxlKHRoaW5nLCBoYW5kbGVyKSB7XG4gIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZykuaW50ZXJjZXB0XyhoYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0UHJvcGVydHkodGhpbmcsIHByb3BlcnR5LCBoYW5kbGVyKSB7XG4gIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcGVydHkpLmludGVyY2VwdF8oaGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIF9pc0NvbXB1dGVkKHZhbHVlLCBwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpc09ic2VydmFibGVPYmplY3QodmFsdWUpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdmFsdWVbJG1vYnhdLnZhbHVlc18uaGFzKHByb3BlcnR5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBhdG9tID0gZ2V0QXRvbSh2YWx1ZSwgcHJvcGVydHkpO1xuICAgIHJldHVybiBpc0NvbXB1dGVkVmFsdWUoYXRvbSk7XG4gIH1cblxuICByZXR1cm4gaXNDb21wdXRlZFZhbHVlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaXNDb21wdXRlZCh2YWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGFyZ3VtZW50cy5sZW5ndGggPiAxKSByZXR1cm4gZGllKFwiaXNDb21wdXRlZCBleHBlY3RzIG9ubHkgMSBhcmd1bWVudC4gVXNlIGlzQ29tcHV0ZWRQcm9wIHRvIGluc3BlY3QgdGhlIG9ic2VydmFiaWxpdHkgb2YgYSBwcm9wZXJ0eVwiKTtcbiAgcmV0dXJuIF9pc0NvbXB1dGVkKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaXNDb21wdXRlZFByb3AodmFsdWUsIHByb3BOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzU3RyaW5naXNoKHByb3BOYW1lKSkgcmV0dXJuIGRpZShcImlzQ29tcHV0ZWQgZXhwZWN0ZWQgYSBwcm9wZXJ0eSBuYW1lIGFzIHNlY29uZCBhcmd1bWVudFwiKTtcbiAgcmV0dXJuIF9pc0NvbXB1dGVkKHZhbHVlLCBwcm9wTmFtZSk7XG59XG5cbmZ1bmN0aW9uIF9pc09ic2VydmFibGUodmFsdWUsIHByb3BlcnR5KSB7XG4gIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcblxuICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGlzT2JzZXJ2YWJsZU1hcCh2YWx1ZSkgfHwgaXNPYnNlcnZhYmxlQXJyYXkodmFsdWUpKSkgcmV0dXJuIGRpZShcImlzT2JzZXJ2YWJsZShvYmplY3QsIHByb3BlcnR5TmFtZSkgaXMgbm90IHN1cHBvcnRlZCBmb3IgYXJyYXlzIGFuZCBtYXBzLiBVc2UgbWFwLmhhcyBvciBhcnJheS5sZW5ndGggaW5zdGVhZC5cIik7XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlWyRtb2J4XS52YWx1ZXNfLmhhcyhwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIEZvciBmaXJzdCBjaGVjaywgc2VlICM3MDFcblxuXG4gIHJldHVybiBpc09ic2VydmFibGVPYmplY3QodmFsdWUpIHx8ICEhdmFsdWVbJG1vYnhdIHx8IGlzQXRvbSh2YWx1ZSkgfHwgaXNSZWFjdGlvbih2YWx1ZSkgfHwgaXNDb21wdXRlZFZhbHVlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlKHZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkgZGllKFwiaXNPYnNlcnZhYmxlIGV4cGVjdHMgb25seSAxIGFyZ3VtZW50LiBVc2UgaXNPYnNlcnZhYmxlUHJvcCB0byBpbnNwZWN0IHRoZSBvYnNlcnZhYmlsaXR5IG9mIGEgcHJvcGVydHlcIik7XG4gIHJldHVybiBfaXNPYnNlcnZhYmxlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlUHJvcCh2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNTdHJpbmdpc2gocHJvcE5hbWUpKSByZXR1cm4gZGllKFwiZXhwZWN0ZWQgYSBwcm9wZXJ0eSBuYW1lIGFzIHNlY29uZCBhcmd1bWVudFwiKTtcbiAgcmV0dXJuIF9pc09ic2VydmFibGUodmFsdWUsIHByb3BOYW1lKTtcbn1cblxuZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0ua2V5c18oKTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVNYXAob2JqKSB8fCBpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKG9iai5rZXlzKCkpO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm1hcChmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9KTtcbiAgfVxuXG4gIGRpZSg1KTtcbn1cblxuZnVuY3Rpb24gdmFsdWVzKG9iaikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gb2JqLmdldChrZXkpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ob2JqLnZhbHVlcygpKTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9XG5cbiAgZGllKDYpO1xufVxuXG5mdW5jdGlvbiBlbnRyaWVzKG9iaikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqW2tleV1dO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgcmV0dXJuIGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9iai5nZXQoa2V5KV07XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShvYmouZW50cmllcygpKTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBbaW5kZXgsIGtleV07XG4gICAgfSk7XG4gIH1cblxuICBkaWUoNyk7XG59XG5cbmZ1bmN0aW9uIHNldChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIWlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHZhciBfdmFsdWVzID0ga2V5O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9rZXkgaW4gX3ZhbHVlcykge1xuICAgICAgICBzZXQob2JqLCBfa2V5LCBfdmFsdWVzW19rZXldKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICBvYmpbJG1vYnhdLnNldF8oa2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICBvYmouc2V0KGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgb2JqLmFkZChrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gXCJudW1iZXJcIikga2V5ID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgaWYgKGtleSA8IDApIGRpZShcIkludmFsaWQgaW5kZXg6ICdcIiArIGtleSArIFwiJ1wiKTtcbiAgICBzdGFydEJhdGNoKCk7XG4gICAgaWYgKGtleSA+PSBvYmoubGVuZ3RoKSBvYmoubGVuZ3RoID0ga2V5ICsgMTtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIGVuZEJhdGNoKCk7XG4gIH0gZWxzZSBkaWUoOCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShvYmosIGtleSkge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICBvYmpbJG1vYnhdLmRlbGV0ZV8oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIG9ialtcImRlbGV0ZVwiXShrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgb2JqW1wiZGVsZXRlXCJdKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcIm51bWJlclwiKSBrZXkgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICBvYmouc3BsaWNlKGtleSwgMSk7XG4gIH0gZWxzZSB7XG4gICAgZGllKDkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5oYXNfKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmhhcyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIG9iai5oYXMoa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIGtleSA+PSAwICYmIGtleSA8IG9iai5sZW5ndGg7XG4gIH1cblxuICBkaWUoMTApO1xufVxuXG5mdW5jdGlvbiBnZXQob2JqLCBrZXkpIHtcbiAgaWYgKCFoYXMob2JqLCBrZXkpKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmpbJG1vYnhdLmdldF8oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIHJldHVybiBvYmouZ2V0KGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuXG4gIGRpZSgxMSk7XG59XG5cbmZ1bmN0aW9uIG9ic2VydmUodGhpbmcsIHByb3BPckNiLCBjYk9yRmlyZSwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gIGlmIChpc0Z1bmN0aW9uKGNiT3JGaXJlKSkgcmV0dXJuIG9ic2VydmVPYnNlcnZhYmxlUHJvcGVydHkodGhpbmcsIHByb3BPckNiLCBjYk9yRmlyZSwgZmlyZUltbWVkaWF0ZWx5KTtlbHNlIHJldHVybiBvYnNlcnZlT2JzZXJ2YWJsZSh0aGluZywgcHJvcE9yQ2IsIGNiT3JGaXJlKTtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZU9ic2VydmFibGUodGhpbmcsIGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKS5vYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KTtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZU9ic2VydmFibGVQcm9wZXJ0eSh0aGluZywgcHJvcGVydHksIGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wZXJ0eSkub2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSk7XG59XG5cbmZ1bmN0aW9uIGNhY2hlKG1hcCwga2V5LCB2YWx1ZSkge1xuICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRvSlNIZWxwZXIoc291cmNlLCBfX2FscmVhZHlTZWVuKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCB8fCB0eXBlb2Ygc291cmNlICE9PSBcIm9iamVjdFwiIHx8IHNvdXJjZSBpbnN0YW5jZW9mIERhdGUgfHwgIWlzT2JzZXJ2YWJsZShzb3VyY2UpKSByZXR1cm4gc291cmNlO1xuICBpZiAoaXNPYnNlcnZhYmxlVmFsdWUoc291cmNlKSkgcmV0dXJuIHRvSlNIZWxwZXIoc291cmNlLmdldCgpLCBfX2FscmVhZHlTZWVuKTtcblxuICBpZiAoX19hbHJlYWR5U2Vlbi5oYXMoc291cmNlKSkge1xuICAgIHJldHVybiBfX2FscmVhZHlTZWVuLmdldChzb3VyY2UpO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KHNvdXJjZSkpIHtcbiAgICB2YXIgcmVzID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkpO1xuICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICByZXNbaWR4XSA9IHRvSlNIZWxwZXIodmFsdWUsIF9fYWxyZWFkeVNlZW4pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlU2V0KHNvdXJjZSkpIHtcbiAgICB2YXIgX3JlcyA9IGNhY2hlKF9fYWxyZWFkeVNlZW4sIHNvdXJjZSwgbmV3IFNldCgpKTtcblxuICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgX3Jlcy5hZGQodG9KU0hlbHBlcih2YWx1ZSwgX19hbHJlYWR5U2VlbikpO1xuICAgIH0pO1xuICAgIHJldHVybiBfcmVzO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChzb3VyY2UpKSB7XG4gICAgdmFyIF9yZXMyID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBuZXcgTWFwKCkpO1xuXG4gICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIF9yZXMyLnNldChrZXksIHRvSlNIZWxwZXIodmFsdWUsIF9fYWxyZWFkeVNlZW4pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3JlczI7XG4gIH0gZWxzZSB7XG4gICAgLy8gbXVzdCBiZSBvYnNlcnZhYmxlIG9iamVjdFxuICAgIGtleXMoc291cmNlKTsgLy8gbWFrZSBzdXJlIGtleXMgYXJlIG9ic2VydmVkXG5cbiAgICB2YXIgX3JlczMgPSBjYWNoZShfX2FscmVhZHlTZWVuLCBzb3VyY2UsIHt9KTtcblxuICAgIGdldFBsYWluT2JqZWN0S2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX3JlczNba2V5XSA9IHRvSlNIZWxwZXIoc291cmNlW2tleV0sIF9fYWxyZWFkeVNlZW4pO1xuICAgIH0pO1xuICAgIHJldHVybiBfcmVzMztcbiAgfVxufVxuLyoqXHJcbiAqIEJhc2ljYWxseSwgYSBkZWVwIGNsb25lLCBzbyB0aGF0IG5vIHJlYWN0aXZlIHByb3BlcnR5IHdpbGwgZXhpc3QgYW55bW9yZS5cclxuICovXG5cblxuZnVuY3Rpb24gdG9KUyhzb3VyY2UsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBvcHRpb25zKSBkaWUoXCJ0b0pTIG5vIGxvbmdlciBzdXBwb3J0cyBvcHRpb25zXCIpO1xuICByZXR1cm4gdG9KU0hlbHBlcihzb3VyY2UsIG5ldyBNYXAoKSk7XG59XG5cbmZ1bmN0aW9uIHRyYWNlKCkge1xuICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSBkaWUoXCJ0cmFjZSgpIGlzIG5vdCBhdmFpbGFibGUgaW4gcHJvZHVjdGlvbiBidWlsZHNcIik7XG4gIHZhciBlbnRlckJyZWFrUG9pbnQgPSBmYWxzZTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwiYm9vbGVhblwiKSBlbnRlckJyZWFrUG9pbnQgPSBhcmdzLnBvcCgpO1xuICB2YXIgZGVyaXZhdGlvbiA9IGdldEF0b21Gcm9tQXJncyhhcmdzKTtcblxuICBpZiAoIWRlcml2YXRpb24pIHtcbiAgICByZXR1cm4gZGllKFwiJ3RyYWNlKGJyZWFrPyknIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgdHJhY2tlZCBjb21wdXRlZCB2YWx1ZSBvciBhIFJlYWN0aW9uLiBDb25zaWRlciBwYXNzaW5nIGluIHRoZSBjb21wdXRlZCB2YWx1ZSBvciByZWFjdGlvbiBleHBsaWNpdGx5XCIpO1xuICB9XG5cbiAgaWYgKGRlcml2YXRpb24uaXNUcmFjaW5nXyA9PT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIHRyYWNpbmcgZW5hYmxlZFwiKTtcbiAgfVxuXG4gIGRlcml2YXRpb24uaXNUcmFjaW5nXyA9IGVudGVyQnJlYWtQb2ludCA/IFRyYWNlTW9kZS5CUkVBSyA6IFRyYWNlTW9kZS5MT0c7XG59XG5cbmZ1bmN0aW9uIGdldEF0b21Gcm9tQXJncyhhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGdldEF0b20oYXJnc1swXSk7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZ2V0QXRvbShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfVxufVxuLyoqXHJcbiAqIER1cmluZyBhIHRyYW5zYWN0aW9uIG5vIHZpZXdzIGFyZSB1cGRhdGVkIHVudGlsIHRoZSBlbmQgb2YgdGhlIHRyYW5zYWN0aW9uLlxyXG4gKiBUaGUgdHJhbnNhY3Rpb24gd2lsbCBiZSBydW4gc3luY2hyb25vdXNseSBub25ldGhlbGVzcy5cclxuICpcclxuICogQHBhcmFtIGFjdGlvbiBhIGZ1bmN0aW9uIHRoYXQgdXBkYXRlcyBzb21lIHJlYWN0aXZlIHN0YXRlXHJcbiAqIEByZXR1cm5zIGFueSB2YWx1ZSB0aGF0IHdhcyByZXR1cm5lZCBieSB0aGUgJ2FjdGlvbicgcGFyYW1ldGVyLlxyXG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2FjdGlvbihhY3Rpb24sIHRoaXNBcmcpIHtcbiAgaWYgKHRoaXNBcmcgPT09IHZvaWQgMCkge1xuICAgIHRoaXNBcmcgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBzdGFydEJhdGNoKCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYWN0aW9uLmFwcGx5KHRoaXNBcmcpO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2hlbihwcmVkaWNhdGUsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgYXJnMSAmJiB0eXBlb2YgYXJnMSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIHdoZW5Qcm9taXNlKHByZWRpY2F0ZSwgYXJnMSk7XG4gIHJldHVybiBfd2hlbihwcmVkaWNhdGUsIGFyZzEsIGFyZzIgfHwge30pO1xufVxuXG5mdW5jdGlvbiBfd2hlbihwcmVkaWNhdGUsIGVmZmVjdCwgb3B0cykge1xuICB2YXIgdGltZW91dEhhbmRsZTtcblxuICBpZiAodHlwZW9mIG9wdHMudGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZGlzcG9zZXJbJG1vYnhdLmlzRGlzcG9zZWRfKSB7XG4gICAgICAgIGRpc3Bvc2VyKCk7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIldIRU5fVElNRU9VVFwiKTtcbiAgICAgICAgaWYgKG9wdHMub25FcnJvcikgb3B0cy5vbkVycm9yKGVycm9yKTtlbHNlIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0sIG9wdHMudGltZW91dCk7XG4gIH1cblxuICBvcHRzLm5hbWUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBvcHRzLm5hbWUgfHwgXCJXaGVuQFwiICsgZ2V0TmV4dElkKCkgOiBcIldoZW5cIjtcbiAgdmFyIGVmZmVjdEFjdGlvbiA9IGNyZWF0ZUFjdGlvbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBvcHRzLm5hbWUgKyBcIi1lZmZlY3RcIiA6IFwiV2hlbi1lZmZlY3RcIiwgZWZmZWN0KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgdmFyIGRpc3Bvc2VyID0gYXV0b3J1bihmdW5jdGlvbiAocikge1xuICAgIC8vIHByZWRpY2F0ZSBzaG91bGQgbm90IGNoYW5nZSBzdGF0ZVxuICAgIHZhciBjb25kID0gYWxsb3dTdGF0ZUNoYW5nZXMoZmFsc2UsIHByZWRpY2F0ZSk7XG5cbiAgICBpZiAoY29uZCkge1xuICAgICAgci5kaXNwb3NlKCk7XG4gICAgICBpZiAodGltZW91dEhhbmRsZSkgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgICAgZWZmZWN0QWN0aW9uKCk7XG4gICAgfVxuICB9LCBvcHRzKTtcbiAgcmV0dXJuIGRpc3Bvc2VyO1xufVxuXG5mdW5jdGlvbiB3aGVuUHJvbWlzZShwcmVkaWNhdGUsIG9wdHMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBvcHRzICYmIG9wdHMub25FcnJvcikgcmV0dXJuIGRpZShcInRoZSBvcHRpb25zICdvbkVycm9yJyBhbmQgJ3Byb21pc2UnIGNhbm5vdCBiZSBjb21iaW5lZFwiKTtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgZGlzcG9zZXIgPSBfd2hlbihwcmVkaWNhdGUsIHJlc29sdmUsIF9leHRlbmRzKHt9LCBvcHRzLCB7XG4gICAgICBvbkVycm9yOiByZWplY3RcbiAgICB9KSk7XG5cbiAgICBjYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICBkaXNwb3NlcigpO1xuICAgICAgcmVqZWN0KFwiV0hFTl9DQU5DRUxMRURcIik7XG4gICAgfTtcbiAgfSk7XG4gIHJlcy5jYW5jZWwgPSBjYW5jZWw7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGdldEFkbSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFskbW9ieF07XG59IC8vIE9wdGltaXphdGlvbjogd2UgZG9uJ3QgbmVlZCB0aGUgaW50ZXJtZWRpYXRlIG9iamVjdHMgYW5kIGNvdWxkIGhhdmUgYSBjb21wbGV0ZWx5IGN1c3RvbSBhZG1pbmlzdHJhdGlvbiBmb3IgRHluYW1pY09iamVjdHMsXG4vLyBhbmQgc2tpcCBlaXRoZXIgdGhlIGludGVybmFsIHZhbHVlcyBtYXAsIG9yIHRoZSBiYXNlIG9iamVjdCB3aXRoIGl0cyBwcm9wZXJ0eSBkZXNjcmlwdG9ycyFcblxuXG52YXIgb2JqZWN0UHJveHlUcmFwcyA9IHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBuYW1lKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJkZXRlY3QgbmV3IHByb3BlcnRpZXMgdXNpbmcgdGhlICdpbicgb3BlcmF0b3IuIFVzZSAnaGFzJyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gZ2V0QWRtKHRhcmdldCkuaGFzXyhuYW1lKTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBuYW1lKSB7XG4gICAgcmV0dXJuIGdldEFkbSh0YXJnZXQpLmdldF8obmFtZSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgX2dldEFkbSRzZXRfO1xuXG4gICAgaWYgKCFpc1N0cmluZ2lzaChuYW1lKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhZ2V0QWRtKHRhcmdldCkudmFsdWVzXy5oYXMobmFtZSkpIHtcbiAgICAgIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJhZGQgYSBuZXcgb2JzZXJ2YWJsZSBwcm9wZXJ0eSB0aHJvdWdoIGRpcmVjdCBhc3NpZ25tZW50LiBVc2UgJ3NldCcgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgfSAvLyBudWxsIChpbnRlcmNlcHRlZCkgLT4gdHJ1ZSAoc3VjY2VzcylcblxuXG4gICAgcmV0dXJuIChfZ2V0QWRtJHNldF8gPSBnZXRBZG0odGFyZ2V0KS5zZXRfKG5hbWUsIHZhbHVlLCB0cnVlKSkgIT0gbnVsbCA/IF9nZXRBZG0kc2V0XyA6IHRydWU7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUpIHtcbiAgICB2YXIgX2dldEFkbSRkZWxldGVfO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcImRlbGV0ZSBwcm9wZXJ0aWVzIGZyb20gYW4gb2JzZXJ2YWJsZSBvYmplY3QuIFVzZSAncmVtb3ZlJyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU3RyaW5naXNoKG5hbWUpKSByZXR1cm4gZmFsc2U7IC8vIG51bGwgKGludGVyY2VwdGVkKSAtPiB0cnVlIChzdWNjZXNzKVxuXG4gICAgcmV0dXJuIChfZ2V0QWRtJGRlbGV0ZV8gPSBnZXRBZG0odGFyZ2V0KS5kZWxldGVfKG5hbWUsIHRydWUpKSAhPSBudWxsID8gX2dldEFkbSRkZWxldGVfIDogdHJ1ZTtcbiAgfSxcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcikge1xuICAgIHZhciBfZ2V0QWRtJGRlZmluZVByb3BlcnQ7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiZGVmaW5lIHByb3BlcnR5IG9uIGFuIG9ic2VydmFibGUgb2JqZWN0LiBVc2UgJ2RlZmluZVByb3BlcnR5JyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICB9IC8vIG51bGwgKGludGVyY2VwdGVkKSAtPiB0cnVlIChzdWNjZXNzKVxuXG5cbiAgICByZXR1cm4gKF9nZXRBZG0kZGVmaW5lUHJvcGVydCA9IGdldEFkbSh0YXJnZXQpLmRlZmluZVByb3BlcnR5XyhuYW1lLCBkZXNjcmlwdG9yKSkgIT0gbnVsbCA/IF9nZXRBZG0kZGVmaW5lUHJvcGVydCA6IHRydWU7XG4gIH0sXG4gIG93bktleXM6IGZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJpdGVyYXRlIGtleXMgdG8gZGV0ZWN0IGFkZGVkIC8gcmVtb3ZlZCBwcm9wZXJ0aWVzLiBVc2UgYGtleXNgIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiBnZXRBZG0odGFyZ2V0KS5vd25LZXlzXygpO1xuICB9LFxuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KSB7XG4gICAgZGllKDEzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXNEeW5hbWljT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIF90YXJnZXQkJG1vYngsIF90YXJnZXQkJG1vYngkcHJveHlfO1xuXG4gIGFzc2VydFByb3hpZXMoKTtcbiAgdGFyZ2V0ID0gYXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XG4gIHJldHVybiAoX3RhcmdldCQkbW9ieCRwcm94eV8gPSAoX3RhcmdldCQkbW9ieCA9IHRhcmdldFskbW9ieF0pLnByb3h5XykgIT0gbnVsbCA/IF90YXJnZXQkJG1vYngkcHJveHlfIDogX3RhcmdldCQkbW9ieC5wcm94eV8gPSBuZXcgUHJveHkodGFyZ2V0LCBvYmplY3RQcm94eVRyYXBzKTtcbn1cblxuZnVuY3Rpb24gaGFzSW50ZXJjZXB0b3JzKGludGVyY2VwdGFibGUpIHtcbiAgcmV0dXJuIGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyAhPT0gdW5kZWZpbmVkICYmIGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXy5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckludGVyY2VwdG9yKGludGVyY2VwdGFibGUsIGhhbmRsZXIpIHtcbiAgdmFyIGludGVyY2VwdG9ycyA9IGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyB8fCAoaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfID0gW10pO1xuICBpbnRlcmNlcHRvcnMucHVzaChoYW5kbGVyKTtcbiAgcmV0dXJuIG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSBpbnRlcmNlcHRvcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkgaW50ZXJjZXB0b3JzLnNwbGljZShpZHgsIDEpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0Q2hhbmdlKGludGVyY2VwdGFibGUsIGNoYW5nZSkge1xuICB2YXIgcHJldlUgPSB1bnRyYWNrZWRTdGFydCgpO1xuXG4gIHRyeSB7XG4gICAgLy8gSW50ZXJjZXB0b3IgY2FuIG1vZGlmeSB0aGUgYXJyYXksIGNvcHkgaXQgdG8gYXZvaWQgY29uY3VycmVudCBtb2RpZmljYXRpb24sIHNlZSAjMTk1MFxuICAgIHZhciBpbnRlcmNlcHRvcnMgPSBbXS5jb25jYXQoaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfIHx8IFtdKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW50ZXJjZXB0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2hhbmdlID0gaW50ZXJjZXB0b3JzW2ldKGNoYW5nZSk7XG4gICAgICBpZiAoY2hhbmdlICYmICFjaGFuZ2UudHlwZSkgZGllKDE0KTtcbiAgICAgIGlmICghY2hhbmdlKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlO1xuICB9IGZpbmFsbHkge1xuICAgIHVudHJhY2tlZEVuZChwcmV2VSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTGlzdGVuZXJzKGxpc3RlbmFibGUpIHtcbiAgcmV0dXJuIGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzXyAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzXy5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVyKGxpc3RlbmFibGUsIGhhbmRsZXIpIHtcbiAgdmFyIGxpc3RlbmVycyA9IGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzXyB8fCAobGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfID0gW10pO1xuICBsaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcbiAgcmV0dXJuIG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSBsaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkgbGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKGxpc3RlbmFibGUsIGNoYW5nZSkge1xuICB2YXIgcHJldlUgPSB1bnRyYWNrZWRTdGFydCgpO1xuICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfO1xuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuO1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0oY2hhbmdlKTtcbiAgfVxuXG4gIHVudHJhY2tlZEVuZChwcmV2VSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VPYnNlcnZhYmxlKHRhcmdldCwgYW5ub3RhdGlvbnMsIG9wdGlvbnMpIHtcbiAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpWyRtb2J4XTtcbiAgc3RhcnRCYXRjaCgpO1xuXG4gIHRyeSB7XG4gICAgdmFyIF9hbm5vdGF0aW9uczsgLy8gRGVmYXVsdCB0byBkZWNvcmF0b3JzXG5cblxuICAgIChfYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucykgIT0gbnVsbCA/IF9hbm5vdGF0aW9ucyA6IGFubm90YXRpb25zID0gY29sbGVjdFN0b3JlZEFubm90YXRpb25zKHRhcmdldCk7IC8vIEFubm90YXRlXG5cbiAgICBvd25LZXlzKGFubm90YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBhZG0ubWFrZV8oa2V5LCBhbm5vdGF0aW9uc1trZXldKTtcbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBlbmRCYXRjaCgpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gbWFrZUF1dG9PYnNlcnZhYmxlKHRhcmdldCwgb3ZlcnJpZGVzLCBvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiAhaXNQbGFpbk9iamVjdChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIGRpZShcIidtYWtlQXV0b09ic2VydmFibGUnIGNhbiBvbmx5IGJlIHVzZWQgZm9yIGNsYXNzZXMgdGhhdCBkb24ndCBoYXZlIGEgc3VwZXJjbGFzc1wiKTtcbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCkpIGRpZShcIm1ha2VBdXRvT2JzZXJ2YWJsZSBjYW4gb25seSBiZSB1c2VkIG9uIG9iamVjdHMgbm90IGFscmVhZHkgbWFkZSBvYnNlcnZhYmxlXCIpO1xuICB9IC8vIE9wdGltaXphdGlvbiAoYXZvaWRzIHZpc2l0aW5nIHByb3RvcylcbiAgLy8gYXNzdW1lcyB0aGF0IGFubm90YXRpb24ubWFrZV8vLmV4dGVuZF8gd29ya3MgdGhlIHNhbWUgZm9yIHBsYWluIG9iamVjdHNcblxuXG4gIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gZXh0ZW5kT2JzZXJ2YWJsZSh0YXJnZXQsIHRhcmdldCwgb3ZlcnJpZGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBhZG0gPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKVskbW9ieF07XG4gIHN0YXJ0QmF0Y2goKTtcblxuICB0cnkge1xuICAgIC8vIFVzZSBjYWNoZWQgaW5mZXJyZWQgYW5ub3RhdGlvbnMgaWYgYXZhaWxhYmxlIChvbmx5IGluIGNsYXNzZXMpXG4gICAgaWYgKHRhcmdldFtpbmZlcnJlZEFubm90YXRpb25zU3ltYm9sXSkge1xuICAgICAgdGFyZ2V0W2luZmVycmVkQW5ub3RhdGlvbnNTeW1ib2xdLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGFkbS5tYWtlXyhrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2lnbm9yZUtleXM7XG5cbiAgICAgIHZhciBpZ25vcmVLZXlzID0gKF9pZ25vcmVLZXlzID0ge30sIF9pZ25vcmVLZXlzWyRtb2J4XSA9IDEsIF9pZ25vcmVLZXlzW2luZmVycmVkQW5ub3RhdGlvbnNTeW1ib2xdID0gMSwgX2lnbm9yZUtleXMuY29uc3RydWN0b3IgPSAxLCBfaWdub3JlS2V5cyk7XG5cbiAgICAgIHZhciBtYWtlID0gZnVuY3Rpb24gbWFrZShrZXkpIHtcbiAgICAgICAgaWYgKGlnbm9yZUtleXNba2V5XSkgcmV0dXJuO1xuICAgICAgICBpZ25vcmVLZXlzW2tleV0gPSAxO1xuICAgICAgICBhZG0ubWFrZV8oa2V5LCAvLyBtdXN0IHBhc3MgXCJ1bmRlZmluZWRcIiBmb3IgeyBrZXk6IHVuZGVmaW5lZCB9XG4gICAgICAgICFvdmVycmlkZXMgPyB0cnVlIDoga2V5IGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlc1trZXldIDogdHJ1ZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgY3VycmVudCA9IHRhcmdldDtcblxuICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIG93bktleXMoY3VycmVudCkuZm9yRWFjaChtYWtlKTtcbiAgICAgICAgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgZW5kQmF0Y2goKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBTUExJQ0UgPSBcInNwbGljZVwiO1xudmFyIFVQREFURSA9IFwidXBkYXRlXCI7XG52YXIgTUFYX1NQTElDRV9TSVpFID0gMTAwMDA7IC8vIFNlZSBlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvODU5XG5cbnZhciBhcnJheVRyYXBzID0ge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCh0YXJnZXQsIG5hbWUpIHtcbiAgICB2YXIgYWRtID0gdGFyZ2V0WyRtb2J4XTtcbiAgICBpZiAobmFtZSA9PT0gJG1vYngpIHJldHVybiBhZG07XG4gICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHJldHVybiBhZG0uZ2V0QXJyYXlMZW5ndGhfKCk7XG5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgJiYgIWlzTmFOKG5hbWUpKSB7XG4gICAgICByZXR1cm4gYWRtLmdldF8ocGFyc2VJbnQobmFtZSkpO1xuICAgIH1cblxuICAgIGlmIChoYXNQcm9wKGFycmF5RXh0ZW5zaW9ucywgbmFtZSkpIHtcbiAgICAgIHJldHVybiBhcnJheUV4dGVuc2lvbnNbbmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFtuYW1lXTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBhZG0gPSB0YXJnZXRbJG1vYnhdO1xuXG4gICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgIGFkbS5zZXRBcnJheUxlbmd0aF8odmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIiB8fCBpc05hTihuYW1lKSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG51bWVyaWMgc3RyaW5nXG4gICAgICBhZG0uc2V0XyhwYXJzZUludChuYW1lKSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoKSB7XG4gICAgZGllKDE1KTtcbiAgfVxufTtcblxudmFyIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gdGhpcyBpcyB0aGUgcHJvcCB0aGF0IGdldHMgcHJveGllZCwgc28gY2FuJ3QgcmVwbGFjZSBpdCFcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24obmFtZSwgZW5oYW5jZXIsIG93bmVkXywgbGVnYWN5TW9kZV8pIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKSA6IFwiT2JzZXJ2YWJsZUFycmF5XCI7XG4gICAgfVxuXG4gICAgdGhpcy5vd25lZF8gPSB2b2lkIDA7XG4gICAgdGhpcy5sZWdhY3lNb2RlXyA9IHZvaWQgMDtcbiAgICB0aGlzLmF0b21fID0gdm9pZCAwO1xuICAgIHRoaXMudmFsdWVzXyA9IFtdO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgdGhpcy5lbmhhbmNlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3h5XyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RLbm93bkxlbmd0aF8gPSAwO1xuICAgIHRoaXMub3duZWRfID0gb3duZWRfO1xuICAgIHRoaXMubGVnYWN5TW9kZV8gPSBsZWdhY3lNb2RlXztcbiAgICB0aGlzLmF0b21fID0gbmV3IEF0b20obmFtZSk7XG5cbiAgICB0aGlzLmVuaGFuY2VyXyA9IGZ1bmN0aW9uIChuZXdWLCBvbGRWKSB7XG4gICAgICByZXR1cm4gZW5oYW5jZXIobmV3Viwgb2xkViwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gbmFtZSArIFwiWy4uXVwiIDogXCJPYnNlcnZhYmxlQXJyYXlbLi5dXCIpO1xuICAgIH07XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZWhhbmNlVmFsdWVfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlXyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZXNfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlc18odmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZXMubGVuZ3RoID4gMCkgcmV0dXJuIHZhbHVlcy5tYXAodGhpcy5kZWhhbmNlcik7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICBfcHJvdG8uaW50ZXJjZXB0XyA9IGZ1bmN0aW9uIGludGVyY2VwdF8oaGFuZGxlcikge1xuICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICB9O1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICBpZiAoZmlyZUltbWVkaWF0ZWx5ID09PSB2b2lkIDApIHtcbiAgICAgIGZpcmVJbW1lZGlhdGVseSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwiYXJyYXlcIixcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLmF0b21fLm5hbWVfLFxuICAgICAgICB0eXBlOiBcInNwbGljZVwiLFxuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgYWRkZWQ6IHRoaXMudmFsdWVzXy5zbGljZSgpLFxuICAgICAgICBhZGRlZENvdW50OiB0aGlzLnZhbHVlc18ubGVuZ3RoLFxuICAgICAgICByZW1vdmVkOiBbXSxcbiAgICAgICAgcmVtb3ZlZENvdW50OiAwXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XG4gIH07XG5cbiAgX3Byb3RvLmdldEFycmF5TGVuZ3RoXyA9IGZ1bmN0aW9uIGdldEFycmF5TGVuZ3RoXygpIHtcbiAgICB0aGlzLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXy5sZW5ndGg7XG4gIH07XG5cbiAgX3Byb3RvLnNldEFycmF5TGVuZ3RoXyA9IGZ1bmN0aW9uIHNldEFycmF5TGVuZ3RoXyhuZXdMZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIG5ld0xlbmd0aCAhPT0gXCJudW1iZXJcIiB8fCBuZXdMZW5ndGggPCAwKSBkaWUoXCJPdXQgb2YgcmFuZ2U6IFwiICsgbmV3TGVuZ3RoKTtcbiAgICB2YXIgY3VycmVudExlbmd0aCA9IHRoaXMudmFsdWVzXy5sZW5ndGg7XG4gICAgaWYgKG5ld0xlbmd0aCA9PT0gY3VycmVudExlbmd0aCkgcmV0dXJuO2Vsc2UgaWYgKG5ld0xlbmd0aCA+IGN1cnJlbnRMZW5ndGgpIHtcbiAgICAgIHZhciBuZXdJdGVtcyA9IG5ldyBBcnJheShuZXdMZW5ndGggLSBjdXJyZW50TGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdMZW5ndGggLSBjdXJyZW50TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3SXRlbXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICB9IC8vIE5vIEFycmF5LmZpbGwgZXZlcnl3aGVyZS4uLlxuXG5cbiAgICAgIHRoaXMuc3BsaWNlV2l0aEFycmF5XyhjdXJyZW50TGVuZ3RoLCAwLCBuZXdJdGVtcyk7XG4gICAgfSBlbHNlIHRoaXMuc3BsaWNlV2l0aEFycmF5XyhuZXdMZW5ndGgsIGN1cnJlbnRMZW5ndGggLSBuZXdMZW5ndGgpO1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVBcnJheUxlbmd0aF8gPSBmdW5jdGlvbiB1cGRhdGVBcnJheUxlbmd0aF8ob2xkTGVuZ3RoLCBkZWx0YSkge1xuICAgIGlmIChvbGRMZW5ndGggIT09IHRoaXMubGFzdEtub3duTGVuZ3RoXykgZGllKDE2KTtcbiAgICB0aGlzLmxhc3RLbm93bkxlbmd0aF8gKz0gZGVsdGE7XG4gICAgaWYgKHRoaXMubGVnYWN5TW9kZV8gJiYgZGVsdGEgPiAwKSByZXNlcnZlQXJyYXlCdWZmZXIob2xkTGVuZ3RoICsgZGVsdGEgKyAxKTtcbiAgfTtcblxuICBfcHJvdG8uc3BsaWNlV2l0aEFycmF5XyA9IGZ1bmN0aW9uIHNwbGljZVdpdGhBcnJheV8oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmF0b21fKTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy52YWx1ZXNfLmxlbmd0aDtcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgaW5kZXggPSAwO2Vsc2UgaWYgKGluZGV4ID4gbGVuZ3RoKSBpbmRleCA9IGxlbmd0aDtlbHNlIGlmIChpbmRleCA8IDApIGluZGV4ID0gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaW5kZXgpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSBkZWxldGVDb3VudCA9IGxlbmd0aCAtIGluZGV4O2Vsc2UgaWYgKGRlbGV0ZUNvdW50ID09PSB1bmRlZmluZWQgfHwgZGVsZXRlQ291bnQgPT09IG51bGwpIGRlbGV0ZUNvdW50ID0gMDtlbHNlIGRlbGV0ZUNvdW50ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGVsZXRlQ291bnQsIGxlbmd0aCAtIGluZGV4KSk7XG4gICAgaWYgKG5ld0l0ZW1zID09PSB1bmRlZmluZWQpIG5ld0l0ZW1zID0gRU1QVFlfQVJSQVk7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgdHlwZTogU1BMSUNFLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHJlbW92ZWRDb3VudDogZGVsZXRlQ291bnQsXG4gICAgICAgIGFkZGVkOiBuZXdJdGVtc1xuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIEVNUFRZX0FSUkFZO1xuICAgICAgZGVsZXRlQ291bnQgPSBjaGFuZ2UucmVtb3ZlZENvdW50O1xuICAgICAgbmV3SXRlbXMgPSBjaGFuZ2UuYWRkZWQ7XG4gICAgfVxuXG4gICAgbmV3SXRlbXMgPSBuZXdJdGVtcy5sZW5ndGggPT09IDAgPyBuZXdJdGVtcyA6IG5ld0l0ZW1zLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIF90aGlzLmVuaGFuY2VyXyh2LCB1bmRlZmluZWQpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMubGVnYWN5TW9kZV8gfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB2YXIgbGVuZ3RoRGVsdGEgPSBuZXdJdGVtcy5sZW5ndGggLSBkZWxldGVDb3VudDtcbiAgICAgIHRoaXMudXBkYXRlQXJyYXlMZW5ndGhfKGxlbmd0aCwgbGVuZ3RoRGVsdGEpOyAvLyBjaGVja3MgaWYgaW50ZXJuYWwgYXJyYXkgd2Fzbid0IG1vZGlmaWVkXG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHRoaXMuc3BsaWNlSXRlbXNJbnRvVmFsdWVzXyhpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKTtcbiAgICBpZiAoZGVsZXRlQ291bnQgIT09IDAgfHwgbmV3SXRlbXMubGVuZ3RoICE9PSAwKSB0aGlzLm5vdGlmeUFycmF5U3BsaWNlXyhpbmRleCwgbmV3SXRlbXMsIHJlcyk7XG4gICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlc18ocmVzKTtcbiAgfTtcblxuICBfcHJvdG8uc3BsaWNlSXRlbXNJbnRvVmFsdWVzXyA9IGZ1bmN0aW9uIHNwbGljZUl0ZW1zSW50b1ZhbHVlc18oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcykge1xuICAgIGlmIChuZXdJdGVtcy5sZW5ndGggPCBNQVhfU1BMSUNFX1NJWkUpIHtcbiAgICAgIHZhciBfdGhpcyR2YWx1ZXNfO1xuXG4gICAgICByZXR1cm4gKF90aGlzJHZhbHVlc18gPSB0aGlzLnZhbHVlc18pLnNwbGljZS5hcHBseShfdGhpcyR2YWx1ZXNfLCBbaW5kZXgsIGRlbGV0ZUNvdW50XS5jb25jYXQobmV3SXRlbXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlcyA9IHRoaXMudmFsdWVzXy5zbGljZShpbmRleCwgaW5kZXggKyBkZWxldGVDb3VudCk7XG4gICAgICB2YXIgb2xkSXRlbXMgPSB0aGlzLnZhbHVlc18uc2xpY2UoaW5kZXggKyBkZWxldGVDb3VudCk7XG4gICAgICB0aGlzLnZhbHVlc18ubGVuZ3RoID0gaW5kZXggKyBuZXdJdGVtcy5sZW5ndGggLSBkZWxldGVDb3VudDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnZhbHVlc19baW5kZXggKyBpXSA9IG5ld0l0ZW1zW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgb2xkSXRlbXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHRoaXMudmFsdWVzX1tpbmRleCArIG5ld0l0ZW1zLmxlbmd0aCArIF9pXSA9IG9sZEl0ZW1zW19pXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm5vdGlmeUFycmF5Q2hpbGRVcGRhdGVfID0gZnVuY3Rpb24gbm90aWZ5QXJyYXlDaGlsZFVwZGF0ZV8oaW5kZXgsIG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIHZhciBub3RpZnlTcHkgPSAhdGhpcy5vd25lZF8gJiYgaXNTcHlFbmFibGVkKCk7XG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgIG9ic2VydmFibGVLaW5kOiBcImFycmF5XCIsXG4gICAgICBvYmplY3Q6IHRoaXMucHJveHlfLFxuICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLmF0b21fLm5hbWVfLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlXG4gICAgfSA6IG51bGw7IC8vIFRoZSByZWFzb24gd2h5IHRoaXMgaXMgb24gcmlnaHQgaGFuZCBzaWRlIGhlcmUgKGFuZCBub3QgYWJvdmUpLCBpcyB0aGlzIHdheSB0aGUgdWdsaWZpZXIgd2lsbCBkcm9wIGl0LCBidXQgaXQgd29uJ3RcbiAgICAvLyBjYXVzZSBhbnkgcnVudGltZSBvdmVyaGVhZCBpbiBkZXZlbG9wbWVudCBtb2RlIHdpdGhvdXQgTk9ERV9FTlYgc2V0LCB1bmxlc3Mgc3B5aW5nIGlzIGVuYWJsZWRcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgIHRoaXMuYXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSBzcHlSZXBvcnRFbmQoKTtcbiAgfTtcblxuICBfcHJvdG8ubm90aWZ5QXJyYXlTcGxpY2VfID0gZnVuY3Rpb24gbm90aWZ5QXJyYXlTcGxpY2VfKGluZGV4LCBhZGRlZCwgcmVtb3ZlZCkge1xuICAgIHZhciBub3RpZnlTcHkgPSAhdGhpcy5vd25lZF8gJiYgaXNTcHlFbmFibGVkKCk7XG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgIG9ic2VydmFibGVLaW5kOiBcImFycmF5XCIsXG4gICAgICBvYmplY3Q6IHRoaXMucHJveHlfLFxuICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLmF0b21fLm5hbWVfLFxuICAgICAgdHlwZTogU1BMSUNFLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgIHJlbW92ZWRDb3VudDogcmVtb3ZlZC5sZW5ndGgsXG4gICAgICBhZGRlZENvdW50OiBhZGRlZC5sZW5ndGhcbiAgICB9IDogbnVsbDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICB0aGlzLmF0b21fLnJlcG9ydENoYW5nZWQoKTsgLy8gY29uZm9ybTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvb2JzZXJ2ZVxuXG4gICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICB9O1xuXG4gIF9wcm90by5nZXRfID0gZnVuY3Rpb24gZ2V0XyhpbmRleCkge1xuICAgIGlmIChpbmRleCA8IHRoaXMudmFsdWVzXy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZV8odGhpcy52YWx1ZXNfW2luZGV4XSk7XG4gICAgfVxuXG4gICAgY29uc29sZS53YXJuKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiW21vYnhdIE91dCBvZiBib3VuZHMgcmVhZDogXCIgKyBpbmRleCA6IFwiW21vYnguYXJyYXldIEF0dGVtcHQgdG8gcmVhZCBhbiBhcnJheSBpbmRleCAoXCIgKyBpbmRleCArIFwiKSB0aGF0IGlzIG91dCBvZiBib3VuZHMgKFwiICsgdGhpcy52YWx1ZXNfLmxlbmd0aCArIFwiKS4gUGxlYXNlIGNoZWNrIGxlbmd0aCBmaXJzdC4gT3V0IG9mIGJvdW5kIGluZGljZXMgd2lsbCBub3QgYmUgdHJhY2tlZCBieSBNb2JYXCIpO1xuICB9O1xuXG4gIF9wcm90by5zZXRfID0gZnVuY3Rpb24gc2V0XyhpbmRleCwgbmV3VmFsdWUpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXNfO1xuXG4gICAgaWYgKGluZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgLy8gdXBkYXRlIGF0IGluZGV4IGluIHJhbmdlXG4gICAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmF0b21fKTtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHZhbHVlc1tpbmRleF07XG5cbiAgICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8sXG4gICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybjtcbiAgICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIG5ld1ZhbHVlID0gdGhpcy5lbmhhbmNlcl8obmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIHZhciBjaGFuZ2VkID0gbmV3VmFsdWUgIT09IG9sZFZhbHVlO1xuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMubm90aWZ5QXJyYXlDaGlsZFVwZGF0ZV8oaW5kZXgsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgLy8gYWRkIGEgbmV3IGl0ZW1cbiAgICAgIHRoaXMuc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgMCwgW25ld1ZhbHVlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG91dCBvZiBib3VuZHNcbiAgICAgIGRpZSgxNywgaW5kZXgsIHZhbHVlcy5sZW5ndGgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb247XG59KCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGVBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSwgb3duZWQpIHtcbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIG5hbWUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk9ic2VydmFibGVBcnJheUBcIiArIGdldE5leHRJZCgpIDogXCJPYnNlcnZhYmxlQXJyYXlcIjtcbiAgfVxuXG4gIGlmIChvd25lZCA9PT0gdm9pZCAwKSB7XG4gICAgb3duZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGFzc2VydFByb3hpZXMoKTtcbiAgdmFyIGFkbSA9IG5ldyBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbihuYW1lLCBlbmhhbmNlciwgb3duZWQsIGZhbHNlKTtcbiAgYWRkSGlkZGVuRmluYWxQcm9wKGFkbS52YWx1ZXNfLCAkbW9ieCwgYWRtKTtcbiAgdmFyIHByb3h5ID0gbmV3IFByb3h5KGFkbS52YWx1ZXNfLCBhcnJheVRyYXBzKTtcbiAgYWRtLnByb3h5XyA9IHByb3h5O1xuXG4gIGlmIChpbml0aWFsVmFsdWVzICYmIGluaXRpYWxWYWx1ZXMubGVuZ3RoKSB7XG4gICAgdmFyIHByZXYgPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KHRydWUpO1xuICAgIGFkbS5zcGxpY2VXaXRoQXJyYXlfKDAsIDAsIGluaXRpYWxWYWx1ZXMpO1xuICAgIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHByZXYpO1xuICB9XG5cbiAgcmV0dXJuIHByb3h5O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuXG52YXIgYXJyYXlFeHRlbnNpb25zID0ge1xuICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKDApO1xuICB9LFxuICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKG5ld0l0ZW1zKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIHJldHVybiBhZG0uc3BsaWNlV2l0aEFycmF5XygwLCBhZG0udmFsdWVzXy5sZW5ndGgsIG5ld0l0ZW1zKTtcbiAgfSxcbiAgLy8gVXNlZCBieSBKU09OLnN0cmluZ2lmeVxuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgpO1xuICB9LFxuXG4gIC8qXHJcbiAgICogZnVuY3Rpb25zIHRoYXQgZG8gYWx0ZXIgdGhlIGludGVybmFsIHN0cnVjdHVyZSBvZiB0aGUgYXJyYXksIChiYXNlZCBvbiBsaWIuZXM2LmQudHMpXHJcbiAgICogc2luY2UgdGhlc2UgZnVuY3Rpb25zIGFsdGVyIHRoZSBpbm5lciBzdHJ1Y3R1cmUgb2YgdGhlIGFycmF5LCB0aGUgaGF2ZSBzaWRlIGVmZmVjdHMuXHJcbiAgICogQmVjYXVzZSB0aGUgaGF2ZSBzaWRlIGVmZmVjdHMsIHRoZXkgc2hvdWxkIG5vdCBiZSB1c2VkIGluIGNvbXB1dGVkIGZ1bmN0aW9uLFxyXG4gICAqIGFuZCBmb3IgdGhhdCByZWFzb24gdGhlIGRvIG5vdCBjYWxsIGRlcGVuZGVuY3lTdGF0ZS5ub3RpZnlPYnNlcnZlZFxyXG4gICAqL1xuICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShpbmRleCwgZGVsZXRlQ291bnQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbmV3SXRlbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgbmV3SXRlbXNbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcblxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW107XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIGFkbS5zcGxpY2VXaXRoQXJyYXlfKGluZGV4KTtcblxuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gYWRtLnNwbGljZVdpdGhBcnJheV8oaW5kZXgsIGRlbGV0ZUNvdW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRtLnNwbGljZVdpdGhBcnJheV8oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcyk7XG4gIH0sXG4gIHNwbGljZVdpdGhBcnJheTogZnVuY3Rpb24gc3BsaWNlV2l0aEFycmF5KGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpIHtcbiAgICByZXR1cm4gdGhpc1skbW9ieF0uc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKTtcbiAgfSxcbiAgcHVzaDogZnVuY3Rpb24gcHVzaCgpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG5cbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBpdGVtc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGFkbS5zcGxpY2VXaXRoQXJyYXlfKGFkbS52YWx1ZXNfLmxlbmd0aCwgMCwgaXRlbXMpO1xuICAgIHJldHVybiBhZG0udmFsdWVzXy5sZW5ndGg7XG4gIH0sXG4gIHBvcDogZnVuY3Rpb24gcG9wKCkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZShNYXRoLm1heCh0aGlzWyRtb2J4XS52YWx1ZXNfLmxlbmd0aCAtIDEsIDApLCAxKVswXTtcbiAgfSxcbiAgc2hpZnQ6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZSgwLCAxKVswXTtcbiAgfSxcbiAgdW5zaGlmdDogZnVuY3Rpb24gdW5zaGlmdCgpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG5cbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBpdGVtc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cblxuICAgIGFkbS5zcGxpY2VXaXRoQXJyYXlfKDAsIDAsIGl0ZW1zKTtcbiAgICByZXR1cm4gYWRtLnZhbHVlc18ubGVuZ3RoO1xuICB9LFxuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIC8vIHJldmVyc2UgYnkgZGVmYXVsdCBtdXRhdGVzIGluIHBsYWNlIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdFxuICAgIC8vIHdoaWNoIG1ha2VzIGl0IGJvdGggYSAnZGVyaXZhdGlvbicgYW5kIGEgJ211dGF0aW9uJy5cbiAgICBpZiAoZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB7XG4gICAgICBkaWUoMzcsIFwicmV2ZXJzZVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcGxhY2UodGhpcy5zbGljZSgpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgLy8gc29ydCBieSBkZWZhdWx0IG11dGF0ZXMgaW4gcGxhY2UgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0XG4gICAgLy8gd2hpY2ggZ29lcyBhZ2FpbnN0IGFsbCBnb29kIHByYWN0aWNlcy4gTGV0J3Mgbm90IGNoYW5nZSB0aGUgYXJyYXkgaW4gcGxhY2UhXG4gICAgaWYgKGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgZGllKDM3LCBcInNvcnRcIik7XG4gICAgfVxuXG4gICAgdmFyIGNvcHkgPSB0aGlzLnNsaWNlKCk7XG4gICAgY29weS5zb3J0LmFwcGx5KGNvcHksIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5yZXBsYWNlKGNvcHkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSh2YWx1ZSkge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICB2YXIgaWR4ID0gYWRtLmRlaGFuY2VWYWx1ZXNfKGFkbS52YWx1ZXNfKS5pbmRleE9mKHZhbHVlKTtcblxuICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgdGhpcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbi8qKlxyXG4gKiBXcmFwIGZ1bmN0aW9uIGZyb20gcHJvdG90eXBlXHJcbiAqIFdpdGhvdXQgdGhpcywgZXZlcnl0aGluZyB3b3JrcyBhcyB3ZWxsLCBidXQgdGhpcyB3b3Jrc1xyXG4gKiBmYXN0ZXIgYXMgZXZlcnl0aGluZyB3b3JrcyBvbiB1bnByb3hpZWQgdmFsdWVzXHJcbiAqL1xuXG5hZGRBcnJheUV4dGVuc2lvbihcImNvbmNhdFwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmxhdFwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiaW5jbHVkZXNcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImluZGV4T2ZcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImpvaW5cIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImxhc3RJbmRleE9mXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJzbGljZVwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwidG9TdHJpbmdcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInRvTG9jYWxlU3RyaW5nXCIsIHNpbXBsZUZ1bmMpOyAvLyBtYXBcblxuYWRkQXJyYXlFeHRlbnNpb24oXCJldmVyeVwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZpbHRlclwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZpbmRcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmaW5kSW5kZXhcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmbGF0TWFwXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZm9yRWFjaFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcIm1hcFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInNvbWVcIiwgbWFwTGlrZUZ1bmMpOyAvLyByZWR1Y2VcblxuYWRkQXJyYXlFeHRlbnNpb24oXCJyZWR1Y2VcIiwgcmVkdWNlTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJyZWR1Y2VSaWdodFwiLCByZWR1Y2VMaWtlRnVuYyk7XG5cbmZ1bmN0aW9uIGFkZEFycmF5RXh0ZW5zaW9uKGZ1bmNOYW1lLCBmdW5jRmFjdG9yeSkge1xuICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZVtmdW5jTmFtZV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGFycmF5RXh0ZW5zaW9uc1tmdW5jTmFtZV0gPSBmdW5jRmFjdG9yeShmdW5jTmFtZSk7XG4gIH1cbn0gLy8gUmVwb3J0IGFuZCBkZWxlZ2F0ZSB0byBkZWhhbmNlZCBhcnJheVxuXG5cbmZ1bmN0aW9uIHNpbXBsZUZ1bmMoZnVuY05hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgYWRtLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgdmFyIGRlaGFuY2VkVmFsdWVzID0gYWRtLmRlaGFuY2VWYWx1ZXNfKGFkbS52YWx1ZXNfKTtcbiAgICByZXR1cm4gZGVoYW5jZWRWYWx1ZXNbZnVuY05hbWVdLmFwcGx5KGRlaGFuY2VkVmFsdWVzLCBhcmd1bWVudHMpO1xuICB9O1xufSAvLyBNYWtlIHN1cmUgY2FsbGJhY2tzIHJlY2lldmUgY29ycmVjdCBhcnJheSBhcmcgIzIzMjZcblxuXG5mdW5jdGlvbiBtYXBMaWtlRnVuYyhmdW5jTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgYWRtLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgdmFyIGRlaGFuY2VkVmFsdWVzID0gYWRtLmRlaGFuY2VWYWx1ZXNfKGFkbS52YWx1ZXNfKTtcbiAgICByZXR1cm4gZGVoYW5jZWRWYWx1ZXNbZnVuY05hbWVdKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgZWxlbWVudCwgaW5kZXgsIF90aGlzMik7XG4gICAgfSk7XG4gIH07XG59IC8vIE1ha2Ugc3VyZSBjYWxsYmFja3MgcmVjaWV2ZSBjb3JyZWN0IGFycmF5IGFyZyAjMjMyNlxuXG5cbmZ1bmN0aW9uIHJlZHVjZUxpa2VGdW5jKGZ1bmNOYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgYWRtLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgdmFyIGRlaGFuY2VkVmFsdWVzID0gYWRtLmRlaGFuY2VWYWx1ZXNfKGFkbS52YWx1ZXNfKTsgLy8gIzI0MzIgLSByZWR1Y2UgYmVoYXZpb3IgZGVwZW5kcyBvbiBhcmd1bWVudHMubGVuZ3RoXG5cbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG5cbiAgICBhcmd1bWVudHNbMF0gPSBmdW5jdGlvbiAoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlLCBpbmRleCwgX3RoaXMzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlaGFuY2VkVmFsdWVzW2Z1bmNOYW1lXS5hcHBseShkZWhhbmNlZFZhbHVlcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIGlzT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uXCIsIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKTtcblxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHRoaW5nKSAmJiBpc09ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKHRoaW5nWyRtb2J4XSk7XG59XG5cbnZhciBfU3ltYm9sJGl0ZXJhdG9yLCBfU3ltYm9sJHRvU3RyaW5nVGFnO1xuXG52YXIgT2JzZXJ2YWJsZU1hcE1hcmtlciA9IHt9O1xudmFyIEFERCA9IFwiYWRkXCI7XG52YXIgREVMRVRFID0gXCJkZWxldGVcIjsgLy8ganVzdCBleHRlbmQgTWFwPyBTZWUgYWxzbyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9uZXN0aGFydXMvMTNiNGQ3NGYyZWY0YTJmNDM1N2RiZDNmYzIzYzFlNTRcbi8vIEJ1dDogaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L2lzc3Vlcy8xNTU2XG5cbl9TeW1ib2wkaXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XG5fU3ltYm9sJHRvU3RyaW5nVGFnID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuXG52YXIgT2JzZXJ2YWJsZU1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIGhhc01hcCwgbm90IGhhc2hNYXAgPi0pLlxuICBmdW5jdGlvbiBPYnNlcnZhYmxlTWFwKGluaXRpYWxEYXRhLCBlbmhhbmNlcl8sIG5hbWVfKSB7XG4gICAgaWYgKGVuaGFuY2VyXyA9PT0gdm9pZCAwKSB7XG4gICAgICBlbmhhbmNlcl8gPSBkZWVwRW5oYW5jZXI7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVfID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWVfID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJPYnNlcnZhYmxlTWFwQFwiICsgZ2V0TmV4dElkKCkgOiBcIk9ic2VydmFibGVNYXBcIjtcbiAgICB9XG5cbiAgICB0aGlzLmVuaGFuY2VyXyA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXNbJG1vYnhdID0gT2JzZXJ2YWJsZU1hcE1hcmtlcjtcbiAgICB0aGlzLmRhdGFfID0gdm9pZCAwO1xuICAgIHRoaXMuaGFzTWFwXyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleXNBdG9tXyA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmhhbmNlcl8gPSBlbmhhbmNlcl87XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKE1hcCkpIHtcbiAgICAgIGRpZSgxOCk7XG4gICAgfVxuXG4gICAgdGhpcy5rZXlzQXRvbV8gPSBjcmVhdGVBdG9tKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5rZXlzKClcIiA6IFwiT2JzZXJ2YWJsZU1hcC5rZXlzKClcIik7XG4gICAgdGhpcy5kYXRhXyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmhhc01hcF8gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5tZXJnZShpbml0aWFsRGF0YSk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhc18gPSBmdW5jdGlvbiBoYXNfKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFfLmhhcyhrZXkpO1xuICB9O1xuXG4gIF9wcm90by5oYXMgPSBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICghZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSByZXR1cm4gdGhpcy5oYXNfKGtleSk7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5oYXNNYXBfLmdldChrZXkpO1xuXG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgdmFyIG5ld0VudHJ5ID0gZW50cnkgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKHRoaXMuaGFzXyhrZXkpLCByZWZlcmVuY2VFbmhhbmNlciwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLlwiICsgc3RyaW5naWZ5S2V5KGtleSkgKyBcIj9cIiA6IFwiT2JzZXJ2YWJsZU1hcC5rZXk/XCIsIGZhbHNlKTtcbiAgICAgIHRoaXMuaGFzTWFwXy5zZXQoa2V5LCBuZXdFbnRyeSk7XG4gICAgICBvbkJlY29tZVVub2JzZXJ2ZWQobmV3RW50cnksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhc01hcF9bXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRyeS5nZXQoKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICB2YXIgaGFzS2V5ID0gdGhpcy5oYXNfKGtleSk7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogaGFzS2V5ID8gVVBEQVRFIDogQURELFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbmFtZToga2V5XG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gdGhpcztcbiAgICAgIHZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgIH1cblxuICAgIGlmIChoYXNLZXkpIHtcbiAgICAgIHRoaXMudXBkYXRlVmFsdWVfKGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZFZhbHVlXyhrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG9bXCJkZWxldGVcIl0gPSBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5rZXlzQXRvbV8pO1xuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuYW1lOiBrZXlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNfKGtleSkpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG5cbiAgICAgIHZhciBfY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwibWFwXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogREVMRVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG9sZFZhbHVlOiB0aGlzLmRhdGFfLmdldChrZXkpLnZhbHVlXyxcbiAgICAgICAgbmFtZToga2V5XG4gICAgICB9IDogbnVsbDtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UpO1xuICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcblxuICAgICAgICBfdGhpczIudXBkYXRlSGFzTWFwRW50cnlfKGtleSwgZmFsc2UpO1xuXG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gX3RoaXMyLmRhdGFfLmdldChrZXkpO1xuXG4gICAgICAgIG9ic2VydmFibGUuc2V0TmV3VmFsdWVfKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgX3RoaXMyLmRhdGFfW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlSGFzTWFwRW50cnlfID0gZnVuY3Rpb24gdXBkYXRlSGFzTWFwRW50cnlfKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmhhc01hcF8uZ2V0KGtleSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnNldE5ld1ZhbHVlXyh2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by51cGRhdGVWYWx1ZV8gPSBmdW5jdGlvbiB1cGRhdGVWYWx1ZV8oa2V5LCBuZXdWYWx1ZSkge1xuICAgIHZhciBvYnNlcnZhYmxlID0gdGhpcy5kYXRhXy5nZXQoa2V5KTtcbiAgICBuZXdWYWx1ZSA9IG9ic2VydmFibGUucHJlcGFyZU5ld1ZhbHVlXyhuZXdWYWx1ZSk7XG5cbiAgICBpZiAobmV3VmFsdWUgIT09IGdsb2JhbFN0YXRlLlVOQ0hBTkdFRCkge1xuICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJtYXBcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgb2xkVmFsdWU6IG9ic2VydmFibGUudmFsdWVfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgfSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICAgIG9ic2VydmFibGUuc2V0TmV3VmFsdWVfKG5ld1ZhbHVlKTtcbiAgICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYWRkVmFsdWVfID0gZnVuY3Rpb24gYWRkVmFsdWVfKGtleSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMua2V5c0F0b21fKTtcbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUobmV3VmFsdWUsIF90aGlzMy5lbmhhbmNlcl8sIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IF90aGlzMy5uYW1lXyArIFwiLlwiICsgc3RyaW5naWZ5S2V5KGtleSkgOiBcIk9ic2VydmFibGVNYXAua2V5XCIsIGZhbHNlKTtcblxuICAgICAgX3RoaXMzLmRhdGFfLnNldChrZXksIG9ic2VydmFibGUpO1xuXG4gICAgICBuZXdWYWx1ZSA9IG9ic2VydmFibGUudmFsdWVfOyAvLyB2YWx1ZSBtaWdodCBoYXZlIGJlZW4gY2hhbmdlZFxuXG4gICAgICBfdGhpczMudXBkYXRlSGFzTWFwRW50cnlfKGtleSwgdHJ1ZSk7XG5cbiAgICAgIF90aGlzMy5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgIH0pO1xuICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwibWFwXCIsXG4gICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICB0eXBlOiBBREQsXG4gICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICBuYW1lOiBrZXksXG4gICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICB9IDogbnVsbDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAodGhpcy5oYXMoa2V5KSkgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlXyh0aGlzLmRhdGFfLmdldChrZXkpLmdldCgpKTtcbiAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVfKHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZV8gPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWVfKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8ua2V5cyA9IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5kYXRhXy5rZXlzKCk7XG4gIH07XG5cbiAgX3Byb3RvLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXMoKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBfa2V5cyRuZXh0ID0ga2V5cy5uZXh0KCksXG4gICAgICAgICAgICBkb25lID0gX2tleXMkbmV4dC5kb25lLFxuICAgICAgICAgICAgdmFsdWUgPSBfa2V5cyRuZXh0LnZhbHVlO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZG9uZSxcbiAgICAgICAgICB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IHNlbGYuZ2V0KHZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5lbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXMoKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBfa2V5cyRuZXh0MiA9IGtleXMubmV4dCgpLFxuICAgICAgICAgICAgZG9uZSA9IF9rZXlzJG5leHQyLmRvbmUsXG4gICAgICAgICAgICB2YWx1ZSA9IF9rZXlzJG5leHQyLnZhbHVlO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZG9uZSxcbiAgICAgICAgICB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IFt2YWx1ZSwgc2VsZi5nZXQodmFsdWUpXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90b1tfU3ltYm9sJGl0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0aGlzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zdGVwLnZhbHVlLFxuICAgICAgICAgIGtleSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgIHZhbHVlID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKiogTWVyZ2UgYW5vdGhlciBvYmplY3QgaW50byB0aGlzIG9iamVjdCwgcmV0dXJucyB0aGlzLiAqL1xuICA7XG5cbiAgX3Byb3RvLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2Uob3RoZXIpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmIChpc09ic2VydmFibGVNYXAob3RoZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBNYXAob3RoZXIpO1xuICAgIH1cblxuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KG90aGVyKSkgZ2V0UGxhaW5PYmplY3RLZXlzKG90aGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5zZXQoa2V5LCBvdGhlcltrZXldKTtcbiAgICAgIH0pO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkob3RoZXIpKSBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBrZXkgPSBfcmVmWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBfcmVmWzFdO1xuICAgICAgICByZXR1cm4gX3RoaXM0LnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0pO2Vsc2UgaWYgKGlzRVM2TWFwKG90aGVyKSkge1xuICAgICAgICBpZiAob3RoZXIuY29uc3RydWN0b3IgIT09IE1hcCkgZGllKDE5LCBvdGhlcik7XG4gICAgICAgIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyICE9PSBudWxsICYmIG90aGVyICE9PSB1bmRlZmluZWQpIGRpZSgyMCwgb3RoZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgdW50cmFja2VkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoX3RoaXM1LmtleXMoKSksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIF90aGlzNVtcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UodmFsdWVzKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7IC8vIEltcGxlbWVudGF0aW9uIHJlcXVpcmVtZW50czpcbiAgICAvLyAtIHJlc3BlY3Qgb3JkZXJpbmcgb2YgcmVwbGFjZW1lbnQgbWFwXG4gICAgLy8gLSBhbGxvdyBpbnRlcmNlcHRvcnMgdG8gcnVuIGFuZCBwb3RlbnRpYWxseSBwcmV2ZW50IGluZGl2aWR1YWwgb3BlcmF0aW9uc1xuICAgIC8vIC0gZG9uJ3QgcmVjcmVhdGUgb2JzZXJ2YWJsZXMgdGhhdCBhbHJlYWR5IGV4aXN0IGluIG9yaWdpbmFsIG1hcCAoc28gd2UgZG9uJ3QgZGVzdHJveSBleGlzdGluZyBzdWJzY3JpcHRpb25zKVxuICAgIC8vIC0gZG9uJ3QgX2tleXNBdG9tLnJlcG9ydENoYW5nZWQgaWYgdGhlIGtleXMgb2YgcmVzdWx0aW5nIG1hcCBhcmUgaW5kZW50aWNhbCAob3JkZXIgbWF0dGVycyEpXG4gICAgLy8gLSBub3RlIHRoYXQgcmVzdWx0IG1hcCBtYXkgZGlmZmVyIGZyb20gcmVwbGFjZW1lbnQgbWFwIGR1ZSB0byB0aGUgaW50ZXJjZXB0b3JzXG5cblxuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gbWFwIHNvIHdlIGNhbiBkbyBxdWljayBrZXkgbG9va3Vwc1xuICAgICAgdmFyIHJlcGxhY2VtZW50TWFwID0gY29udmVydFRvTWFwKHZhbHVlcyk7XG4gICAgICB2YXIgb3JkZXJlZERhdGEgPSBuZXcgTWFwKCk7IC8vIFVzZWQgZm9yIG9wdGltaXphdGlvblxuXG4gICAgICB2YXIga2V5c1JlcG9ydENoYW5nZWRDYWxsZWQgPSBmYWxzZTsgLy8gRGVsZXRlIGtleXMgdGhhdCBkb24ndCBleGlzdCBpbiByZXBsYWNlbWVudCBtYXBcbiAgICAgIC8vIGlmIHRoZSBrZXkgZGVsZXRpb24gaXMgcHJldmVudGVkIGJ5IGludGVyY2VwdG9yXG4gICAgICAvLyBhZGQgZW50cnkgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVzdWx0IG1hcFxuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShfdGhpczYuZGF0YV8ua2V5cygpKSwgX3N0ZXAzOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGtleSA9IF9zdGVwMy52YWx1ZTsgLy8gQ29uY3VycmVudGx5IGl0ZXJhdGluZy9kZWxldGluZyBrZXlzXG4gICAgICAgIC8vIGl0ZXJhdG9yIHNob3VsZCBoYW5kbGUgdGhpcyBjb3JyZWN0bHlcblxuICAgICAgICBpZiAoIXJlcGxhY2VtZW50TWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgdmFyIGRlbGV0ZWQgPSBfdGhpczZbXCJkZWxldGVcIl0oa2V5KTsgLy8gV2FzIHRoZSBrZXkgcmVtb3ZlZD9cblxuXG4gICAgICAgICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgICAgIC8vIF9rZXlzQXRvbS5yZXBvcnRDaGFuZ2VkKCkgd2FzIGFscmVhZHkgY2FsbGVkXG4gICAgICAgICAgICBrZXlzUmVwb3J0Q2hhbmdlZENhbGxlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERlbGV0ZSBwcmV2ZW50ZWQgYnkgaW50ZXJjZXB0b3JcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF90aGlzNi5kYXRhXy5nZXQoa2V5KTtcblxuICAgICAgICAgICAgb3JkZXJlZERhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBNZXJnZSBlbnRyaWVzXG5cblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UocmVwbGFjZW1lbnRNYXAuZW50cmllcygpKSwgX3N0ZXA0OyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwNCR2YWx1ZSA9IF9zdGVwNC52YWx1ZSxcbiAgICAgICAgICAgIF9rZXkgPSBfc3RlcDQkdmFsdWVbMF0sXG4gICAgICAgICAgICBfdmFsdWUgPSBfc3RlcDQkdmFsdWVbMV07IC8vIFdlIHdpbGwgd2FudCB0byBrbm93IHdoZXRoZXIgYSBuZXcga2V5IGlzIGFkZGVkXG5cbiAgICAgICAgdmFyIGtleUV4aXN0ZWQgPSBfdGhpczYuZGF0YV8uaGFzKF9rZXkpOyAvLyBBZGQgb3IgdXBkYXRlIHZhbHVlXG5cblxuICAgICAgICBfdGhpczYuc2V0KF9rZXksIF92YWx1ZSk7IC8vIFRoZSBhZGRpdGlvbiBjb3VsZCBoYXZlIGJlZW4gcHJldmVudCBieSBpbnRlcmNlcHRvclxuXG5cbiAgICAgICAgaWYgKF90aGlzNi5kYXRhXy5oYXMoX2tleSkpIHtcbiAgICAgICAgICAvLyBUaGUgdXBkYXRlIGNvdWxkIGhhdmUgYmVlbiBwcmV2ZW50ZWQgYnkgaW50ZXJjZXB0b3JcbiAgICAgICAgICAvLyBhbmQgYWxzbyB3ZSB3YW50IHRvIHByZXNlcnZlIGV4aXN0aW5nIHZhbHVlc1xuICAgICAgICAgIC8vIHNvIHVzZSB2YWx1ZSBmcm9tIF9kYXRhIG1hcCAoaW5zdGVhZCBvZiByZXBsYWNlbWVudCBtYXApXG4gICAgICAgICAgdmFyIF92YWx1ZTIgPSBfdGhpczYuZGF0YV8uZ2V0KF9rZXkpO1xuXG4gICAgICAgICAgb3JkZXJlZERhdGEuc2V0KF9rZXksIF92YWx1ZTIpOyAvLyBXYXMgYSBuZXcga2V5IGFkZGVkP1xuXG4gICAgICAgICAgaWYgKCFrZXlFeGlzdGVkKSB7XG4gICAgICAgICAgICAvLyBfa2V5c0F0b20ucmVwb3J0Q2hhbmdlZCgpIHdhcyBhbHJlYWR5IGNhbGxlZFxuICAgICAgICAgICAga2V5c1JlcG9ydENoYW5nZWRDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDaGVjayBmb3IgcG9zc2libGUga2V5IG9yZGVyIGNoYW5nZVxuXG5cbiAgICAgIGlmICgha2V5c1JlcG9ydENoYW5nZWRDYWxsZWQpIHtcbiAgICAgICAgaWYgKF90aGlzNi5kYXRhXy5zaXplICE9PSBvcmRlcmVkRGF0YS5zaXplKSB7XG4gICAgICAgICAgLy8gSWYgc2l6ZSBkaWZmZXJzLCBrZXlzIGFyZSBkZWZpbml0ZWx5IG1vZGlmaWVkXG4gICAgICAgICAgX3RoaXM2LmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGl0ZXIxID0gX3RoaXM2LmRhdGFfLmtleXMoKTtcblxuICAgICAgICAgIHZhciBpdGVyMiA9IG9yZGVyZWREYXRhLmtleXMoKTtcbiAgICAgICAgICB2YXIgbmV4dDEgPSBpdGVyMS5uZXh0KCk7XG4gICAgICAgICAgdmFyIG5leHQyID0gaXRlcjIubmV4dCgpO1xuXG4gICAgICAgICAgd2hpbGUgKCFuZXh0MS5kb25lKSB7XG4gICAgICAgICAgICBpZiAobmV4dDEudmFsdWUgIT09IG5leHQyLnZhbHVlKSB7XG4gICAgICAgICAgICAgIF90aGlzNi5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXh0MSA9IGl0ZXIxLm5leHQoKTtcbiAgICAgICAgICAgIG5leHQyID0gaXRlcjIubmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBVc2UgY29ycmVjdGx5IG9yZGVyZWQgbWFwXG5cblxuICAgICAgX3RoaXM2LmRhdGFfID0gb3JkZXJlZERhdGE7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBPYnNlcnZhYmxlTWFwXVwiO1xuICB9O1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIE9ic2VydmVzIHRoaXMgb2JqZWN0LiBUcmlnZ2VycyBmb3IgdGhlIGV2ZW50cyAnYWRkJywgJ3VwZGF0ZScgYW5kICdkZWxldGUnLlxyXG4gICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L29ic2VydmVcclxuICAgKiBmb3IgY2FsbGJhY2sgZGV0YWlsc1xyXG4gICAqL1xuXG5cbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IGZpcmVJbW1lZGlhdGVseT10cnVlIGluIGNvbWJpbmF0aW9uIHdpdGggbWFwcy5cIik7XG4gICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xuICB9O1xuXG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGVNYXAsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCR0b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcIk1hcFwiO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYnNlcnZhYmxlTWFwO1xufSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuXG52YXIgaXNPYnNlcnZhYmxlTWFwID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlTWFwXCIsIE9ic2VydmFibGVNYXApO1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9NYXAoZGF0YVN0cnVjdHVyZSkge1xuICBpZiAoaXNFUzZNYXAoZGF0YVN0cnVjdHVyZSkgfHwgaXNPYnNlcnZhYmxlTWFwKGRhdGFTdHJ1Y3R1cmUpKSB7XG4gICAgcmV0dXJuIGRhdGFTdHJ1Y3R1cmU7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhU3RydWN0dXJlKSkge1xuICAgIHJldHVybiBuZXcgTWFwKGRhdGFTdHJ1Y3R1cmUpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoZGF0YVN0cnVjdHVyZSkpIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGRhdGFTdHJ1Y3R1cmUpIHtcbiAgICAgIG1hcC5zZXQoa2V5LCBkYXRhU3RydWN0dXJlW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpZSgyMSwgZGF0YVN0cnVjdHVyZSk7XG4gIH1cbn1cblxudmFyIF9TeW1ib2wkaXRlcmF0b3IkMSwgX1N5bWJvbCR0b1N0cmluZ1RhZyQxO1xuXG52YXIgT2JzZXJ2YWJsZVNldE1hcmtlciA9IHt9O1xuX1N5bWJvbCRpdGVyYXRvciQxID0gU3ltYm9sLml0ZXJhdG9yO1xuX1N5bWJvbCR0b1N0cmluZ1RhZyQxID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuXG52YXIgT2JzZXJ2YWJsZVNldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGVTZXQoaW5pdGlhbERhdGEsIGVuaGFuY2VyLCBuYW1lXykge1xuICAgIGlmIChlbmhhbmNlciA9PT0gdm9pZCAwKSB7XG4gICAgICBlbmhhbmNlciA9IGRlZXBFbmhhbmNlcjtcbiAgICB9XG5cbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk9ic2VydmFibGVTZXRAXCIgKyBnZXROZXh0SWQoKSA6IFwiT2JzZXJ2YWJsZVNldFwiO1xuICAgIH1cblxuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpc1skbW9ieF0gPSBPYnNlcnZhYmxlU2V0TWFya2VyO1xuICAgIHRoaXMuZGF0YV8gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5hdG9tXyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmhhbmNlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKFNldCkpIHtcbiAgICAgIGRpZSgyMik7XG4gICAgfVxuXG4gICAgdGhpcy5hdG9tXyA9IGNyZWF0ZUF0b20odGhpcy5uYW1lXyk7XG5cbiAgICB0aGlzLmVuaGFuY2VyXyA9IGZ1bmN0aW9uIChuZXdWLCBvbGRWKSB7XG4gICAgICByZXR1cm4gZW5oYW5jZXIobmV3Viwgb2xkViwgbmFtZV8pO1xuICAgIH07XG5cbiAgICBpZiAoaW5pdGlhbERhdGEpIHtcbiAgICAgIHRoaXMucmVwbGFjZShpbml0aWFsRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVTZXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZWhhbmNlVmFsdWVfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlXyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoX3RoaXMuZGF0YV8udmFsdWVzKCkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgX3RoaXNbXCJkZWxldGVcIl0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tGbiwgdGhpc0FyZykge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRoaXMpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgdmFyIHZhbHVlID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgY2FsbGJhY2tGbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCB2YWx1ZSwgdGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMuYXRvbV8pO1xuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuZXdWYWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiB0aGlzOyAvLyBpZGVhbGx5LCB2YWx1ZSA9IGNoYW5nZS52YWx1ZSB3b3VsZCBiZSBkb25lIGhlcmUsIHNvIHRoYXQgdmFsdWVzIGNhbiBiZVxuICAgICAgLy8gY2hhbmdlZCBieSBpbnRlcmNlcHRvci4gU2FtZSBhcHBsaWVzIGZvciBvdGhlciBTZXQgYW5kIE1hcCBhcGkncy5cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuZGF0YV8uYWRkKF90aGlzMi5lbmhhbmNlcl8odmFsdWUsIHVuZGVmaW5lZCkpO1xuXG4gICAgICAgIF90aGlzMi5hdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCk7XG4gICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuXG4gICAgICB2YXIgX2NoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInNldFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuZXdWYWx1ZTogdmFsdWVcbiAgICAgIH0gOiBudWxsO1xuXG4gICAgICBpZiAobm90aWZ5U3B5ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZSk7XG4gICAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZSk7XG4gICAgICBpZiAobm90aWZ5U3B5ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgc3B5UmVwb3J0RW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gX2RlbGV0ZSh2YWx1ZSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXModmFsdWUpKSB7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcblxuICAgICAgdmFyIF9jaGFuZ2UyID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwic2V0XCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogREVMRVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG9sZFZhbHVlOiB2YWx1ZVxuICAgICAgfSA6IG51bGw7XG5cbiAgICAgIGlmIChub3RpZnlTcHkgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSBzcHlSZXBvcnRTdGFydChfY2hhbmdlMik7XG4gICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5hdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG5cbiAgICAgICAgX3RoaXMzLmRhdGFfW1wiZGVsZXRlXCJdKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UyKTtcbiAgICAgIGlmIChub3RpZnlTcHkgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaGFzID0gZnVuY3Rpb24gaGFzKHZhbHVlKSB7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiB0aGlzLmRhdGFfLmhhcyh0aGlzLmRlaGFuY2VWYWx1ZV8odmFsdWUpKTtcbiAgfTtcblxuICBfcHJvdG8uZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgdmFyIGtleXMgPSBBcnJheS5mcm9tKHRoaXMua2V5cygpKTtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkuZnJvbSh0aGlzLnZhbHVlcygpKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgbmV4dEluZGV4ICs9IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA8IHZhbHVlcy5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IFtrZXlzW2luZGV4XSwgdmFsdWVzW2luZGV4XV0sXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmtleXMgPSBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICB9O1xuXG4gIF9wcm90by52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICB2YXIgb2JzZXJ2YWJsZVZhbHVlcyA9IEFycmF5LmZyb20odGhpcy5kYXRhXy52YWx1ZXMoKSk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICByZXR1cm4gbmV4dEluZGV4IDwgb2JzZXJ2YWJsZVZhbHVlcy5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IHNlbGYuZGVoYW5jZVZhbHVlXyhvYnNlcnZhYmxlVmFsdWVzW25leHRJbmRleCsrXSksXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKG90aGVyKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlU2V0KG90aGVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2V0KG90aGVyKTtcbiAgICB9XG5cbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvdGhlcikpIHtcbiAgICAgICAgX3RoaXM0LmNsZWFyKCk7XG5cbiAgICAgICAgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc0VTNlNldChvdGhlcikpIHtcbiAgICAgICAgX3RoaXM0LmNsZWFyKCk7XG5cbiAgICAgICAgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvdGhlciAhPT0gbnVsbCAmJiBvdGhlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpZShcIkNhbm5vdCBpbml0aWFsaXplIHNldCBmcm9tIFwiICsgb3RoZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAvLyAuLi4gJ2ZpcmVJbW1lZGlhdGVseScgY291bGQgYWxzbyBiZSB0cnVlP1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IGZpcmVJbW1lZGlhdGVseT10cnVlIGluIGNvbWJpbmF0aW9uIHdpdGggc2V0cy5cIik7XG4gICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xuICB9O1xuXG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IE9ic2VydmFibGVTZXRdXCI7XG4gIH07XG5cbiAgX3Byb3RvW19TeW1ib2wkaXRlcmF0b3IkMV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGVTZXQsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnJDEsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJTZXRcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2JzZXJ2YWJsZVNldDtcbn0oKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cblxudmFyIGlzT2JzZXJ2YWJsZVNldCA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZVNldFwiLCBPYnNlcnZhYmxlU2V0KTtcbnZhciBpbmZlcnJlZEFubm90YXRpb25zU3ltYm9sID0gLyojX19QVVJFX18qL1N5bWJvbChcIm1vYngtaW5mZXJyZWQtYW5ub3RhdGlvbnNcIik7XG52YXIgZGVzY3JpcHRvckNhY2hlID0gLyojX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG52YXIgUkVNT1ZFID0gXCJyZW1vdmVcIjtcblxudmFyIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbih0YXJnZXRfLCB2YWx1ZXNfLCBuYW1lXywgLy8gVXNlZCBhbnl0aW1lIGFubm90YXRpb24gaXMgbm90IGV4cGxpY2l0ZWx5IHByb3ZpZGVkXG4gIGRlZmF1bHRBbm5vdGF0aW9uXywgLy8gQmluZCBhdXRvbWF0aWNhbGx5IGluZmVycmVkIGFjdGlvbnM/XG4gIGF1dG9CaW5kXykge1xuICAgIGlmICh2YWx1ZXNfID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlc18gPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRBbm5vdGF0aW9uXyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0QW5ub3RhdGlvbl8gPSBvYnNlcnZhYmxlO1xuICAgIH1cblxuICAgIGlmIChhdXRvQmluZF8gPT09IHZvaWQgMCkge1xuICAgICAgYXV0b0JpbmRfID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy50YXJnZXRfID0gdm9pZCAwO1xuICAgIHRoaXMudmFsdWVzXyA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVmYXVsdEFubm90YXRpb25fID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0b0JpbmRfID0gdm9pZCAwO1xuICAgIHRoaXMua2V5c0F0b21fID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5wcm94eV8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc1BsYWluT2JqZWN0XyA9IHZvaWQgMDtcbiAgICB0aGlzLmFwcGxpZWRBbm5vdGF0aW9uc18gPSB2b2lkIDA7XG4gICAgdGhpcy5wZW5kaW5nS2V5c18gPSB2b2lkIDA7XG4gICAgdGhpcy50YXJnZXRfID0gdGFyZ2V0XztcbiAgICB0aGlzLnZhbHVlc18gPSB2YWx1ZXNfO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgICB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXyA9IGRlZmF1bHRBbm5vdGF0aW9uXztcbiAgICB0aGlzLmF1dG9CaW5kXyA9IGF1dG9CaW5kXztcbiAgICB0aGlzLmtleXNBdG9tXyA9IG5ldyBBdG9tKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5rZXlzXCIgOiBcIk9ic2VydmFibGVPYmplY3Qua2V5c1wiKTsgLy8gT3B0aW1pemF0aW9uOiB3ZSB1c2UgdGhpcyBmcmVxdWVudGx5XG5cbiAgICB0aGlzLmlzUGxhaW5PYmplY3RfID0gaXNQbGFpbk9iamVjdCh0aGlzLnRhcmdldF8pO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNBbm5vdGF0aW9uKHRoaXMuZGVmYXVsdEFubm90YXRpb25fKSkge1xuICAgICAgZGllKFwiZGVmYXVsdEFubm90YXRpb24gbXVzdCBiZSB2YWxpZCBhbm5vdGF0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdHlwZW9mIHRoaXMuYXV0b0JpbmRfICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgZGllKFwiYXV0b0JpbmQgbXVzdCBiZSBib29sZWFuXCIpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIC8vIFByZXBhcmUgc3RydWN0dXJlIGZvciB0cmFja2luZyB3aGljaCBmaWVsZHMgd2VyZSBhbHJlYWR5IGFubm90YXRlZFxuICAgICAgdGhpcy5hcHBsaWVkQW5ub3RhdGlvbnNfID0ge307XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldE9ic2VydmFibGVQcm9wVmFsdWVfID0gZnVuY3Rpb24gZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXy5nZXQoa2V5KS5nZXQoKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8gPSBmdW5jdGlvbiBzZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXksIG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLnZhbHVlc18uZ2V0KGtleSk7XG5cbiAgICBpZiAob2JzZXJ2YWJsZSBpbnN0YW5jZW9mIENvbXB1dGVkVmFsdWUpIHtcbiAgICAgIG9ic2VydmFibGUuc2V0KG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gaW50ZXJjZXB0XG5cblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIG51bGw7XG4gICAgICBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICB9XG5cbiAgICBuZXdWYWx1ZSA9IG9ic2VydmFibGUucHJlcGFyZU5ld1ZhbHVlXyhuZXdWYWx1ZSk7IC8vIG5vdGlmeSBzcHkgJiBvYnNlcnZlcnNcblxuICAgIGlmIChuZXdWYWx1ZSAhPT0gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEKSB7XG4gICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgdmFyIG5vdGlmeVNweSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1NweUVuYWJsZWQoKTtcblxuICAgICAgdmFyIF9jaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm9iamVjdFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBvbGRWYWx1ZTogb2JzZXJ2YWJsZS52YWx1ZV8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9IDogbnVsbDtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UpO1xuICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5nZXRfID0gZnVuY3Rpb24gZ2V0XyhrZXkpIHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uICYmICFoYXNQcm9wKHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgLy8gS2V5IGRvZXNuJ3QgZXhpc3QgeWV0LCBzdWJzY3JpYmUgZm9yIGl0IGluIGNhc2UgaXQncyBhZGRlZCBsYXRlclxuICAgICAgdGhpcy5oYXNfKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0X1trZXldO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxyXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxyXG4gICAqIEBwYXJhbSB7QW5ub3RhdGlvbnxib29sZWFufSBhbm5vdGF0aW9uIHRydWUgLSBpbmZlciBmcm9tIGRlc2NyaXB0b3IsIGZhbHNlIC0gY29weSBhcyBpc1xyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJveHlUcmFwIHdoZXRoZXIgaXQncyBjYWxsZWQgZnJvbSBwcm94eSB0cmFwXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbH0gdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlIChwcm94eVRyYXAgKyBub24tY29uZmlndXJhYmxlKSwgbnVsbCB3aGVuIGNhbmNlbGxlZCBieSBpbnRlcmNlcHRvclxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldF8gPSBmdW5jdGlvbiBzZXRfKGtleSwgdmFsdWUsIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfSAvLyBEb24ndCB1c2UgLmhhcyhrZXkpIC0gd2UgY2FyZSBhYm91dCBvd25cblxuXG4gICAgaWYgKGhhc1Byb3AodGhpcy50YXJnZXRfLCBrZXkpKSB7XG4gICAgICAvLyBFeGlzdGluZyBwcm9wXG4gICAgICBpZiAodGhpcy52YWx1ZXNfLmhhcyhrZXkpKSB7XG4gICAgICAgIC8vIE9ic2VydmFibGUgKGNhbiBiZSBpbnRlcmNlcHRlZClcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICAvLyBOb24tb2JzZXJ2YWJsZSAtIHByb3h5XG4gICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0aGlzLnRhcmdldF8sIGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9uLW9ic2VydmFibGVcbiAgICAgICAgdGhpcy50YXJnZXRfW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5ldyBwcm9wXG4gICAgICByZXR1cm4gdGhpcy5leHRlbmRfKGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0sIHRoaXMuZGVmYXVsdEFubm90YXRpb25fLCBwcm94eVRyYXApO1xuICAgIH1cbiAgfSAvLyBUcmFwIGZvciBcImluXCJcbiAgO1xuXG4gIF9wcm90by5oYXNfID0gZnVuY3Rpb24gaGFzXyhrZXkpIHtcbiAgICBpZiAoIWdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgLy8gU2tpcCBrZXkgc3Vic2NyaXB0aW9uIG91dHNpZGUgZGVyaXZhdGlvblxuICAgICAgcmV0dXJuIGtleSBpbiB0aGlzLnRhcmdldF87XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nS2V5c18gfHwgKHRoaXMucGVuZGluZ0tleXNfID0gbmV3IE1hcCgpKTtcbiAgICB2YXIgZW50cnkgPSB0aGlzLnBlbmRpbmdLZXlzXy5nZXQoa2V5KTtcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGVudHJ5ID0gbmV3IE9ic2VydmFibGVWYWx1ZShrZXkgaW4gdGhpcy50YXJnZXRfLCByZWZlcmVuY2VFbmhhbmNlciwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLlwiICsgc3RyaW5naWZ5S2V5KGtleSkgKyBcIj9cIiA6IFwiT2JzZXJ2YWJsZU9iamVjdC5rZXk/XCIsIGZhbHNlKTtcbiAgICAgIHRoaXMucGVuZGluZ0tleXNfLnNldChrZXksIGVudHJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW50cnkuZ2V0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XHJcbiAgICogQHBhcmFtIHtBbm5vdGF0aW9ufGJvb2xlYW59IGFubm90YXRpb24gdHJ1ZSAtIGluZmVyIGZyb20gb2JqZWN0IG9yIGl0J3MgcHJvdG90eXBlLCBmYWxzZSAtIGlnbm9yZVxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm1ha2VfID0gZnVuY3Rpb24gbWFrZV8oa2V5LCBhbm5vdGF0aW9uKSB7XG4gICAgaWYgKGFubm90YXRpb24gPT09IHRydWUpIHtcbiAgICAgIGFubm90YXRpb24gPSB0aGlzLmluZmVyQW5ub3RhdGlvbl8oa2V5KTtcbiAgICB9XG5cbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhc3NlcnRBbm5vdGFibGUodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcbiAgICBhbm5vdGF0aW9uLm1ha2VfKHRoaXMsIGtleSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eURlc2NyaXB0b3J9IGRlc2NyaXB0b3JcclxuICAgKiBAcGFyYW0ge0Fubm90YXRpb258Ym9vbGVhbn0gYW5ub3RhdGlvbiB0cnVlIC0gaW5mZXIgZnJvbSBkZXNjcmlwdG9yLCBmYWxzZSAtIGNvcHkgYXMgaXNcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5leHRlbmRfID0gZnVuY3Rpb24gZXh0ZW5kXyhrZXksIGRlc2NyaXB0b3IsIGFubm90YXRpb24sIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFubm90YXRpb24gPT09IHRydWUpIHtcbiAgICAgIGFubm90YXRpb24gPSBpbmZlckFubm90YXRpb25Gcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLCB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXywgdGhpcy5hdXRvQmluZF8pO1xuICAgIH1cblxuICAgIGlmIChhbm5vdGF0aW9uID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmaW5lUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbiAgICB9XG5cbiAgICBhc3NlcnRBbm5vdGFibGUodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcbiAgICB2YXIgb3V0Y29tZSA9IGFubm90YXRpb24uZXh0ZW5kXyh0aGlzLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG5cbiAgICBpZiAob3V0Y29tZSkge1xuICAgICAgcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Y29tZTtcbiAgfTtcblxuICBfcHJvdG8uaW5mZXJBbm5vdGF0aW9uXyA9IGZ1bmN0aW9uIGluZmVyQW5ub3RhdGlvbl8oa2V5KSB7XG4gICAgdmFyIF90aGlzJHRhcmdldF8kaW5mZXJyZTsgLy8gSW5oZXJpdGVkIGlzIGZpbmUgLSBhbm5vdGF0aW9uIGNhbm5vdCBkaWZmZXIgaW4gc3ViY2xhc3NcblxuXG4gICAgdmFyIGFubm90YXRpb24gPSAoX3RoaXMkdGFyZ2V0XyRpbmZlcnJlID0gdGhpcy50YXJnZXRfW2luZmVycmVkQW5ub3RhdGlvbnNTeW1ib2xdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdGFyZ2V0XyRpbmZlcnJlLmdldChrZXkpO1xuICAgIGlmIChhbm5vdGF0aW9uKSByZXR1cm4gYW5ub3RhdGlvbjtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMudGFyZ2V0XztcblxuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXREZXNjcmlwdG9yKGN1cnJlbnQsIGtleSk7XG5cbiAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgIGFubm90YXRpb24gPSBpbmZlckFubm90YXRpb25Gcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLCB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXywgdGhpcy5hdXRvQmluZF8pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50KTtcbiAgICB9IC8vIE5vdCBmb3VuZCAoZmFsc2UgbWVhbnMgaWdub3JlKVxuXG5cbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkaWUoMSwgXCJ0cnVlXCIsIGtleSk7XG4gICAgfSAvLyBDYWNoZSB0aGUgYW5ub3RhdGlvbi5cbiAgICAvLyBOb3RlIHdlIGNhbiBkbyB0aGlzIG9ubHkgYmVjYXVzZSBhbm5vdGF0aW9uIGFuZCBmaWVsZCBjYW4ndCBjaGFuZ2UuXG5cblxuICAgIGlmICghdGhpcy5pc1BsYWluT2JqZWN0Xykge1xuICAgICAgLy8gV2UgY291bGQgYWxzbyBwbGFjZSBpdCBvbiBmdXJ0aGVzdCBwcm90bywgc2hvdWRuJ3QgbWF0dGVyXG4gICAgICB2YXIgY2xvc2VzdFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMudGFyZ2V0Xyk7XG5cbiAgICAgIGlmICghaGFzUHJvcChjbG9zZXN0UHJvdG8sIGluZmVycmVkQW5ub3RhdGlvbnNTeW1ib2wpKSB7XG4gICAgICAgIGFkZEhpZGRlblByb3AoY2xvc2VzdFByb3RvLCBpbmZlcnJlZEFubm90YXRpb25zU3ltYm9sLCBuZXcgTWFwKCkpO1xuICAgICAgfVxuXG4gICAgICBjbG9zZXN0UHJvdG9baW5mZXJyZWRBbm5vdGF0aW9uc1N5bWJvbF0uc2V0KGtleSwgYW5ub3RhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFubm90YXRpb247XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eURlc2NyaXB0b3J9IGRlc2NyaXB0b3JcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZWZpbmVQcm9wZXJ0eV8gPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eV8oa2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzdGFydEJhdGNoKCk7IC8vIERlbGV0ZVxuXG4gICAgICB2YXIgZGVsZXRlT3V0Y29tZSA9IHRoaXMuZGVsZXRlXyhrZXkpO1xuXG4gICAgICBpZiAoIWRlbGV0ZU91dGNvbWUpIHtcbiAgICAgICAgLy8gRmFpbHVyZSBvciBpbnRlcmNlcHRlZFxuICAgICAgICByZXR1cm4gZGVsZXRlT3V0Y29tZTtcbiAgICAgIH0gLy8gQUREIGludGVyY2VwdG9yXG5cblxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgdHlwZTogQURELFxuICAgICAgICAgIG5ld1ZhbHVlOiBkZXNjcmlwdG9yLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcblxuICAgICAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yID0gX2V4dGVuZHMoe30sIGRlc2NyaXB0b3IsIHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIERlZmluZVxuXG5cbiAgICAgIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgaWYgKCFSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfSAvLyBOb3RpZnlcblxuXG4gICAgICB0aGlzLm5vdGlmeVByb3BlcnR5QWRkaXRpb25fKGtleSwgZGVzY3JpcHRvci52YWx1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSWYgb3JpZ2luYWwgZGVzY3JpcHRvciBiZWNvbWVzIHJlbGV2YW50LCBtb3ZlIHRoaXMgdG8gYW5ub3RhdGlvbiBkaXJlY3RseVxuICA7XG5cbiAgX3Byb3RvLmRlZmluZU9ic2VydmFibGVQcm9wZXJ0eV8gPSBmdW5jdGlvbiBkZWZpbmVPYnNlcnZhYmxlUHJvcGVydHlfKGtleSwgdmFsdWUsIGVuaGFuY2VyLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzdGFydEJhdGNoKCk7IC8vIERlbGV0ZVxuXG4gICAgICB2YXIgZGVsZXRlT3V0Y29tZSA9IHRoaXMuZGVsZXRlXyhrZXkpO1xuXG4gICAgICBpZiAoIWRlbGV0ZU91dGNvbWUpIHtcbiAgICAgICAgLy8gRmFpbHVyZSBvciBpbnRlcmNlcHRlZFxuICAgICAgICByZXR1cm4gZGVsZXRlT3V0Y29tZTtcbiAgICAgIH0gLy8gQUREIGludGVyY2VwdG9yXG5cblxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgdHlwZTogQURELFxuICAgICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBudWxsO1xuICAgICAgICB2YWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhY2hlZERlc2NyaXB0b3IgPSBnZXRDYWNoZWRPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3Ioa2V5KTtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycyA/IHRoaXMuaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGNhY2hlZERlc2NyaXB0b3IuZ2V0LFxuICAgICAgICBzZXQ6IGNhY2hlZERlc2NyaXB0b3Iuc2V0XG4gICAgICB9OyAvLyBEZWZpbmVcblxuICAgICAgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICBpZiAoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBfb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUodmFsdWUsIGVuaGFuY2VyLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB0aGlzLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSA6IFwiT2JzZXJ2YWJsZU9iamVjdC5rZXlcIiwgZmFsc2UpO1xuXG4gICAgICB0aGlzLnZhbHVlc18uc2V0KGtleSwgX29ic2VydmFibGUpOyAvLyBOb3RpZnkgKHZhbHVlIHBvc3NpYmx5IGNoYW5nZWQgYnkgT2JzZXJ2YWJsZVZhbHVlKVxuXG4gICAgICB0aGlzLm5vdGlmeVByb3BlcnR5QWRkaXRpb25fKGtleSwgX29ic2VydmFibGUudmFsdWVfKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiBvcmlnaW5hbCBkZXNjcmlwdG9yIGJlY29tZXMgcmVsZXZhbnQsIG1vdmUgdGhpcyB0byBhbm5vdGF0aW9uIGRpcmVjdGx5XG4gIDtcblxuICBfcHJvdG8uZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eV8gPSBmdW5jdGlvbiBkZWZpbmVDb21wdXRlZFByb3BlcnR5XyhrZXksIG9wdGlvbnMsIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0QmF0Y2goKTsgLy8gRGVsZXRlXG5cbiAgICAgIHZhciBkZWxldGVPdXRjb21lID0gdGhpcy5kZWxldGVfKGtleSk7XG5cbiAgICAgIGlmICghZGVsZXRlT3V0Y29tZSkge1xuICAgICAgICAvLyBGYWlsdXJlIG9yIGludGVyY2VwdGVkXG4gICAgICAgIHJldHVybiBkZWxldGVPdXRjb21lO1xuICAgICAgfSAvLyBBREQgaW50ZXJjZXB0b3JcblxuXG4gICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgICAgbmV3VmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLm5hbWUgfHwgKG9wdGlvbnMubmFtZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpIDogXCJPYnNlcnZhYmxlT2JqZWN0LmtleVwiKTtcbiAgICAgIG9wdGlvbnMuY29udGV4dCA9IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XztcbiAgICAgIHZhciBjYWNoZWREZXNjcmlwdG9yID0gZ2V0Q2FjaGVkT2JzZXJ2YWJsZVByb3BEZXNjcmlwdG9yKGtleSk7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnMgPyB0aGlzLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogY2FjaGVkRGVzY3JpcHRvci5nZXQsXG4gICAgICAgIHNldDogY2FjaGVkRGVzY3JpcHRvci5zZXRcbiAgICAgIH07IC8vIERlZmluZVxuXG4gICAgICBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIGlmICghUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52YWx1ZXNfLnNldChrZXksIG5ldyBDb21wdXRlZFZhbHVlKG9wdGlvbnMpKTsgLy8gTm90aWZ5XG5cbiAgICAgIHRoaXMubm90aWZ5UHJvcGVydHlBZGRpdGlvbl8oa2V5LCB1bmRlZmluZWQpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlEZXNjcmlwdG9yfSBkZXNjcmlwdG9yXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBwcm94eVRyYXAgd2hldGhlciBpdCdzIGNhbGxlZCBmcm9tIHByb3h5IHRyYXBcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxudWxsfSB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUgKHByb3h5VHJhcCArIG5vbi1jb25maWd1cmFibGUpLCBudWxsIHdoZW4gY2FuY2VsbGVkIGJ5IGludGVyY2VwdG9yXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVsZXRlXyA9IGZ1bmN0aW9uIGRlbGV0ZV8oa2V5LCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH0gLy8gTm8gc3VjaCBwcm9wXG5cblxuICAgIGlmICghaGFzUHJvcCh0aGlzLnRhcmdldF8sIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gSW50ZXJjZXB0XG5cblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICB0eXBlOiBSRU1PVkVcbiAgICAgIH0pOyAvLyBDYW5jZWxsZWRcblxuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBudWxsO1xuICAgIH0gLy8gRGVsZXRlXG5cblxuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMkcGVuZGluZ0tleXNfLCBfdGhpcyRwZW5kaW5nS2V5c18kZ2U7XG5cbiAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuXG4gICAgICB2YXIgX29ic2VydmFibGUyID0gdGhpcy52YWx1ZXNfLmdldChrZXkpOyAvLyBWYWx1ZSBuZWVkZWQgZm9yIHNwaWVzL2xpc3RlbmVyc1xuXG5cbiAgICAgIHZhciB2YWx1ZSA9IHVuZGVmaW5lZDsgLy8gT3B0aW1pemF0aW9uOiBkb24ndCBwdWxsIHRoZSB2YWx1ZSB1bmxlc3Mgd2Ugd2lsbCBuZWVkIGl0XG5cbiAgICAgIGlmICghX29ic2VydmFibGUyICYmIChub3RpZnkgfHwgbm90aWZ5U3B5KSkge1xuICAgICAgICB2YXIgX2dldERlc2NyaXB0b3I7XG5cbiAgICAgICAgdmFsdWUgPSAoX2dldERlc2NyaXB0b3IgPSBnZXREZXNjcmlwdG9yKHRoaXMudGFyZ2V0Xywga2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXREZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgfSAvLyBkZWxldGUgcHJvcCAoZG8gZmlyc3QsIG1heSBmYWlsKVxuXG5cbiAgICAgIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgaWYgKCFSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGFyZ2V0X1trZXldO1xuICAgICAgfSAvLyBBbGxvdyByZS1hbm5vdGF0aW5nIHRoaXMgZmllbGRcblxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFwcGxpZWRBbm5vdGF0aW9uc19ba2V5XTtcbiAgICAgIH0gLy8gQ2xlYXIgb2JzZXJ2YWJsZVxuXG5cbiAgICAgIGlmIChfb2JzZXJ2YWJsZTIpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNfW1wiZGVsZXRlXCJdKGtleSk7IC8vIGZvciBjb21wdXRlZCwgdmFsdWUgaXMgdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKF9vYnNlcnZhYmxlMiBpbnN0YW5jZW9mIE9ic2VydmFibGVWYWx1ZSkge1xuICAgICAgICAgIHZhbHVlID0gX29ic2VydmFibGUyLnZhbHVlXztcbiAgICAgICAgfSAvLyBOb3RpZnk6IGF1dG9ydW4oKCkgPT4gb2JqW2tleV0pLCBzZWUgIzE3OTZcblxuXG4gICAgICAgIHByb3BhZ2F0ZUNoYW5nZWQoX29ic2VydmFibGUyKTtcbiAgICAgIH0gLy8gTm90aWZ5IFwia2V5cy9lbnRyaWVzL3ZhbHVlc1wiIG9ic2VydmVyc1xuXG5cbiAgICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTsgLy8gTm90aWZ5IFwiaGFzXCIgb2JzZXJ2ZXJzXG4gICAgICAvLyBcImluXCIgYXMgaXQgbWF5IHN0aWxsIGV4aXN0IGluIHByb3RvXG5cbiAgICAgIChfdGhpcyRwZW5kaW5nS2V5c18gPSB0aGlzLnBlbmRpbmdLZXlzXykgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRwZW5kaW5nS2V5c18kZ2UgPSBfdGhpcyRwZW5kaW5nS2V5c18uZ2V0KGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwZW5kaW5nS2V5c18kZ2Uuc2V0KGtleSBpbiB0aGlzLnRhcmdldF8pOyAvLyBOb3RpZnkgc3BpZXMvbGlzdGVuZXJzXG5cbiAgICAgIGlmIChub3RpZnkgfHwgbm90aWZ5U3B5KSB7XG4gICAgICAgIHZhciBfY2hhbmdlMiA9IHtcbiAgICAgICAgICB0eXBlOiBSRU1PVkUsXG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICAgIG9sZFZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBuYW1lOiBrZXlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UyKTtcbiAgICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UyKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxyXG4gICAqIE9ic2VydmVzIHRoaXMgb2JqZWN0LiBUcmlnZ2VycyBmb3IgdGhlIGV2ZW50cyAnYWRkJywgJ3VwZGF0ZScgYW5kICdkZWxldGUnLlxyXG4gICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L29ic2VydmVcclxuICAgKiBmb3IgY2FsbGJhY2sgZGV0YWlsc1xyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8oY2FsbGJhY2ssIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IHRoZSBmaXJlIGltbWVkaWF0ZWx5IHByb3BlcnR5IGZvciBvYnNlcnZhYmxlIG9iamVjdHMuXCIpO1xuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICBfcHJvdG8uaW50ZXJjZXB0XyA9IGZ1bmN0aW9uIGludGVyY2VwdF8oaGFuZGxlcikge1xuICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICB9O1xuXG4gIF9wcm90by5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyA9IGZ1bmN0aW9uIG5vdGlmeVByb3BlcnR5QWRkaXRpb25fKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXMkcGVuZGluZ0tleXNfMiwgX3RoaXMkcGVuZGluZ0tleXNfMiRnO1xuXG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICB2YXIgbm90aWZ5U3B5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuXG4gICAgaWYgKG5vdGlmeSB8fCBub3RpZnlTcHkpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm9iamVjdFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgfSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cblxuICAgIChfdGhpcyRwZW5kaW5nS2V5c18yID0gdGhpcy5wZW5kaW5nS2V5c18pID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkcGVuZGluZ0tleXNfMiRnID0gX3RoaXMkcGVuZGluZ0tleXNfMi5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBlbmRpbmdLZXlzXzIkZy5zZXQodHJ1ZSk7IC8vIE5vdGlmeSBcImtleXMvZW50cmllcy92YWx1ZXNcIiBvYnNlcnZlcnNcblxuICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgfTtcblxuICBfcHJvdG8ub3duS2V5c18gPSBmdW5jdGlvbiBvd25LZXlzXygpIHtcbiAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiBvd25LZXlzKHRoaXMudGFyZ2V0Xyk7XG4gIH07XG5cbiAgX3Byb3RvLmtleXNfID0gZnVuY3Rpb24ga2V5c18oKSB7XG4gICAgLy8gUmV0dXJucyBlbnVtZXJhYmxlICYmIG93biwgYnV0IHVuZm9ydHVuYXRlbHkga2V5c0F0b20gd2lsbCByZXBvcnQgb24gQU5ZIGtleSBjaGFuZ2UuXG4gICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gT2JqZWN0LmtleXMob2JqZWN0KSBhbmQgUmVmbGVjdC5vd25LZXlzKG9iamVjdCkgLSBib3RoIGFyZSBoYW5kbGVkIGJ5IG93bktleXMgdHJhcC5cbiAgICAvLyBXZSBjYW4gZWl0aGVyIG92ZXItcmVwb3J0IGluIE9iamVjdC5rZXlzKG9iamVjdCkgb3IgdW5kZXItcmVwb3J0IGluIFJlZmxlY3Qub3duS2V5cyhvYmplY3QpXG4gICAgLy8gV2UgY2hvb3NlIHRvIG92ZXItcmVwb3J0IGluIE9iamVjdC5rZXlzKG9iamVjdCksIGJlY2F1c2U6XG4gICAgLy8gLSB0eXBpY2FsbHkgaXQncyB1c2VkIHdpdGggc2ltcGxlIGRhdGEgb2JqZWN0c1xuICAgIC8vIC0gd2hlbiBzeW1ib2xpYy9ub24tZW51bWVyYWJsZSBrZXlzIGFyZSByZWxldmFudCBSZWZsZWN0Lm93bktleXMgd29ya3MgYXMgZXhwZWN0ZWRcbiAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRhcmdldF8pO1xuICB9O1xuXG4gIHJldHVybiBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb247XG59KCk7XG5cbmZ1bmN0aW9uIGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJG5hbWU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBvcHRpb25zICYmIGlzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQpKSB7XG4gICAgZGllKFwiT3B0aW9ucyBjYW4ndCBiZSBwcm92aWRlZCBmb3IgYWxyZWFkeSBvYnNlcnZhYmxlIG9iamVjdHMuXCIpO1xuICB9XG5cbiAgaWYgKGhhc1Byb3AodGFyZ2V0LCAkbW9ieCkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICEoZ2V0QWRtaW5pc3RyYXRpb24odGFyZ2V0KSBpbnN0YW5jZW9mIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbikpIHtcbiAgICAgIGRpZShcIkNhbm5vdCBjb252ZXJ0ICdcIiArIGdldERlYnVnTmFtZSh0YXJnZXQpICsgXCInIGludG8gb2JzZXJ2YWJsZSBvYmplY3Q6XCIgKyBcIlxcblRoZSB0YXJnZXQgaXMgYWxyZWFkeSBvYnNlcnZhYmxlIG9mIGRpZmZlcmVudCB0eXBlLlwiICsgXCJcXG5FeHRlbmRpbmcgYnVpbHRpbnMgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIU9iamVjdC5pc0V4dGVuc2libGUodGFyZ2V0KSkgZGllKFwiQ2Fubm90IG1ha2UgdGhlIGRlc2lnbmF0ZWQgb2JqZWN0IG9ic2VydmFibGU7IGl0IGlzIG5vdCBleHRlbnNpYmxlXCIpO1xuICB2YXIgbmFtZSA9IChfb3B0aW9ucyRuYW1lID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lKSAhPSBudWxsID8gX29wdGlvbnMkbmFtZSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IChpc1BsYWluT2JqZWN0KHRhcmdldCkgPyBcIk9ic2VydmFibGVPYmplY3RcIiA6IHRhcmdldC5jb25zdHJ1Y3Rvci5uYW1lKSArIFwiQFwiICsgZ2V0TmV4dElkKCkgOiBcIk9ic2VydmFibGVPYmplY3RcIjtcbiAgdmFyIGFkbSA9IG5ldyBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24odGFyZ2V0LCBuZXcgTWFwKCksIFN0cmluZyhuYW1lKSwgZ2V0QW5ub3RhdGlvbkZyb21PcHRpb25zKG9wdGlvbnMpLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmF1dG9CaW5kKTtcbiAgYWRkSGlkZGVuUHJvcCh0YXJnZXQsICRtb2J4LCBhZG0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgaXNPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvblwiLCBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24pO1xuXG5mdW5jdGlvbiBnZXRDYWNoZWRPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3Ioa2V5KSB7XG4gIHJldHVybiBkZXNjcmlwdG9yQ2FjaGVba2V5XSB8fCAoZGVzY3JpcHRvckNhY2hlW2tleV0gPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5KTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSB7XG4gIGlmIChpc09iamVjdCh0aGluZykpIHtcbiAgICByZXR1cm4gaXNPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24odGhpbmdbJG1vYnhdKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQoYWRtLCBhbm5vdGF0aW9uLCBrZXkpIHtcbiAgdmFyIF9hZG0kdGFyZ2V0XyRzdG9yZWRBbjtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgYWRtLmFwcGxpZWRBbm5vdGF0aW9uc19ba2V5XSA9IGFubm90YXRpb247XG4gIH0gLy8gUmVtb3ZlIGFwcGxpZWQgZGVjb3JhdG9yIGFubm90YXRpb24gc28gd2UgZG9uJ3QgdHJ5IHRvIGFwcGx5IGl0IGFnYWluIGluIHN1YmNsYXNzIGNvbnN0cnVjdG9yXG5cblxuICAoX2FkbSR0YXJnZXRfJHN0b3JlZEFuID0gYWRtLnRhcmdldF9bc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSA9PSBudWxsID8gdHJ1ZSA6IGRlbGV0ZSBfYWRtJHRhcmdldF8kc3RvcmVkQW5ba2V5XTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QW5ub3RhYmxlKGFkbSwgYW5ub3RhdGlvbiwga2V5KSB7XG4gIC8vIFZhbGlkIGFubm90YXRpb25cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNBbm5vdGF0aW9uKGFubm90YXRpb24pKSB7XG4gICAgZGllKFwiQ2Fubm90IGFubm90YXRlICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6IEludmFsaWQgYW5ub3RhdGlvbi5cIik7XG4gIH1cbiAgLypcclxuICAvLyBDb25maWd1cmFibGUsIG5vdCBzZWFsZWQsIG5vdCBmcm96ZW5cclxuICAvLyBQb3NzaWJseSBub3QgbmVlZGVkLCBqdXN0IGEgbGl0dGxlIGJldHRlciBlcnJvciB0aGVuIHRoZSBvbmUgdGhyb3duIGJ5IGVuZ2luZS5cclxuICAvLyBDYXNlcyB3aGVyZSB0aGlzIHdvdWxkIGJlIHVzZWZ1bCB0aGUgbW9zdCAoc3ViY2xhc3MgZmllbGQgaW5pdGlhbGl6ZXIpIGFyZSBub3QgaW50ZXJjZXB0YWJsZSBieSB0aGlzLlxyXG4gIGlmIChfX0RFVl9fKSB7XHJcbiAgICAgIGNvbnN0IGNvbmZpZ3VyYWJsZSA9IGdldERlc2NyaXB0b3IoYWRtLnRhcmdldF8sIGtleSk/LmNvbmZpZ3VyYWJsZVxyXG4gICAgICBjb25zdCBmcm96ZW4gPSBPYmplY3QuaXNGcm96ZW4oYWRtLnRhcmdldF8pXHJcbiAgICAgIGNvbnN0IHNlYWxlZCA9IE9iamVjdC5pc1NlYWxlZChhZG0udGFyZ2V0XylcclxuICAgICAgaWYgKCFjb25maWd1cmFibGUgfHwgZnJvemVuIHx8IHNlYWxlZCkge1xyXG4gICAgICAgICAgY29uc3QgZmllbGROYW1lID0gYCR7YWRtLm5hbWVffS4ke2tleS50b1N0cmluZygpfWBcclxuICAgICAgICAgIGNvbnN0IHJlcXVlc3RlZEFubm90YXRpb25UeXBlID0gYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV9cclxuICAgICAgICAgIGxldCBlcnJvciA9IGBDYW5ub3QgYXBwbHkgJyR7cmVxdWVzdGVkQW5ub3RhdGlvblR5cGV9JyB0byAnJHtmaWVsZE5hbWV9JzpgXHJcbiAgICAgICAgICBpZiAoZnJvemVuKSB7XHJcbiAgICAgICAgICAgICAgZXJyb3IgKz0gYFxcbk9iamVjdCBpcyBmcm96ZW4uYFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHNlYWxlZCkge1xyXG4gICAgICAgICAgICAgIGVycm9yICs9IGBcXG5PYmplY3QgaXMgc2VhbGVkLmBcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghY29uZmlndXJhYmxlKSB7XHJcbiAgICAgICAgICAgICAgZXJyb3IgKz0gYFxcbnByb3BlcnR5IGlzIG5vdCBjb25maWd1cmFibGUuYFxyXG4gICAgICAgICAgICAgIC8vIE1lbnRpb24gb25seSBpZiBjYXVzZWQgYnkgdXMgdG8gYXZvaWQgY29uZnVzaW9uXHJcbiAgICAgICAgICAgICAgaWYgKGhhc1Byb3AoYWRtLmFwcGxpZWRBbm5vdGF0aW9ucyEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgZXJyb3IgKz0gYFxcblRvIHByZXZlbnQgYWNjaWRlbnRhbCByZS1kZWZpbml0aW9uIG9mIGEgZmllbGQgYnkgYSBzdWJjbGFzcywgYFxyXG4gICAgICAgICAgICAgICAgICBlcnJvciArPSBgYWxsIGFubm90YXRlZCBmaWVsZHMgb2Ygbm9uLXBsYWluIG9iamVjdHMgKGNsYXNzZXMpIGFyZSBub3QgY29uZmlndXJhYmxlLmBcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkaWUoZXJyb3IpXHJcbiAgICAgIH1cclxuICB9XHJcbiAgKi9cbiAgLy8gTm90IGFubm90YXRlZFxuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNPdmVycmlkZShhbm5vdGF0aW9uKSAmJiBoYXNQcm9wKGFkbS5hcHBsaWVkQW5ub3RhdGlvbnNfLCBrZXkpKSB7XG4gICAgdmFyIGZpZWxkTmFtZSA9IGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCk7XG4gICAgdmFyIGN1cnJlbnRBbm5vdGF0aW9uVHlwZSA9IGFkbS5hcHBsaWVkQW5ub3RhdGlvbnNfW2tleV0uYW5ub3RhdGlvblR5cGVfO1xuICAgIHZhciByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSA9IGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfO1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSArIFwiJyB0byAnXCIgKyBmaWVsZE5hbWUgKyBcIic6XCIgKyAoXCJcXG5UaGUgZmllbGQgaXMgYWxyZWFkeSBhbm5vdGF0ZWQgd2l0aCAnXCIgKyBjdXJyZW50QW5ub3RhdGlvblR5cGUgKyBcIicuXCIpICsgXCJcXG5SZS1hbm5vdGF0aW5nIGZpZWxkcyBpcyBub3QgYWxsb3dlZC5cIiArIFwiXFxuVXNlICdvdmVycmlkZScgYW5ub3RhdGlvbiBmb3IgbWV0aG9kcyBvdmVycmlkZW4gYnkgc3ViY2xhc3MuXCIpO1xuICB9XG59XG4vKipcclxuICogVGhpcyBhcnJheSBidWZmZXIgY29udGFpbnMgdHdvIGxpc3RzIG9mIHByb3BlcnRpZXMsIHNvIHRoYXQgYWxsIGFycmF5c1xyXG4gKiBjYW4gcmVjeWNsZSB0aGVpciBwcm9wZXJ0eSBkZWZpbml0aW9ucywgd2hpY2ggc2lnbmlmaWNhbnRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZSBvZiBjcmVhdGluZ1xyXG4gKiBwcm9wZXJ0aWVzIG9uIHRoZSBmbHkuXHJcbiAqL1xuXG5cbnZhciBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFID0gMDsgLy8gVHlwZXNjcmlwdCB3b3JrYXJvdW5kIHRvIG1ha2Ugc3VyZSBPYnNlcnZhYmxlQXJyYXkgZXh0ZW5kcyBBcnJheVxuXG52YXIgU3R1YkFycmF5ID0gZnVuY3Rpb24gU3R1YkFycmF5KCkge307XG5cbmZ1bmN0aW9uIGluaGVyaXQoY3RvciwgcHJvdG8pIHtcbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihjdG9yLnByb3RvdHlwZSwgcHJvdG8pO1xuICB9IGVsc2UgaWYgKGN0b3IucHJvdG90eXBlLl9fcHJvdG9fXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3Rvci5wcm90b3R5cGUuX19wcm90b19fID0gcHJvdG87XG4gIH0gZWxzZSB7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBwcm90bztcbiAgfVxufVxuXG5pbmhlcml0KFN0dWJBcnJheSwgQXJyYXkucHJvdG90eXBlKTsgLy8gV2VleCBwcm90byBmcmVlemUgcHJvdGVjdGlvbiB3YXMgaGVyZSxcbi8vIGJ1dCBpdCBpcyB1bmNsZWFyIHdoeSB0aGUgaGFjayBpcyBuZWVkIGFzIE1vYlggbmV2ZXIgY2hhbmdlZCB0aGUgcHJvdG90eXBlXG4vLyBhbnl3YXksIHNvIHJlbW92ZWQgaXQgaW4gVjZcblxudmFyIExlZ2FjeU9ic2VydmFibGVBcnJheSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0dWJBcnJheSkge1xuICBfaW5oZXJpdHNMb29zZShMZWdhY3lPYnNlcnZhYmxlQXJyYXksIF9TdHViQXJyYXkpO1xuXG4gIGZ1bmN0aW9uIExlZ2FjeU9ic2VydmFibGVBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSwgb3duZWQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKSA6IFwiT2JzZXJ2YWJsZUFycmF5XCI7XG4gICAgfVxuXG4gICAgaWYgKG93bmVkID09PSB2b2lkIDApIHtcbiAgICAgIG93bmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfU3R1YkFycmF5LmNhbGwodGhpcykgfHwgdGhpcztcbiAgICB2YXIgYWRtID0gbmV3IE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKG5hbWUsIGVuaGFuY2VyLCBvd25lZCwgdHJ1ZSk7XG4gICAgYWRtLnByb3h5XyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpO1xuICAgIGFkZEhpZGRlbkZpbmFsUHJvcChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgJG1vYngsIGFkbSk7XG5cbiAgICBpZiAoaW5pdGlhbFZhbHVlcyAmJiBpbml0aWFsVmFsdWVzLmxlbmd0aCkge1xuICAgICAgdmFyIHByZXYgPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KHRydWUpOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgIF90aGlzLnNwbGljZVdpdGhBcnJheSgwLCAwLCBpbml0aWFsVmFsdWVzKTtcblxuICAgICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExlZ2FjeU9ic2VydmFibGVBcnJheS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB0aGlzWyRtb2J4XS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFycmF5cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFycmF5c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLnNsaWNlKCksIC8vQHRzLWlnbm9yZVxuICAgIGFycmF5cy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBpc09ic2VydmFibGVBcnJheShhKSA/IGEuc2xpY2UoKSA6IGE7XG4gICAgfSkpO1xuICB9O1xuXG4gIF9wcm90b1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIG5leHRJbmRleCA8IHNlbGYubGVuZ3RoID8ge1xuICAgICAgICAgIHZhbHVlOiBzZWxmW25leHRJbmRleCsrXSxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9IDoge1xuICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhMZWdhY3lPYnNlcnZhYmxlQXJyYXksIFt7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLmdldEFycmF5TGVuZ3RoXygpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGVuZ3RoKSB7XG4gICAgICB0aGlzWyRtb2J4XS5zZXRBcnJheUxlbmd0aF8obmV3TGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcIkFycmF5XCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExlZ2FjeU9ic2VydmFibGVBcnJheTtcbn0oU3R1YkFycmF5KTtcblxuT2JqZWN0LmVudHJpZXMoYXJyYXlFeHRlbnNpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBwcm9wID0gX3JlZlswXSxcbiAgICAgIGZuID0gX3JlZlsxXTtcbiAgaWYgKHByb3AgIT09IFwiY29uY2F0XCIpIGFkZEhpZGRlblByb3AoTGVnYWN5T2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZSwgcHJvcCwgZm4pO1xufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKGluZGV4KSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLmdldF8oaW5kZXgpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXNbJG1vYnhdLnNldF8oaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5QnVmZmVySXRlbShpbmRleCkge1xuICBkZWZpbmVQcm9wZXJ0eShMZWdhY3lPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLCBcIlwiICsgaW5kZXgsIGNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKGluZGV4KSk7XG59XG5cbmZ1bmN0aW9uIHJlc2VydmVBcnJheUJ1ZmZlcihtYXgpIHtcbiAgaWYgKG1heCA+IE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkU7IGluZGV4IDwgbWF4ICsgMTAwOyBpbmRleCsrKSB7XG4gICAgICBjcmVhdGVBcnJheUJ1ZmZlckl0ZW0oaW5kZXgpO1xuICAgIH1cblxuICAgIE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUgPSBtYXg7XG4gIH1cbn1cblxucmVzZXJ2ZUFycmF5QnVmZmVyKDEwMDApO1xuXG5mdW5jdGlvbiBjcmVhdGVMZWdhY3lBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IExlZ2FjeU9ic2VydmFibGVBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldEF0b20odGhpbmcsIHByb3BlcnR5KSB7XG4gIGlmICh0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiYgdGhpbmcgIT09IG51bGwpIHtcbiAgICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpKSB7XG4gICAgICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkgZGllKDIzKTtcbiAgICAgIHJldHVybiB0aGluZ1skbW9ieF0uYXRvbV87XG4gICAgfVxuXG4gICAgaWYgKGlzT2JzZXJ2YWJsZVNldCh0aGluZykpIHtcbiAgICAgIHJldHVybiB0aGluZ1skbW9ieF07XG4gICAgfVxuXG4gICAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0aGluZykpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpbmcua2V5c0F0b21fO1xuICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGluZy5kYXRhXy5nZXQocHJvcGVydHkpIHx8IHRoaW5nLmhhc01hcF8uZ2V0KHByb3BlcnR5KTtcbiAgICAgIGlmICghb2JzZXJ2YWJsZSkgZGllKDI1LCBwcm9wZXJ0eSwgZ2V0RGVidWdOYW1lKHRoaW5nKSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSkge1xuICAgICAgaWYgKCFwcm9wZXJ0eSkgcmV0dXJuIGRpZSgyNik7XG5cbiAgICAgIHZhciBfb2JzZXJ2YWJsZSA9IHRoaW5nWyRtb2J4XS52YWx1ZXNfLmdldChwcm9wZXJ0eSk7XG5cbiAgICAgIGlmICghX29ic2VydmFibGUpIGRpZSgyNywgcHJvcGVydHksIGdldERlYnVnTmFtZSh0aGluZykpO1xuICAgICAgcmV0dXJuIF9vYnNlcnZhYmxlO1xuICAgIH1cblxuICAgIGlmIChpc0F0b20odGhpbmcpIHx8IGlzQ29tcHV0ZWRWYWx1ZSh0aGluZykgfHwgaXNSZWFjdGlvbih0aGluZykpIHtcbiAgICAgIHJldHVybiB0aGluZztcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGluZykpIHtcbiAgICBpZiAoaXNSZWFjdGlvbih0aGluZ1skbW9ieF0pKSB7XG4gICAgICAvLyBkaXNwb3NlciBmdW5jdGlvblxuICAgICAgcmV0dXJuIHRoaW5nWyRtb2J4XTtcbiAgICB9XG4gIH1cblxuICBkaWUoMjgpO1xufVxuXG5mdW5jdGlvbiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcGVydHkpIHtcbiAgaWYgKCF0aGluZykgZGllKDI5KTtcbiAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbihnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkpO1xuICBpZiAoaXNBdG9tKHRoaW5nKSB8fCBpc0NvbXB1dGVkVmFsdWUodGhpbmcpIHx8IGlzUmVhY3Rpb24odGhpbmcpKSByZXR1cm4gdGhpbmc7XG4gIGlmIChpc09ic2VydmFibGVNYXAodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZVNldCh0aGluZykpIHJldHVybiB0aGluZztcbiAgaWYgKHRoaW5nWyRtb2J4XSkgcmV0dXJuIHRoaW5nWyRtb2J4XTtcbiAgZGllKDI0LCB0aGluZyk7XG59XG5cbmZ1bmN0aW9uIGdldERlYnVnTmFtZSh0aGluZywgcHJvcGVydHkpIHtcbiAgdmFyIG5hbWVkO1xuXG4gIGlmIChwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbmFtZWQgPSBnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSk7XG4gIH0gZWxzZSBpZiAoaXNBY3Rpb24odGhpbmcpKSB7XG4gICAgcmV0dXJuIHRoaW5nLm5hbWU7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSB8fCBpc09ic2VydmFibGVNYXAodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZVNldCh0aGluZykpIHtcbiAgICBuYW1lZCA9IGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB2YWxpZCBmb3IgYXJyYXlzIGFzIHdlbGxcbiAgICBuYW1lZCA9IGdldEF0b20odGhpbmcpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVkLm5hbWVfO1xufVxuXG52YXIgdG9TdHJpbmcgPSBvYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiLCBkZXB0aCkge1xuICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgIGRlcHRoID0gLTE7XG4gIH1cblxuICByZXR1cm4gZXEoYSwgYiwgZGVwdGgpO1xufSAvLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvYmxvYi81YzIzN2E3YzY4MmZiNjhmZDUzNzgyMDNmMGJmMjJkY2UxNjI0ODU0L3VuZGVyc2NvcmUuanMjTDExODYtTDEyODlcbi8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG5cblxuZnVuY3Rpb24gZXEoYSwgYiwgZGVwdGgsIGFTdGFjaywgYlN0YWNrKSB7XG4gIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7IC8vIGBudWxsYCBvciBgdW5kZWZpbmVkYCBvbmx5IGVxdWFsIHRvIGl0c2VsZiAoc3RyaWN0IGNvbXBhcmlzb24pLlxuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7IC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG5cbiAgaWYgKGEgIT09IGEpIHJldHVybiBiICE9PSBiOyAvLyBFeGhhdXN0IHByaW1pdGl2ZSBjaGVja3NcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBhO1xuICBpZiAoIWlzRnVuY3Rpb24odHlwZSkgJiYgdHlwZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiAhPSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7IC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG5cbiAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgIGNhc2UgXCJbb2JqZWN0IFJlZ0V4cF1cIjogLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcblxuICAgIGNhc2UgXCJbb2JqZWN0IFN0cmluZ11cIjpcbiAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICByZXR1cm4gXCJcIiArIGEgPT09IFwiXCIgKyBiO1xuXG4gICAgY2FzZSBcIltvYmplY3QgTnVtYmVyXVwiOlxuICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOLlxuICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjsgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cblxuICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcblxuICAgIGNhc2UgXCJbb2JqZWN0IERhdGVdXCI6XG4gICAgY2FzZSBcIltvYmplY3QgQm9vbGVhbl1cIjpcbiAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgIHJldHVybiArYSA9PT0gK2I7XG5cbiAgICBjYXNlIFwiW29iamVjdCBTeW1ib2xdXCI6XG4gICAgICByZXR1cm4gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wudmFsdWVPZi5jYWxsKGEpID09PSBTeW1ib2wudmFsdWVPZi5jYWxsKGIpO1xuXG4gICAgY2FzZSBcIltvYmplY3QgTWFwXVwiOlxuICAgIGNhc2UgXCJbb2JqZWN0IFNldF1cIjpcbiAgICAgIC8vIE1hcHMgYW5kIFNldHMgYXJlIHVud3JhcHBlZCB0byBhcnJheXMgb2YgZW50cnktcGFpcnMsIGFkZGluZyBhbiBpbmNpZGVudGFsIGxldmVsLlxuICAgICAgLy8gSGlkZSB0aGlzIGV4dHJhIGxldmVsIGJ5IGluY3JlYXNpbmcgdGhlIGRlcHRoLlxuICAgICAgaWYgKGRlcHRoID49IDApIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gIH0gLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG5cblxuICBhID0gdW53cmFwKGEpO1xuICBiID0gdW53cmFwKGIpO1xuICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSBcIltvYmplY3QgQXJyYXldXCI7XG5cbiAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICBpZiAodHlwZW9mIGEgIT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7IC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG5cbiAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLFxuICAgICAgICBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG5cbiAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJiBpc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gYSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXB0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChkZXB0aCA8IDApIHtcbiAgICBkZXB0aCA9IC0xO1xuICB9IC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuXG5cbiAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgfSAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG5cblxuICBhU3RhY2sucHVzaChhKTtcbiAgYlN0YWNrLnB1c2goYik7IC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuXG4gIGlmIChhcmVBcnJheXMpIHtcbiAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlOyAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBkZXB0aCAtIDEsIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBrZXk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cblxuICAgIGlmIChPYmplY3Qua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgIGlmICghKGhhc1Byb3AoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgZGVwdGggLSAxLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuXG5cbiAgYVN0YWNrLnBvcCgpO1xuICBiU3RhY2sucG9wKCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB1bndyYXAoYSkge1xuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkoYSkpIHJldHVybiBhLnNsaWNlKCk7XG4gIGlmIChpc0VTNk1hcChhKSB8fCBpc09ic2VydmFibGVNYXAoYSkpIHJldHVybiBBcnJheS5mcm9tKGEuZW50cmllcygpKTtcbiAgaWYgKGlzRVM2U2V0KGEpIHx8IGlzT2JzZXJ2YWJsZVNldChhKSkgcmV0dXJuIEFycmF5LmZyb20oYS5lbnRyaWVzKCkpO1xuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gbWFrZUl0ZXJhYmxlKGl0ZXJhdG9yKSB7XG4gIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBnZXRTZWxmO1xuICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGYoKSB7XG4gIHJldHVybiB0aGlzO1xufVxuLyoqXHJcbiAqIEluZmVycyB0aGUgYmVzdCBmaXR0aW5nIGFubm90YXRpb24gZnJvbSBwcm9wZXJ0eSBkZXNjcmlwdG9yIG9yIGZhbHNlIGlmIHRoZSBmaWVsZCBzaG91ZG4ndCBiZSBhbm5vdGF0ZWRcclxuICogLSBnZXR0ZXIoK3NldHRlcikgLT4gY29tcHV0ZWRcclxuICogLSBzZXR0ZXIgdy9vIGdldHRlciAtPiBmYWxzZSAoaWdub3JlKVxyXG4gKiAtIGZsb3cgLT4gZmFsc2UgKGlnbm9yZSlcclxuICogLSBnZW5lcmF0b3IgLT4gZmxvd1xyXG4gKiAtIGFjdGlvbiAtPiBmYWxzZSAoaWdub3JlKVxyXG4gKiAtIGZ1bmN0aW9uIC0+IGFjdGlvbiAob3B0aW9uYWxseSBib3VuZClcclxuICogLSBvdGhlciAtPiBkZWZhdWx0QW5ub3RhdGlvblxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbmZlckFubm90YXRpb25Gcm9tRGVzY3JpcHRvcihkZXNjLCBkZWZhdWx0QW5ub3RhdGlvbiwgYXV0b0JpbmQpIHtcbiAgaWYgKGRlc2MuZ2V0KSByZXR1cm4gY29tcHV0ZWQ7XG4gIGlmIChkZXNjLnNldCkgcmV0dXJuIGZhbHNlOyAvLyBpZ25vcmUgbG9uZSBzZXR0ZXJcbiAgLy8gSWYgYWxyZWFkeSB3cmFwcGVkIGluIGFjdGlvbi9mbG93LCBkb24ndCBkbyB0aGF0IGFub3RoZXIgdGltZSwgYnV0IGFzc3VtZSBpdCBpcyBhbHJlYWR5IHNldCB1cCBwcm9wZXJseS5cblxuICByZXR1cm4gaXNGdW5jdGlvbihkZXNjLnZhbHVlKSA/IGlzR2VuZXJhdG9yKGRlc2MudmFsdWUpID8gaXNGbG93KGRlc2MudmFsdWUpID8gZmFsc2UgOiBmbG93IDogaXNBY3Rpb24oZGVzYy52YWx1ZSkgPyBmYWxzZSA6IGF1dG9CaW5kID8gYXV0b0FjdGlvbi5ib3VuZCA6IGF1dG9BY3Rpb24gOiBkZWZhdWx0QW5ub3RhdGlvbjtcbn1cblxuZnVuY3Rpb24gaXNBbm5vdGF0aW9uKHRoaW5nKSB7XG4gIHJldHVybiAoLy8gQ2FuIGJlIGZ1bmN0aW9uXG4gICAgdGhpbmcgaW5zdGFuY2VvZiBPYmplY3QgJiYgdHlwZW9mIHRoaW5nLmFubm90YXRpb25UeXBlXyA9PT0gXCJzdHJpbmdcIiAmJiBpc0Z1bmN0aW9uKHRoaW5nLm1ha2VfKSAmJiBpc0Z1bmN0aW9uKHRoaW5nLmV4dGVuZF8pXG4gICk7XG59XG4vKipcclxuICogKGMpIE1pY2hlbCBXZXN0c3RyYXRlIDIwMTUgLSAyMDIwXHJcbiAqIE1JVCBMaWNlbnNlZFxyXG4gKlxyXG4gKiBXZWxjb21lIHRvIHRoZSBtb2J4IHNvdXJjZXMhIFRvIGdldCBhbiBnbG9iYWwgb3ZlcnZpZXcgb2YgaG93IE1vYlggaW50ZXJuYWxseSB3b3JrcyxcclxuICogdGhpcyBpcyBhIGdvb2QgcGxhY2UgdG8gc3RhcnQ6XHJcbiAqIGh0dHBzOi8vbWVkaXVtLmNvbS9AbXdlc3RzdHJhdGUvYmVjb21pbmctZnVsbHktcmVhY3RpdmUtYW4taW4tZGVwdGgtZXhwbGFuYXRpb24tb2YtbW9ic2VydmFibGUtNTU5OTUyNjJhMjU0Iy54dmJoNnFkNzRcclxuICpcclxuICogU291cmNlIGZvbGRlcnM6XHJcbiAqID09PT09PT09PT09PT09PVxyXG4gKlxyXG4gKiAtIGFwaS8gICAgIE1vc3Qgb2YgdGhlIHB1YmxpYyBzdGF0aWMgbWV0aG9kcyBleHBvc2VkIGJ5IHRoZSBtb2R1bGUgY2FuIGJlIGZvdW5kIGhlcmUuXHJcbiAqIC0gY29yZS8gICAgSW1wbGVtZW50YXRpb24gb2YgdGhlIE1vYlggYWxnb3JpdGhtOyBhdG9tcywgZGVyaXZhdGlvbnMsIHJlYWN0aW9ucywgZGVwZW5kZW5jeSB0cmVlcywgb3B0aW1pemF0aW9ucy4gQ29vbCBzdHVmZiBjYW4gYmUgZm91bmQgaGVyZS5cclxuICogLSB0eXBlcy8gICBBbGwgdGhlIG1hZ2ljIHRoYXQgaXMgbmVlZCB0byBoYXZlIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCB2YWx1ZXMgaXMgaW4gdGhpcyBmb2xkZXIuIEluY2x1ZGluZyB0aGUgbW9kaWZpZXJzIGxpa2UgYGFzRmxhdGAuXHJcbiAqIC0gdXRpbHMvICAgVXRpbGl0eSBzdHVmZi5cclxuICpcclxuICovXG5cblxuW1wiU3ltYm9sXCIsIFwiTWFwXCIsIFwiU2V0XCIsIFwiU3ltYm9sXCJdLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgdmFyIGcgPSBnZXRHbG9iYWwoKTtcblxuICBpZiAodHlwZW9mIGdbbV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkaWUoXCJNb2JYIHJlcXVpcmVzIGdsb2JhbCAnXCIgKyBtICsgXCInIHRvIGJlIGF2YWlsYWJsZSBvciBwb2x5ZmlsbGVkXCIpO1xuICB9XG59KTtcblxuaWYgKHR5cGVvZiBfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gXCJvYmplY3RcIikge1xuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmR5a29nL21vYngtZGV2dG9vbHMvXG4gIF9fTU9CWF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdE1vYngoe1xuICAgIHNweTogc3B5LFxuICAgIGV4dHJhczoge1xuICAgICAgZ2V0RGVidWdOYW1lOiBnZXREZWJ1Z05hbWVcbiAgICB9LFxuICAgICRtb2J4OiAkbW9ieFxuICB9KTtcbn1cblxuZXhwb3J0IHsgJG1vYngsIEZsb3dDYW5jZWxsYXRpb25FcnJvciwgT2JzZXJ2YWJsZU1hcCwgT2JzZXJ2YWJsZVNldCwgUmVhY3Rpb24sIGFsbG93U3RhdGVDaGFuZ2VzIGFzIF9hbGxvd1N0YXRlQ2hhbmdlcywgcnVuSW5BY3Rpb24gYXMgX2FsbG93U3RhdGVDaGFuZ2VzSW5zaWRlQ29tcHV0ZWQsIGFsbG93U3RhdGVSZWFkc0VuZCBhcyBfYWxsb3dTdGF0ZVJlYWRzRW5kLCBhbGxvd1N0YXRlUmVhZHNTdGFydCBhcyBfYWxsb3dTdGF0ZVJlYWRzU3RhcnQsIGF1dG9BY3Rpb24gYXMgX2F1dG9BY3Rpb24sIF9lbmRBY3Rpb24sIGdldEFkbWluaXN0cmF0aW9uIGFzIF9nZXRBZG1pbmlzdHJhdGlvbiwgZ2V0R2xvYmFsU3RhdGUgYXMgX2dldEdsb2JhbFN0YXRlLCBpbnRlcmNlcHRSZWFkcyBhcyBfaW50ZXJjZXB0UmVhZHMsIGlzQ29tcHV0aW5nRGVyaXZhdGlvbiBhcyBfaXNDb21wdXRpbmdEZXJpdmF0aW9uLCByZXNldEdsb2JhbFN0YXRlIGFzIF9yZXNldEdsb2JhbFN0YXRlLCBfc3RhcnRBY3Rpb24sIGFjdGlvbiwgYXV0b3J1biwgY29tcGFyZXIsIGNvbXB1dGVkLCBjb25maWd1cmUsIGNyZWF0ZUF0b20sIGVudHJpZXMsIGV4dGVuZE9ic2VydmFibGUsIGZsb3csIGZsb3dSZXN1bHQsIGdldCwgZ2V0QXRvbSwgZ2V0RGVidWdOYW1lLCBnZXREZXBlbmRlbmN5VHJlZSwgZ2V0T2JzZXJ2ZXJUcmVlLCBoYXMsIGludGVyY2VwdCwgaXNBY3Rpb24sIGlzT2JzZXJ2YWJsZVZhbHVlIGFzIGlzQm94ZWRPYnNlcnZhYmxlLCBpc0NvbXB1dGVkLCBpc0NvbXB1dGVkUHJvcCwgaXNGbG93Q2FuY2VsbGF0aW9uRXJyb3IsIGlzT2JzZXJ2YWJsZSwgaXNPYnNlcnZhYmxlQXJyYXksIGlzT2JzZXJ2YWJsZU1hcCwgaXNPYnNlcnZhYmxlT2JqZWN0LCBpc09ic2VydmFibGVQcm9wLCBpc09ic2VydmFibGVTZXQsIGtleXMsIG1ha2VBdXRvT2JzZXJ2YWJsZSwgbWFrZU9ic2VydmFibGUsIG9ic2VydmFibGUsIG9ic2VydmUsIG9uQmVjb21lT2JzZXJ2ZWQsIG9uQmVjb21lVW5vYnNlcnZlZCwgb25SZWFjdGlvbkVycm9yLCBvdmVycmlkZSwgcmVhY3Rpb24sIHJlbW92ZSwgcnVuSW5BY3Rpb24sIHNldCwgc3B5LCB0b0pTLCB0cmFjZSwgdHJhbnNhY3Rpb24sIHVudHJhY2tlZCwgdmFsdWVzLCB3aGVuIH07IiwiaW1wb3J0IHsgY3JlYXRlQWN0aW9uVHJhY2tpbmdNaWRkbGV3YXJlMiwgcmVjb3JkUGF0Y2hlcywgaXNBY3Rpb25Db250ZXh0VGhpc09yQ2hpbGRPZiwgaXNTdGF0ZVRyZWVOb2RlLCBnZXRUeXBlLCBnZXRTbmFwc2hvdCwgb25QYXRjaCwgYWRkTWlkZGxld2FyZSwgZ2V0UGF0aCwgYXBwbHlTbmFwc2hvdCwgb25TbmFwc2hvdCwgaGFzUGFyZW50LCBnZXRQYXJlbnQsIGFwcGx5QWN0aW9uLCB0eXBlcywgcmVzb2x2ZVBhdGgsIGdldEVudiwgZ2V0Um9vdCwgYWRkRGlzcG9zZXIsIGRlY29yYXRlLCBmbG93LCBhcHBseVBhdGNoIH0gZnJvbSAnbW9ieC1zdGF0ZS10cmVlJztcbnZhciBhdG9taWMgPSBjcmVhdGVBY3Rpb25UcmFja2luZ01pZGRsZXdhcmUyKHtcbiAgZmlsdGVyOiBmdW5jdGlvbiAoY2FsbCkge1xuICAgIC8vIG9ubHkgY2FsbCB0aGUgbWV0aG9kcyBhYm92ZSBmb3IgYWN0aW9ucyB0aGF0IHdlcmUgbm90IGJlaW5nIHJlY29yZGVkLFxuICAgIC8vIGJ1dCBkbyBub3QgY2FsbCB0aGVtIGZvciBjaGlsZCBhY2lvbnMgKHdoaWNoIGluaGVyaXQgYSBjb3B5IG9mIHRoZSBlbnYpXG4gICAgaWYgKGNhbGwuZW52KSB7XG4gICAgICAvLyBhbHJlYWR5IHJlY29yZGluZ1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBvblN0YXJ0OiBmdW5jdGlvbiAoY2FsbCkge1xuICAgIHZhciByZWNvcmRlciA9IHJlY29yZFBhdGNoZXMoY2FsbC50cmVlLCBmdW5jdGlvbiAoX3BhdGNoLCBfaW52ZXJzZVBhdGNoLCBhY3Rpb25Db250ZXh0KSB7XG4gICAgICAvLyBvbmx5IHJlY29yZCBwYXRjaGVzIHRoYXQgd2VyZSBnZW5lcmF0ZWQgYnkgdGhpcyBhY3Rpb24gb3IgY2hpbGRyZW4gb2YgdGhpcyBhY3Rpb25cbiAgICAgIHJldHVybiAhIWFjdGlvbkNvbnRleHQgJiYgaXNBY3Rpb25Db250ZXh0VGhpc09yQ2hpbGRPZihhY3Rpb25Db250ZXh0LCBjYWxsLmlkKTtcbiAgICB9KTtcbiAgICByZWNvcmRlci5yZXN1bWUoKTtcbiAgICBjYWxsLmVudiA9IHtcbiAgICAgIHJlY29yZGVyOiByZWNvcmRlclxuICAgIH07XG4gIH0sXG4gIG9uRmluaXNoOiBmdW5jdGlvbiAoY2FsbCwgZXJyb3IpIHtcbiAgICB2YXIgcmVjb3JkZXIgPSBjYWxsLmVudi5yZWNvcmRlcjtcbiAgICBjYWxsLmVudiA9IHVuZGVmaW5lZDtcbiAgICByZWNvcmRlci5zdG9wKCk7XG5cbiAgICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVjb3JkZXIudW5kbygpO1xuICAgIH1cbiAgfVxufSk7XG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHtcbiAgICBsYWJlbDogMCxcbiAgICBzZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodFswXSAmIDEpIHRocm93IHRbMV07XG4gICAgICByZXR1cm4gdFsxXTtcbiAgICB9LFxuICAgIHRyeXM6IFtdLFxuICAgIG9wczogW11cbiAgfSxcbiAgICAgIGYsXG4gICAgICB5LFxuICAgICAgdCxcbiAgICAgIGc7XG4gIHJldHVybiBnID0ge1xuICAgIG5leHQ6IHZlcmIoMCksXG4gICAgXCJ0aHJvd1wiOiB2ZXJiKDEpLFxuICAgIFwicmV0dXJuXCI6IHZlcmIoMilcbiAgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBnO1xuXG4gIGZ1bmN0aW9uIHZlcmIobikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblxuICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXG4gICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3BbMV0sXG4gICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG5cbiAgICAgICAgICBfLnRyeXMucG9wKCk7XG5cbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG5cbiAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cbiAgICAgICAgICBfLnRyeXMucG9wKCk7XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb3AgPSBbNiwgZV07XG4gICAgICB5ID0gMDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZiA9IHQgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCxcbiAgICAgIGRvbmU6IHRydWVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcbiAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgbSA9IHMgJiYgb1tzXSxcbiAgICAgIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbyAmJiBvW2krK10sXG4gICAgICAgIGRvbmU6ICFvXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxuXG5mdW5jdGlvbiBfX3JlYWQobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLFxuICAgICAgcixcbiAgICAgIGFyID0gW10sXG4gICAgICBlO1xuXG4gIHRyeSB7XG4gICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZSA9IHtcbiAgICAgIGVycm9yOiBlcnJvclxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZSkgdGhyb3cgZS5lcnJvcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXI7XG59XG5cbmZ1bmN0aW9uIF9fc3ByZWFkKCkge1xuICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuXG4gIHJldHVybiBhcjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHRpbnkgcHJveHkgYXJvdW5kIGEgTVNUIHRyZWUgdGhhdCBjb25mb3JtcyB0byB0aGUgcmVkdXggc3RvcmUgYXBpLlxuICogVGhpcyBtYWtlcyBpdCBwb3NzaWJsZSB0byB1c2UgTVNUIGluc2lkZSBhIHJlZHV4IGFwcGxpY2F0aW9uLlxuICpcbiAqIFNlZSB0aGUgW3JlZHV4LXRvZG9tdmMgZXhhbXBsZV0oaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4LXN0YXRlLXRyZWUvYmxvYi9lOWU4MDRjOGM0M2UxZWRkZTRhYWJiZDUyNjc1NTQ0ZTJiM2E5MDViL2V4YW1wbGVzL3JlZHV4LXRvZG9tdmMvc3JjL2luZGV4LmpzI0wyMCkgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAcGFyYW0geyp9IG1vZGVsXG4gKiBAcGFyYW0gey4uLk1pZGRsZVdhcmVbXX0gbWlkZGxld2FyZXNcbiAqIEByZXR1cm5zIHtJUmVkdXhTdG9yZX1cbiAqL1xuXG5cbnZhciBhc1JlZHV4U3RvcmUgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgdmFyIG1pZGRsZXdhcmVzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBtaWRkbGV3YXJlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIGlmICghaXNTdGF0ZVRyZWVOb2RlKG1vZGVsKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9kZWwgb2JqZWN0XCIpO1xuICB2YXIgc3RvcmUgPSB7XG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRTbmFwc2hvdChtb2RlbCk7XG4gICAgfSxcbiAgICBkaXNwYXRjaDogZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgcnVuTWlkZGxlV2FyZShhY3Rpb24sIHJ1bm5lcnMuc2xpY2UoKSwgZnVuY3Rpb24gKG5ld0FjdGlvbikge1xuICAgICAgICByZXR1cm4gYXBwbHlBY3Rpb24obW9kZWwsIHJlZHV4QWN0aW9uVG9BY3Rpb24obmV3QWN0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gb25TbmFwc2hvdChtb2RlbCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcbiAgdmFyIHJ1bm5lcnMgPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG13KSB7XG4gICAgcmV0dXJuIG13KHN0b3JlKTtcbiAgfSk7XG4gIHJldHVybiBzdG9yZTtcbn07XG5cbmZ1bmN0aW9uIHJlZHV4QWN0aW9uVG9BY3Rpb24oYWN0aW9uKSB7XG4gIHZhciBhY3Rpb25BcmdzID0gT2JqZWN0LmFzc2lnbih7fSwgYWN0aW9uKTtcbiAgZGVsZXRlIGFjdGlvbkFyZ3MudHlwZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBhY3Rpb24udHlwZSxcbiAgICBhcmdzOiBbYWN0aW9uQXJnc11cbiAgfTtcbn1cblxuZnVuY3Rpb24gcnVuTWlkZGxlV2FyZShhY3Rpb24sIHJ1bm5lcnMsIG5leHQpIHtcbiAgZnVuY3Rpb24gbihyZXRWYWwpIHtcbiAgICB2YXIgZiA9IHJ1bm5lcnMuc2hpZnQoKTtcbiAgICBpZiAoZikgZihuKShyZXRWYWwpO2Vsc2UgbmV4dChyZXRWYWwpO1xuICB9XG5cbiAgbihhY3Rpb24pO1xufVxuXG5mdW5jdGlvbiBnZXRBY3Rpb25Db250ZXh0TmFtZUFuZFR5cGVQYXRoKGFjdGlvbkNvbnRleHQsIGxvZ0FyZ3NOZWFyTmFtZSkge1xuICB2YXIgbmFtZSA9IGFjdGlvbkNvbnRleHQubmFtZTtcbiAgdmFyIHRhcmdldFR5cGVQYXRoID0gYWN0aW9uQ29udGV4dC50YXJnZXRUeXBlUGF0aDtcblxuICBpZiAobG9nQXJnc05lYXJOYW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBhY3Rpb25Db250ZXh0LmNhbGxBcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpO1xuICAgIH0pLmpvaW4oXCIsIFwiKTtcblxuICAgIGlmIChhcmdzLmxlbmd0aCA+IDY0KSB7XG4gICAgICBhcmdzID0gYXJncy5zbGljZSgwLCA2NCkgKyBcIi4uLlwiO1xuICAgIH1cblxuICAgIG5hbWUgKz0gXCIoXCIgKyBhcmdzICsgXCIpXCI7XG4gIH1cblxuICBpZiAoYWN0aW9uQ29udGV4dC5ydW5uaW5nQXN5bmMpIHtcbiAgICBuYW1lICs9IFwiIChcIiArIChhY3Rpb25Db250ZXh0LnN0ZXAgIT09IHVuZGVmaW5lZCA/IGFjdGlvbkNvbnRleHQuc3RlcCA6IFwiP1wiKSArIFwiKVwiO1xuICB9XG5cbiAgaWYgKGFjdGlvbkNvbnRleHQuZXJyb3JlZCkge1xuICAgIG5hbWUgKz0gXCIgLWVycm9yIHRocm93bi1cIjtcbiAgfVxuXG4gIGlmIChhY3Rpb25Db250ZXh0LnBhcmVudCkge1xuICAgIHZhciByZXQgPSBnZXRBY3Rpb25Db250ZXh0TmFtZUFuZFR5cGVQYXRoKGFjdGlvbkNvbnRleHQucGFyZW50LCBsb2dBcmdzTmVhck5hbWUpO1xuXG4gICAgaWYgKHJldCkge1xuICAgICAgbmFtZSA9IHJldC5uYW1lICsgXCIgPj4+IFwiICsgbmFtZTtcbiAgICAgIHRhcmdldFR5cGVQYXRoID0gcmV0LnRhcmdldFR5cGVQYXRoICsgXCIgPj4+IFwiICsgdGFyZ2V0VHlwZVBhdGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHRhcmdldFR5cGVQYXRoOiB0YXJnZXRUeXBlUGF0aFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUeXBlTmFtZShub2RlKSB7XG4gIHJldHVybiBnZXRUeXBlKG5vZGUpLm5hbWUgfHwgXCIoVW5uYW1lZFR5cGUpXCI7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldFR5cGVQYXRoKG5vZGUpIHtcbiAgdmFyIGN1cnJlbnQgPSBub2RlO1xuICB2YXIgbmFtZXMgPSBbXTtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG5hbWVzLnVuc2hpZnQoZ2V0VHlwZU5hbWUoY3VycmVudCkpO1xuICAgIGN1cnJlbnQgPSBoYXNQYXJlbnQoY3VycmVudCkgPyBnZXRQYXJlbnQoY3VycmVudCkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59XG4vKipcbiAqIENvbm5lY3RzIGEgTVNUIHRyZWUgdG8gdGhlIFJlZHV4IGRldnRvb2xzLlxuICogU2VlIHRoaXMgW2V4YW1wbGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC1zdGF0ZS10cmVlL2Jsb2IvZTllODA0YzhjNDNlMWVkZGU0YWFiYmQ1MjY3NTU0NGUyYjNhOTA1Yi9leGFtcGxlcy9yZWR1eC10b2RvbXZjL3NyYy9pbmRleC5qcyNMMjEpXG4gKiBmb3IgYSBzZXR1cCBleGFtcGxlLlxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSB7Kn0gcmVtb3RlRGV2RGVwXG4gKiBAcGFyYW0ge0lBbnlTdGF0ZVRyZWVOb2RlfSBtb2RlbFxuICogQHBhcmFtIHt7XG4gKiAgICAgICAgIGxvZ0lkZW1wb3RlbnRBY3Rpb25TdGVwcz86IGJvb2xlYW5cbiAqICAgICAgICAgbG9nQ2hpbGRBY3Rpb25zPzogYm9vbGVhblxuICogICAgICAgICBsb2dBcmdzTmVhck5hbWU/OiBib29sZWFuXG4gKiAgICAgfX0gW29wdGlvbnNdXG4gKi9cblxuXG5mdW5jdGlvbiBjb25uZWN0UmVkdXhEZXZ0b29scyhyZW1vdGVEZXZEZXAsIG1vZGVsLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gX19hc3NpZ24oe1xuICAgIGxvZ0lkZW1wb3RlbnRBY3Rpb25TdGVwczogdHJ1ZSxcbiAgICBsb2dDaGlsZEFjdGlvbnM6IGZhbHNlLFxuICAgIGxvZ0FyZ3NOZWFyTmFtZTogdHJ1ZVxuICB9LCBvcHRpb25zKTtcblxuICB2YXIgaGFuZGxpbmdNb25pdG9yQWN0aW9uID0gMDsgLy8gQ29ubmVjdCB0byB0aGUgbW9uaXRvclxuXG4gIHZhciByZW1vdGVkZXYgPSByZW1vdGVEZXZEZXAuY29ubmVjdFZpYUV4dGVuc2lvbih7XG4gICAgbmFtZTogZ2V0VHlwZShtb2RlbCkubmFtZVxuICB9KTsgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZSBzdGF0ZSAoaWYgbmVlZCBtb3JlIHRoYW4ganVzdCBsb2dnaW5nKVxuXG4gIHJlbW90ZWRldi5zdWJzY3JpYmUoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS50eXBlID09PSBcIkRJU1BBVENIXCIpIHtcbiAgICAgIGhhbmRsZU1vbml0b3JBY3Rpb25zKHJlbW90ZWRldiwgbW9kZWwsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBpbml0aWFsU3RhdGUgPSBnZXRTbmFwc2hvdChtb2RlbCk7XG4gIHJlbW90ZWRldi5pbml0KGluaXRpYWxTdGF0ZSk7XG4gIHZhciBhY3Rpb25Db250ZXh0cyA9IG5ldyBNYXAoKTtcbiAgdmFyIGNoYW5nZXNNYWRlU2V0dGVyID0gdW5kZWZpbmVkO1xuXG4gIGlmICghb3B0cy5sb2dJZGVtcG90ZW50QWN0aW9uU3RlcHMpIHtcbiAgICBvblBhdGNoKG1vZGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWhhbmRsaW5nTW9uaXRvckFjdGlvbiAmJiBjaGFuZ2VzTWFkZVNldHRlcikge1xuICAgICAgICBjaGFuZ2VzTWFkZVNldHRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYWRkTWlkZGxld2FyZShtb2RlbCwgYWN0aW9uTWlkZGxld2FyZSwgZmFsc2UpO1xuXG4gIGZ1bmN0aW9uIGFjdGlvbk1pZGRsZXdhcmUoY2FsbCwgbmV4dCkge1xuICAgIGlmIChoYW5kbGluZ01vbml0b3JBY3Rpb24pIHtcbiAgICAgIG5leHQoY2FsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQ7IC8vIGZpbmQgdGhlIGNvbnRleHQgb2YgdGhlIHBhcmVudCBhY3Rpb24gKGlmIGFueSlcblxuICAgIGZvciAodmFyIGkgPSBjYWxsLmFsbFBhcmVudElkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHBhcmVudElkID0gY2FsbC5hbGxQYXJlbnRJZHNbaV07XG4gICAgICB2YXIgZm91bmRDb250ZXh0ID0gYWN0aW9uQ29udGV4dHMuZ2V0KHBhcmVudElkKTtcblxuICAgICAgaWYgKGZvdW5kQ29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gZm91bmRDb250ZXh0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIGlmIGl0IGlzIGFuIGFjdGlvbiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBhY3Rpb24gY29udGV4dFxuICAgIC8vIGFuZCBhbHNvIGlmIHRoZXJlJ3Mgbm8gY29udGV4dCAoZS5nLiB0aGUgbWlkZGxld2FyZSB3YXMgY29ubmVjdGVkIGluIHRoZSBtaWRkbGUgb2YgYW4gYWN0aW9uIHdpdGggYSBmbG93KVxuXG5cbiAgICBpZiAoY2FsbC50eXBlID09PSBcImFjdGlvblwiIHx8ICFjb250ZXh0KSB7XG4gICAgICB2YXIgdGFyZ2V0VHlwZVBhdGggPSBnZXRUYXJnZXRUeXBlUGF0aChjYWxsLmNvbnRleHQpLmpvaW4oXCIvXCIpO1xuICAgICAgdmFyIHBhcmVudENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdmFyIHBhdGggPSBjYWxsLmNvbnRleHQgPyBcInJvb3RcIiArIGdldFBhdGgoY2FsbC5jb250ZXh0KSA6IFwiKnVua25vd24qXCI7XG4gICAgICBjb250ZXh0ID0ge1xuICAgICAgICAvLyB1c2UgYSBzcGFjZSByYXRoZXIgdGhhbiBhIGRvdCBzbyB0aGF0IHRoZSByZWR1eCBkZXZ0b29scyBtb3ZlIHRoZSBhY3Rpb25zIHRvIHRoZSBuZXh0IGxpbmUgaWYgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlXG4gICAgICAgIG5hbWU6IFwiW1wiICsgcGF0aCArIFwiXSBcIiArIChjYWxsLm5hbWUgfHwgXCIqdW5rbm93bkFjdGlvbipcIiksXG4gICAgICAgIHRhcmdldFR5cGVQYXRoOiB0YXJnZXRUeXBlUGF0aCxcbiAgICAgICAgaWQ6IGNhbGwuaWQsXG4gICAgICAgIHJ1bm5pbmdBc3luYzogZmFsc2UsXG4gICAgICAgIGVycm9yZWQ6IGZhbHNlLFxuICAgICAgICBlcnJvclJlcG9ydGVkOiBmYWxzZSxcbiAgICAgICAgc3RlcDogY2FsbC50eXBlID09PSBcImFjdGlvblwiID8gMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgY2FsbEFyZ3M6IFtdLFxuICAgICAgICBjaGFuZ2VzTWFkZVNldHRlcjogdW5kZWZpbmVkXG4gICAgICB9O1xuXG4gICAgICBpZiAoY2FsbC50eXBlID09PSBcImFjdGlvblwiKSB7XG4gICAgICAgIGlmIChjYWxsLmFyZ3MpIHtcbiAgICAgICAgICBjb250ZXh0LmNhbGxBcmdzID0gX19zcHJlYWQoY2FsbC5hcmdzKTtcbiAgICAgICAgfSAvLyBzdWJhY3Rpb24sIGFzc2lnbiB0aGUgcGFyZW50IGFjdGlvbiBjb250ZXh0XG5cblxuICAgICAgICBpZiAoY2FsbC5wYXJlbnRJZCkge1xuICAgICAgICAgIGNvbnRleHQucGFyZW50ID0gcGFyZW50Q29udGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjdGlvbkNvbnRleHRzLnNldChjYWxsLmlkLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlc01hZGUgPSBmYWxzZTtcblxuICAgIGNvbnRleHQuY2hhbmdlc01hZGVTZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFuZ2VzTWFkZSA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBvbGRDaGFuZ2VzTWFkZVNldHRlciA9IGNoYW5nZXNNYWRlU2V0dGVyO1xuICAgIGNoYW5nZXNNYWRlU2V0dGVyID0gY29udGV4dC5jaGFuZ2VzTWFkZVNldHRlcjsgLy8gY2FwdHVyZSBhbnkgZXJyb3JzIGFuZCByZXRocm93IHRoZW0gbGF0ZXIgKGFmdGVyIGl0IGlzIGxvZ2dlZClcblxuICAgIHZhciBlcnJvclRocm93bjtcblxuICAgIHRyeSB7XG4gICAgICBuZXh0KGNhbGwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yVGhyb3duID0gZTtcbiAgICAgIGNvbnRleHQuZXJyb3JlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgY2hhbmdlc01hZGVTZXR0ZXIgPSBvbGRDaGFuZ2VzTWFkZVNldHRlcjtcbiAgICBjb250ZXh0LmNoYW5nZXNNYWRlU2V0dGVyID0gdW5kZWZpbmVkO1xuICAgIHZhciBjaGFuZ2VkVGhlTW9kZWwgPSBvcHRzLmxvZ0lkZW1wb3RlbnRBY3Rpb25TdGVwcyA/IHRydWUgOiBjaGFuZ2VzTWFkZTtcblxuICAgIHN3aXRjaCAoY2FsbC50eXBlKSB7XG4gICAgICBjYXNlIFwiZmxvd19zcGF3blwiOlxuICAgICAgY2FzZSBcImZsb3dfcmVzdW1lXCI6XG4gICAgICBjYXNlIFwiZmxvd19yZXN1bWVfZXJyb3JcIjpcbiAgICAgICAgLy8gbm90IGVycm9yZWQgc2luY2UgdGhlIHByb21pc2UgZXJyb3IgbWlnaHQgYmUgY2F1Z2h0XG4gICAgICAgIC8vIHdoZW4gdGhpcyBldmVudHMgY29tZSB3ZSBjYW4gYmUgc3VyZSB0aGF0IHRoaXMgYWN0aW9uIGlzIGJlaW5nIHJ1biBhc3luYywgYXMgd2VsbCBhcyBpdHMgcGFyZW50IGFjdGlvbnNcbiAgICAgICAgY29udGV4dC5ydW5uaW5nQXN5bmMgPSB0cnVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gY29udGV4dC5wYXJlbnQ7XG5cbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5ydW5uaW5nQXN5bmMgPSB0cnVlO1xuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImZsb3dfdGhyb3dcIjpcbiAgICAgICAgY29udGV4dC5lcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfSAvLyBvbmx5IGxvZyBpZjpcbiAgICAvLyAtIGl0IGlzIGEgc3luYyAobmV2ZXIgcnVuIGFzeW5jIGNvZGUpIGFjdGlvblxuICAgIC8vIC0gYSBmbG93X3Jlc3VtZVxuICAgIC8vIC0gYSBmbG93X3Rocm93IHRoYXQgd2Fzbid0IHJlcG9ydGVkIGFzIGFuIGVycm9yIGJlZm9yZVxuICAgIC8vIHdlIGRvbid0IGluY2x1ZGUgb3RoZXIga2luZHMgc2luY2UgZmxvd19zcGF3biBuZXZlciBjb250YWluIHN0YXRlIGNoYW5nZXMgYW5kIGZsb3dfcmVzdW1lX2Vycm9yIG1pZ2h0IGJlIGNhdWdodCBieSBhbmQgaGFuZGxlZCB0aGUgcGFyZW50XG5cblxuICAgIHZhciBzeW5jQWN0aW9uID0gY2FsbC50eXBlID09PSBcImFjdGlvblwiICYmICFjb250ZXh0LnJ1bm5pbmdBc3luYztcbiAgICB2YXIgbG9nID0gc3luY0FjdGlvbiB8fCBjYWxsLnR5cGUgPT09IFwiZmxvd19yZXN1bWVcIiB8fCBjYWxsLnR5cGUgPT09IFwiZmxvd190aHJvd1wiICYmICFjb250ZXh0LmVycm9yUmVwb3J0ZWQ7IC8vIGRvIG5vdCBsb2cgY2hpbGQgYWN0aW9ucyBpZiBhc2tlZCBub3QgdG8sIGJ1dCBvbmx5IGZvciBzeW5jIGFjdGlvbnNcblxuICAgIGlmICghb3B0cy5sb2dDaGlsZEFjdGlvbnMgJiYgY29udGV4dC5wYXJlbnQgJiYgIWNvbnRleHQucnVubmluZ0FzeW5jKSB7XG4gICAgICBsb2cgPSBmYWxzZTsgLy8gZ2l2ZSB0aGUgY2hpbGQgYWN0aW9uIGNoYW5nZXMgdG8gdGhlIHBhcmVudCBhY3Rpb25cblxuICAgICAgaWYgKGNoYW5nZXNNYWRlICYmIGNvbnRleHQucGFyZW50LmNoYW5nZXNNYWRlU2V0dGVyKSB7XG4gICAgICAgIGNvbnRleHQucGFyZW50LmNoYW5nZXNNYWRlU2V0dGVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxvZykge1xuICAgICAgdmFyIGxvZ1N0ZXAgPSBmdW5jdGlvbiAobG9nQ29udGV4dCkge1xuICAgICAgICB2YXIgc24gPSBnZXRTbmFwc2hvdChtb2RlbCk7XG4gICAgICAgIHZhciBuYW1lcyA9IGdldEFjdGlvbkNvbnRleHROYW1lQW5kVHlwZVBhdGgobG9nQ29udGV4dCwgb3B0cy5sb2dBcmdzTmVhck5hbWUpO1xuICAgICAgICB2YXIgY29weSA9IHtcbiAgICAgICAgICB0eXBlOiBuYW1lcy5uYW1lLFxuICAgICAgICAgIHRhcmdldFR5cGVQYXRoOiBuYW1lcy50YXJnZXRUeXBlUGF0aCxcbiAgICAgICAgICBhcmdzOiBsb2dDb250ZXh0LmNhbGxBcmdzXG4gICAgICAgIH07XG4gICAgICAgIHJlbW90ZWRldi5zZW5kKGNvcHksIHNuKTsgLy8gd2UgZG8gaXQgb3ZlciB0aGUgb3JpZ2luYWwgY29udGV4dCwgbm90IHRoZSBsb2cgY29udGV4dCwgc2luY2UgdGhlIG9yaWdpbmFsIGNvbnRleHQgbWlnaHQgdGhyb3cgYnV0IHRoZSBvcmlnaW5hbCBjb250ZXh0IG1pZ2h0IG5vdFxuXG4gICAgICAgIGlmIChjb250ZXh0LmVycm9yZWQpIHtcbiAgICAgICAgICBjb250ZXh0LmVycm9yUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgICB9IC8vIGluY3JlYXNlIHRoZSBzdGVwIGZvciBsb2dnaW5nIHB1cnBvc2VzLCBhcyB3ZWxsIGFzIGFueSBwYXJlbnQgc3RlcHMgKHNpbmNlIGNoaWxkIHN0ZXBzIGNvdW50IGFzIGEgcGFyZW50IHN0ZXApXG5cblxuICAgICAgICBpZiAoY29udGV4dC5zdGVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb250ZXh0LnN0ZXArKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnQgPSBjb250ZXh0LnBhcmVudDtcblxuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5zdGVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmVudC5zdGVwKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfTsgLy8gaWYgaXQgaXMgYW4gYXN5bmMgc3ViYWN0aW9uIHdlIG5lZWQgdG8gbG9nIGl0IHNpbmNlIGl0IG1hZGUgYSBjaGFuZ2UsIGJ1dCB3ZSB3aWxsIGxvZyBpdCBhcyBpZiBpdCB3ZXJlIHRoZSByb290XG5cblxuICAgICAgdmFyIGxvZ0FzUm9vdCA9IGNvbnRleHQucGFyZW50ICYmICFvcHRzLmxvZ0NoaWxkQWN0aW9ucztcblxuICAgICAgaWYgKGNoYW5nZWRUaGVNb2RlbCkge1xuICAgICAgICB2YXIgbG9nQ29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICAgICAgaWYgKGxvZ0FzUm9vdCkge1xuICAgICAgICAgIHdoaWxlIChsb2dDb250ZXh0LnBhcmVudCkge1xuICAgICAgICAgICAgbG9nQ29udGV4dCA9IGxvZ0NvbnRleHQucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvZ1N0ZXAobG9nQ29udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCFsb2dBc1Jvb3QgJiYgY29udGV4dC5lcnJvcmVkICYmICFjb250ZXh0LmVycm9yUmVwb3J0ZWQpIHtcbiAgICAgICAgbG9nU3RlcChjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IC8vIG9uY2UgdGhlIGFjdGlvbiBpcyB0b3RhbGx5IGZpbmlzaGVkIHJlbW92ZSBpdCBmcm9tIHRoZSBjb250ZXh0IGxpc3QgdG8gYXZvaWQgbWVtIGxlYWtzXG5cblxuICAgIGlmIChjYWxsLnR5cGUgPT09IFwiZmxvd19yZXR1cm5cIiB8fCBjYWxsLnR5cGUgPT09IFwiZmxvd190aHJvd1wiIHx8ICFjb250ZXh0LnJ1bm5pbmdBc3luYykge1xuICAgICAgYWN0aW9uQ29udGV4dHMuZGVsZXRlKGNvbnRleHQuaWQpO1xuICAgIH0gLy8gcmV0aHJvdyBwcmV2aW91c2x5IGNhcHR1cmVkIGV4Y2VwdG9uIGlmIG5lZWRlZFxuXG5cbiAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgIHRocm93IGVycm9yVGhyb3duO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vbml0b3JBY3Rpb25zKHJlbW90ZWRldjIsIG1vZGVsMiwgbWVzc2FnZSkge1xuICAgIHRyeSB7XG4gICAgICBoYW5kbGluZ01vbml0b3JBY3Rpb24rKztcblxuICAgICAgc3dpdGNoIChtZXNzYWdlLnBheWxvYWQudHlwZSkge1xuICAgICAgICBjYXNlIFwiUkVTRVRcIjpcbiAgICAgICAgICBhcHBseVNuYXBzaG90KG1vZGVsMiwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgICByZXR1cm4gcmVtb3RlZGV2Mi5pbml0KGluaXRpYWxTdGF0ZSk7XG5cbiAgICAgICAgY2FzZSBcIkNPTU1JVFwiOlxuICAgICAgICAgIHJldHVybiByZW1vdGVkZXYyLmluaXQoZ2V0U25hcHNob3QobW9kZWwyKSk7XG5cbiAgICAgICAgY2FzZSBcIlJPTExCQUNLXCI6XG4gICAgICAgICAgcmV0dXJuIHJlbW90ZWRldjIuaW5pdChyZW1vdGVEZXZEZXAuZXh0cmFjdFN0YXRlKG1lc3NhZ2UpKTtcblxuICAgICAgICBjYXNlIFwiSlVNUF9UT19TVEFURVwiOlxuICAgICAgICBjYXNlIFwiSlVNUF9UT19BQ1RJT05cIjpcbiAgICAgICAgICBhcHBseVNuYXBzaG90KG1vZGVsMiwgcmVtb3RlRGV2RGVwLmV4dHJhY3RTdGF0ZShtZXNzYWdlKSk7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgXCJJTVBPUlRfU1RBVEVcIjpcbiAgICAgICAgICB2YXIgbmV4dExpZnRlZFN0YXRlID0gbWVzc2FnZS5wYXlsb2FkLm5leHRMaWZ0ZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgY29tcHV0ZWRTdGF0ZXMgPSBuZXh0TGlmdGVkU3RhdGUuY29tcHV0ZWRTdGF0ZXM7XG4gICAgICAgICAgYXBwbHlTbmFwc2hvdChtb2RlbDIsIGNvbXB1dGVkU3RhdGVzW2NvbXB1dGVkU3RhdGVzLmxlbmd0aCAtIDFdLnN0YXRlKTtcbiAgICAgICAgICByZW1vdGVkZXYyLnNlbmQobnVsbCwgbmV4dExpZnRlZFN0YXRlKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaGFuZGxpbmdNb25pdG9yQWN0aW9uLS07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUFjdGlvbkxvZ2dlcihjYWxsLCBuZXh0KSB7XG4gIGlmIChjYWxsLnR5cGUgPT09IFwiYWN0aW9uXCIgJiYgY2FsbC5wYXJlbnRJZCA9PT0gMCkgY29uc29sZS5sb2coXCJbTVNUXSBcIiArIGdldFBhdGgoY2FsbC5jb250ZXh0KSArIFwiL1wiICsgY2FsbC5uYW1lKTtcbiAgcmV0dXJuIG5leHQoY2FsbCk7XG59XG5cbmZ1bmN0aW9uIGFjdGlvbkxvZ2dlcihjYWxsLCBuZXh0KSB7XG4gIHZhciBza2lwID0gY2FsbC50eXBlID09PSBcImFjdGlvblwiICYmIGNhbGwucGFyZW50SWQgIT09IDAgfHwgY2FsbC50eXBlID09PSBcImZsb3dfcmVzdW1lXCIgfHwgY2FsbC50eXBlID09PSBcImZsb3dfcmVzdW1lX2Vycm9yXCI7XG4gIGlmICghc2tpcCkgY29uc29sZS5sb2coXCJbTVNUXSAjXCIgKyBjYWxsLnJvb3RJZCArIFwiIFwiICsgY2FsbC50eXBlICsgXCIgLSBcIiArIGdldFBhdGgoY2FsbC5jb250ZXh0KSArIFwiL1wiICsgY2FsbC5uYW1lKTtcbiAgbmV4dChjYWxsKTtcbn1cblxudmFyIFRpbWVUcmF2ZWxsZXIgPSB0eXBlcy5tb2RlbChcIlRpbWVUcmF2ZWxsZXJcIiwge1xuICBoaXN0b3J5OiB0eXBlcy5hcnJheSh0eXBlcy5mcm96ZW4oKSksXG4gIHVuZG9JZHg6IC0xLFxuICB0YXJnZXRQYXRoOiBcIlwiXG59KS52aWV3cyhmdW5jdGlvbiAoc2VsZikge1xuICByZXR1cm4ge1xuICAgIGdldCBjYW5VbmRvKCkge1xuICAgICAgcmV0dXJuIHNlbGYudW5kb0lkeCA+IDA7XG4gICAgfSxcblxuICAgIGdldCBjYW5SZWRvKCkge1xuICAgICAgcmV0dXJuIHNlbGYudW5kb0lkeCA8IHNlbGYuaGlzdG9yeS5sZW5ndGggLSAxO1xuICAgIH1cblxuICB9O1xufSkuYWN0aW9ucyhmdW5jdGlvbiAoc2VsZikge1xuICB2YXIgdGFyZ2V0U3RvcmU7XG4gIHZhciBzbmFwc2hvdERpc3Bvc2VyO1xuICB2YXIgc2tpcE5leHRVbmRvU3RhdGUgPSBmYWxzZTtcbiAgcmV0dXJuIHtcbiAgICBhZGRVbmRvU3RhdGU6IGZ1bmN0aW9uICh0b2Rvcykge1xuICAgICAgaWYgKHNraXBOZXh0VW5kb1N0YXRlKSB7XG4gICAgICAgIC8vIHNraXAgcmVjb3JkaW5nIGlmIHRoaXMgc3RhdGUgd2FzIGNhdXNlZCBieSB1bmRvIC8gcmVkb1xuICAgICAgICBza2lwTmV4dFVuZG9TdGF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuaGlzdG9yeS5zcGxpY2Uoc2VsZi51bmRvSWR4ICsgMSk7XG4gICAgICBzZWxmLmhpc3RvcnkucHVzaCh0b2Rvcyk7XG4gICAgICBzZWxmLnVuZG9JZHggPSBzZWxmLmhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgICB9LFxuICAgIGFmdGVyQ3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0YXJnZXRTdG9yZSA9IHNlbGYudGFyZ2V0UGF0aCA/IHJlc29sdmVQYXRoKHNlbGYsIHNlbGYudGFyZ2V0UGF0aCkgOiBnZXRFbnYoc2VsZikudGFyZ2V0U3RvcmU7XG4gICAgICBpZiAoIXRhcmdldFN0b3JlKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmluZCB0YXJnZXQgc3RvcmUgZm9yIFRpbWVUcmF2ZWxsZXIuIFBsZWFzZSBwcm92aWRlIGB0YXJnZXRQYXRoYCBwcm9wZXJ0eSwgb3IgYSBgdGFyZ2V0U3RvcmVgIGluIHRoZSBlbnZpcm9ubWVudFwiKTsgLy8gVE9ETzogY2hlY2sgaWYgdGFyZ2V0U3RvcmUgZG9lc24ndCBjb250YWluIHNlbGZcbiAgICAgIC8vIGlmIChjb250YWlucyh0YXJnZXRTdG9yZSwgc2VsZikpIHRocm93IG5ldyBFcnJvcihcIlRpbWVUcmF2ZWxsZXIgc2hvdWxkbid0IGJlIHJlY29yZGluZyBpdHNlbGYuIFBsZWFzZSBzcGVjaWZ5IGEgc2libGluZyBhcyB0YXJldCwgbm90IHNvbWUgcGFyZW50XCIpXG4gICAgICAvLyBzdGFydCBsaXN0ZW5pbmcgdG8gY2hhbmdlc1xuXG4gICAgICBzbmFwc2hvdERpc3Bvc2VyID0gb25TbmFwc2hvdCh0YXJnZXRTdG9yZSwgZnVuY3Rpb24gKHNuYXBzaG90KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5hZGRVbmRvU3RhdGUoc25hcHNob3QpO1xuICAgICAgfSk7IC8vIHJlY29yZCBhbiBpbml0aWFsIHN0YXRlIGlmIG5vIGtub3duXG5cbiAgICAgIGlmIChzZWxmLmhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuYWRkVW5kb1N0YXRlKGdldFNuYXBzaG90KHRhcmdldFN0b3JlKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICBzbmFwc2hvdERpc3Bvc2VyKCk7XG4gICAgfSxcbiAgICB1bmRvOiBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnVuZG9JZHgtLTtcbiAgICAgIHNraXBOZXh0VW5kb1N0YXRlID0gdHJ1ZTtcbiAgICAgIGFwcGx5U25hcHNob3QodGFyZ2V0U3RvcmUsIHNlbGYuaGlzdG9yeVtzZWxmLnVuZG9JZHhdKTtcbiAgICB9LFxuICAgIHJlZG86IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYudW5kb0lkeCsrO1xuICAgICAgc2tpcE5leHRVbmRvU3RhdGUgPSB0cnVlO1xuICAgICAgYXBwbHlTbmFwc2hvdCh0YXJnZXRTdG9yZSwgc2VsZi5oaXN0b3J5W3NlbGYudW5kb0lkeF0pO1xuICAgIH1cbiAgfTtcbn0pO1xudmFyIEVudHJ5ID0gdHlwZXMubW9kZWwoXCJVbmRvTWFuYWdlckVudHJ5XCIsIHtcbiAgcGF0Y2hlczogdHlwZXMuZnJvemVuKCksXG4gIGludmVyc2VQYXRjaGVzOiB0eXBlcy5mcm96ZW4oKVxufSk7XG52YXIgVW5kb01hbmFnZXIgPSB0eXBlcy5tb2RlbChcIlVuZG9NYW5hZ2VyXCIsIHtcbiAgaGlzdG9yeTogdHlwZXMuYXJyYXkoRW50cnkpLFxuICB1bmRvSWR4OiAwXG59KS52aWV3cyhmdW5jdGlvbiAoc2VsZikge1xuICByZXR1cm4ge1xuICAgIGdldCB1bmRvTGV2ZWxzKCkge1xuICAgICAgcmV0dXJuIHNlbGYudW5kb0lkeDtcbiAgICB9LFxuXG4gICAgZ2V0IHJlZG9MZXZlbHMoKSB7XG4gICAgICByZXR1cm4gc2VsZi5oaXN0b3J5Lmxlbmd0aCAtIHNlbGYudW5kb0lkeDtcbiAgICB9LFxuXG4gICAgZ2V0IGNhblVuZG8oKSB7XG4gICAgICByZXR1cm4gdGhpcy51bmRvTGV2ZWxzID4gMDtcbiAgICB9LFxuXG4gICAgZ2V0IGNhblJlZG8oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWRvTGV2ZWxzID4gMDtcbiAgICB9XG5cbiAgfTtcbn0pLmFjdGlvbnMoZnVuY3Rpb24gKHNlbGYpIHtcbiAgdmFyIHRhcmdldFN0b3JlO1xuICB2YXIgcmVjb3JkaW5nRGlzYWJsZWQgPSAwO1xuICB2YXIgZ3JvdXBSZWNvcmRlcnMgPSBbXTtcbiAgdmFyIHVuZG9SZWRvTWlkZGxld2FyZSA9IGNyZWF0ZUFjdGlvblRyYWNraW5nTWlkZGxld2FyZTIoe1xuICAgIGZpbHRlcjogZnVuY3Rpb24gKGNhbGwpIHtcbiAgICAgIGlmIChjYWxsLmVudikge1xuICAgICAgICAvLyBhbHJlYWR5IHJlY29yZGluZ1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsLmNvbnRleHQgPT09IHNlbGYpIHtcbiAgICAgICAgLy8gYWxzbyBza2lwIGFjdGlvbnMgb3ZlciBzZWxmXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBvblN0YXJ0OiBmdW5jdGlvbiAoY2FsbCkge1xuICAgICAgdmFyIHJlY29yZGVyID0gcmVjb3JkUGF0Y2hlcyhjYWxsLnRyZWUsIGZ1bmN0aW9uIChfcGF0Y2gsIF9pbnZlcnNlUGF0Y2gsIGFjdGlvbkNvbnRleHQpIHtcbiAgICAgICAgaWYgKHJlY29yZGluZ0Rpc2FibGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IC8vIG9ubHkgcmVjb3JkIHBhdGNoZXMgdGhhdCB3ZXJlIGdlbmVyYXRlZCBieSB0aGlzIGFjdGlvbiBvciBjaGlsZHJlbiBvZiB0aGlzIGFjdGlvblxuXG5cbiAgICAgICAgcmV0dXJuICEhYWN0aW9uQ29udGV4dCAmJiBpc0FjdGlvbkNvbnRleHRUaGlzT3JDaGlsZE9mKGFjdGlvbkNvbnRleHQsIGNhbGwuaWQpO1xuICAgICAgfSk7XG4gICAgICByZWNvcmRlci5yZXN1bWUoKTtcbiAgICAgIGNhbGwuZW52ID0ge1xuICAgICAgICByZWNvcmRlcjogcmVjb3JkZXJcbiAgICAgIH07XG4gICAgfSxcbiAgICBvbkZpbmlzaDogZnVuY3Rpb24gKGNhbGwsIGVycm9yKSB7XG4gICAgICB2YXIgcmVjb3JkZXIgPSBjYWxsLmVudi5yZWNvcmRlcjtcbiAgICAgIGNhbGwuZW52ID0gdW5kZWZpbmVkO1xuICAgICAgcmVjb3JkZXIuc3RvcCgpO1xuXG4gICAgICBpZiAoZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZ3JvdXBSZWNvcmRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBncm91cFJlY29yZGVyID0gZ3JvdXBSZWNvcmRlcnNbZ3JvdXBSZWNvcmRlcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgZ3JvdXBSZWNvcmRlci5wYXRjaGVzID0gZ3JvdXBSZWNvcmRlci5wYXRjaGVzLmNvbmNhdChyZWNvcmRlci5wYXRjaGVzKTtcbiAgICAgICAgICBncm91cFJlY29yZGVyLmludmVyc2VQYXRjaGVzID0gZ3JvdXBSZWNvcmRlci5pbnZlcnNlUGF0Y2hlcy5jb25jYXQocmVjb3JkZXIuaW52ZXJzZVBhdGNoZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuYWRkVW5kb1N0YXRlKHJlY29yZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjb3JkZXIudW5kbygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHNraXBSZWNvcmRpbmcgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZWNvcmRpbmdEaXNhYmxlZCsrO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZWNvcmRpbmdEaXNhYmxlZC0tO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGFkZFVuZG9TdGF0ZTogZnVuY3Rpb24gKHJlY29yZGVyKSB7XG4gICAgICB0aGlzLndpdGhvdXRVbmRvKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJlY29yZGVyLnBhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gc2tpcCByZWNvcmRpbmcgaWYgcGF0Y2hlcyBpcyBlbXB0eVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuaGlzdG9yeS5zcGxpY2Uoc2VsZi51bmRvSWR4KTtcbiAgICAgICAgc2VsZi5oaXN0b3J5LnB1c2goe1xuICAgICAgICAgIHBhdGNoZXM6IHJlY29yZGVyLnBhdGNoZXMsXG4gICAgICAgICAgaW52ZXJzZVBhdGNoZXM6IHJlY29yZGVyLmludmVyc2VQYXRjaGVzXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWF4TGVuZ3RoID0gZ2V0RW52KHNlbGYpLm1heEhpc3RvcnlMZW5ndGggfHwgSW5maW5pdHk7XG4gICAgICAgIHNlbGYuaGlzdG9yeS5zcGxpY2UoMCwgc2VsZi5oaXN0b3J5Lmxlbmd0aCAtIG1heExlbmd0aCk7XG4gICAgICAgIHNlbGYudW5kb0lkeCA9IHNlbGYuaGlzdG9yeS5sZW5ndGg7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGFmdGVyQ3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VsZlJvb3QgPSBnZXRSb290KHNlbGYpO1xuICAgICAgdGFyZ2V0U3RvcmUgPSBnZXRFbnYoc2VsZikudGFyZ2V0U3RvcmUgfHwgc2VsZlJvb3Q7XG5cbiAgICAgIGlmICh0YXJnZXRTdG9yZSA9PT0gc2VsZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmRvTWFuYWdlciBzaG91bGQgYmUgY3JlYXRlZCBhcyBwYXJ0IG9mIGEgdHJlZSwgb3Igd2l0aCBgdGFyZ2V0U3RvcmVgIGluIGl0J3MgZW52aXJvbm1lbnRcIik7XG4gICAgICB9XG5cbiAgICAgIGFkZERpc3Bvc2VyKHNlbGYsIGFkZE1pZGRsZXdhcmUodGFyZ2V0U3RvcmUsIHVuZG9SZWRvTWlkZGxld2FyZSwgZmFsc2UpKTtcbiAgICB9LFxuICAgIHVuZG86IGRlY29yYXRlKGF0b21pYywgZnVuY3Rpb24gKCkge1xuICAgICAgc2tpcFJlY29yZGluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc2VsZi5jYW5VbmRvKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5kbyBub3QgcG9zc2libGUsIG5vdGhpbmcgdG8gdW5kb1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGx5UGF0Y2goZ2V0Um9vdCh0YXJnZXRTdG9yZSksIC8vIG4uYjogcmV2ZXJzZSBwYXRjaGVzIGJhY2sgdG8gZm9ydGhcbiAgICAgICAgc2VsZi5oaXN0b3J5W3NlbGYudW5kb0lkeCAtIDFdLmludmVyc2VQYXRjaGVzLnNsaWNlKCkucmV2ZXJzZSgpKTtcbiAgICAgICAgc2VsZi51bmRvSWR4LS07XG4gICAgICB9KTtcbiAgICB9KSxcbiAgICByZWRvOiBkZWNvcmF0ZShhdG9taWMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNraXBSZWNvcmRpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNlbGYuY2FuUmVkbykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlZG8gbm90IHBvc3NpYmxlLCBub3RoaW5nIHRvIHJlZG9cIik7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBseVBhdGNoKGdldFJvb3QodGFyZ2V0U3RvcmUpLCBzZWxmLmhpc3Rvcnlbc2VsZi51bmRvSWR4XS5wYXRjaGVzKTtcbiAgICAgICAgc2VsZi51bmRvSWR4Kys7XG4gICAgICB9KTtcbiAgICB9KSxcbiAgICB3aXRob3V0VW5kbzogZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gc2tpcFJlY29yZGluZyhmbik7XG4gICAgfSxcbiAgICB3aXRob3V0VW5kb0Zsb3c6IGZ1bmN0aW9uIChnZW5lcmF0b3JGbikge1xuICAgICAgcmV0dXJuIGZsb3coZnVuY3Rpb24gX193aXRob3V0VW5kb0Zsb3dfXygpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmVjb3JkaW5nRGlzYWJsZWQrKztcbiAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwsIDMsIDRdKTtcblxuICAgICAgICAgICAgICByZXR1cm4gWzVcbiAgICAgICAgICAgICAgLyp5aWVsZCoqL1xuICAgICAgICAgICAgICAsIF9fdmFsdWVzKGdlbmVyYXRvckZuKCkpXTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByZXR1cm4gWzJcbiAgICAgICAgICAgICAgLypyZXR1cm4qL1xuICAgICAgICAgICAgICAsIF9hLnNlbnQoKV07XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmVjb3JkaW5nRGlzYWJsZWQtLTtcbiAgICAgICAgICAgICAgcmV0dXJuIFs3XG4gICAgICAgICAgICAgIC8qZW5kZmluYWxseSovXG4gICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgcmV0dXJuIFsyXG4gICAgICAgICAgICAgIC8qcmV0dXJuKi9cbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzdGFydEdyb3VwOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIGlmIChncm91cFJlY29yZGVycy5sZW5ndGggPj0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhIHByZXZpb3VzIHN0YXJ0R3JvdXAgaXMgc3RpbGwgcnVubmluZywgZGlkIHlvdSBmb3JnZXQgdG8gY2FsbCBzdG9wR3JvdXA/XCIpO1xuICAgICAgfVxuXG4gICAgICBncm91cFJlY29yZGVycy5wdXNoKHtcbiAgICAgICAgcGF0Y2hlczogW10sXG4gICAgICAgIGludmVyc2VQYXRjaGVzOiBbXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9LFxuICAgIHN0b3BHcm91cDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGdyb3VwUmVjb3JkZXIgPSBncm91cFJlY29yZGVycy5wb3AoKTtcblxuICAgICAgaWYgKCFncm91cFJlY29yZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImVhY2ggY2FsbCB0byBzdG9wR3JvdXAgcmVxdWlyZXMgYSBwcmV2aW91cyBjYWxsIHRvIHN0YXJ0R3JvdXAsIGRpZCB5b3UgZm9yZ2V0IHRvIGNhbGwgc3RhcnRHcm91cD9cIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRkVW5kb1N0YXRlKGdyb3VwUmVjb3JkZXIpO1xuICAgIH0sXG4gICAgY2xlYXI6IGRlY29yYXRlKGF0b21pYywgZnVuY3Rpb24gKCkge1xuICAgICAgc2tpcFJlY29yZGluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuaGlzdG9yeS5jbGVhcigpO1xuICAgICAgICBzZWxmLnVuZG9JZHggPSAwO1xuICAgICAgfSk7XG4gICAgfSksXG4gICAgY2xlYXJVbmRvOiBkZWNvcmF0ZShhdG9taWMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNraXBSZWNvcmRpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmhpc3Rvcnkuc3BsaWNlKDAsIHNlbGYudW5kb0xldmVscyk7XG4gICAgICAgIHNlbGYudW5kb0lkeCA9IDA7XG4gICAgICB9KTtcbiAgICB9KSxcbiAgICBjbGVhclJlZG86IGRlY29yYXRlKGF0b21pYywgZnVuY3Rpb24gKCkge1xuICAgICAgc2tpcFJlY29yZGluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuaGlzdG9yeS5zcGxpY2Uoc2VsZi51bmRvSWR4LCBzZWxmLnJlZG9MZXZlbHMpO1xuICAgICAgfSk7XG4gICAgfSlcbiAgfTtcbn0pO1xuZXhwb3J0IHsgVGltZVRyYXZlbGxlciwgVW5kb01hbmFnZXIsIGFjdGlvbkxvZ2dlciwgYXNSZWR1eFN0b3JlLCBhdG9taWMsIGNvbm5lY3RSZWR1eERldnRvb2xzLCBzaW1wbGVBY3Rpb25Mb2dnZXIgfTsiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTsgLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gIH1cblxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgfVxufSkoKTtcblxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICB9IC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG5cblxuICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgfSAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG5cblxuICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgfVxuICB9XG59XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkcmFpbmluZyA9IGZhbHNlO1xuXG4gIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZUluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgZHJhaW5RdWV1ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gIGlmIChkcmFpbmluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICBkcmFpbmluZyA9IHRydWU7XG4gIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbikge1xuICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gW107XG5cbiAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICB9XG5cbiAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG5cbiAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICB9XG59OyAvLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5cblxuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gIHRoaXMuZnVuID0gZnVuO1xuICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xuXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIFtdO1xufTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnLyc7XG59O1xuXG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDA7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnOyAvLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7IC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuXG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsXG4gICAgICAgIHZzdHIsXG4gICAgICAgIGssXG4gICAgICAgIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbiAodikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuXG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24gKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG5cbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBydW50aW1lID0gZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cblxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cblxuICBleHBvcnRzLndyYXAgPSB3cmFwOyAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgIGFyZzogZm4uY2FsbChvYmosIGFyZylcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInRocm93XCIsXG4gICAgICAgIGFyZzogZXJyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjsgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuXG5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuXG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9IEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiOyAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvciA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuXG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07IC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG5cblxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICBfX2F3YWl0OiBhcmdcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfSAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuXG5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yOyAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cblxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpO1xuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9IC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcblxuXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG5cbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lID8gR2VuU3RhdGVDb21wbGV0ZWQgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7IC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG5cblxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcblxuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7IC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cblxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYzsgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH0gLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuXG5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfSAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG5cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiOyAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgdHJ5TG9jOiBsb2NzWzBdXG4gICAgfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbe1xuICAgICAgdHJ5TG9jOiBcInJvb3RcIlxuICAgIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBrZXlzLnJldmVyc2UoKTsgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG5cbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9IC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuXG5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuXG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfSAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG5cblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBkb25lUmVzdWx0XG4gICAgfTtcbiAgfVxuXG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBkb25lOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7IC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uICh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmICh0eXBlID09PSBcImJyZWFrXCIgfHwgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8IHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuICAgIGZpbmlzaDogZnVuY3Rpb24gKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9IC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9OyAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cblxuICByZXR1cm4gZXhwb3J0cztcbn0oIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4vLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbnR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9KTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGRlZmF1bHRTb2NrZXRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0U29ja2V0T3B0aW9ucyA9IHtcbiAgc2VjdXJlOiB0cnVlLFxuICBob3N0bmFtZTogJ3JlbW90ZWRldi5pbycsXG4gIHBvcnQ6IDQ0MyxcbiAgYXV0b1JlY29ubmVjdDogdHJ1ZSxcbiAgYXV0b1JlY29ubmVjdE9wdGlvbnM6IHtcbiAgICByYW5kb21uZXNzOiA2MDAwMFxuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuc2VuZCA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuZXh0cmFjdFN0YXRlID0gZXh0cmFjdFN0YXRlO1xuZXhwb3J0cy5nZW5lcmF0ZUlkID0gZ2VuZXJhdGVJZDtcbmV4cG9ydHMuc3RhcnQgPSBzdGFydDtcbmV4cG9ydHMuY29ubmVjdCA9IGNvbm5lY3Q7XG5leHBvcnRzLmNvbm5lY3RWaWFFeHRlbnNpb24gPSBjb25uZWN0VmlhRXh0ZW5zaW9uO1xuXG52YXIgX2pzYW4gPSByZXF1aXJlKCdqc2FuJyk7XG5cbnZhciBfc29ja2V0Y2x1c3RlckNsaWVudCA9IHJlcXVpcmUoJ3NvY2tldGNsdXN0ZXItY2xpZW50Jyk7XG5cbnZhciBfc29ja2V0Y2x1c3RlckNsaWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zb2NrZXRjbHVzdGVyQ2xpZW50KTtcblxudmFyIF9ybkhvc3REZXRlY3QgPSByZXF1aXJlKCdybi1ob3N0LWRldGVjdCcpO1xuXG52YXIgX3JuSG9zdERldGVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ybkhvc3REZXRlY3QpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgZGVmYXVsdDogb2JqXG4gIH07XG59XG5cbnZhciBzb2NrZXQgPSB1bmRlZmluZWQ7XG52YXIgY2hhbm5lbCA9IHVuZGVmaW5lZDtcbnZhciBsaXN0ZW5lcnMgPSB7fTtcblxuZnVuY3Rpb24gZXh0cmFjdFN0YXRlKG1lc3NhZ2UpIHtcbiAgaWYgKCFtZXNzYWdlIHx8ICFtZXNzYWdlLnN0YXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAodHlwZW9mIG1lc3NhZ2Uuc3RhdGUgPT09ICdzdHJpbmcnKSByZXR1cm4gKDAsIF9qc2FuLnBhcnNlKShtZXNzYWdlLnN0YXRlKTtcbiAgcmV0dXJuIG1lc3NhZ2Uuc3RhdGU7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSWQoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMik7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2VzKG1lc3NhZ2UpIHtcbiAgaWYgKCFtZXNzYWdlLnBheWxvYWQpIG1lc3NhZ2UucGF5bG9hZCA9IG1lc3NhZ2UuYWN0aW9uO1xuICBPYmplY3Qua2V5cyhsaXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKG1lc3NhZ2UuaW5zdGFuY2VJZCAmJiBpZCAhPT0gbWVzc2FnZS5pbnN0YW5jZUlkKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnNbaWRdID09PSAnZnVuY3Rpb24nKSBsaXN0ZW5lcnNbaWRdKG1lc3NhZ2UpO2Vsc2UgbGlzdGVuZXJzW2lkXS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgZm4obWVzc2FnZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXRjaCgpIHtcbiAgaWYgKGNoYW5uZWwpIHJldHVybjtcbiAgc29ja2V0LmVtaXQoJ2xvZ2luJywgJ21hc3RlcicsIGZ1bmN0aW9uIChlcnIsIGNoYW5uZWxOYW1lKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjaGFubmVsID0gc29ja2V0LnN1YnNjcmliZShjaGFubmVsTmFtZSk7XG4gICAgY2hhbm5lbC53YXRjaChoYW5kbGVNZXNzYWdlcyk7XG4gICAgc29ja2V0Lm9uKGNoYW5uZWxOYW1lLCBoYW5kbGVNZXNzYWdlcyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb25uZWN0VG9TZXJ2ZXIob3B0aW9ucykge1xuICBpZiAoc29ja2V0KSByZXR1cm47XG4gIHZhciBzb2NrZXRPcHRpb25zID0gdW5kZWZpbmVkO1xuXG4gIGlmIChvcHRpb25zLnBvcnQpIHtcbiAgICBzb2NrZXRPcHRpb25zID0ge1xuICAgICAgcG9ydDogb3B0aW9ucy5wb3J0LFxuICAgICAgaG9zdG5hbWU6ICgwLCBfcm5Ib3N0RGV0ZWN0Mi5kZWZhdWx0KShvcHRpb25zLmhvc3RuYW1lIHx8ICdsb2NhbGhvc3QnKSxcbiAgICAgIHNlY3VyZTogISFvcHRpb25zLnNlY3VyZVxuICAgIH07XG4gIH0gZWxzZSBzb2NrZXRPcHRpb25zID0gX2NvbnN0YW50cy5kZWZhdWx0U29ja2V0T3B0aW9ucztcblxuICBzb2NrZXQgPSBfc29ja2V0Y2x1c3RlckNsaWVudDIuZGVmYXVsdC5jcmVhdGUoc29ja2V0T3B0aW9ucyk7XG4gIHdhdGNoKCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5wb3J0ICYmICFvcHRpb25zLmhvc3RuYW1lKSB7XG4gICAgICBvcHRpb25zLmhvc3RuYW1lID0gJ2xvY2FsaG9zdCc7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdFRvU2VydmVyKG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1BY3Rpb24oYWN0aW9uLCBjb25maWcpIHtcbiAgaWYgKGFjdGlvbi5hY3Rpb24pIHJldHVybiBhY3Rpb247XG4gIHZhciBsaWZ0ZWRBY3Rpb24gPSB7XG4gICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gIH07XG5cbiAgaWYgKGFjdGlvbikge1xuICAgIGlmIChjb25maWcuZ2V0QWN0aW9uVHlwZSkgbGlmdGVkQWN0aW9uLmFjdGlvbiA9IGNvbmZpZy5nZXRBY3Rpb25UeXBlKGFjdGlvbik7ZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycpIGxpZnRlZEFjdGlvbi5hY3Rpb24gPSB7XG4gICAgICAgIHR5cGU6IGFjdGlvblxuICAgICAgfTtlbHNlIGlmICghYWN0aW9uLnR5cGUpIGxpZnRlZEFjdGlvbi5hY3Rpb24gPSB7XG4gICAgICAgIHR5cGU6ICd1cGRhdGUnXG4gICAgICB9O2Vsc2UgbGlmdGVkQWN0aW9uLmFjdGlvbiA9IGFjdGlvbjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGlmdGVkQWN0aW9uLmFjdGlvbiA9IHtcbiAgICAgIHR5cGU6IGFjdGlvblxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbGlmdGVkQWN0aW9uO1xufVxuXG5mdW5jdGlvbiBfc2VuZChhY3Rpb24sIHN0YXRlLCBvcHRpb25zLCB0eXBlLCBpbnN0YW5jZUlkKSB7XG4gIHN0YXJ0KG9wdGlvbnMpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWVzc2FnZSA9IHtcbiAgICAgIHBheWxvYWQ6IHN0YXRlID8gKDAsIF9qc2FuLnN0cmluZ2lmeSkoc3RhdGUpIDogJycsXG4gICAgICBhY3Rpb246IHR5cGUgPT09ICdBQ1RJT04nID8gKDAsIF9qc2FuLnN0cmluZ2lmeSkodHJhbnNmb3JtQWN0aW9uKGFjdGlvbiwgb3B0aW9ucykpIDogYWN0aW9uLFxuICAgICAgdHlwZTogdHlwZSB8fCAnQUNUSU9OJyxcbiAgICAgIGlkOiBzb2NrZXQuaWQsXG4gICAgICBpbnN0YW5jZUlkOiBpbnN0YW5jZUlkLFxuICAgICAgbmFtZTogb3B0aW9ucy5uYW1lXG4gICAgfTtcbiAgICBzb2NrZXQuZW1pdChzb2NrZXQuaWQgPyAnbG9nJyA6ICdsb2ctbm9pZCcsIG1lc3NhZ2UpO1xuICB9LCAwKTtcbn1cblxuZXhwb3J0cy5zZW5kID0gX3NlbmQ7XG5cbmZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gIHZhciBpZCA9IGdlbmVyYXRlSWQob3B0aW9ucy5pbnN0YW5jZUlkKTtcbiAgc3RhcnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICBfc2VuZChhY3Rpb24gfHwge30sIHN0YXRlLCBvcHRpb25zLCAnSU5JVCcsIGlkKTtcbiAgICB9LFxuICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgICBpZiAoIWxpc3RlbmVyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgaWYgKCFsaXN0ZW5lcnNbaWRdKSBsaXN0ZW5lcnNbaWRdID0gW107XG4gICAgICBsaXN0ZW5lcnNbaWRdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnNbaWRdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBsaXN0ZW5lcnNbaWRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgZGVsZXRlIGxpc3RlbmVyc1tpZF07XG4gICAgfSxcbiAgICBzZW5kOiBmdW5jdGlvbiBzZW5kKGFjdGlvbiwgcGF5bG9hZCkge1xuICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICBfc2VuZChhY3Rpb24sIHBheWxvYWQsIG9wdGlvbnMsICdBQ1RJT04nLCBpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc2VuZCh1bmRlZmluZWQsIHBheWxvYWQsIG9wdGlvbnMsICdTVEFURScsIGlkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcihwYXlsb2FkKSB7XG4gICAgICBzb2NrZXQuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdFUlJPUicsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgIGlkOiBzb2NrZXQuaWQsXG4gICAgICAgIGluc3RhbmNlSWQ6IGlkXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbm5lY3RWaWFFeHRlbnNpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlbW90ZSB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18pIHtcbiAgICByZXR1cm4gY29ubmVjdChvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXy5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGNvbm5lY3Q6IGNvbm5lY3QsXG4gIGNvbm5lY3RWaWFFeHRlbnNpb246IGNvbm5lY3RWaWFFeHRlbnNpb24sXG4gIHNlbmQ6IF9zZW5kLFxuICBleHRyYWN0U3RhdGU6IGV4dHJhY3RTdGF0ZSxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZFxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZXZUb29scycpOyIsIid1c2Ugc3RyaWN0Jztcbi8qXG4gKiBJdCBvbmx5IGZvciBEZWJ1ZyBSZW1vdGVseSBtb2RlIGZvciBBbmRyb2lkXG4gKiBXaGVuIF9fREVWX18gPT09IGZhbHNlLCB3ZSBjYW4ndCB1c2Ugd2luZG93LnJlcXVpcmUoJ05hdGl2ZU1vZHVsZXMnKVxuICovXG5cbmZ1bmN0aW9uIGdldEJ5UmVtb3RlQ29uZmlnKGhvc3RuYW1lKSB7XG4gIHZhciByZW1vdGVNb2R1bGVDb25maWcgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19mYkJhdGNoZWRCcmlkZ2VDb25maWcgJiYgd2luZG93Ll9fZmJCYXRjaGVkQnJpZGdlQ29uZmlnLnJlbW90ZU1vZHVsZUNvbmZpZztcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJlbW90ZU1vZHVsZUNvbmZpZykgfHwgaG9zdG5hbWUgIT09ICdsb2NhbGhvc3QnICYmIGhvc3RuYW1lICE9PSAnMTI3LjAuMC4xJykgcmV0dXJuIHtcbiAgICBob3N0bmFtZTogaG9zdG5hbWUsXG4gICAgcGFzc2VkOiBmYWxzZVxuICB9O1xuICB2YXIgcmVzdWx0ID0gaG9zdG5hbWU7XG4gIHZhciBwYXNzZWQgPSBmYWxzZTtcbiAgcmVtb3RlTW9kdWxlQ29uZmlnLnNvbWUoZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIGlmICghY29uZmlnKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIG5hbWUgPSBjb25maWdbMF07XG4gICAgdmFyIGNvbnRlbnQgPSBjb25maWdbMV07XG5cbiAgICBpZiAoKG5hbWUgPT09ICdBbmRyb2lkQ29uc3RhbnRzJyB8fCBuYW1lID09PSAnUGxhdGZvcm1Db25zdGFudHMnKSAmJiBjb250ZW50ICYmIGNvbnRlbnQuU2VydmVySG9zdCkge1xuICAgICAgcmVzdWx0ID0gY29udGVudC5TZXJ2ZXJIb3N0LnNwbGl0KCc6JylbMF07XG4gICAgICBwYXNzZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdTb3VyY2VDb2RlJyAmJiBjb250ZW50ICYmIGNvbnRlbnQuc2NyaXB0VVJMKSB7XG4gICAgICByZXN1bHQgPSBjb250ZW50LnNjcmlwdFVSTC5yZXBsYWNlKC9odHRwcz86XFwvXFwvLywgJycpLnNwbGl0KCc6JylbMF07XG4gICAgICBwYXNzZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBob3N0bmFtZTogcmVzdWx0LFxuICAgIHBhc3NlZDogcGFzc2VkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEJ5Uk5SZXF1aXJlUG9seWZpbGwoaG9zdG5hbWUpIHtcbiAgdmFyIG9yaWdpbmFsV2FybiA9IGNvbnNvbGUud2FybjtcbiAgdmFyIE5hdGl2ZU1vZHVsZXM7XG4gIHZhciBDb25zdGFudHM7XG4gIHZhciBTb3VyY2VDb2RlO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Ll9fREVWX18gfHwgdHlwZW9mIHdpbmRvdy5yZXF1aXJlICE9PSAnZnVuY3Rpb24nIHx8IC8vIFJOID49IDAuNTZcbiAgLy8gVE9ETzogR2V0IE5hdGl2ZU1vZHVsZXMgZm9yIFJOID49IDAuNTZcbiAgd2luZG93LnJlcXVpcmUubmFtZSA9PT0gJ21ldHJvUmVxdWlyZScpIHtcbiAgICByZXR1cm4gaG9zdG5hbWU7XG4gIH1cblxuICBjb25zb2xlLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdLmluZGV4T2YgPT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHNbMF0uaW5kZXhPZihcIlJlcXVpcmluZyBtb2R1bGUgJ05hdGl2ZU1vZHVsZXMnIGJ5IG5hbWVcIikgPiAtMSkgcmV0dXJuO1xuICAgIHJldHVybiBvcmlnaW5hbFdhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB0cnkge1xuICAgIE5hdGl2ZU1vZHVsZXMgPSB3aW5kb3cucmVxdWlyZSgnTmF0aXZlTW9kdWxlcycpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIGNvbnNvbGUud2FybiA9IG9yaWdpbmFsV2FybjtcbiAgaWYgKCFOYXRpdmVNb2R1bGVzKSByZXR1cm4gaG9zdG5hbWU7XG4gIENvbnN0YW50cyA9IE5hdGl2ZU1vZHVsZXMuUGxhdGZvcm1Db25zdGFudHMgfHwgTmF0aXZlTW9kdWxlcy5BbmRyb2lkQ29uc3RhbnRzO1xuICBTb3VyY2VDb2RlID0gTmF0aXZlTW9kdWxlcy5Tb3VyY2VDb2RlO1xuXG4gIGlmIChDb25zdGFudHMgJiYgQ29uc3RhbnRzLlNlcnZlckhvc3QpIHtcbiAgICByZXR1cm4gQ29uc3RhbnRzLlNlcnZlckhvc3Quc3BsaXQoJzonKVswXTtcbiAgfSBlbHNlIGlmIChTb3VyY2VDb2RlICYmIFNvdXJjZUNvZGUuc2NyaXB0VVJMKSB7XG4gICAgcmV0dXJuIFNvdXJjZUNvZGUuc2NyaXB0VVJMLnJlcGxhY2UoL2h0dHBzPzpcXC9cXC8vLCAnJykuc3BsaXQoJzonKVswXTtcbiAgfVxuXG4gIHJldHVybiBob3N0bmFtZTtcbn1cbi8qXG4gKiBHZXQgUmVhY3QgTmF0aXZlIHNlcnZlciBJUCBpZiBob3N0bmFtZSBpcyBgbG9jYWxob3N0YFxuICogT24gQW5kcm9pZCBlbXVsYXRvciwgdGhlIElQIG9mIGhvc3QgaXMgYDEwLjAuMi4yYCAoR2VueW1vdGlvbjogMTAuMC4zLjIpXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChob3N0bmFtZSkge1xuICAvLyBDaGVjayBpZiBpdCBpbiBSZWFjdCBOYXRpdmUgZW52aXJvbm1lbnRcbiAgaWYgKHR5cGVvZiBfX2ZiQmF0Y2hlZEJyaWRnZUNvbmZpZyAhPT0gJ29iamVjdCcgfHwgaG9zdG5hbWUgIT09ICdsb2NhbGhvc3QnICYmIGhvc3RuYW1lICE9PSAnMTI3LjAuMC4xJykge1xuICAgIHJldHVybiBob3N0bmFtZTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBnZXRCeVJlbW90ZUNvbmZpZyhob3N0bmFtZSk7IC8vIExlYXZlIGlmIGdldCBob3N0bmFtZSBieSByZW1vdGUgY29uZmlnIHN1Y2Nlc3NmdWxcblxuICBpZiAocmVzdWx0LnBhc3NlZCkge1xuICAgIHJldHVybiByZXN1bHQuaG9zdG5hbWU7XG4gIH0gLy8gT3RoZXJ3aXNlLCB1c2UgUk4ncyByZXF1aXJlIHBvbHlmaWxsXG5cblxuICByZXR1cm4gZ2V0QnlSTlJlcXVpcmVQb2x5ZmlsbChob3N0bmFtZSk7XG59OyIsInZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcblxudmFyIFNDQ2hhbm5lbCA9IGZ1bmN0aW9uIChuYW1lLCBjbGllbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuUEVORElORyA9ICdwZW5kaW5nJztcbiAgdGhpcy5TVUJTQ1JJQkVEID0gJ3N1YnNjcmliZWQnO1xuICB0aGlzLlVOU1VCU0NSSUJFRCA9ICd1bnN1YnNjcmliZWQnO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnN0YXRlID0gdGhpcy5VTlNVQlNDUklCRUQ7XG4gIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcbn07XG5cblNDQ2hhbm5lbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVtaXR0ZXIucHJvdG90eXBlKTtcblxuU0NDaGFubmVsLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdGhpcy53YWl0Rm9yQXV0aCA9IG9wdGlvbnMud2FpdEZvckF1dGggfHwgZmFsc2U7XG4gIHRoaXMuYmF0Y2ggPSBvcHRpb25zLmJhdGNoIHx8IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgfVxufTtcblxuU0NDaGFubmVsLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc3RhdGU7XG59O1xuXG5TQ0NoYW5uZWwucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHRoaXMuY2xpZW50LnN1YnNjcmliZSh0aGlzLm5hbWUsIG9wdGlvbnMpO1xufTtcblxuU0NDaGFubmVsLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbGllbnQudW5zdWJzY3JpYmUodGhpcy5uYW1lKTtcbn07XG5cblNDQ2hhbm5lbC5wcm90b3R5cGUuaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gKGluY2x1ZGVQZW5kaW5nKSB7XG4gIHJldHVybiB0aGlzLmNsaWVudC5pc1N1YnNjcmliZWQodGhpcy5uYW1lLCBpbmNsdWRlUGVuZGluZyk7XG59O1xuXG5TQ0NoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgdGhpcy5jbGllbnQucHVibGlzaCh0aGlzLm5hbWUsIGRhdGEsIGNhbGxiYWNrKTtcbn07XG5cblNDQ2hhbm5lbC5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICB0aGlzLmNsaWVudC53YXRjaCh0aGlzLm5hbWUsIGhhbmRsZXIpO1xufTtcblxuU0NDaGFubmVsLnByb3RvdHlwZS51bndhdGNoID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgdGhpcy5jbGllbnQudW53YXRjaCh0aGlzLm5hbWUsIGhhbmRsZXIpO1xufTtcblxuU0NDaGFubmVsLnByb3RvdHlwZS53YXRjaGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2xpZW50LndhdGNoZXJzKHRoaXMubmFtZSk7XG59O1xuXG5TQ0NoYW5uZWwucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2xpZW50LmRlc3Ryb3lDaGFubmVsKHRoaXMubmFtZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5TQ0NoYW5uZWwgPSBTQ0NoYW5uZWw7IiwiLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcbn1cbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXG5cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbjtcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXG5cblxuRW1pdHRlci5wcm90b3R5cGUub24gPSBFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSkucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xuXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXG5cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID0gRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307IC8vIGFsbFxuXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBzcGVjaWZpYyBldmVudFxuXG5cbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpczsgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuXG5cbiAgdmFyIGNiO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG5cbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cblxuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXG5cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xuXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudCkge1xuICByZXR1cm4gISF0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTsiLCIvLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZHNjYXBlL2N5Y2xlL2Jsb2IvbWFzdGVyL2N5Y2xlLmpzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlY3ljbGUob2JqZWN0KSB7XG4gIC8vIE1ha2UgYSBkZWVwIGNvcHkgb2YgYW4gb2JqZWN0IG9yIGFycmF5LCBhc3N1cmluZyB0aGF0IHRoZXJlIGlzIGF0IG1vc3RcbiAgLy8gb25lIGluc3RhbmNlIG9mIGVhY2ggb2JqZWN0IG9yIGFycmF5IGluIHRoZSByZXN1bHRpbmcgc3RydWN0dXJlLiBUaGVcbiAgLy8gZHVwbGljYXRlIHJlZmVyZW5jZXMgKHdoaWNoIG1pZ2h0IGJlIGZvcm1pbmcgY3ljbGVzKSBhcmUgcmVwbGFjZWQgd2l0aFxuICAvLyBhbiBvYmplY3Qgb2YgdGhlIGZvcm1cbiAgLy8gICAgICB7JHJlZjogUEFUSH1cbiAgLy8gd2hlcmUgdGhlIFBBVEggaXMgYSBKU09OUGF0aCBzdHJpbmcgdGhhdCBsb2NhdGVzIHRoZSBmaXJzdCBvY2N1cmFuY2UuXG4gIC8vIFNvLFxuICAvLyAgICAgIHZhciBhID0gW107XG4gIC8vICAgICAgYVswXSA9IGE7XG4gIC8vICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KEpTT04uZGVjeWNsZShhKSk7XG4gIC8vIHByb2R1Y2VzIHRoZSBzdHJpbmcgJ1t7XCIkcmVmXCI6XCIkXCJ9XScuXG4gIC8vIEpTT05QYXRoIGlzIHVzZWQgdG8gbG9jYXRlIHRoZSB1bmlxdWUgb2JqZWN0LiAkIGluZGljYXRlcyB0aGUgdG9wIGxldmVsIG9mXG4gIC8vIHRoZSBvYmplY3Qgb3IgYXJyYXkuIFtOVU1CRVJdIG9yIFtTVFJJTkddIGluZGljYXRlcyBhIGNoaWxkIG1lbWJlciBvclxuICAvLyBwcm9wZXJ0eS5cbiAgdmFyIG9iamVjdHMgPSBbXSxcbiAgICAgIC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gZWFjaCB1bmlxdWUgb2JqZWN0IG9yIGFycmF5XG4gIHBhdGhzID0gW107IC8vIEtlZXAgdGhlIHBhdGggdG8gZWFjaCB1bmlxdWUgb2JqZWN0IG9yIGFycmF5XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlcmV6KHZhbHVlLCBwYXRoKSB7XG4gICAgLy8gVGhlIGRlcmV6IHJlY3Vyc2VzIHRocm91Z2ggdGhlIG9iamVjdCwgcHJvZHVjaW5nIHRoZSBkZWVwIGNvcHkuXG4gICAgdmFyIGksIC8vIFRoZSBsb29wIGNvdW50ZXJcbiAgICBuYW1lLCAvLyBQcm9wZXJ0eSBuYW1lXG4gICAgbnU7IC8vIFRoZSBuZXcgb2JqZWN0IG9yIGFycmF5XG4gICAgLy8gdHlwZW9mIG51bGwgPT09ICdvYmplY3QnLCBzbyBnbyBvbiBpZiB0aGlzIHZhbHVlIGlzIHJlYWxseSBhbiBvYmplY3QgYnV0IG5vdFxuICAgIC8vIG9uZSBvZiB0aGUgd2VpcmQgYnVpbHRpbiBvYmplY3RzLlxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4pICYmICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCBvciBhcnJheSwgbG9vayB0byBzZWUgaWYgd2UgaGF2ZSBhbHJlYWR5XG4gICAgICAvLyBlbmNvdW50ZXJlZCBpdC4gSWYgc28sIHJldHVybiBhICRyZWYvcGF0aCBvYmplY3QuIFRoaXMgaXMgYSBoYXJkIHdheSxcbiAgICAgIC8vIGxpbmVhciBzZWFyY2ggdGhhdCB3aWxsIGdldCBzbG93ZXIgYXMgdGhlIG51bWJlciBvZiB1bmlxdWUgb2JqZWN0cyBncm93cy5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChvYmplY3RzW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAkcmVmOiBwYXRoc1tpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gT3RoZXJ3aXNlLCBhY2N1bXVsYXRlIHRoZSB1bmlxdWUgdmFsdWUgYW5kIGl0cyBwYXRoLlxuXG5cbiAgICAgIG9iamVjdHMucHVzaCh2YWx1ZSk7XG4gICAgICBwYXRocy5wdXNoKHBhdGgpOyAvLyBJZiBpdCBpcyBhbiBhcnJheSwgcmVwbGljYXRlIHRoZSBhcnJheS5cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIG51ID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgbnVbaV0gPSBkZXJleih2YWx1ZVtpXSwgcGF0aCArICdbJyArIGkgKyAnXScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBpdCBpcyBhbiBvYmplY3QsIHJlcGxpY2F0ZSB0aGUgb2JqZWN0LlxuICAgICAgICBudSA9IHt9O1xuXG4gICAgICAgIGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIG5hbWUpKSB7XG4gICAgICAgICAgICBudVtuYW1lXSA9IGRlcmV6KHZhbHVlW25hbWVdLCBwYXRoICsgJ1snICsgSlNPTi5zdHJpbmdpZnkobmFtZSkgKyAnXScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KG9iamVjdCwgJyQnKTtcbn07IiwidmFyIGRlY3ljbGUgPSByZXF1aXJlKCcuL2RlY3ljbGUnKTtcblxudmFyIGlzU3RyaWN0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIXRoaXM7XG59KCk7XG5cbmZ1bmN0aW9uIEF1dGhUb2tlbkV4cGlyZWRFcnJvcihtZXNzYWdlLCBleHBpcnkpIHtcbiAgdGhpcy5uYW1lID0gJ0F1dGhUb2tlbkV4cGlyZWRFcnJvcic7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuZXhwaXJ5ID0gZXhwaXJ5O1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH1cbn1cblxuQXV0aFRva2VuRXhwaXJlZEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gQXV0aFRva2VuSW52YWxpZEVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gJ0F1dGhUb2tlbkludmFsaWRFcnJvcic7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmICFpc1N0cmljdCkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGFyZ3VtZW50cy5jYWxsZWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgfVxufVxuXG5BdXRoVG9rZW5JbnZhbGlkRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBBdXRoVG9rZW5Ob3RCZWZvcmVFcnJvcihtZXNzYWdlLCBkYXRlKSB7XG4gIHRoaXMubmFtZSA9ICdBdXRoVG9rZW5Ob3RCZWZvcmVFcnJvcic7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuZGF0ZSA9IGRhdGU7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmICFpc1N0cmljdCkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGFyZ3VtZW50cy5jYWxsZWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgfVxufVxuXG5BdXRoVG9rZW5Ob3RCZWZvcmVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7IC8vIEZvciBhbnkgb3RoZXIgYXV0aCB0b2tlbiBlcnJvci5cblxuZnVuY3Rpb24gQXV0aFRva2VuRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSAnQXV0aFRva2VuRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH1cbn1cblxuQXV0aFRva2VuRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBTaWxlbnRNaWRkbGV3YXJlQmxvY2tlZEVycm9yKG1lc3NhZ2UsIHR5cGUpIHtcbiAgdGhpcy5uYW1lID0gJ1NpbGVudE1pZGRsZXdhcmVCbG9ja2VkRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH1cbn1cblxuU2lsZW50TWlkZGxld2FyZUJsb2NrZWRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIEludmFsaWRBY3Rpb25FcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9ICdJbnZhbGlkQWN0aW9uRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH1cbn1cblxuSW52YWxpZEFjdGlvbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gSW52YWxpZEFyZ3VtZW50c0Vycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gJ0ludmFsaWRBcmd1bWVudHNFcnJvcic7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmICFpc1N0cmljdCkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGFyZ3VtZW50cy5jYWxsZWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgfVxufVxuXG5JbnZhbGlkQXJndW1lbnRzRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBJbnZhbGlkT3B0aW9uc0Vycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gJ0ludmFsaWRPcHRpb25zRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH1cbn1cblxuSW52YWxpZE9wdGlvbnNFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIEludmFsaWRNZXNzYWdlRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSAnSW52YWxpZE1lc3NhZ2VFcnJvcic7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmICFpc1N0cmljdCkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGFyZ3VtZW50cy5jYWxsZWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgfVxufVxuXG5JbnZhbGlkTWVzc2FnZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gU29ja2V0UHJvdG9jb2xFcnJvcihtZXNzYWdlLCBjb2RlKSB7XG4gIHRoaXMubmFtZSA9ICdTb2NrZXRQcm90b2NvbEVycm9yJztcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5jb2RlID0gY29kZTtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgJiYgIWlzU3RyaWN0KSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgYXJndW1lbnRzLmNhbGxlZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICB9XG59XG5cblNvY2tldFByb3RvY29sRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBTZXJ2ZXJQcm90b2NvbEVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gJ1NlcnZlclByb3RvY29sRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH1cbn1cblxuU2VydmVyUHJvdG9jb2xFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIEhUVFBTZXJ2ZXJFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9ICdIVFRQU2VydmVyRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH1cbn1cblxuSFRUUFNlcnZlckVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gUmVzb3VyY2VMaW1pdEVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gJ1Jlc291cmNlTGltaXRFcnJvcic7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmICFpc1N0cmljdCkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGFyZ3VtZW50cy5jYWxsZWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgfVxufVxuXG5SZXNvdXJjZUxpbWl0RXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBUaW1lb3V0RXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSAnVGltZW91dEVycm9yJztcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgJiYgIWlzU3RyaWN0KSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgYXJndW1lbnRzLmNhbGxlZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICB9XG59XG5cblRpbWVvdXRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIEJhZENvbm5lY3Rpb25FcnJvcihtZXNzYWdlLCB0eXBlKSB7XG4gIHRoaXMubmFtZSA9ICdCYWRDb25uZWN0aW9uRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH1cbn1cblxuQmFkQ29ubmVjdGlvbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gQnJva2VyRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSAnQnJva2VyRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH1cbn1cblxuQnJva2VyRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBQcm9jZXNzRXhpdEVycm9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgdGhpcy5uYW1lID0gJ1Byb2Nlc3NFeGl0RXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLmNvZGUgPSBjb2RlO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH1cbn1cblxuUHJvY2Vzc0V4aXRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIFVua25vd25FcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9ICdVbmtub3duRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiAhaXNTdHJpY3QpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIH1cbn1cblxuVW5rbm93bkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTsgLy8gRXhwb3NlIGFsbCBlcnJvciB0eXBlcy5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEF1dGhUb2tlbkV4cGlyZWRFcnJvcjogQXV0aFRva2VuRXhwaXJlZEVycm9yLFxuICBBdXRoVG9rZW5JbnZhbGlkRXJyb3I6IEF1dGhUb2tlbkludmFsaWRFcnJvcixcbiAgQXV0aFRva2VuTm90QmVmb3JlRXJyb3I6IEF1dGhUb2tlbk5vdEJlZm9yZUVycm9yLFxuICBBdXRoVG9rZW5FcnJvcjogQXV0aFRva2VuRXJyb3IsXG4gIFNpbGVudE1pZGRsZXdhcmVCbG9ja2VkRXJyb3I6IFNpbGVudE1pZGRsZXdhcmVCbG9ja2VkRXJyb3IsXG4gIEludmFsaWRBY3Rpb25FcnJvcjogSW52YWxpZEFjdGlvbkVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRzRXJyb3I6IEludmFsaWRBcmd1bWVudHNFcnJvcixcbiAgSW52YWxpZE9wdGlvbnNFcnJvcjogSW52YWxpZE9wdGlvbnNFcnJvcixcbiAgSW52YWxpZE1lc3NhZ2VFcnJvcjogSW52YWxpZE1lc3NhZ2VFcnJvcixcbiAgU29ja2V0UHJvdG9jb2xFcnJvcjogU29ja2V0UHJvdG9jb2xFcnJvcixcbiAgU2VydmVyUHJvdG9jb2xFcnJvcjogU2VydmVyUHJvdG9jb2xFcnJvcixcbiAgSFRUUFNlcnZlckVycm9yOiBIVFRQU2VydmVyRXJyb3IsXG4gIFJlc291cmNlTGltaXRFcnJvcjogUmVzb3VyY2VMaW1pdEVycm9yLFxuICBUaW1lb3V0RXJyb3I6IFRpbWVvdXRFcnJvcixcbiAgQmFkQ29ubmVjdGlvbkVycm9yOiBCYWRDb25uZWN0aW9uRXJyb3IsXG4gIEJyb2tlckVycm9yOiBCcm9rZXJFcnJvcixcbiAgUHJvY2Vzc0V4aXRFcnJvcjogUHJvY2Vzc0V4aXRFcnJvcixcbiAgVW5rbm93bkVycm9yOiBVbmtub3duRXJyb3Jcbn07XG5tb2R1bGUuZXhwb3J0cy5zb2NrZXRQcm90b2NvbEVycm9yU3RhdHVzZXMgPSB7XG4gIDEwMDE6ICdTb2NrZXQgd2FzIGRpc2Nvbm5lY3RlZCcsXG4gIDEwMDI6ICdBIFdlYlNvY2tldCBwcm90b2NvbCBlcnJvciB3YXMgZW5jb3VudGVyZWQnLFxuICAxMDAzOiAnU2VydmVyIHRlcm1pbmF0ZWQgc29ja2V0IGJlY2F1c2UgaXQgcmVjZWl2ZWQgaW52YWxpZCBkYXRhJyxcbiAgMTAwNTogJ1NvY2tldCBjbG9zZWQgd2l0aG91dCBzdGF0dXMgY29kZScsXG4gIDEwMDY6ICdTb2NrZXQgaHVuZyB1cCcsXG4gIDEwMDc6ICdNZXNzYWdlIGZvcm1hdCB3YXMgaW5jb3JyZWN0JyxcbiAgMTAwODogJ0VuY291bnRlcmVkIGEgcG9saWN5IHZpb2xhdGlvbicsXG4gIDEwMDk6ICdNZXNzYWdlIHdhcyB0b28gYmlnIHRvIHByb2Nlc3MnLFxuICAxMDEwOiAnQ2xpZW50IGVuZGVkIHRoZSBjb25uZWN0aW9uIGJlY2F1c2UgdGhlIHNlcnZlciBkaWQgbm90IGNvbXBseSB3aXRoIGV4dGVuc2lvbiByZXF1aXJlbWVudHMnLFxuICAxMDExOiAnU2VydmVyIGVuY291bnRlcmVkIGFuIHVuZXhwZWN0ZWQgZmF0YWwgY29uZGl0aW9uJyxcbiAgNDAwMDogJ1NlcnZlciBwaW5nIHRpbWVkIG91dCcsXG4gIDQwMDE6ICdDbGllbnQgcG9uZyB0aW1lZCBvdXQnLFxuICA0MDAyOiAnU2VydmVyIGZhaWxlZCB0byBzaWduIGF1dGggdG9rZW4nLFxuICA0MDAzOiAnRmFpbGVkIHRvIGNvbXBsZXRlIGhhbmRzaGFrZScsXG4gIDQwMDQ6ICdDbGllbnQgZmFpbGVkIHRvIHNhdmUgYXV0aCB0b2tlbicsXG4gIDQwMDU6ICdEaWQgbm90IHJlY2VpdmUgI2hhbmRzaGFrZSBmcm9tIGNsaWVudCBiZWZvcmUgdGltZW91dCcsXG4gIDQwMDY6ICdGYWlsZWQgdG8gYmluZCBzb2NrZXQgdG8gbWVzc2FnZSBicm9rZXInLFxuICA0MDA3OiAnQ2xpZW50IGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudCB0aW1lZCBvdXQnLFxuICA0MDA4OiAnU2VydmVyIHJlamVjdGVkIGhhbmRzaGFrZSBmcm9tIGNsaWVudCdcbn07XG5tb2R1bGUuZXhwb3J0cy5zb2NrZXRQcm90b2NvbElnbm9yZVN0YXR1c2VzID0ge1xuICAxMDAwOiAnU29ja2V0IGNsb3NlZCBub3JtYWxseScsXG4gIDEwMDE6ICdTb2NrZXQgaHVuZyB1cCdcbn07IC8vIFByb3BlcnRpZXMgcmVsYXRlZCB0byBlcnJvciBkb21haW5zIGNhbm5vdCBiZSBzZXJpYWxpemVkLlxuXG52YXIgdW5zZXJpYWxpemFibGVFcnJvclByb3BlcnRpZXMgPSB7XG4gIGRvbWFpbjogMSxcbiAgZG9tYWluRW1pdHRlcjogMSxcbiAgZG9tYWluVGhyb3duOiAxXG59OyAvLyBDb252ZXJ0IGFuIGVycm9yIGludG8gYSBKU09OLWNvbXBhdGlibGUgdHlwZSB3aGljaCBjYW4gbGF0ZXIgYmUgaHlkcmF0ZWRcbi8vIGJhY2sgdG8gaXRzICpvcmlnaW5hbCogZm9ybS5cblxubW9kdWxlLmV4cG9ydHMuZGVoeWRyYXRlRXJyb3IgPSBmdW5jdGlvbiBkZWh5ZHJhdGVFcnJvcihlcnJvciwgaW5jbHVkZVN0YWNrVHJhY2UpIHtcbiAgdmFyIGRlaHlkcmF0ZWRFcnJvcjtcblxuICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgIGRlaHlkcmF0ZWRFcnJvciA9IHtcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xuXG4gICAgaWYgKGluY2x1ZGVTdGFja1RyYWNlKSB7XG4gICAgICBkZWh5ZHJhdGVkRXJyb3Iuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpIGluIGVycm9yKSB7XG4gICAgICBpZiAoIXVuc2VyaWFsaXphYmxlRXJyb3JQcm9wZXJ0aWVzW2ldKSB7XG4gICAgICAgIGRlaHlkcmF0ZWRFcnJvcltpXSA9IGVycm9yW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkZWh5ZHJhdGVkRXJyb3IgPSAnW2Z1bmN0aW9uICcgKyAoZXJyb3IubmFtZSB8fCAnYW5vbnltb3VzJykgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgZGVoeWRyYXRlZEVycm9yID0gZXJyb3I7XG4gIH1cblxuICByZXR1cm4gZGVjeWNsZShkZWh5ZHJhdGVkRXJyb3IpO1xufTsgLy8gQ29udmVydCBhIGRlaHlkcmF0ZWQgZXJyb3IgYmFjayB0byBpdHMgKm9yaWdpbmFsKiBmb3JtLlxuXG5cbm1vZHVsZS5leHBvcnRzLmh5ZHJhdGVFcnJvciA9IGZ1bmN0aW9uIGh5ZHJhdGVFcnJvcihlcnJvcikge1xuICB2YXIgaHlkcmF0ZWRFcnJvciA9IG51bGw7XG5cbiAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgICAgaHlkcmF0ZWRFcnJvciA9IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKTtcblxuICAgICAgZm9yICh2YXIgaSBpbiBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICBoeWRyYXRlZEVycm9yW2ldID0gZXJyb3JbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaHlkcmF0ZWRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoeWRyYXRlZEVycm9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZGVjeWNsZSA9IGRlY3ljbGU7IiwidmFyIGJhc2U2NENoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG52YXIgdmFsaWRKU09OU3RhcnRSZWdleCA9IC9eWyBcXG5cXHJcXHRdKlt7XFxbXS87XG5cbnZhciBhcnJheUJ1ZmZlclRvQmFzZTY0ID0gZnVuY3Rpb24gKGFycmF5YnVmZmVyKSB7XG4gIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgdmFyIGJhc2U2NCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICBiYXNlNjQgKz0gYmFzZTY0Q2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgYmFzZTY0ICs9IGJhc2U2NENoYXJzWyhieXRlc1tpXSAmIDMpIDw8IDQgfCBieXRlc1tpICsgMV0gPj4gNF07XG4gICAgYmFzZTY0ICs9IGJhc2U2NENoYXJzWyhieXRlc1tpICsgMV0gJiAxNSkgPDwgMiB8IGJ5dGVzW2kgKyAyXSA+PiA2XTtcbiAgICBiYXNlNjQgKz0gYmFzZTY0Q2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICB9XG5cbiAgaWYgKGxlbiAlIDMgPT09IDIpIHtcbiAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArICc9JztcbiAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyAnPT0nO1xuICB9XG5cbiAgcmV0dXJuIGJhc2U2NDtcbn07XG5cbnZhciBiaW5hcnlUb0Jhc2U2NFJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiB2YWx1ZSBpbnN0YW5jZW9mIGdsb2JhbC5BcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlNjQ6IHRydWUsXG4gICAgICBkYXRhOiBhcnJheUJ1ZmZlclRvQmFzZTY0KHZhbHVlKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLkJ1ZmZlcikge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGdsb2JhbC5CdWZmZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U2NDogdHJ1ZSxcbiAgICAgICAgZGF0YTogdmFsdWUudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICB9O1xuICAgIH0gLy8gU29tZSB2ZXJzaW9ucyBvZiBOb2RlLmpzIGNvbnZlcnQgQnVmZmVycyB0byBPYmplY3RzIGJlZm9yZSB0aGV5IGFyZSBwYXNzZWQgdG9cbiAgICAvLyB0aGUgcmVwbGFjZXIgZnVuY3Rpb24gLSBCZWNhdXNlIG9mIHRoaXMsIHdlIG5lZWQgdG8gcmVoeWRyYXRlIEJ1ZmZlcnNcbiAgICAvLyBiZWZvcmUgd2UgY2FuIGNvbnZlcnQgdGhlbSB0byBiYXNlNjQgc3RyaW5ncy5cblxuXG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSkpIHtcbiAgICAgIHZhciByZWh5ZHJhdGVkQnVmZmVyO1xuXG4gICAgICBpZiAoZ2xvYmFsLkJ1ZmZlci5mcm9tKSB7XG4gICAgICAgIHJlaHlkcmF0ZWRCdWZmZXIgPSBnbG9iYWwuQnVmZmVyLmZyb20odmFsdWUuZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWh5ZHJhdGVkQnVmZmVyID0gbmV3IGdsb2JhbC5CdWZmZXIodmFsdWUuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U2NDogdHJ1ZSxcbiAgICAgICAgZGF0YTogcmVoeWRyYXRlZEJ1ZmZlci50b1N0cmluZygnYmFzZTY0JylcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTsgLy8gRGVjb2RlIHRoZSBkYXRhIHdoaWNoIHdhcyB0cmFuc21pdHRlZCBvdmVyIHRoZSB3aXJlIHRvIGEgSmF2YVNjcmlwdCBPYmplY3QgaW4gYSBmb3JtYXQgd2hpY2ggU0MgdW5kZXJzdGFuZHMuXG4vLyBTZWUgZW5jb2RlIGZ1bmN0aW9uIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG5cblxubW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gTGVhdmUgcGluZyBvciBwb25nIG1lc3NhZ2UgYXMgaXNcblxuXG4gIGlmIChpbnB1dCA9PT0gJyMxJyB8fCBpbnB1dCA9PT0gJyMyJykge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIHZhciBtZXNzYWdlID0gaW5wdXQudG9TdHJpbmcoKTsgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHRvIGRldGVjdCBpbnZhbGlkIEpTT04gcGFja2V0IHNvb25lci5cblxuICBpZiAoIXZhbGlkSlNPTlN0YXJ0UmVnZXgudGVzdChtZXNzYWdlKSkge1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gIHJldHVybiBtZXNzYWdlO1xufTsgLy8gRW5jb2RlIGEgcmF3IEphdmFTY3JpcHQgb2JqZWN0ICh3aGljaCBpcyBpbiB0aGUgU0MgcHJvdG9jb2wgZm9ybWF0KSBpbnRvIGEgZm9ybWF0IGZvclxuLy8gdHJhbnNmZXJpbmcgaXQgb3ZlciB0aGUgd2lyZS4gSW4gdGhpcyBjYXNlLCB3ZSBqdXN0IGNvbnZlcnQgaXQgaW50byBhIHNpbXBsZSBKU09OIHN0cmluZy5cbi8vIElmIHlvdSB3YW50IHRvIGNyZWF0ZSB5b3VyIG93biBjdXN0b20gY29kZWMsIHlvdSBjYW4gZW5jb2RlIHRoZSBvYmplY3QgaW50byBhbnkgZm9ybWF0XG4vLyAoZS5nLiBiaW5hcnkgQXJyYXlCdWZmZXIgb3Igc3RyaW5nIHdpdGggYW55IGtpbmQgb2YgY29tcHJlc3Npb24pIHNvIGxvbmcgYXMgeW91ciBkZWNvZGVcbi8vIGZ1bmN0aW9uIGlzIGFibGUgdG8gcmVoeWRyYXRlIHRoYXQgb2JqZWN0IGJhY2sgaW50byBpdHMgb3JpZ2luYWwgSmF2YVNjcmlwdCBPYmplY3QgZm9ybWF0XG4vLyAod2hpY2ggYWRoZXJlcyB0byB0aGUgU0MgcHJvdG9jb2wpLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Tb2NrZXRDbHVzdGVyL3NvY2tldGNsdXN0ZXIvYmxvYi9tYXN0ZXIvc29ja2V0Y2x1c3Rlci1wcm90b2NvbC5tZFxuLy8gZm9yIGRldGFpbHMgYWJvdXQgdGhlIFNDIHByb3RvY29sLlxuXG5cbm1vZHVsZS5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgLy8gTGVhdmUgcGluZyBvciBwb25nIG1lc3NhZ2UgYXMgaXNcbiAgaWYgKG9iamVjdCA9PT0gJyMxJyB8fCBvYmplY3QgPT09ICcjMicpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iamVjdCwgYmluYXJ5VG9CYXNlNjRSZXBsYWNlcik7XG59OyIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuXG4gIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICB9IC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG5cblxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgfSAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcblxuXG4gICAgdmFyIHRhc2sgPSB7XG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfTtcbiAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICB2YXIgYXJncyA9IHRhc2suYXJncztcblxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzOlxuICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcblxuICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcblxuICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG4gICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcblxuICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJiB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG5cbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICB9O1xuXG4gICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cbiAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24gKGhhbmRsZSkge1xuICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgfTtcbiAgfSAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cblxuXG4gIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7IC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cblxuICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG4gIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcbiAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgIC8vIEZvciBJRSA24oCTOFxuICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gIH1cblxuICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZik7IiwidmFyIFNDQ2xpZW50U29ja2V0ID0gcmVxdWlyZSgnLi9saWIvc2NjbGllbnRzb2NrZXQnKTtcblxudmFyIGZhY3RvcnkgPSByZXF1aXJlKCcuL2xpYi9mYWN0b3J5Jyk7XG5cbm1vZHVsZS5leHBvcnRzLmZhY3RvcnkgPSBmYWN0b3J5O1xubW9kdWxlLmV4cG9ydHMuU0NDbGllbnRTb2NrZXQgPSBTQ0NsaWVudFNvY2tldDtcbm1vZHVsZS5leHBvcnRzLkVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICByZXR1cm4gZmFjdG9yeS5jcmVhdGUob3B0aW9ucyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gbW9kdWxlLmV4cG9ydHMuY3JlYXRlO1xuXG5tb2R1bGUuZXhwb3J0cy5kZXN0cm95ID0gZnVuY3Rpb24gKHNvY2tldCkge1xuICByZXR1cm4gZmFjdG9yeS5kZXN0cm95KHNvY2tldCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jbGllbnRzID0gZmFjdG9yeS5jbGllbnRzO1xubW9kdWxlLmV4cG9ydHMudmVyc2lvbiA9ICcxMy4wLjEnOyIsInZhciBBdXRoRW5naW5lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9pbnRlcm5hbFN0b3JhZ2UgPSB7fTtcbiAgdGhpcy5pc0xvY2FsU3RvcmFnZUVuYWJsZWQgPSB0aGlzLl9jaGVja0xvY2FsU3RvcmFnZUVuYWJsZWQoKTtcbn07XG5cbkF1dGhFbmdpbmUucHJvdG90eXBlLl9jaGVja0xvY2FsU3RvcmFnZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlcnI7XG5cbiAgdHJ5IHtcbiAgICAvLyBTb21lIGJyb3dzZXJzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaGVyZSBpZiBsb2NhbFN0b3JhZ2UgaXMgZGlzYWJsZWQuXG4gICAgZ2xvYmFsLmxvY2FsU3RvcmFnZTsgLy8gU2FmYXJpLCBpbiBQcml2YXRlIEJyb3dzaW5nIE1vZGUsIGxvb2tzIGxpa2UgaXQgc3VwcG9ydHMgbG9jYWxTdG9yYWdlIGJ1dCBhbGwgY2FsbHMgdG8gc2V0SXRlbVxuICAgIC8vIHRocm93IFF1b3RhRXhjZWVkZWRFcnJvci4gV2UncmUgZ29pbmcgdG8gZGV0ZWN0IHRoaXMgYW5kIGF2b2lkIGhhcmQgdG8gZGVidWcgZWRnZSBjYXNlcy5cblxuICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnX19zY0xvY2FsU3RvcmFnZVRlc3QnLCAxKTtcbiAgICBnbG9iYWwubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ19fc2NMb2NhbFN0b3JhZ2VUZXN0Jyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlO1xuICB9XG5cbiAgcmV0dXJuICFlcnI7XG59O1xuXG5BdXRoRW5naW5lLnByb3RvdHlwZS5zYXZlVG9rZW4gPSBmdW5jdGlvbiAobmFtZSwgdG9rZW4sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0aGlzLmlzTG9jYWxTdG9yYWdlRW5hYmxlZCAmJiBnbG9iYWwubG9jYWxTdG9yYWdlKSB7XG4gICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKG5hbWUsIHRva2VuKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9pbnRlcm5hbFN0b3JhZ2VbbmFtZV0gPSB0b2tlbjtcbiAgfVxuXG4gIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwsIHRva2VuKTtcbn07XG5cbkF1dGhFbmdpbmUucHJvdG90eXBlLnJlbW92ZVRva2VuID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gIHZhciB0b2tlbjtcbiAgdGhpcy5sb2FkVG9rZW4obmFtZSwgZnVuY3Rpb24gKGVyciwgYXV0aFRva2VuKSB7XG4gICAgdG9rZW4gPSBhdXRoVG9rZW47XG4gIH0pO1xuXG4gIGlmICh0aGlzLmlzTG9jYWxTdG9yYWdlRW5hYmxlZCAmJiBnbG9iYWwubG9jYWxTdG9yYWdlKSB7XG4gICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSB0aGlzLl9pbnRlcm5hbFN0b3JhZ2VbbmFtZV07XG4gIH1cblxuICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsLCB0b2tlbik7XG59O1xuXG5BdXRoRW5naW5lLnByb3RvdHlwZS5sb2FkVG9rZW4gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgdmFyIHRva2VuO1xuXG4gIGlmICh0aGlzLmlzTG9jYWxTdG9yYWdlRW5hYmxlZCAmJiBnbG9iYWwubG9jYWxTdG9yYWdlKSB7XG4gICAgdG9rZW4gPSBnbG9iYWwubG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdG9rZW4gPSB0aGlzLl9pbnRlcm5hbFN0b3JhZ2VbbmFtZV0gfHwgbnVsbDtcbiAgfVxuXG4gIGNhbGxiYWNrKG51bGwsIHRva2VuKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkF1dGhFbmdpbmUgPSBBdXRoRW5naW5lOyIsInZhciBTQ0NsaWVudFNvY2tldCA9IHJlcXVpcmUoJy4vc2NjbGllbnRzb2NrZXQnKTtcblxudmFyIHNjRXJyb3JzID0gcmVxdWlyZSgnc2MtZXJyb3JzJyk7XG5cbnZhciB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xuXG52YXIgSW52YWxpZEFyZ3VtZW50c0Vycm9yID0gc2NFcnJvcnMuSW52YWxpZEFyZ3VtZW50c0Vycm9yO1xudmFyIF9jbGllbnRzID0ge307XG5cbmZ1bmN0aW9uIGdldE11bHRpcGxleElkKG9wdGlvbnMpIHtcbiAgdmFyIHByb3RvY29sUHJlZml4ID0gb3B0aW9ucy5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nO1xuICB2YXIgcXVlcnlTdHJpbmcgPSAnJztcblxuICBpZiAob3B0aW9ucy5xdWVyeSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5xdWVyeSA9PSAnc3RyaW5nJykge1xuICAgICAgcXVlcnlTdHJpbmcgPSBvcHRpb25zLnF1ZXJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcXVlcnlBcnJheSA9IFtdO1xuICAgICAgdmFyIHF1ZXJ5TWFwID0gb3B0aW9ucy5xdWVyeTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHF1ZXJ5TWFwKSB7XG4gICAgICAgIGlmIChxdWVyeU1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgcXVlcnlBcnJheS5wdXNoKGtleSArICc9JyArIHF1ZXJ5TWFwW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChxdWVyeUFycmF5Lmxlbmd0aCkge1xuICAgICAgICBxdWVyeVN0cmluZyA9ICc/JyArIHF1ZXJ5QXJyYXkuam9pbignJicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBob3N0O1xuXG4gIGlmIChvcHRpb25zLmhvc3QpIHtcbiAgICBob3N0ID0gb3B0aW9ucy5ob3N0O1xuICB9IGVsc2Uge1xuICAgIGhvc3QgPSBvcHRpb25zLmhvc3RuYW1lICsgJzonICsgb3B0aW9ucy5wb3J0O1xuICB9XG5cbiAgcmV0dXJuIHByb3RvY29sUHJlZml4ICsgaG9zdCArIG9wdGlvbnMucGF0aCArIHF1ZXJ5U3RyaW5nO1xufVxuXG5mdW5jdGlvbiBpc1VybFNlY3VyZSgpIHtcbiAgcmV0dXJuIGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5wcm90b2NvbCA9PSAnaHR0cHM6Jztcbn1cblxuZnVuY3Rpb24gZ2V0UG9ydChvcHRpb25zLCBpc1NlY3VyZURlZmF1bHQpIHtcbiAgdmFyIGlzU2VjdXJlID0gb3B0aW9ucy5zZWN1cmUgPT0gbnVsbCA/IGlzU2VjdXJlRGVmYXVsdCA6IG9wdGlvbnMuc2VjdXJlO1xuICByZXR1cm4gb3B0aW9ucy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydCA/IGxvY2F0aW9uLnBvcnQgOiBpc1NlY3VyZSA/IDQ0MyA6IDgwKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAob3B0aW9ucy5ob3N0ICYmICFvcHRpb25zLmhvc3QubWF0Y2goL1teOl0rOlxcZHsyLDV9LykpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0Vycm9yKCdUaGUgaG9zdCBvcHRpb24gc2hvdWxkIGluY2x1ZGUgYm90aCcgKyAnIHRoZSBob3N0bmFtZSBhbmQgdGhlIHBvcnQgbnVtYmVyIGluIHRoZSBmb3JtYXQgXCJob3N0bmFtZTpwb3J0XCInKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhvc3QgJiYgb3B0aW9ucy5ob3N0bmFtZSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzRXJyb3IoJ1RoZSBob3N0IG9wdGlvbiBzaG91bGQgYWxyZWFkeSBpbmNsdWRlJyArICcgdGhlIGhvc3RuYW1lIGFuZCB0aGUgcG9ydCBudW1iZXIgaW4gdGhlIGZvcm1hdCBcImhvc3RuYW1lOnBvcnRcIicgKyAnIC0gQmVjYXVzZSBvZiB0aGlzLCB5b3Ugc2hvdWxkIG5ldmVyIHVzZSBob3N0IGFuZCBob3N0bmFtZSBvcHRpb25zIHRvZ2V0aGVyJyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5ob3N0ICYmIG9wdGlvbnMucG9ydCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzRXJyb3IoJ1RoZSBob3N0IG9wdGlvbiBzaG91bGQgYWxyZWFkeSBpbmNsdWRlJyArICcgdGhlIGhvc3RuYW1lIGFuZCB0aGUgcG9ydCBudW1iZXIgaW4gdGhlIGZvcm1hdCBcImhvc3RuYW1lOnBvcnRcIicgKyAnIC0gQmVjYXVzZSBvZiB0aGlzLCB5b3Ugc2hvdWxkIG5ldmVyIHVzZSBob3N0IGFuZCBwb3J0IG9wdGlvbnMgdG9nZXRoZXInKTtcbiAgfVxuXG4gIHZhciBpc1NlY3VyZURlZmF1bHQgPSBpc1VybFNlY3VyZSgpO1xuICB2YXIgb3B0cyA9IHtcbiAgICBwb3J0OiBnZXRQb3J0KG9wdGlvbnMsIGlzU2VjdXJlRGVmYXVsdCksXG4gICAgaG9zdG5hbWU6IGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5ob3N0bmFtZSB8fCAnbG9jYWxob3N0JyxcbiAgICBwYXRoOiAnL3NvY2tldGNsdXN0ZXIvJyxcbiAgICBzZWN1cmU6IGlzU2VjdXJlRGVmYXVsdCxcbiAgICBhdXRvQ29ubmVjdDogdHJ1ZSxcbiAgICBhdXRvUmVjb25uZWN0OiB0cnVlLFxuICAgIGF1dG9TdWJzY3JpYmVPbkNvbm5lY3Q6IHRydWUsXG4gICAgY29ubmVjdFRpbWVvdXQ6IDIwMDAwLFxuICAgIGFja1RpbWVvdXQ6IDEwMDAwLFxuICAgIHRpbWVzdGFtcFJlcXVlc3RzOiBmYWxzZSxcbiAgICB0aW1lc3RhbXBQYXJhbTogJ3QnLFxuICAgIGF1dGhFbmdpbmU6IG51bGwsXG4gICAgYXV0aFRva2VuTmFtZTogJ3NvY2tldENsdXN0ZXIuYXV0aFRva2VuJyxcbiAgICBiaW5hcnlUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgIG11bHRpcGxleDogdHJ1ZSxcbiAgICBwdWJTdWJCYXRjaER1cmF0aW9uOiBudWxsLFxuICAgIGNsb25lRGF0YTogZmFsc2VcbiAgfTtcblxuICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb3B0c1tpXSA9IG9wdGlvbnNbaV07XG4gICAgfVxuICB9XG5cbiAgb3B0cy5jbGllbnRNYXAgPSBfY2xpZW50cztcblxuICBpZiAob3B0cy5tdWx0aXBsZXggPT09IGZhbHNlKSB7XG4gICAgb3B0cy5jbGllbnRJZCA9IHV1aWQudjQoKTtcbiAgICB2YXIgc29ja2V0ID0gbmV3IFNDQ2xpZW50U29ja2V0KG9wdHMpO1xuICAgIF9jbGllbnRzW29wdHMuY2xpZW50SWRdID0gc29ja2V0O1xuICAgIHJldHVybiBzb2NrZXQ7XG4gIH1cblxuICBvcHRzLmNsaWVudElkID0gZ2V0TXVsdGlwbGV4SWQob3B0cyk7XG5cbiAgaWYgKF9jbGllbnRzW29wdHMuY2xpZW50SWRdKSB7XG4gICAgaWYgKG9wdHMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgIF9jbGllbnRzW29wdHMuY2xpZW50SWRdLmNvbm5lY3QoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX2NsaWVudHNbb3B0cy5jbGllbnRJZF0gPSBuZXcgU0NDbGllbnRTb2NrZXQob3B0cyk7XG4gIH1cblxuICByZXR1cm4gX2NsaWVudHNbb3B0cy5jbGllbnRJZF07XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3koc29ja2V0KSB7XG4gIHNvY2tldC5kZXN0cm95KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGU6IGNyZWF0ZSxcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgY2xpZW50czogX2NsaWVudHNcbn07IiwidmFyIHNjRXJyb3JzID0gcmVxdWlyZSgnc2MtZXJyb3JzJyk7XG5cbnZhciBJbnZhbGlkQWN0aW9uRXJyb3IgPSBzY0Vycm9ycy5JbnZhbGlkQWN0aW9uRXJyb3I7XG5cbnZhciBSZXNwb25zZSA9IGZ1bmN0aW9uIChzb2NrZXQsIGlkKSB7XG4gIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuc2VudCA9IGZhbHNlO1xufTtcblxuUmVzcG9uc2UucHJvdG90eXBlLl9yZXNwb25kID0gZnVuY3Rpb24gKHJlc3BvbnNlRGF0YSkge1xuICBpZiAodGhpcy5zZW50KSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBY3Rpb25FcnJvcignUmVzcG9uc2UgJyArIHRoaXMuaWQgKyAnIGhhcyBhbHJlYWR5IGJlZW4gc2VudCcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2VudCA9IHRydWU7XG4gICAgdGhpcy5zb2NrZXQuc2VuZCh0aGlzLnNvY2tldC5lbmNvZGUocmVzcG9uc2VEYXRhKSk7XG4gIH1cbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICBpZiAodGhpcy5pZCkge1xuICAgIHZhciByZXNwb25zZURhdGEgPSB7XG4gICAgICByaWQ6IHRoaXMuaWRcbiAgICB9O1xuXG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzcG9uc2VEYXRhLmRhdGEgPSBkYXRhO1xuICAgIH1cblxuICAgIHRoaXMuX3Jlc3BvbmQocmVzcG9uc2VEYXRhKTtcbiAgfVxufTtcblxuUmVzcG9uc2UucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBkYXRhKSB7XG4gIGlmICh0aGlzLmlkKSB7XG4gICAgdmFyIGVyciA9IHNjRXJyb3JzLmRlaHlkcmF0ZUVycm9yKGVycm9yKTtcbiAgICB2YXIgcmVzcG9uc2VEYXRhID0ge1xuICAgICAgcmlkOiB0aGlzLmlkLFxuICAgICAgZXJyb3I6IGVyclxuICAgIH07XG5cbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXNwb25zZURhdGEuZGF0YSA9IGRhdGE7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVzcG9uZChyZXNwb25zZURhdGEpO1xuICB9XG59O1xuXG5SZXNwb25zZS5wcm90b3R5cGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyb3IsIGRhdGEpIHtcbiAgaWYgKGVycm9yKSB7XG4gICAgdGhpcy5lcnJvcihlcnJvciwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lbmQoZGF0YSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLlJlc3BvbnNlID0gUmVzcG9uc2U7IiwidmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG52YXIgU0NDaGFubmVsID0gcmVxdWlyZSgnc2MtY2hhbm5lbCcpLlNDQ2hhbm5lbDtcblxudmFyIFJlc3BvbnNlID0gcmVxdWlyZSgnLi9yZXNwb25zZScpLlJlc3BvbnNlO1xuXG52YXIgQXV0aEVuZ2luZSA9IHJlcXVpcmUoJy4vYXV0aCcpLkF1dGhFbmdpbmU7XG5cbnZhciBmb3JtYXR0ZXIgPSByZXF1aXJlKCdzYy1mb3JtYXR0ZXInKTtcblxudmFyIFNDVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9zY3RyYW5zcG9ydCcpLlNDVHJhbnNwb3J0O1xuXG52YXIgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG52YXIgTGlua2VkTGlzdCA9IHJlcXVpcmUoJ2xpbmtlZC1saXN0Jyk7XG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlLTY0Jyk7XG5cbnZhciBjbG9uZSA9IHJlcXVpcmUoJ2Nsb25lJyk7XG5cbnZhciBzY0Vycm9ycyA9IHJlcXVpcmUoJ3NjLWVycm9ycycpO1xuXG52YXIgSW52YWxpZEFyZ3VtZW50c0Vycm9yID0gc2NFcnJvcnMuSW52YWxpZEFyZ3VtZW50c0Vycm9yO1xudmFyIEludmFsaWRNZXNzYWdlRXJyb3IgPSBzY0Vycm9ycy5JbnZhbGlkTWVzc2FnZUVycm9yO1xudmFyIEludmFsaWRBY3Rpb25FcnJvciA9IHNjRXJyb3JzLkludmFsaWRBY3Rpb25FcnJvcjtcbnZhciBTb2NrZXRQcm90b2NvbEVycm9yID0gc2NFcnJvcnMuU29ja2V0UHJvdG9jb2xFcnJvcjtcbnZhciBUaW1lb3V0RXJyb3IgPSBzY0Vycm9ycy5UaW1lb3V0RXJyb3I7XG52YXIgQmFkQ29ubmVjdGlvbkVycm9yID0gc2NFcnJvcnMuQmFkQ29ubmVjdGlvbkVycm9yO1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBTQ0NsaWVudFNvY2tldCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy5zdGF0ZSA9IHRoaXMuQ0xPU0VEO1xuICB0aGlzLmF1dGhTdGF0ZSA9IHRoaXMuVU5BVVRIRU5USUNBVEVEO1xuICB0aGlzLnNpZ25lZEF1dGhUb2tlbiA9IG51bGw7XG4gIHRoaXMuYXV0aFRva2VuID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gIHRoaXMucGVuZGluZ1JlY29ubmVjdFRpbWVvdXQgPSBudWxsO1xuICB0aGlzLnByZXBhcmluZ1BlbmRpbmdTdWJzY3JpcHRpb25zID0gZmFsc2U7XG4gIHRoaXMuY2xpZW50SWQgPSBvcHRzLmNsaWVudElkO1xuICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gb3B0cy5jb25uZWN0VGltZW91dDtcbiAgdGhpcy5hY2tUaW1lb3V0ID0gb3B0cy5hY2tUaW1lb3V0O1xuICB0aGlzLmNoYW5uZWxQcmVmaXggPSBvcHRzLmNoYW5uZWxQcmVmaXggfHwgbnVsbDtcbiAgdGhpcy5kaXNjb25uZWN0T25VbmxvYWQgPSBvcHRzLmRpc2Nvbm5lY3RPblVubG9hZCA9PSBudWxsID8gdHJ1ZSA6IG9wdHMuZGlzY29ubmVjdE9uVW5sb2FkO1xuICB0aGlzLmF1dGhUb2tlbk5hbWUgPSBvcHRzLmF1dGhUb2tlbk5hbWU7IC8vIHBpbmdUaW1lb3V0IHdpbGwgYmUgYWNrVGltZW91dCBhdCB0aGUgc3RhcnQsIGJ1dCBpdCB3aWxsXG4gIC8vIGJlIHVwZGF0ZWQgd2l0aCB2YWx1ZXMgcHJvdmlkZWQgYnkgdGhlICdjb25uZWN0JyBldmVudFxuXG4gIHRoaXMucGluZ1RpbWVvdXQgPSB0aGlzLmFja1RpbWVvdXQ7XG4gIHRoaXMucGluZ1RpbWVvdXREaXNhYmxlZCA9ICEhb3B0cy5waW5nVGltZW91dERpc2FibGVkO1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuX2NsaWVudE1hcCA9IG9wdHMuY2xpZW50TWFwIHx8IHt9O1xuICB2YXIgbWF4VGltZW91dCA9IE1hdGgucG93KDIsIDMxKSAtIDE7XG5cbiAgdmFyIHZlcmlmeUR1cmF0aW9uID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgIGlmIChzZWxmW3Byb3BlcnR5TmFtZV0gPiBtYXhUaW1lb3V0KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0Vycm9yKCdUaGUgJyArIHByb3BlcnR5TmFtZSArICcgdmFsdWUgcHJvdmlkZWQgZXhjZWVkZWQgdGhlIG1heGltdW0gYW1vdW50IGFsbG93ZWQnKTtcbiAgICB9XG4gIH07XG5cbiAgdmVyaWZ5RHVyYXRpb24oJ2Nvbm5lY3RUaW1lb3V0Jyk7XG4gIHZlcmlmeUR1cmF0aW9uKCdhY2tUaW1lb3V0Jyk7XG4gIHRoaXMuX2xvY2FsRXZlbnRzID0ge1xuICAgICdjb25uZWN0JzogMSxcbiAgICAnY29ubmVjdEFib3J0JzogMSxcbiAgICAnY2xvc2UnOiAxLFxuICAgICdkaXNjb25uZWN0JzogMSxcbiAgICAnbWVzc2FnZSc6IDEsXG4gICAgJ2Vycm9yJzogMSxcbiAgICAncmF3JzogMSxcbiAgICAna2lja091dCc6IDEsXG4gICAgJ3N1YnNjcmliZSc6IDEsXG4gICAgJ3Vuc3Vic2NyaWJlJzogMSxcbiAgICAnc3Vic2NyaWJlU3RhdGVDaGFuZ2UnOiAxLFxuICAgICdhdXRoU3RhdGVDaGFuZ2UnOiAxLFxuICAgICdhdXRoZW50aWNhdGUnOiAxLFxuICAgICdkZWF1dGhlbnRpY2F0ZSc6IDEsXG4gICAgJ3JlbW92ZUF1dGhUb2tlbic6IDEsXG4gICAgJ3N1YnNjcmliZVJlcXVlc3QnOiAxXG4gIH07XG4gIHRoaXMuY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgdGhpcy5fZW1pdEJ1ZmZlciA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHRoaXMuY2hhbm5lbHMgPSB7fTtcbiAgdGhpcy5vcHRpb25zID0gb3B0cztcbiAgdGhpcy5fY2lkID0gMTtcblxuICB0aGlzLm9wdGlvbnMuY2FsbElkR2VuZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZWxmLl9jaWQrKztcbiAgfTtcblxuICBpZiAodGhpcy5vcHRpb25zLmF1dG9SZWNvbm5lY3QpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9SZWNvbm5lY3RPcHRpb25zID09IG51bGwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5hdXRvUmVjb25uZWN0T3B0aW9ucyA9IHt9O1xuICAgIH0gLy8gQWRkIHByb3BlcnRpZXMgdG8gdGhlIHRoaXMub3B0aW9ucy5hdXRvUmVjb25uZWN0T3B0aW9ucyBvYmplY3QuXG4gICAgLy8gV2UgYXNzaWduIHRoZSByZWZlcmVuY2UgdG8gYSByZWNvbm5lY3RPcHRpb25zIHZhcmlhYmxlIHRvIGF2b2lkIHJlcGV0aXRpb24uXG5cblxuICAgIHZhciByZWNvbm5lY3RPcHRpb25zID0gdGhpcy5vcHRpb25zLmF1dG9SZWNvbm5lY3RPcHRpb25zO1xuXG4gICAgaWYgKHJlY29ubmVjdE9wdGlvbnMuaW5pdGlhbERlbGF5ID09IG51bGwpIHtcbiAgICAgIHJlY29ubmVjdE9wdGlvbnMuaW5pdGlhbERlbGF5ID0gMTAwMDA7XG4gICAgfVxuXG4gICAgaWYgKHJlY29ubmVjdE9wdGlvbnMucmFuZG9tbmVzcyA9PSBudWxsKSB7XG4gICAgICByZWNvbm5lY3RPcHRpb25zLnJhbmRvbW5lc3MgPSAxMDAwMDtcbiAgICB9XG5cbiAgICBpZiAocmVjb25uZWN0T3B0aW9ucy5tdWx0aXBsaWVyID09IG51bGwpIHtcbiAgICAgIHJlY29ubmVjdE9wdGlvbnMubXVsdGlwbGllciA9IDEuNTtcbiAgICB9XG5cbiAgICBpZiAocmVjb25uZWN0T3B0aW9ucy5tYXhEZWxheSA9PSBudWxsKSB7XG4gICAgICByZWNvbm5lY3RPcHRpb25zLm1heERlbGF5ID0gNjAwMDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5zdWJzY3JpcHRpb25SZXRyeU9wdGlvbnMgPT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy5zdWJzY3JpcHRpb25SZXRyeU9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuYXV0aEVuZ2luZSkge1xuICAgIHRoaXMuYXV0aCA9IHRoaXMub3B0aW9ucy5hdXRoRW5naW5lO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXV0aCA9IG5ldyBBdXRoRW5naW5lKCk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmNvZGVjRW5naW5lKSB7XG4gICAgdGhpcy5jb2RlYyA9IHRoaXMub3B0aW9ucy5jb2RlY0VuZ2luZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWZhdWx0IGNvZGVjIGVuZ2luZVxuICAgIHRoaXMuY29kZWMgPSBmb3JtYXR0ZXI7XG4gIH1cblxuICB0aGlzLm9wdGlvbnMucGF0aCA9IHRoaXMub3B0aW9ucy5wYXRoLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG4gIHRoaXMub3B0aW9ucy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG5cbiAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucXVlcnkgPT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLm9wdGlvbnMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLm9wdGlvbnMucXVlcnkpO1xuICB9XG5cbiAgdGhpcy5fY2hhbm5lbEVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXG4gIHRoaXMuX3VubG9hZEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5kaXNjb25uZWN0KCk7XG4gIH07XG5cbiAgaWYgKGlzQnJvd3NlciAmJiB0aGlzLmRpc2Nvbm5lY3RPblVubG9hZCAmJiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLl91bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH1cblxuICB0aGlzLl9jbGllbnRNYXBbdGhpcy5jbGllbnRJZF0gPSB0aGlzO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuYXV0b0Nvbm5lY3QpIHtcbiAgICB0aGlzLmNvbm5lY3QoKTtcbiAgfVxufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFbWl0dGVyLnByb3RvdHlwZSk7XG5TQ0NsaWVudFNvY2tldC5DT05ORUNUSU5HID0gU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLkNPTk5FQ1RJTkcgPSBTQ1RyYW5zcG9ydC5wcm90b3R5cGUuQ09OTkVDVElORztcblNDQ2xpZW50U29ja2V0Lk9QRU4gPSBTQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuT1BFTiA9IFNDVHJhbnNwb3J0LnByb3RvdHlwZS5PUEVOO1xuU0NDbGllbnRTb2NrZXQuQ0xPU0VEID0gU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLkNMT1NFRCA9IFNDVHJhbnNwb3J0LnByb3RvdHlwZS5DTE9TRUQ7XG5TQ0NsaWVudFNvY2tldC5BVVRIRU5USUNBVEVEID0gU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLkFVVEhFTlRJQ0FURUQgPSAnYXV0aGVudGljYXRlZCc7XG5TQ0NsaWVudFNvY2tldC5VTkFVVEhFTlRJQ0FURUQgPSBTQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuVU5BVVRIRU5USUNBVEVEID0gJ3VuYXV0aGVudGljYXRlZCc7XG5TQ0NsaWVudFNvY2tldC5QRU5ESU5HID0gU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLlBFTkRJTkcgPSAncGVuZGluZyc7XG5TQ0NsaWVudFNvY2tldC5pZ25vcmVTdGF0dXNlcyA9IHNjRXJyb3JzLnNvY2tldFByb3RvY29sSWdub3JlU3RhdHVzZXM7XG5TQ0NsaWVudFNvY2tldC5lcnJvclN0YXR1c2VzID0gc2NFcnJvcnMuc29ja2V0UHJvdG9jb2xFcnJvclN0YXR1c2VzO1xuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLl9wcml2YXRlRXZlbnRIYW5kbGVyTWFwID0ge1xuICAnI3B1Ymxpc2gnOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB1bmRlY29yYXRlZENoYW5uZWxOYW1lID0gdGhpcy5fdW5kZWNvcmF0ZUNoYW5uZWxOYW1lKGRhdGEuY2hhbm5lbCk7XG5cbiAgICB2YXIgaXNTdWJzY3JpYmVkID0gdGhpcy5pc1N1YnNjcmliZWQodW5kZWNvcmF0ZWRDaGFubmVsTmFtZSwgdHJ1ZSk7XG5cbiAgICBpZiAoaXNTdWJzY3JpYmVkKSB7XG4gICAgICB0aGlzLl9jaGFubmVsRW1pdHRlci5lbWl0KHVuZGVjb3JhdGVkQ2hhbm5lbE5hbWUsIGRhdGEuZGF0YSk7XG4gICAgfVxuICB9LFxuICAnI2tpY2tPdXQnOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB1bmRlY29yYXRlZENoYW5uZWxOYW1lID0gdGhpcy5fdW5kZWNvcmF0ZUNoYW5uZWxOYW1lKGRhdGEuY2hhbm5lbCk7XG5cbiAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbdW5kZWNvcmF0ZWRDaGFubmVsTmFtZV07XG5cbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsICdraWNrT3V0JywgZGF0YS5tZXNzYWdlLCB1bmRlY29yYXRlZENoYW5uZWxOYW1lKTtcbiAgICAgIGNoYW5uZWwuZW1pdCgna2lja091dCcsIGRhdGEubWVzc2FnZSwgdW5kZWNvcmF0ZWRDaGFubmVsTmFtZSk7XG5cbiAgICAgIHRoaXMuX3RyaWdnZXJDaGFubmVsVW5zdWJzY3JpYmUoY2hhbm5lbCk7XG4gICAgfVxuICB9LFxuICAnI3NldEF1dGhUb2tlbic6IGZ1bmN0aW9uIChkYXRhLCByZXNwb25zZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChkYXRhKSB7XG4gICAgICB2YXIgdHJpZ2dlckF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBub24tZmF0YWwgZXJyb3IsIHdlIGRvbid0IHdhbnQgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAvLyBiZWNhdXNlIG9mIHRoaXMgYnV0IHdlIGRvIHdhbnQgdG8gbm90aWZ5IHRoZSBzZXJ2ZXIgYW5kIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgLy8gb24gdGhlIGNsaWVudC5cbiAgICAgICAgICByZXNwb25zZS5lcnJvcihlcnIpO1xuXG4gICAgICAgICAgc2VsZi5fb25TQ0Vycm9yKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5fY2hhbmdlVG9BdXRoZW50aWNhdGVkU3RhdGUoZGF0YS50b2tlbik7XG5cbiAgICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5hdXRoLnNhdmVUb2tlbih0aGlzLmF1dGhUb2tlbk5hbWUsIGRhdGEudG9rZW4sIHt9LCB0cmlnZ2VyQXV0aGVudGljYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzcG9uc2UuZXJyb3IobmV3IEludmFsaWRNZXNzYWdlRXJyb3IoJ05vIHRva2VuIGRhdGEgcHJvdmlkZWQgYnkgI3NldEF1dGhUb2tlbiBldmVudCcpKTtcbiAgICB9XG4gIH0sXG4gICcjcmVtb3ZlQXV0aFRva2VuJzogZnVuY3Rpb24gKGRhdGEsIHJlc3BvbnNlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuYXV0aC5yZW1vdmVUb2tlbih0aGlzLmF1dGhUb2tlbk5hbWUsIGZ1bmN0aW9uIChlcnIsIG9sZFRva2VuKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIE5vbi1mYXRhbCBlcnJvciAtIERvIG5vdCBjbG9zZSB0aGUgY29ubmVjdGlvblxuICAgICAgICByZXNwb25zZS5lcnJvcihlcnIpO1xuXG4gICAgICAgIHNlbGYuX29uU0NFcnJvcihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHNlbGYsICdyZW1vdmVBdXRoVG9rZW4nLCBvbGRUb2tlbik7XG5cbiAgICAgICAgc2VsZi5fY2hhbmdlVG9VbmF1dGhlbnRpY2F0ZWRTdGF0ZUFuZENsZWFyVG9rZW5zKCk7XG5cbiAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gICcjZGlzY29ubmVjdCc6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoZGF0YS5jb2RlLCBkYXRhLmRhdGEpO1xuICB9XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnN0YXRlO1xufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLmdldEJ5dGVzUmVjZWl2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRyYW5zcG9ydC5nZXRCeXRlc1JlY2VpdmVkKCk7XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuZGVhdXRoZW50aWNhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmF1dGgucmVtb3ZlVG9rZW4odGhpcy5hdXRoVG9rZW5OYW1lLCBmdW5jdGlvbiAoZXJyLCBvbGRUb2tlbikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIE5vbi1mYXRhbCBlcnJvciAtIERvIG5vdCBjbG9zZSB0aGUgY29ubmVjdGlvblxuICAgICAgc2VsZi5fb25TQ0Vycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIEVtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbChzZWxmLCAncmVtb3ZlQXV0aFRva2VuJywgb2xkVG9rZW4pO1xuXG4gICAgICBpZiAoc2VsZi5zdGF0ZSAhPSBzZWxmLkNMT1NFRCkge1xuICAgICAgICBzZWxmLmVtaXQoJyNyZW1vdmVBdXRoVG9rZW4nKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fY2hhbmdlVG9VbmF1dGhlbnRpY2F0ZWRTdGF0ZUFuZENsZWFyVG9rZW5zKCk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZXJyKTtcbiAgfSk7XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IFNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBJbnZhbGlkQWN0aW9uRXJyb3IoJ0Nhbm5vdCBjb25uZWN0IGEgZGVzdHJveWVkIGNsaWVudCcpO1xuXG4gICAgdGhpcy5fb25TQ0Vycm9yKGVycm9yKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLnN0YXRlID09IHRoaXMuQ0xPU0VEKSB7XG4gICAgdGhpcy5wZW5kaW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgdGhpcy5wZW5kaW5nUmVjb25uZWN0VGltZW91dCA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlY29ubmVjdFRpbWVvdXRSZWYpO1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLkNPTk5FQ1RJTkc7XG4gICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsICdjb25uZWN0aW5nJyk7XG5cbiAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgIHRoaXMudHJhbnNwb3J0Lm9mZigpO1xuICAgIH1cblxuICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3IFNDVHJhbnNwb3J0KHRoaXMuYXV0aCwgdGhpcy5jb2RlYywgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5vbignb3BlbicsIGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgIHNlbGYuc3RhdGUgPSBzZWxmLk9QRU47XG5cbiAgICAgIHNlbGYuX29uU0NPcGVuKHN0YXR1cyk7XG4gICAgfSk7XG4gICAgdGhpcy50cmFuc3BvcnQub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgc2VsZi5fb25TQ0Vycm9yKGVycik7XG4gICAgfSk7XG4gICAgdGhpcy50cmFuc3BvcnQub24oJ2Nsb3NlJywgZnVuY3Rpb24gKGNvZGUsIGRhdGEpIHtcbiAgICAgIHNlbGYuc3RhdGUgPSBzZWxmLkNMT1NFRDtcblxuICAgICAgc2VsZi5fb25TQ0Nsb3NlKGNvZGUsIGRhdGEpO1xuICAgIH0pO1xuICAgIHRoaXMudHJhbnNwb3J0Lm9uKCdvcGVuQWJvcnQnLCBmdW5jdGlvbiAoY29kZSwgZGF0YSkge1xuICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuQ0xPU0VEO1xuXG4gICAgICBzZWxmLl9vblNDQ2xvc2UoY29kZSwgZGF0YSwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy50cmFuc3BvcnQub24oJ2V2ZW50JywgZnVuY3Rpb24gKGV2ZW50LCBkYXRhLCByZXMpIHtcbiAgICAgIHNlbGYuX29uU0NFdmVudChldmVudCwgZGF0YSwgcmVzKTtcbiAgICB9KTtcbiAgfVxufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uIChjb2RlLCBkYXRhKSB7XG4gIHRoaXMuZGlzY29ubmVjdChjb2RlLCBkYXRhKTtcbiAgdGhpcy5jb25uZWN0KCk7XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChjb2RlLCBkYXRhKSB7XG4gIGNvZGUgPSBjb2RlIHx8IDEwMDA7XG5cbiAgaWYgKHR5cGVvZiBjb2RlICE9ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNFcnJvcignSWYgc3BlY2lmaWVkLCB0aGUgY29kZSBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLk9QRU4gfHwgdGhpcy5zdGF0ZSA9PSB0aGlzLkNPTk5FQ1RJTkcpIHtcbiAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZShjb2RlLCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBlbmRpbmdSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICB0aGlzLnBlbmRpbmdSZWNvbm5lY3RUaW1lb3V0ID0gbnVsbDtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVjb25uZWN0VGltZW91dFJlZik7XG4gIH1cbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGNvZGUsIGRhdGEpIHtcbiAgaWYgKGlzQnJvd3NlciAmJiBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLl91bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH1cblxuICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3QoY29kZSwgZGF0YSk7XG4gIGRlbGV0ZSB0aGlzLl9jbGllbnRNYXBbdGhpcy5jbGllbnRJZF07XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuX2NoYW5nZVRvVW5hdXRoZW50aWNhdGVkU3RhdGVBbmRDbGVhclRva2VucyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYXV0aFN0YXRlICE9IHRoaXMuVU5BVVRIRU5USUNBVEVEKSB7XG4gICAgdmFyIG9sZFN0YXRlID0gdGhpcy5hdXRoU3RhdGU7XG4gICAgdmFyIG9sZFNpZ25lZFRva2VuID0gdGhpcy5zaWduZWRBdXRoVG9rZW47XG4gICAgdGhpcy5hdXRoU3RhdGUgPSB0aGlzLlVOQVVUSEVOVElDQVRFRDtcbiAgICB0aGlzLnNpZ25lZEF1dGhUb2tlbiA9IG51bGw7XG4gICAgdGhpcy5hdXRoVG9rZW4gPSBudWxsO1xuICAgIHZhciBzdGF0ZUNoYW5nZURhdGEgPSB7XG4gICAgICBvbGRTdGF0ZTogb2xkU3RhdGUsXG4gICAgICBuZXdTdGF0ZTogdGhpcy5hdXRoU3RhdGVcbiAgICB9O1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCAnYXV0aFN0YXRlQ2hhbmdlJywgc3RhdGVDaGFuZ2VEYXRhKTtcbiAgICBFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgJ2RlYXV0aGVudGljYXRlJywgb2xkU2lnbmVkVG9rZW4pO1xuICB9XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuX2NoYW5nZVRvQXV0aGVudGljYXRlZFN0YXRlID0gZnVuY3Rpb24gKHNpZ25lZEF1dGhUb2tlbikge1xuICB0aGlzLnNpZ25lZEF1dGhUb2tlbiA9IHNpZ25lZEF1dGhUb2tlbjtcbiAgdGhpcy5hdXRoVG9rZW4gPSB0aGlzLl9leHRyYWN0QXV0aFRva2VuRGF0YShzaWduZWRBdXRoVG9rZW4pO1xuXG4gIGlmICh0aGlzLmF1dGhTdGF0ZSAhPSB0aGlzLkFVVEhFTlRJQ0FURUQpIHtcbiAgICB2YXIgb2xkU3RhdGUgPSB0aGlzLmF1dGhTdGF0ZTtcbiAgICB0aGlzLmF1dGhTdGF0ZSA9IHRoaXMuQVVUSEVOVElDQVRFRDtcbiAgICB2YXIgc3RhdGVDaGFuZ2VEYXRhID0ge1xuICAgICAgb2xkU3RhdGU6IG9sZFN0YXRlLFxuICAgICAgbmV3U3RhdGU6IHRoaXMuYXV0aFN0YXRlLFxuICAgICAgc2lnbmVkQXV0aFRva2VuOiBzaWduZWRBdXRoVG9rZW4sXG4gICAgICBhdXRoVG9rZW46IHRoaXMuYXV0aFRva2VuXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5wcmVwYXJpbmdQZW5kaW5nU3Vic2NyaXB0aW9ucykge1xuICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ1N1YnNjcmlwdGlvbnMoKTtcbiAgICB9XG5cbiAgICBFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgJ2F1dGhTdGF0ZUNoYW5nZScsIHN0YXRlQ2hhbmdlRGF0YSk7XG4gIH1cblxuICBFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgJ2F1dGhlbnRpY2F0ZScsIHNpZ25lZEF1dGhUb2tlbik7XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuZGVjb2RlQmFzZTY0ID0gZnVuY3Rpb24gKGVuY29kZWRTdHJpbmcpIHtcbiAgdmFyIGRlY29kZWRTdHJpbmc7XG5cbiAgaWYgKHR5cGVvZiBCdWZmZXIgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoZ2xvYmFsLmF0b2IpIHtcbiAgICAgIGRlY29kZWRTdHJpbmcgPSBnbG9iYWwuYXRvYihlbmNvZGVkU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjb2RlZFN0cmluZyA9IGJhc2U2NC5kZWNvZGUoZW5jb2RlZFN0cmluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKGVuY29kZWRTdHJpbmcsICdiYXNlNjQnKTtcbiAgICBkZWNvZGVkU3RyaW5nID0gYnVmZmVyLnRvU3RyaW5nKCd1dGY4Jyk7XG4gIH1cblxuICByZXR1cm4gZGVjb2RlZFN0cmluZztcbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5lbmNvZGVCYXNlNjQgPSBmdW5jdGlvbiAoZGVjb2RlZFN0cmluZykge1xuICB2YXIgZW5jb2RlZFN0cmluZztcblxuICBpZiAodHlwZW9mIEJ1ZmZlciA9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChnbG9iYWwuYnRvYSkge1xuICAgICAgZW5jb2RlZFN0cmluZyA9IGdsb2JhbC5idG9hKGRlY29kZWRTdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGVkU3RyaW5nID0gYmFzZTY0LmVuY29kZShkZWNvZGVkU3RyaW5nKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIoZGVjb2RlZFN0cmluZywgJ3V0ZjgnKTtcbiAgICBlbmNvZGVkU3RyaW5nID0gYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgfVxuXG4gIHJldHVybiBlbmNvZGVkU3RyaW5nO1xufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLl9leHRyYWN0QXV0aFRva2VuRGF0YSA9IGZ1bmN0aW9uIChzaWduZWRBdXRoVG9rZW4pIHtcbiAgdmFyIHRva2VuUGFydHMgPSAoc2lnbmVkQXV0aFRva2VuIHx8ICcnKS5zcGxpdCgnLicpO1xuICB2YXIgZW5jb2RlZFRva2VuRGF0YSA9IHRva2VuUGFydHNbMV07XG5cbiAgaWYgKGVuY29kZWRUb2tlbkRhdGEgIT0gbnVsbCkge1xuICAgIHZhciB0b2tlbkRhdGEgPSBlbmNvZGVkVG9rZW5EYXRhO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRva2VuRGF0YSA9IHRoaXMuZGVjb2RlQmFzZTY0KHRva2VuRGF0YSk7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh0b2tlbkRhdGEpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0b2tlbkRhdGE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuZ2V0QXV0aFRva2VuID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5hdXRoVG9rZW47XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuZ2V0U2lnbmVkQXV0aFRva2VuID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zaWduZWRBdXRoVG9rZW47XG59OyAvLyBQZXJmb3JtIGNsaWVudC1pbml0aWF0ZWQgYXV0aGVudGljYXRpb24gYnkgcHJvdmlkaW5nIGFuIGVuY3J5cHRlZCB0b2tlbiBzdHJpbmcuXG5cblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIChzaWduZWRBdXRoVG9rZW4sIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5lbWl0KCcjYXV0aGVudGljYXRlJywgc2lnbmVkQXV0aFRva2VuLCBmdW5jdGlvbiAoZXJyLCBhdXRoU3RhdHVzKSB7XG4gICAgaWYgKGF1dGhTdGF0dXMgJiYgYXV0aFN0YXR1cy5pc0F1dGhlbnRpY2F0ZWQgIT0gbnVsbCkge1xuICAgICAgLy8gSWYgYXV0aFN0YXR1cyBpcyBjb3JyZWN0bHkgZm9ybWF0dGVkIChoYXMgYW4gaXNBdXRoZW50aWNhdGVkIHByb3BlcnR5KSxcbiAgICAgIC8vIHRoZW4gd2Ugd2lsbCByZWh5ZHJhdGUgdGhlIGF1dGhFcnJvci5cbiAgICAgIGlmIChhdXRoU3RhdHVzLmF1dGhFcnJvcikge1xuICAgICAgICBhdXRoU3RhdHVzLmF1dGhFcnJvciA9IHNjRXJyb3JzLmh5ZHJhdGVFcnJvcihhdXRoU3RhdHVzLmF1dGhFcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvbWUgZXJyb3JzIGxpa2UgQmFkQ29ubmVjdGlvbkVycm9yIGFuZCBUaW1lb3V0RXJyb3Igd2lsbCBub3QgcGFzcyBhIHZhbGlkXG4gICAgICAvLyBhdXRoU3RhdHVzIG9iamVjdCB0byB0aGUgY3VycmVudCBmdW5jdGlvbiwgc28gd2UgbmVlZCB0byBjcmVhdGUgaXQgb3Vyc2VsdmVzLlxuICAgICAgYXV0aFN0YXR1cyA9IHtcbiAgICAgICAgaXNBdXRoZW50aWNhdGVkOiBzZWxmLmF1dGhTdGF0ZSxcbiAgICAgICAgYXV0aEVycm9yOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChlcnIubmFtZSAhPSAnQmFkQ29ubmVjdGlvbkVycm9yJyAmJiBlcnIubmFtZSAhPSAnVGltZW91dEVycm9yJykge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGEgYmFkL2Nsb3NlZCBjb25uZWN0aW9uIG9yIGEgdGltZW91dCwgd2UgbWFpbnRhaW4gdGhlIGxhc3RcbiAgICAgICAgLy8ga25vd24gYXV0aCBzdGF0ZSBzaW5jZSB0aG9zZSBlcnJvcnMgZG9uJ3QgbWVhbiB0aGF0IHRoZSB0b2tlbiBpcyBpbnZhbGlkLlxuICAgICAgICBzZWxmLl9jaGFuZ2VUb1VuYXV0aGVudGljYXRlZFN0YXRlQW5kQ2xlYXJUb2tlbnMoKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZXJyLCBhdXRoU3RhdHVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5hdXRoLnNhdmVUb2tlbihzZWxmLmF1dGhUb2tlbk5hbWUsIHNpZ25lZEF1dGhUb2tlbiwge30sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHNlbGYuX29uU0NFcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF1dGhTdGF0dXMuaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICAgICAgc2VsZi5fY2hhbmdlVG9BdXRoZW50aWNhdGVkU3RhdGUoc2lnbmVkQXV0aFRva2VuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLl9jaGFuZ2VUb1VuYXV0aGVudGljYXRlZFN0YXRlQW5kQ2xlYXJUb2tlbnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVyciwgYXV0aFN0YXR1cyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLl90cnlSZWNvbm5lY3QgPSBmdW5jdGlvbiAoaW5pdGlhbERlbGF5KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGV4cG9uZW50ID0gdGhpcy5jb25uZWN0QXR0ZW1wdHMrKztcbiAgdmFyIHJlY29ubmVjdE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuYXV0b1JlY29ubmVjdE9wdGlvbnM7XG4gIHZhciB0aW1lb3V0O1xuXG4gIGlmIChpbml0aWFsRGVsYXkgPT0gbnVsbCB8fCBleHBvbmVudCA+IDApIHtcbiAgICB2YXIgaW5pdGlhbFRpbWVvdXQgPSBNYXRoLnJvdW5kKHJlY29ubmVjdE9wdGlvbnMuaW5pdGlhbERlbGF5ICsgKHJlY29ubmVjdE9wdGlvbnMucmFuZG9tbmVzcyB8fCAwKSAqIE1hdGgucmFuZG9tKCkpO1xuICAgIHRpbWVvdXQgPSBNYXRoLnJvdW5kKGluaXRpYWxUaW1lb3V0ICogTWF0aC5wb3cocmVjb25uZWN0T3B0aW9ucy5tdWx0aXBsaWVyLCBleHBvbmVudCkpO1xuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBpbml0aWFsRGVsYXk7XG4gIH1cblxuICBpZiAodGltZW91dCA+IHJlY29ubmVjdE9wdGlvbnMubWF4RGVsYXkpIHtcbiAgICB0aW1lb3V0ID0gcmVjb25uZWN0T3B0aW9ucy5tYXhEZWxheTtcbiAgfVxuXG4gIGNsZWFyVGltZW91dCh0aGlzLl9yZWNvbm5lY3RUaW1lb3V0UmVmKTtcbiAgdGhpcy5wZW5kaW5nUmVjb25uZWN0ID0gdHJ1ZTtcbiAgdGhpcy5wZW5kaW5nUmVjb25uZWN0VGltZW91dCA9IHRpbWVvdXQ7XG4gIHRoaXMuX3JlY29ubmVjdFRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmNvbm5lY3QoKTtcbiAgfSwgdGltZW91dCk7XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuX29uU0NPcGVuID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucHJlcGFyaW5nUGVuZGluZ1N1YnNjcmlwdGlvbnMgPSB0cnVlO1xuXG4gIGlmIChzdGF0dXMpIHtcbiAgICB0aGlzLmlkID0gc3RhdHVzLmlkO1xuICAgIHRoaXMucGluZ1RpbWVvdXQgPSBzdGF0dXMucGluZ1RpbWVvdXQ7XG4gICAgdGhpcy50cmFuc3BvcnQucGluZ1RpbWVvdXQgPSB0aGlzLnBpbmdUaW1lb3V0O1xuXG4gICAgaWYgKHN0YXR1cy5pc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIHRoaXMuX2NoYW5nZVRvQXV0aGVudGljYXRlZFN0YXRlKHN0YXR1cy5hdXRoVG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jaGFuZ2VUb1VuYXV0aGVudGljYXRlZFN0YXRlQW5kQ2xlYXJUb2tlbnMoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIGF1dGgubG9hZFRva2VuIChpbiBzY3RyYW5zcG9ydC5qcykgZmFpbHMgd2l0aFxuICAgIC8vIGFuIGVycm9yIC0gVGhpcyBtZWFucyB0aGF0IHRoZSBzaWduZWRBdXRoVG9rZW4gY2Fubm90IGJlIGxvYWRlZCBieVxuICAgIC8vIHRoZSBhdXRoIGVuZ2luZSBhbmQgdGhlcmVmb3JlLCB3ZSBuZWVkIHRvIHVuYXV0aGVudGljYXRlIHRoZSBjbGllbnQuXG4gICAgdGhpcy5fY2hhbmdlVG9VbmF1dGhlbnRpY2F0ZWRTdGF0ZUFuZENsZWFyVG9rZW5zKCk7XG4gIH1cblxuICB0aGlzLmNvbm5lY3RBdHRlbXB0cyA9IDA7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5hdXRvU3Vic2NyaWJlT25Db25uZWN0KSB7XG4gICAgdGhpcy5wcm9jZXNzUGVuZGluZ1N1YnNjcmlwdGlvbnMoKTtcbiAgfSAvLyBJZiB0aGUgdXNlciBpbnZva2VzIHRoZSBjYWxsYmFjayB3aGlsZSBpbiBhdXRvU3Vic2NyaWJlT25Db25uZWN0IG1vZGUsIGl0XG4gIC8vIHdvbid0IGJyZWFrIGFueXRoaW5nLlxuXG5cbiAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsICdjb25uZWN0Jywgc3RhdHVzLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5wcm9jZXNzUGVuZGluZ1N1YnNjcmlwdGlvbnMoKTtcbiAgfSk7XG5cbiAgaWYgKHRoaXMuc3RhdGUgPT0gdGhpcy5PUEVOKSB7XG4gICAgdGhpcy5fZmx1c2hFbWl0QnVmZmVyKCk7XG4gIH1cbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5fb25TQ0Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB2YXIgc2VsZiA9IHRoaXM7IC8vIFRocm93IGVycm9yIGluIGRpZmZlcmVudCBzdGFjayBmcmFtZSBzbyB0aGF0IGVycm9yIGhhbmRsaW5nXG4gIC8vIGNhbm5vdCBpbnRlcmZlcmUgd2l0aCBhIHJlY29ubmVjdCBhY3Rpb24uXG5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHNlbGYsICdlcnJvcicsIGVycik7XG4gICAgfVxuICB9LCAwKTtcbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5fc3VzcGVuZFN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaGFubmVsLCBuZXdTdGF0ZTtcblxuICBmb3IgKHZhciBjaGFubmVsTmFtZSBpbiB0aGlzLmNoYW5uZWxzKSB7XG4gICAgaWYgKHRoaXMuY2hhbm5lbHMuaGFzT3duUHJvcGVydHkoY2hhbm5lbE5hbWUpKSB7XG4gICAgICBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaGFubmVsTmFtZV07XG5cbiAgICAgIGlmIChjaGFubmVsLnN0YXRlID09IGNoYW5uZWwuU1VCU0NSSUJFRCB8fCBjaGFubmVsLnN0YXRlID09IGNoYW5uZWwuUEVORElORykge1xuICAgICAgICBuZXdTdGF0ZSA9IGNoYW5uZWwuUEVORElORztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1N0YXRlID0gY2hhbm5lbC5VTlNVQlNDUklCRUQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RyaWdnZXJDaGFubmVsVW5zdWJzY3JpYmUoY2hhbm5lbCwgbmV3U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLl9hYm9ydEFsbFBlbmRpbmdFdmVudHNEdWVUb0JhZENvbm5lY3Rpb24gPSBmdW5jdGlvbiAoZmFpbHVyZVR5cGUpIHtcbiAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5fZW1pdEJ1ZmZlci5oZWFkO1xuICB2YXIgbmV4dE5vZGU7XG5cbiAgd2hpbGUgKGN1cnJlbnROb2RlKSB7XG4gICAgbmV4dE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0O1xuICAgIHZhciBldmVudE9iamVjdCA9IGN1cnJlbnROb2RlLmRhdGE7XG4gICAgY2xlYXJUaW1lb3V0KGV2ZW50T2JqZWN0LnRpbWVvdXQpO1xuICAgIGRlbGV0ZSBldmVudE9iamVjdC50aW1lb3V0O1xuICAgIGN1cnJlbnROb2RlLmRldGFjaCgpO1xuICAgIGN1cnJlbnROb2RlID0gbmV4dE5vZGU7XG4gICAgdmFyIGNhbGxiYWNrID0gZXZlbnRPYmplY3QuY2FsbGJhY2s7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGRlbGV0ZSBldmVudE9iamVjdC5jYWxsYmFjaztcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcIkV2ZW50ICdcIiArIGV2ZW50T2JqZWN0LmV2ZW50ICsgXCInIHdhcyBhYm9ydGVkIGR1ZSB0byBhIGJhZCBjb25uZWN0aW9uXCI7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgQmFkQ29ubmVjdGlvbkVycm9yKGVycm9yTWVzc2FnZSwgZmFpbHVyZVR5cGUpO1xuICAgICAgY2FsbGJhY2suY2FsbChldmVudE9iamVjdCwgZXJyb3IsIGV2ZW50T2JqZWN0KTtcbiAgICB9IC8vIENsZWFudXAgYW55IHBlbmRpbmcgcmVzcG9uc2UgY2FsbGJhY2sgaW4gdGhlIHRyYW5zcG9ydCBsYXllciB0b28uXG5cblxuICAgIGlmIChldmVudE9iamVjdC5jaWQpIHtcbiAgICAgIHRoaXMudHJhbnNwb3J0LmNhbmNlbFBlbmRpbmdSZXNwb25zZShldmVudE9iamVjdC5jaWQpO1xuICAgIH1cbiAgfVxufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLl9vblNDQ2xvc2UgPSBmdW5jdGlvbiAoY29kZSwgZGF0YSwgb3BlbkFib3J0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5pZCA9IG51bGw7XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgdGhpcy50cmFuc3BvcnQub2ZmKCk7XG4gIH1cblxuICB0aGlzLnBlbmRpbmdSZWNvbm5lY3QgPSBmYWxzZTtcbiAgdGhpcy5wZW5kaW5nUmVjb25uZWN0VGltZW91dCA9IG51bGw7XG4gIGNsZWFyVGltZW91dCh0aGlzLl9yZWNvbm5lY3RUaW1lb3V0UmVmKTtcblxuICB0aGlzLl9zdXNwZW5kU3Vic2NyaXB0aW9ucygpO1xuXG4gIHRoaXMuX2Fib3J0QWxsUGVuZGluZ0V2ZW50c0R1ZVRvQmFkQ29ubmVjdGlvbihvcGVuQWJvcnQgPyAnY29ubmVjdEFib3J0JyA6ICdkaXNjb25uZWN0Jyk7IC8vIFRyeSB0byByZWNvbm5lY3RcbiAgLy8gb24gc2VydmVyIHBpbmcgdGltZW91dCAoNDAwMClcbiAgLy8gb3Igb24gY2xpZW50IHBvbmcgdGltZW91dCAoNDAwMSlcbiAgLy8gb3Igb24gY2xvc2Ugd2l0aG91dCBzdGF0dXMgKDEwMDUpXG4gIC8vIG9yIG9uIGhhbmRzaGFrZSBmYWlsdXJlICg0MDAzKVxuICAvLyBvciBvbiBoYW5kc2hha2UgcmVqZWN0aW9uICg0MDA4KVxuICAvLyBvciBvbiBzb2NrZXQgaHVuZyB1cCAoMTAwNilcblxuXG4gIGlmICh0aGlzLm9wdGlvbnMuYXV0b1JlY29ubmVjdCkge1xuICAgIGlmIChjb2RlID09IDQwMDAgfHwgY29kZSA9PSA0MDAxIHx8IGNvZGUgPT0gMTAwNSkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwaW5nIG9yIHBvbmcgdGltZW91dCBvciBzb2NrZXQgY2xvc2VzIHdpdGhvdXRcbiAgICAgIC8vIHN0YXR1cywgZG9uJ3Qgd2FpdCBiZWZvcmUgdHJ5aW5nIHRvIHJlY29ubmVjdCAtIFRoZXNlIGNvdWxkIGhhcHBlblxuICAgICAgLy8gaWYgdGhlIGNsaWVudCB3YWtlcyB1cCBhZnRlciBhIHBlcmlvZCBvZiBpbmFjdGl2aXR5IGFuZCBpbiB0aGlzIGNhc2Ugd2VcbiAgICAgIC8vIHdhbnQgdG8gcmUtZXN0YWJsaXNoIHRoZSBjb25uZWN0aW9uIGFzIHNvb24gYXMgcG9zc2libGUuXG4gICAgICB0aGlzLl90cnlSZWNvbm5lY3QoMCk7IC8vIENvZGVzIDQ1MDAgYW5kIGFib3ZlIHdpbGwgYmUgdHJlYXRlZCBhcyBwZXJtYW5lbnQgZGlzY29ubmVjdHMuXG4gICAgICAvLyBTb2NrZXQgd2lsbCBub3QgdHJ5IHRvIGF1dG8tcmVjb25uZWN0LlxuXG4gICAgfSBlbHNlIGlmIChjb2RlICE9IDEwMDAgJiYgY29kZSA8IDQ1MDApIHtcbiAgICAgIHRoaXMuX3RyeVJlY29ubmVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcGVuQWJvcnQpIHtcbiAgICBFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwoc2VsZiwgJ2Nvbm5lY3RBYm9ydCcsIGNvZGUsIGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbChzZWxmLCAnZGlzY29ubmVjdCcsIGNvZGUsIGRhdGEpO1xuICB9XG5cbiAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHNlbGYsICdjbG9zZScsIGNvZGUsIGRhdGEpO1xuXG4gIGlmICghU0NDbGllbnRTb2NrZXQuaWdub3JlU3RhdHVzZXNbY29kZV0pIHtcbiAgICB2YXIgY2xvc2VNZXNzYWdlO1xuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGNsb3NlTWVzc2FnZSA9ICdTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgY29kZSArICcgYW5kIHJlYXNvbjogJyArIGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlTWVzc2FnZSA9ICdTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgY29kZTtcbiAgICB9XG5cbiAgICB2YXIgZXJyID0gbmV3IFNvY2tldFByb3RvY29sRXJyb3IoU0NDbGllbnRTb2NrZXQuZXJyb3JTdGF0dXNlc1tjb2RlXSB8fCBjbG9zZU1lc3NhZ2UsIGNvZGUpO1xuXG4gICAgdGhpcy5fb25TQ0Vycm9yKGVycik7XG4gIH1cbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5fb25TQ0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhLCByZXMpIHtcbiAgdmFyIGhhbmRsZXIgPSB0aGlzLl9wcml2YXRlRXZlbnRIYW5kbGVyTWFwW2V2ZW50XTtcblxuICBpZiAoaGFuZGxlcikge1xuICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBkYXRhLCByZXMpO1xuICB9IGVsc2Uge1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCBldmVudCwgZGF0YSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmVzICYmIHJlcy5jYWxsYmFjay5hcHBseShyZXMsIGFyZ3VtZW50cyk7XG4gICAgfSk7XG4gIH1cbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICByZXR1cm4gdGhpcy50cmFuc3BvcnQuZGVjb2RlKG1lc3NhZ2UpO1xufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmVuY29kZShvYmplY3QpO1xufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLl9mbHVzaEVtaXRCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuX2VtaXRCdWZmZXIuaGVhZDtcbiAgdmFyIG5leHROb2RlO1xuXG4gIHdoaWxlIChjdXJyZW50Tm9kZSkge1xuICAgIG5leHROb2RlID0gY3VycmVudE5vZGUubmV4dDtcbiAgICB2YXIgZXZlbnRPYmplY3QgPSBjdXJyZW50Tm9kZS5kYXRhO1xuICAgIGN1cnJlbnROb2RlLmRldGFjaCgpO1xuICAgIHRoaXMudHJhbnNwb3J0LmVtaXRPYmplY3QoZXZlbnRPYmplY3QpO1xuICAgIGN1cnJlbnROb2RlID0gbmV4dE5vZGU7XG4gIH1cbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5faGFuZGxlRXZlbnRBY2tUaW1lb3V0ID0gZnVuY3Rpb24gKGV2ZW50T2JqZWN0LCBldmVudE5vZGUpIHtcbiAgaWYgKGV2ZW50Tm9kZSkge1xuICAgIGV2ZW50Tm9kZS5kZXRhY2goKTtcbiAgfVxuXG4gIGRlbGV0ZSBldmVudE9iamVjdC50aW1lb3V0O1xuICB2YXIgY2FsbGJhY2sgPSBldmVudE9iamVjdC5jYWxsYmFjaztcblxuICBpZiAoY2FsbGJhY2spIHtcbiAgICBkZWxldGUgZXZlbnRPYmplY3QuY2FsbGJhY2s7XG4gICAgdmFyIGVycm9yID0gbmV3IFRpbWVvdXRFcnJvcihcIkV2ZW50IHJlc3BvbnNlIGZvciAnXCIgKyBldmVudE9iamVjdC5ldmVudCArIFwiJyB0aW1lZCBvdXRcIik7XG4gICAgY2FsbGJhY2suY2FsbChldmVudE9iamVjdCwgZXJyb3IsIGV2ZW50T2JqZWN0KTtcbiAgfSAvLyBDbGVhbnVwIGFueSBwZW5kaW5nIHJlc3BvbnNlIGNhbGxiYWNrIGluIHRoZSB0cmFuc3BvcnQgbGF5ZXIgdG9vLlxuXG5cbiAgaWYgKGV2ZW50T2JqZWN0LmNpZCkge1xuICAgIHRoaXMudHJhbnNwb3J0LmNhbmNlbFBlbmRpbmdSZXNwb25zZShldmVudE9iamVjdC5jaWQpO1xuICB9XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuX2VtaXQgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEsIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLkNMT1NFRCkge1xuICAgIHRoaXMuY29ubmVjdCgpO1xuICB9XG5cbiAgdmFyIGV2ZW50T2JqZWN0ID0ge1xuICAgIGV2ZW50OiBldmVudCxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfTtcbiAgdmFyIGV2ZW50Tm9kZSA9IG5ldyBMaW5rZWRMaXN0Lkl0ZW0oKTtcblxuICBpZiAodGhpcy5vcHRpb25zLmNsb25lRGF0YSkge1xuICAgIGV2ZW50T2JqZWN0LmRhdGEgPSBjbG9uZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudE9iamVjdC5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGV2ZW50Tm9kZS5kYXRhID0gZXZlbnRPYmplY3Q7XG4gIGV2ZW50T2JqZWN0LnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9oYW5kbGVFdmVudEFja1RpbWVvdXQoZXZlbnRPYmplY3QsIGV2ZW50Tm9kZSk7XG4gIH0sIHRoaXMuYWNrVGltZW91dCk7XG5cbiAgdGhpcy5fZW1pdEJ1ZmZlci5hcHBlbmQoZXZlbnROb2RlKTtcblxuICBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLk9QRU4pIHtcbiAgICB0aGlzLl9mbHVzaEVtaXRCdWZmZXIoKTtcbiAgfVxufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLnRyYW5zcG9ydC5zZW5kKGRhdGEpO1xufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEsIGNhbGxiYWNrKSB7XG4gIGlmICh0aGlzLl9sb2NhbEV2ZW50c1tldmVudF0gPT0gbnVsbCkge1xuICAgIHRoaXMuX2VtaXQoZXZlbnQsIGRhdGEsIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmIChldmVudCA9PSAnZXJyb3InKSB7XG4gICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgSW52YWxpZEFjdGlvbkVycm9yKCdUaGUgXCInICsgZXZlbnQgKyAnXCIgZXZlbnQgaXMgcmVzZXJ2ZWQgYW5kIGNhbm5vdCBiZSBlbWl0dGVkIG9uIGEgY2xpZW50IHNvY2tldCcpO1xuXG4gICAgdGhpcy5fb25TQ0Vycm9yKGVycm9yKTtcbiAgfVxufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAoY2hhbm5lbE5hbWUsIGRhdGEsIGNhbGxiYWNrKSB7XG4gIHZhciBwdWJEYXRhID0ge1xuICAgIGNoYW5uZWw6IHRoaXMuX2RlY29yYXRlQ2hhbm5lbE5hbWUoY2hhbm5lbE5hbWUpLFxuICAgIGRhdGE6IGRhdGFcbiAgfTtcbiAgdGhpcy5lbWl0KCcjcHVibGlzaCcsIHB1YkRhdGEsIGNhbGxiYWNrKTtcbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5fdHJpZ2dlckNoYW5uZWxTdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2hhbm5lbCwgc3Vic2NyaXB0aW9uT3B0aW9ucykge1xuICB2YXIgY2hhbm5lbE5hbWUgPSBjaGFubmVsLm5hbWU7XG5cbiAgaWYgKGNoYW5uZWwuc3RhdGUgIT0gY2hhbm5lbC5TVUJTQ1JJQkVEKSB7XG4gICAgdmFyIG9sZFN0YXRlID0gY2hhbm5lbC5zdGF0ZTtcbiAgICBjaGFubmVsLnN0YXRlID0gY2hhbm5lbC5TVUJTQ1JJQkVEO1xuICAgIHZhciBzdGF0ZUNoYW5nZURhdGEgPSB7XG4gICAgICBjaGFubmVsOiBjaGFubmVsTmFtZSxcbiAgICAgIG9sZFN0YXRlOiBvbGRTdGF0ZSxcbiAgICAgIG5ld1N0YXRlOiBjaGFubmVsLnN0YXRlLFxuICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uczogc3Vic2NyaXB0aW9uT3B0aW9uc1xuICAgIH07XG4gICAgY2hhbm5lbC5lbWl0KCdzdWJzY3JpYmVTdGF0ZUNoYW5nZScsIHN0YXRlQ2hhbmdlRGF0YSk7XG4gICAgY2hhbm5lbC5lbWl0KCdzdWJzY3JpYmUnLCBjaGFubmVsTmFtZSwgc3Vic2NyaXB0aW9uT3B0aW9ucyk7XG4gICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsICdzdWJzY3JpYmVTdGF0ZUNoYW5nZScsIHN0YXRlQ2hhbmdlRGF0YSk7XG4gICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsICdzdWJzY3JpYmUnLCBjaGFubmVsTmFtZSwgc3Vic2NyaXB0aW9uT3B0aW9ucyk7XG4gIH1cbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5fdHJpZ2dlckNoYW5uZWxTdWJzY3JpYmVGYWlsID0gZnVuY3Rpb24gKGVyciwgY2hhbm5lbCwgc3Vic2NyaXB0aW9uT3B0aW9ucykge1xuICB2YXIgY2hhbm5lbE5hbWUgPSBjaGFubmVsLm5hbWU7XG4gIHZhciBtZWV0c0F1dGhSZXF1aXJlbWVudHMgPSAhY2hhbm5lbC53YWl0Rm9yQXV0aCB8fCB0aGlzLmF1dGhTdGF0ZSA9PSB0aGlzLkFVVEhFTlRJQ0FURUQ7XG5cbiAgaWYgKGNoYW5uZWwuc3RhdGUgIT0gY2hhbm5lbC5VTlNVQlNDUklCRUQgJiYgbWVldHNBdXRoUmVxdWlyZW1lbnRzKSB7XG4gICAgY2hhbm5lbC5zdGF0ZSA9IGNoYW5uZWwuVU5TVUJTQ1JJQkVEO1xuICAgIGNoYW5uZWwuZW1pdCgnc3Vic2NyaWJlRmFpbCcsIGVyciwgY2hhbm5lbE5hbWUsIHN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCAnc3Vic2NyaWJlRmFpbCcsIGVyciwgY2hhbm5lbE5hbWUsIHN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuICB9XG59OyAvLyBDYW5jZWwgYW55IHBlbmRpbmcgc3Vic2NyaWJlIGNhbGxiYWNrXG5cblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLl9jYW5jZWxQZW5kaW5nU3Vic2NyaWJlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICBpZiAoY2hhbm5lbC5fcGVuZGluZ1N1YnNjcmlwdGlvbkNpZCAhPSBudWxsKSB7XG4gICAgdGhpcy50cmFuc3BvcnQuY2FuY2VsUGVuZGluZ1Jlc3BvbnNlKGNoYW5uZWwuX3BlbmRpbmdTdWJzY3JpcHRpb25DaWQpO1xuICAgIGRlbGV0ZSBjaGFubmVsLl9wZW5kaW5nU3Vic2NyaXB0aW9uQ2lkO1xuICB9XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuX2RlY29yYXRlQ2hhbm5lbE5hbWUgPSBmdW5jdGlvbiAoY2hhbm5lbE5hbWUpIHtcbiAgaWYgKHRoaXMuY2hhbm5lbFByZWZpeCkge1xuICAgIGNoYW5uZWxOYW1lID0gdGhpcy5jaGFubmVsUHJlZml4ICsgY2hhbm5lbE5hbWU7XG4gIH1cblxuICByZXR1cm4gY2hhbm5lbE5hbWU7XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuX3VuZGVjb3JhdGVDaGFubmVsTmFtZSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWRDaGFubmVsTmFtZSkge1xuICBpZiAodGhpcy5jaGFubmVsUHJlZml4ICYmIGRlY29yYXRlZENoYW5uZWxOYW1lLmluZGV4T2YodGhpcy5jaGFubmVsUHJlZml4KSA9PSAwKSB7XG4gICAgcmV0dXJuIGRlY29yYXRlZENoYW5uZWxOYW1lLnJlcGxhY2UodGhpcy5jaGFubmVsUHJlZml4LCAnJyk7XG4gIH1cblxuICByZXR1cm4gZGVjb3JhdGVkQ2hhbm5lbE5hbWU7XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG1lZXRzQXV0aFJlcXVpcmVtZW50cyA9ICFjaGFubmVsLndhaXRGb3JBdXRoIHx8IHRoaXMuYXV0aFN0YXRlID09IHRoaXMuQVVUSEVOVElDQVRFRDsgLy8gV2UgY2FuIG9ubHkgZXZlciBoYXZlIG9uZSBwZW5kaW5nIHN1YnNjcmliZSBhY3Rpb24gYXQgYW55IGdpdmVuIHRpbWUgb24gYSBjaGFubmVsXG5cbiAgaWYgKHRoaXMuc3RhdGUgPT0gdGhpcy5PUEVOICYmICF0aGlzLnByZXBhcmluZ1BlbmRpbmdTdWJzY3JpcHRpb25zICYmIGNoYW5uZWwuX3BlbmRpbmdTdWJzY3JpcHRpb25DaWQgPT0gbnVsbCAmJiBtZWV0c0F1dGhSZXF1aXJlbWVudHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIG5vVGltZW91dDogdHJ1ZVxuICAgIH07XG4gICAgdmFyIHN1YnNjcmlwdGlvbk9wdGlvbnMgPSB7XG4gICAgICBjaGFubmVsOiB0aGlzLl9kZWNvcmF0ZUNoYW5uZWxOYW1lKGNoYW5uZWwubmFtZSlcbiAgICB9O1xuXG4gICAgaWYgKGNoYW5uZWwud2FpdEZvckF1dGgpIHtcbiAgICAgIG9wdGlvbnMud2FpdEZvckF1dGggPSB0cnVlO1xuICAgICAgc3Vic2NyaXB0aW9uT3B0aW9ucy53YWl0Rm9yQXV0aCA9IG9wdGlvbnMud2FpdEZvckF1dGg7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5uZWwuZGF0YSkge1xuICAgICAgc3Vic2NyaXB0aW9uT3B0aW9ucy5kYXRhID0gY2hhbm5lbC5kYXRhO1xuICAgIH1cblxuICAgIGlmIChjaGFubmVsLmJhdGNoKSB7XG4gICAgICBvcHRpb25zLmJhdGNoID0gdHJ1ZTtcbiAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnMuYmF0Y2ggPSB0cnVlO1xuICAgIH1cblxuICAgIGNoYW5uZWwuX3BlbmRpbmdTdWJzY3JpcHRpb25DaWQgPSB0aGlzLnRyYW5zcG9ydC5lbWl0KCcjc3Vic2NyaWJlJywgc3Vic2NyaXB0aW9uT3B0aW9ucywgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgZGVsZXRlIGNoYW5uZWwuX3BlbmRpbmdTdWJzY3JpcHRpb25DaWQ7XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgc2VsZi5fdHJpZ2dlckNoYW5uZWxTdWJzY3JpYmVGYWlsKGVyciwgY2hhbm5lbCwgc3Vic2NyaXB0aW9uT3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl90cmlnZ2VyQ2hhbm5lbFN1YnNjcmliZShjaGFubmVsLCBzdWJzY3JpcHRpb25PcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgJ3N1YnNjcmliZVJlcXVlc3QnLCBjaGFubmVsLm5hbWUsIHN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuICB9XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNoYW5uZWxOYW1lLCBvcHRpb25zKSB7XG4gIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaGFubmVsTmFtZV07XG5cbiAgaWYgKCFjaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBTQ0NoYW5uZWwoY2hhbm5lbE5hbWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hhbm5lbHNbY2hhbm5lbE5hbWVdID0gY2hhbm5lbDtcbiAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgY2hhbm5lbC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGNoYW5uZWwuc3RhdGUgPT0gY2hhbm5lbC5VTlNVQlNDUklCRUQpIHtcbiAgICBjaGFubmVsLnN0YXRlID0gY2hhbm5lbC5QRU5ESU5HO1xuXG4gICAgdGhpcy5fdHJ5U3Vic2NyaWJlKGNoYW5uZWwpO1xuICB9XG5cbiAgcmV0dXJuIGNoYW5uZWw7XG59O1xuXG5TQ0NsaWVudFNvY2tldC5wcm90b3R5cGUuX3RyaWdnZXJDaGFubmVsVW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2hhbm5lbCwgbmV3U3RhdGUpIHtcbiAgdmFyIGNoYW5uZWxOYW1lID0gY2hhbm5lbC5uYW1lO1xuICB2YXIgb2xkU3RhdGUgPSBjaGFubmVsLnN0YXRlO1xuXG4gIGlmIChuZXdTdGF0ZSkge1xuICAgIGNoYW5uZWwuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBjaGFubmVsLnN0YXRlID0gY2hhbm5lbC5VTlNVQlNDUklCRUQ7XG4gIH1cblxuICB0aGlzLl9jYW5jZWxQZW5kaW5nU3Vic2NyaWJlQ2FsbGJhY2soY2hhbm5lbCk7XG5cbiAgaWYgKG9sZFN0YXRlID09IGNoYW5uZWwuU1VCU0NSSUJFRCkge1xuICAgIHZhciBzdGF0ZUNoYW5nZURhdGEgPSB7XG4gICAgICBjaGFubmVsOiBjaGFubmVsTmFtZSxcbiAgICAgIG9sZFN0YXRlOiBvbGRTdGF0ZSxcbiAgICAgIG5ld1N0YXRlOiBjaGFubmVsLnN0YXRlXG4gICAgfTtcbiAgICBjaGFubmVsLmVtaXQoJ3N1YnNjcmliZVN0YXRlQ2hhbmdlJywgc3RhdGVDaGFuZ2VEYXRhKTtcbiAgICBjaGFubmVsLmVtaXQoJ3Vuc3Vic2NyaWJlJywgY2hhbm5lbE5hbWUpO1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCAnc3Vic2NyaWJlU3RhdGVDaGFuZ2UnLCBzdGF0ZUNoYW5nZURhdGEpO1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLmVtaXQuY2FsbCh0aGlzLCAndW5zdWJzY3JpYmUnLCBjaGFubmVsTmFtZSk7XG4gIH1cbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5fdHJ5VW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuc3RhdGUgPT0gdGhpcy5PUEVOKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBub1RpbWVvdXQ6IHRydWVcbiAgICB9O1xuXG4gICAgaWYgKGNoYW5uZWwuYmF0Y2gpIHtcbiAgICAgIG9wdGlvbnMuYmF0Y2ggPSB0cnVlO1xuICAgIH0gLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIHN1YnNjcmliZSBhY3Rpb24sIGNhbmNlbCB0aGUgY2FsbGJhY2tcblxuXG4gICAgdGhpcy5fY2FuY2VsUGVuZGluZ1N1YnNjcmliZUNhbGxiYWNrKGNoYW5uZWwpOyAvLyBUaGlzIG9wZXJhdGlvbiBjYW5ub3QgZmFpbCBiZWNhdXNlIHRoZSBUQ1AgcHJvdG9jb2wgZ3VhcmFudGVlcyBkZWxpdmVyeVxuICAgIC8vIHNvIGxvbmcgYXMgdGhlIGNvbm5lY3Rpb24gcmVtYWlucyBvcGVuLiBJZiB0aGUgY29ubmVjdGlvbiBjbG9zZXMsXG4gICAgLy8gdGhlIHNlcnZlciB3aWxsIGF1dG9tYXRpY2FsbHkgdW5zdWJzY3JpYmUgdGhlIGNsaWVudCBhbmQgdGh1cyBjb21wbGV0ZVxuICAgIC8vIHRoZSBvcGVyYXRpb24gb24gdGhlIHNlcnZlciBzaWRlLlxuXG5cbiAgICB2YXIgZGVjb3JhdGVkQ2hhbm5lbE5hbWUgPSB0aGlzLl9kZWNvcmF0ZUNoYW5uZWxOYW1lKGNoYW5uZWwubmFtZSk7XG5cbiAgICB0aGlzLnRyYW5zcG9ydC5lbWl0KCcjdW5zdWJzY3JpYmUnLCBkZWNvcmF0ZWRDaGFubmVsTmFtZSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChjaGFubmVsTmFtZSkge1xuICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hhbm5lbE5hbWVdO1xuXG4gIGlmIChjaGFubmVsKSB7XG4gICAgaWYgKGNoYW5uZWwuc3RhdGUgIT0gY2hhbm5lbC5VTlNVQlNDUklCRUQpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXJDaGFubmVsVW5zdWJzY3JpYmUoY2hhbm5lbCk7XG5cbiAgICAgIHRoaXMuX3RyeVVuc3Vic2NyaWJlKGNoYW5uZWwpO1xuICAgIH1cbiAgfVxufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLmNoYW5uZWwgPSBmdW5jdGlvbiAoY2hhbm5lbE5hbWUsIG9wdGlvbnMpIHtcbiAgdmFyIGN1cnJlbnRDaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaGFubmVsTmFtZV07XG5cbiAgaWYgKCFjdXJyZW50Q2hhbm5lbCkge1xuICAgIGN1cnJlbnRDaGFubmVsID0gbmV3IFNDQ2hhbm5lbChjaGFubmVsTmFtZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5jaGFubmVsc1tjaGFubmVsTmFtZV0gPSBjdXJyZW50Q2hhbm5lbDtcbiAgfVxuXG4gIHJldHVybiBjdXJyZW50Q2hhbm5lbDtcbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5kZXN0cm95Q2hhbm5lbCA9IGZ1bmN0aW9uIChjaGFubmVsTmFtZSkge1xuICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hhbm5lbE5hbWVdO1xuXG4gIGlmIChjaGFubmVsKSB7XG4gICAgY2hhbm5lbC51bndhdGNoKCk7XG4gICAgY2hhbm5lbC51bnN1YnNjcmliZSgpO1xuICAgIGRlbGV0ZSB0aGlzLmNoYW5uZWxzW2NoYW5uZWxOYW1lXTtcbiAgfVxufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLnN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoaW5jbHVkZVBlbmRpbmcpIHtcbiAgdmFyIHN1YnMgPSBbXTtcbiAgdmFyIGNoYW5uZWwsIGluY2x1ZGVDaGFubmVsO1xuXG4gIGZvciAodmFyIGNoYW5uZWxOYW1lIGluIHRoaXMuY2hhbm5lbHMpIHtcbiAgICBpZiAodGhpcy5jaGFubmVscy5oYXNPd25Qcm9wZXJ0eShjaGFubmVsTmFtZSkpIHtcbiAgICAgIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoYW5uZWxOYW1lXTtcblxuICAgICAgaWYgKGluY2x1ZGVQZW5kaW5nKSB7XG4gICAgICAgIGluY2x1ZGVDaGFubmVsID0gY2hhbm5lbCAmJiAoY2hhbm5lbC5zdGF0ZSA9PSBjaGFubmVsLlNVQlNDUklCRUQgfHwgY2hhbm5lbC5zdGF0ZSA9PSBjaGFubmVsLlBFTkRJTkcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5jbHVkZUNoYW5uZWwgPSBjaGFubmVsICYmIGNoYW5uZWwuc3RhdGUgPT0gY2hhbm5lbC5TVUJTQ1JJQkVEO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZUNoYW5uZWwpIHtcbiAgICAgICAgc3Vicy5wdXNoKGNoYW5uZWxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3Vicztcbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5pc1N1YnNjcmliZWQgPSBmdW5jdGlvbiAoY2hhbm5lbE5hbWUsIGluY2x1ZGVQZW5kaW5nKSB7XG4gIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaGFubmVsTmFtZV07XG5cbiAgaWYgKGluY2x1ZGVQZW5kaW5nKSB7XG4gICAgcmV0dXJuICEhY2hhbm5lbCAmJiAoY2hhbm5lbC5zdGF0ZSA9PSBjaGFubmVsLlNVQlNDUklCRUQgfHwgY2hhbm5lbC5zdGF0ZSA9PSBjaGFubmVsLlBFTkRJTkcpO1xuICB9XG5cbiAgcmV0dXJuICEhY2hhbm5lbCAmJiBjaGFubmVsLnN0YXRlID09IGNoYW5uZWwuU1VCU0NSSUJFRDtcbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS5wcm9jZXNzUGVuZGluZ1N1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5wcmVwYXJpbmdQZW5kaW5nU3Vic2NyaXB0aW9ucyA9IGZhbHNlO1xuICB2YXIgcGVuZGluZ0NoYW5uZWxzID0gW107XG5cbiAgZm9yICh2YXIgaSBpbiB0aGlzLmNoYW5uZWxzKSB7XG4gICAgaWYgKHRoaXMuY2hhbm5lbHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXTtcblxuICAgICAgaWYgKGNoYW5uZWwuc3RhdGUgPT0gY2hhbm5lbC5QRU5ESU5HKSB7XG4gICAgICAgIHBlbmRpbmdDaGFubmVscy5wdXNoKGNoYW5uZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBlbmRpbmdDaGFubmVscy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGFwID0gYS5wcmlvcml0eSB8fCAwO1xuICAgIHZhciBicCA9IGIucHJpb3JpdHkgfHwgMDtcblxuICAgIGlmIChhcCA+IGJwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYgKGFwIDwgYnApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9KTtcbiAgcGVuZGluZ0NoYW5uZWxzLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICBzZWxmLl90cnlTdWJzY3JpYmUoY2hhbm5lbCk7XG4gIH0pO1xufTtcblxuU0NDbGllbnRTb2NrZXQucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKGNoYW5uZWxOYW1lLCBoYW5kbGVyKSB7XG4gIGlmICh0eXBlb2YgaGFuZGxlciAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNFcnJvcignTm8gaGFuZGxlciBmdW5jdGlvbiB3YXMgcHJvdmlkZWQnKTtcbiAgfVxuXG4gIHRoaXMuX2NoYW5uZWxFbWl0dGVyLm9uKGNoYW5uZWxOYW1lLCBoYW5kbGVyKTtcbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS51bndhdGNoID0gZnVuY3Rpb24gKGNoYW5uZWxOYW1lLCBoYW5kbGVyKSB7XG4gIGlmIChoYW5kbGVyKSB7XG4gICAgdGhpcy5fY2hhbm5lbEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoY2hhbm5lbE5hbWUsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2NoYW5uZWxFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyhjaGFubmVsTmFtZSk7XG4gIH1cbn07XG5cblNDQ2xpZW50U29ja2V0LnByb3RvdHlwZS53YXRjaGVycyA9IGZ1bmN0aW9uIChjaGFubmVsTmFtZSkge1xuICByZXR1cm4gdGhpcy5fY2hhbm5lbEVtaXR0ZXIubGlzdGVuZXJzKGNoYW5uZWxOYW1lKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU0NDbGllbnRTb2NrZXQ7IiwidmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG52YXIgUmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJykuUmVzcG9uc2U7XG5cbnZhciBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbnZhciBXZWJTb2NrZXQ7XG52YXIgY3JlYXRlV2ViU29ja2V0O1xuXG5pZiAoZ2xvYmFsLldlYlNvY2tldCkge1xuICBXZWJTb2NrZXQgPSBnbG9iYWwuV2ViU29ja2V0O1xuXG4gIGNyZWF0ZVdlYlNvY2tldCA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFdlYlNvY2tldCh1cmkpO1xuICB9O1xufSBlbHNlIHtcbiAgV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcblxuICBjcmVhdGVXZWJTb2NrZXQgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBXZWJTb2NrZXQodXJpLCBudWxsLCBvcHRpb25zKTtcbiAgfTtcbn1cblxudmFyIHNjRXJyb3JzID0gcmVxdWlyZSgnc2MtZXJyb3JzJyk7XG5cbnZhciBUaW1lb3V0RXJyb3IgPSBzY0Vycm9ycy5UaW1lb3V0RXJyb3I7XG52YXIgQmFkQ29ubmVjdGlvbkVycm9yID0gc2NFcnJvcnMuQmFkQ29ubmVjdGlvbkVycm9yO1xuXG52YXIgU0NUcmFuc3BvcnQgPSBmdW5jdGlvbiAoYXV0aEVuZ2luZSwgY29kZWNFbmdpbmUsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnN0YXRlID0gdGhpcy5DTE9TRUQ7XG4gIHRoaXMuYXV0aCA9IGF1dGhFbmdpbmU7XG4gIHRoaXMuY29kZWMgPSBjb2RlY0VuZ2luZTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5jb25uZWN0VGltZW91dCA9IG9wdGlvbnMuY29ubmVjdFRpbWVvdXQ7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBvcHRpb25zLmFja1RpbWVvdXQ7XG4gIHRoaXMucGluZ1RpbWVvdXREaXNhYmxlZCA9ICEhb3B0aW9ucy5waW5nVGltZW91dERpc2FibGVkO1xuICB0aGlzLmNhbGxJZEdlbmVyYXRvciA9IG9wdGlvbnMuY2FsbElkR2VuZXJhdG9yO1xuICB0aGlzLmF1dGhUb2tlbk5hbWUgPSBvcHRpb25zLmF1dGhUb2tlbk5hbWU7XG4gIHRoaXMuX3BpbmdUaW1lb3V0VGlja2VyID0gbnVsbDtcbiAgdGhpcy5fY2FsbGJhY2tNYXAgPSB7fTtcbiAgdGhpcy5fYmF0Y2hTZW5kTGlzdCA9IFtdOyAvLyBPcGVuIHRoZSBjb25uZWN0aW9uLlxuXG4gIHRoaXMuc3RhdGUgPSB0aGlzLkNPTk5FQ1RJTkc7XG4gIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuICB2YXIgd3NTb2NrZXQgPSBjcmVhdGVXZWJTb2NrZXQodXJpLCB0aGlzLm9wdGlvbnMpO1xuICB3c1NvY2tldC5iaW5hcnlUeXBlID0gdGhpcy5vcHRpb25zLmJpbmFyeVR5cGU7XG4gIHRoaXMuc29ja2V0ID0gd3NTb2NrZXQ7XG5cbiAgd3NTb2NrZXQub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uT3BlbigpO1xuICB9O1xuXG4gIHdzU29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgY29kZTtcblxuICAgIGlmIChldmVudC5jb2RlID09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdG8gaGFuZGxlIGFuIGVkZ2UgY2FzZSBpbiBSZWFjdCBOYXRpdmUgd2hlcmVieVxuICAgICAgLy8gZXZlbnQuY29kZSBpcyB1bmRlZmluZWQgd2hlbiB0aGUgbW9iaWxlIGRldmljZSBpcyBsb2NrZWQuXG4gICAgICAvLyBUT0RPOiBUaGlzIGlzIG5vdCBwZXJmZWN0IHNpbmNlIHRoaXMgY29uZGl0aW9uIGNvdWxkIGFsc28gYXBwbHkgdG9cbiAgICAgIC8vIGFuIGFibm9ybWFsIGNsb3NlIChubyBjbG9zZSBjb250cm9sIGZyYW1lKSB3aGljaCB3b3VsZCBiZSBhIDEwMDYuXG4gICAgICBjb2RlID0gMTAwNTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IGV2ZW50LmNvZGU7XG4gICAgfVxuXG4gICAgc2VsZi5fb25DbG9zZShjb2RlLCBldmVudC5yZWFzb24pO1xuICB9O1xuXG4gIHdzU29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBmbGFncykge1xuICAgIHNlbGYuX29uTWVzc2FnZShtZXNzYWdlLmRhdGEpO1xuICB9O1xuXG4gIHdzU29ja2V0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAvLyBUaGUgb25jbG9zZSBldmVudCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGFmdGVyIHRoZSBvbmVycm9yIGV2ZW50XG4gICAgLy8gaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQgLSBPdGhlcndpc2UsIGlmIGl0J3MgaW4gdGhlIG1pZGRsZSBvZlxuICAgIC8vIGNvbm5lY3RpbmcsIHdlIHdhbnQgdG8gY2xvc2UgaXQgbWFudWFsbHkgd2l0aCBhIDEwMDYgLSBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgIC8vIHRvIHByZXZlbnQgaW5jb25zaXN0ZW50IGJlaGF2aW9yIHdoZW4gcnVubmluZyB0aGUgY2xpZW50IGluIE5vZGUuanNcbiAgICAvLyB2cyBpbiBhIGJyb3dzZXIuXG4gICAgaWYgKHNlbGYuc3RhdGUgPT09IHNlbGYuQ09OTkVDVElORykge1xuICAgICAgc2VsZi5fb25DbG9zZSgxMDA2KTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5fY29ubmVjdFRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9vbkNsb3NlKDQwMDcpO1xuXG4gICAgc2VsZi5zb2NrZXQuY2xvc2UoNDAwNyk7XG4gIH0sIHRoaXMuY29ubmVjdFRpbWVvdXQpO1xufTtcblxuU0NUcmFuc3BvcnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFbWl0dGVyLnByb3RvdHlwZSk7XG5TQ1RyYW5zcG9ydC5DT05ORUNUSU5HID0gU0NUcmFuc3BvcnQucHJvdG90eXBlLkNPTk5FQ1RJTkcgPSAnY29ubmVjdGluZyc7XG5TQ1RyYW5zcG9ydC5PUEVOID0gU0NUcmFuc3BvcnQucHJvdG90eXBlLk9QRU4gPSAnb3Blbic7XG5TQ1RyYW5zcG9ydC5DTE9TRUQgPSBTQ1RyYW5zcG9ydC5wcm90b3R5cGUuQ0xPU0VEID0gJ2Nsb3NlZCc7XG5cblNDVHJhbnNwb3J0LnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMub3B0aW9ucy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMub3B0aW9ucy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMub3B0aW9ucy50aW1lc3RhbXBQYXJhbV0gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuZW5jb2RlKHF1ZXJ5KTtcblxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBob3N0O1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuaG9zdCkge1xuICAgIGhvc3QgPSB0aGlzLm9wdGlvbnMuaG9zdDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcG9ydCA9ICcnO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wb3J0ICYmIChzY2hlbWEgPT0gJ3dzcycgJiYgdGhpcy5vcHRpb25zLnBvcnQgIT0gNDQzIHx8IHNjaGVtYSA9PSAnd3MnICYmIHRoaXMub3B0aW9ucy5wb3J0ICE9IDgwKSkge1xuICAgICAgcG9ydCA9ICc6JyArIHRoaXMub3B0aW9ucy5wb3J0O1xuICAgIH1cblxuICAgIGhvc3QgPSB0aGlzLm9wdGlvbnMuaG9zdG5hbWUgKyBwb3J0O1xuICB9XG5cbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgaG9zdCArIHRoaXMub3B0aW9ucy5wYXRoICsgcXVlcnk7XG59O1xuXG5TQ1RyYW5zcG9ydC5wcm90b3R5cGUuX29uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQodGhpcy5fY29ubmVjdFRpbWVvdXRSZWYpO1xuXG4gIHRoaXMuX3Jlc2V0UGluZ1RpbWVvdXQoKTtcblxuICB0aGlzLl9oYW5kc2hha2UoZnVuY3Rpb24gKGVyciwgc3RhdHVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgdmFyIHN0YXR1c0NvZGU7XG5cbiAgICAgIGlmIChzdGF0dXMgJiYgc3RhdHVzLmNvZGUpIHtcbiAgICAgICAgc3RhdHVzQ29kZSA9IHN0YXR1cy5jb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzQ29kZSA9IDQwMDM7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX29uRXJyb3IoZXJyKTtcblxuICAgICAgc2VsZi5fb25DbG9zZShzdGF0dXNDb2RlLCBlcnIudG9TdHJpbmcoKSk7XG5cbiAgICAgIHNlbGYuc29ja2V0LmNsb3NlKHN0YXR1c0NvZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnN0YXRlID0gc2VsZi5PUEVOO1xuICAgICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHNlbGYsICdvcGVuJywgc3RhdHVzKTtcblxuICAgICAgc2VsZi5fcmVzZXRQaW5nVGltZW91dCgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5TQ1RyYW5zcG9ydC5wcm90b3R5cGUuX2hhbmRzaGFrZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuYXV0aC5sb2FkVG9rZW4odGhpcy5hdXRoVG9rZW5OYW1lLCBmdW5jdGlvbiAoZXJyLCB0b2tlbikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERvbid0IHdhaXQgZm9yIHRoaXMuc3RhdGUgdG8gYmUgJ29wZW4nLlxuICAgICAgLy8gVGhlIHVuZGVybHlpbmcgV2ViU29ja2V0ICh0aGlzLnNvY2tldCkgaXMgYWxyZWFkeSBvcGVuLlxuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICB9O1xuICAgICAgc2VsZi5lbWl0KCcjaGFuZHNoYWtlJywge1xuICAgICAgICBhdXRoVG9rZW46IHRva2VuXG4gICAgICB9LCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBzdGF0dXMpIHtcbiAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgIC8vIEFkZCB0aGUgdG9rZW4gd2hpY2ggd2FzIHVzZWQgYXMgcGFydCBvZiBhdXRoZW50aWNhdGlvbiBhdHRlbXB0XG4gICAgICAgICAgLy8gdG8gdGhlIHN0YXR1cyBvYmplY3QuXG4gICAgICAgICAgc3RhdHVzLmF1dGhUb2tlbiA9IHRva2VuO1xuXG4gICAgICAgICAgaWYgKHN0YXR1cy5hdXRoRXJyb3IpIHtcbiAgICAgICAgICAgIHN0YXR1cy5hdXRoRXJyb3IgPSBzY0Vycm9ycy5oeWRyYXRlRXJyb3Ioc3RhdHVzLmF1dGhFcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soZXJyLCBzdGF0dXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cblNDVHJhbnNwb3J0LnByb3RvdHlwZS5fYWJvcnRBbGxQZW5kaW5nRXZlbnRzRHVlVG9CYWRDb25uZWN0aW9uID0gZnVuY3Rpb24gKGZhaWx1cmVUeXBlKSB7XG4gIGZvciAodmFyIGkgaW4gdGhpcy5fY2FsbGJhY2tNYXApIHtcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tNYXAuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIHZhciBldmVudE9iamVjdCA9IHRoaXMuX2NhbGxiYWNrTWFwW2ldO1xuICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrTWFwW2ldO1xuICAgICAgY2xlYXJUaW1lb3V0KGV2ZW50T2JqZWN0LnRpbWVvdXQpO1xuICAgICAgZGVsZXRlIGV2ZW50T2JqZWN0LnRpbWVvdXQ7XG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gXCJFdmVudCAnXCIgKyBldmVudE9iamVjdC5ldmVudCArIFwiJyB3YXMgYWJvcnRlZCBkdWUgdG8gYSBiYWQgY29ubmVjdGlvblwiO1xuICAgICAgdmFyIGJhZENvbm5lY3Rpb25FcnJvciA9IG5ldyBCYWRDb25uZWN0aW9uRXJyb3IoZXJyb3JNZXNzYWdlLCBmYWlsdXJlVHlwZSk7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBldmVudE9iamVjdC5jYWxsYmFjaztcbiAgICAgIGRlbGV0ZSBldmVudE9iamVjdC5jYWxsYmFjaztcbiAgICAgIGNhbGxiYWNrLmNhbGwoZXZlbnRPYmplY3QsIGJhZENvbm5lY3Rpb25FcnJvciwgZXZlbnRPYmplY3QpO1xuICAgIH1cbiAgfVxufTtcblxuU0NUcmFuc3BvcnQucHJvdG90eXBlLl9vbkNsb3NlID0gZnVuY3Rpb24gKGNvZGUsIGRhdGEpIHtcbiAgZGVsZXRlIHRoaXMuc29ja2V0Lm9ub3BlbjtcbiAgZGVsZXRlIHRoaXMuc29ja2V0Lm9uY2xvc2U7XG4gIGRlbGV0ZSB0aGlzLnNvY2tldC5vbm1lc3NhZ2U7XG4gIGRlbGV0ZSB0aGlzLnNvY2tldC5vbmVycm9yO1xuICBjbGVhclRpbWVvdXQodGhpcy5fY29ubmVjdFRpbWVvdXRSZWYpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fcGluZ1RpbWVvdXRUaWNrZXIpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fYmF0Y2hUaW1lb3V0KTtcblxuICBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLk9QRU4pIHtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5DTE9TRUQ7XG4gICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsICdjbG9zZScsIGNvZGUsIGRhdGEpO1xuXG4gICAgdGhpcy5fYWJvcnRBbGxQZW5kaW5nRXZlbnRzRHVlVG9CYWRDb25uZWN0aW9uKCdkaXNjb25uZWN0Jyk7XG4gIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLkNPTk5FQ1RJTkcpIHtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5DTE9TRUQ7XG4gICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsICdvcGVuQWJvcnQnLCBjb2RlLCBkYXRhKTtcblxuICAgIHRoaXMuX2Fib3J0QWxsUGVuZGluZ0V2ZW50c0R1ZVRvQmFkQ29ubmVjdGlvbignY29ubmVjdEFib3J0Jyk7XG4gIH1cbn07XG5cblNDVHJhbnNwb3J0LnByb3RvdHlwZS5faGFuZGxlRXZlbnRPYmplY3QgPSBmdW5jdGlvbiAob2JqLCBtZXNzYWdlKSB7XG4gIGlmIChvYmogJiYgb2JqLmV2ZW50ICE9IG51bGwpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UodGhpcywgb2JqLmNpZCk7XG4gICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsICdldmVudCcsIG9iai5ldmVudCwgb2JqLmRhdGEsIHJlc3BvbnNlKTtcbiAgfSBlbHNlIGlmIChvYmogJiYgb2JqLnJpZCAhPSBudWxsKSB7XG4gICAgdmFyIGV2ZW50T2JqZWN0ID0gdGhpcy5fY2FsbGJhY2tNYXBbb2JqLnJpZF07XG5cbiAgICBpZiAoZXZlbnRPYmplY3QpIHtcbiAgICAgIGNsZWFyVGltZW91dChldmVudE9iamVjdC50aW1lb3V0KTtcbiAgICAgIGRlbGV0ZSBldmVudE9iamVjdC50aW1lb3V0O1xuICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrTWFwW29iai5yaWRdO1xuXG4gICAgICBpZiAoZXZlbnRPYmplY3QuY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlaHlkcmF0ZWRFcnJvciA9IHNjRXJyb3JzLmh5ZHJhdGVFcnJvcihvYmouZXJyb3IpO1xuICAgICAgICBldmVudE9iamVjdC5jYWxsYmFjayhyZWh5ZHJhdGVkRXJyb3IsIG9iai5kYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgRW1pdHRlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsICdldmVudCcsICdyYXcnLCBtZXNzYWdlKTtcbiAgfVxufTtcblxuU0NUcmFuc3BvcnQucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgJ2V2ZW50JywgJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgdmFyIG9iaiA9IHRoaXMuZGVjb2RlKG1lc3NhZ2UpOyAvLyBJZiBwaW5nXG5cbiAgaWYgKG9iaiA9PSAnIzEnKSB7XG4gICAgdGhpcy5fcmVzZXRQaW5nVGltZW91dCgpO1xuXG4gICAgaWYgKHRoaXMuc29ja2V0LnJlYWR5U3RhdGUgPT0gdGhpcy5zb2NrZXQuT1BFTikge1xuICAgICAgdGhpcy5zZW5kT2JqZWN0KCcjMicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLl9oYW5kbGVFdmVudE9iamVjdChvYmpbaV0sIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudE9iamVjdChvYmosIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufTtcblxuU0NUcmFuc3BvcnQucHJvdG90eXBlLl9vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBFbWl0dGVyLnByb3RvdHlwZS5lbWl0LmNhbGwodGhpcywgJ2Vycm9yJywgZXJyKTtcbn07XG5cblNDVHJhbnNwb3J0LnByb3RvdHlwZS5fcmVzZXRQaW5nVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGluZ1RpbWVvdXREaXNhYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fcGluZ1RpbWVvdXRUaWNrZXIpO1xuICB0aGlzLl9waW5nVGltZW91dFRpY2tlciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX29uQ2xvc2UoNDAwMCk7XG5cbiAgICBzZWxmLnNvY2tldC5jbG9zZSg0MDAwKTtcbiAgfSwgdGhpcy5waW5nVGltZW91dCk7XG59O1xuXG5TQ1RyYW5zcG9ydC5wcm90b3R5cGUuZ2V0Qnl0ZXNSZWNlaXZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc29ja2V0LmJ5dGVzUmVjZWl2ZWQ7XG59O1xuXG5TQ1RyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY29kZSwgZGF0YSkge1xuICBjb2RlID0gY29kZSB8fCAxMDAwO1xuXG4gIGlmICh0aGlzLnN0YXRlID09IHRoaXMuT1BFTikge1xuICAgIHZhciBwYWNrZXQgPSB7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH07XG4gICAgdGhpcy5lbWl0KCcjZGlzY29ubmVjdCcsIHBhY2tldCk7XG5cbiAgICB0aGlzLl9vbkNsb3NlKGNvZGUsIGRhdGEpO1xuXG4gICAgdGhpcy5zb2NrZXQuY2xvc2UoY29kZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLkNPTk5FQ1RJTkcpIHtcbiAgICB0aGlzLl9vbkNsb3NlKGNvZGUsIGRhdGEpO1xuXG4gICAgdGhpcy5zb2NrZXQuY2xvc2UoY29kZSk7XG4gIH1cbn07XG5cblNDVHJhbnNwb3J0LnByb3RvdHlwZS5lbWl0T2JqZWN0ID0gZnVuY3Rpb24gKGV2ZW50T2JqZWN0LCBvcHRpb25zKSB7XG4gIHZhciBzaW1wbGVFdmVudE9iamVjdCA9IHtcbiAgICBldmVudDogZXZlbnRPYmplY3QuZXZlbnQsXG4gICAgZGF0YTogZXZlbnRPYmplY3QuZGF0YVxuICB9O1xuXG4gIGlmIChldmVudE9iamVjdC5jYWxsYmFjaykge1xuICAgIHNpbXBsZUV2ZW50T2JqZWN0LmNpZCA9IGV2ZW50T2JqZWN0LmNpZCA9IHRoaXMuY2FsbElkR2VuZXJhdG9yKCk7XG4gICAgdGhpcy5fY2FsbGJhY2tNYXBbZXZlbnRPYmplY3QuY2lkXSA9IGV2ZW50T2JqZWN0O1xuICB9XG5cbiAgdGhpcy5zZW5kT2JqZWN0KHNpbXBsZUV2ZW50T2JqZWN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGV2ZW50T2JqZWN0LmNpZCB8fCBudWxsO1xufTtcblxuU0NUcmFuc3BvcnQucHJvdG90eXBlLl9oYW5kbGVFdmVudEFja1RpbWVvdXQgPSBmdW5jdGlvbiAoZXZlbnRPYmplY3QpIHtcbiAgaWYgKGV2ZW50T2JqZWN0LmNpZCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja01hcFtldmVudE9iamVjdC5jaWRdO1xuICB9XG5cbiAgZGVsZXRlIGV2ZW50T2JqZWN0LnRpbWVvdXQ7XG4gIHZhciBjYWxsYmFjayA9IGV2ZW50T2JqZWN0LmNhbGxiYWNrO1xuXG4gIGlmIChjYWxsYmFjaykge1xuICAgIGRlbGV0ZSBldmVudE9iamVjdC5jYWxsYmFjaztcbiAgICB2YXIgZXJyb3IgPSBuZXcgVGltZW91dEVycm9yKFwiRXZlbnQgcmVzcG9uc2UgZm9yICdcIiArIGV2ZW50T2JqZWN0LmV2ZW50ICsgXCInIHRpbWVkIG91dFwiKTtcbiAgICBjYWxsYmFjay5jYWxsKGV2ZW50T2JqZWN0LCBlcnJvciwgZXZlbnRPYmplY3QpO1xuICB9XG59OyAvLyBUaGUgbGFzdCB0d28gb3B0aW9uYWwgYXJndW1lbnRzIChhIGFuZCBiKSBjYW4gYmUgb3B0aW9ucyBhbmQvb3IgY2FsbGJhY2tcblxuXG5TQ1RyYW5zcG9ydC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCwgZGF0YSwgYSwgYikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjYWxsYmFjaywgb3B0aW9ucztcblxuICBpZiAoYikge1xuICAgIG9wdGlvbnMgPSBhO1xuICAgIGNhbGxiYWNrID0gYjtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgICBjYWxsYmFjayA9IGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBhO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudE9iamVjdCA9IHtcbiAgICBldmVudDogZXZlbnQsXG4gICAgZGF0YTogZGF0YSxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfTtcblxuICBpZiAoY2FsbGJhY2sgJiYgIW9wdGlvbnMubm9UaW1lb3V0KSB7XG4gICAgZXZlbnRPYmplY3QudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5faGFuZGxlRXZlbnRBY2tUaW1lb3V0KGV2ZW50T2JqZWN0KTtcbiAgICB9LCB0aGlzLm9wdGlvbnMuYWNrVGltZW91dCk7XG4gIH1cblxuICB2YXIgY2lkID0gbnVsbDtcblxuICBpZiAodGhpcy5zdGF0ZSA9PSB0aGlzLk9QRU4gfHwgb3B0aW9ucy5mb3JjZSkge1xuICAgIGNpZCA9IHRoaXMuZW1pdE9iamVjdChldmVudE9iamVjdCwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gY2lkO1xufTtcblxuU0NUcmFuc3BvcnQucHJvdG90eXBlLmNhbmNlbFBlbmRpbmdSZXNwb25zZSA9IGZ1bmN0aW9uIChjaWQpIHtcbiAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrTWFwW2NpZF07XG59O1xuXG5TQ1RyYW5zcG9ydC5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHRoaXMuY29kZWMuZGVjb2RlKG1lc3NhZ2UpO1xufTtcblxuU0NUcmFuc3BvcnQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHRoaXMuY29kZWMuZW5jb2RlKG9iamVjdCk7XG59O1xuXG5TQ1RyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIGlmICh0aGlzLnNvY2tldC5yZWFkeVN0YXRlICE9IHRoaXMuc29ja2V0Lk9QRU4pIHtcbiAgICB0aGlzLl9vbkNsb3NlKDEwMDUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gIH1cbn07XG5cblNDVHJhbnNwb3J0LnByb3RvdHlwZS5zZXJpYWxpemVPYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHZhciBzdHIsIGZvcm1hdEVycm9yO1xuXG4gIHRyeSB7XG4gICAgc3RyID0gdGhpcy5lbmNvZGUob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZm9ybWF0RXJyb3IgPSBlcnI7XG5cbiAgICB0aGlzLl9vbkVycm9yKGZvcm1hdEVycm9yKTtcbiAgfVxuXG4gIGlmICghZm9ybWF0RXJyb3IpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5TQ1RyYW5zcG9ydC5wcm90b3R5cGUuc2VuZE9iamVjdEJhdGNoID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5fYmF0Y2hTZW5kTGlzdC5wdXNoKG9iamVjdCk7XG5cbiAgaWYgKHRoaXMuX2JhdGNoVGltZW91dCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2JhdGNoVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlbGV0ZSBzZWxmLl9iYXRjaFRpbWVvdXQ7XG5cbiAgICBpZiAoc2VsZi5fYmF0Y2hTZW5kTGlzdC5sZW5ndGgpIHtcbiAgICAgIHZhciBzdHIgPSBzZWxmLnNlcmlhbGl6ZU9iamVjdChzZWxmLl9iYXRjaFNlbmRMaXN0KTtcblxuICAgICAgaWYgKHN0ciAhPSBudWxsKSB7XG4gICAgICAgIHNlbGYuc2VuZChzdHIpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9iYXRjaFNlbmRMaXN0ID0gW107XG4gICAgfVxuICB9LCB0aGlzLm9wdGlvbnMucHViU3ViQmF0Y2hEdXJhdGlvbiB8fCAwKTtcbn07XG5cblNDVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kT2JqZWN0U2luZ2xlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICB2YXIgc3RyID0gdGhpcy5zZXJpYWxpemVPYmplY3Qob2JqZWN0KTtcblxuICBpZiAoc3RyICE9IG51bGwpIHtcbiAgICB0aGlzLnNlbmQoc3RyKTtcbiAgfVxufTtcblxuU0NUcmFuc3BvcnQucHJvdG90eXBlLnNlbmRPYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYmF0Y2gpIHtcbiAgICB0aGlzLnNlbmRPYmplY3RCYXRjaChvYmplY3QpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2VuZE9iamVjdFNpbmdsZShvYmplY3QpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5TQ1RyYW5zcG9ydCA9IFNDVHJhbnNwb3J0OyIsInZhciBnbG9iYWw7XG5cbmlmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIGdsb2JhbCA9IHNlbGY7XG59IGVsc2Uge1xuICBnbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdyB8fCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0oKTtcbn1cblxudmFyIFdlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcbi8qKlxuICogV2ViU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIFRoZSB0aGlyZCBgb3B0c2Agb3B0aW9ucyBvYmplY3QgZ2V0cyBpZ25vcmVkIGluIHdlYiBicm93c2Vycywgc2luY2UgaXQnc1xuICogbm9uLXN0YW5kYXJkLCBhbmQgdGhyb3dzIGEgVHlwZUVycm9yIGlmIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9laW5hcm9zL3dzL2lzc3Vlcy8yMjdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAcGFyYW0ge0FycmF5fSBwcm90b2NvbHMgKG9wdGlvbmFsKVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgKG9wdGlvbmFsKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB3cyh1cmksIHByb3RvY29scywgb3B0cykge1xuICB2YXIgaW5zdGFuY2U7XG5cbiAgaWYgKHByb3RvY29scykge1xuICAgIGluc3RhbmNlID0gbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scyk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UgPSBuZXcgV2ViU29ja2V0KHVyaSk7XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmlmIChXZWJTb2NrZXQpIHdzLnByb3RvdHlwZSA9IFdlYlNvY2tldC5wcm90b3R5cGU7XG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldCA/IHdzIDogbnVsbDsiLCIvKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xufVxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cblxuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuO1xuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cblxuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9IEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKS5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXG5cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cblxuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTsgLy8gYWxsXG5cbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHNwZWNpZmljIGV2ZW50XG5cblxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzOyAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG5cbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG5cblxuICB2YXIgY2I7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcblxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xuXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cblxuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXG5cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJldHVybiAhIXRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59OyIsInZhciB2MSA9IHJlcXVpcmUoJy4vdjEnKTtcblxudmFyIHY0ID0gcmVxdWlyZSgnLi92NCcpO1xuXG52YXIgdXVpZCA9IHY0O1xudXVpZC52MSA9IHYxO1xudXVpZC52NCA9IHY0O1xubW9kdWxlLmV4cG9ydHMgPSB1dWlkOyIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIHJldHVybiBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ5dGVzVG9VdWlkOyIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBJbiB0aGVcbi8vIGJyb3dzZXIgdGhpcyBpcyBhIGxpdHRsZSBjb21wbGljYXRlZCBkdWUgdG8gdW5rbm93biBxdWFsaXR5IG9mIE1hdGgucmFuZG9tKClcbi8vIGFuZCBpbmNvbnNpc3RlbnQgc3VwcG9ydCBmb3IgdGhlIGBjcnlwdG9gIEFQSS4gIFdlIGRvIHRoZSBiZXN0IHdlIGNhbiB2aWFcbi8vIGZlYXR1cmUtZGV0ZWN0aW9uXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xuXG5pZiAoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8gUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICB2YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICAgIHJldHVybiBybmRzODtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWF0aFJORygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn0iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG5cbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7IC8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxuXG52YXIgX25vZGVJZDtcblxudmFyIF9jbG9ja3NlcTsgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5cblxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwOyAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICB2YXIgYiA9IGJ1ZiB8fCBbXTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7IC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuXG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBybmcoKTtcblxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbc2VlZEJ5dGVzWzBdIHwgMHgwMSwgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1dO1xuICAgIH1cblxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfSAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cblxuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTsgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuXG4gIHZhciBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7IC8vIGB0aW1lX21pZGBcblxuICB2YXIgdG1oID0gbXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmOyAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjsgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG5cbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwOyAvLyBgY2xvY2tfc2VxX2xvd2BcblxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7IC8vIGBub2RlYFxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IGJ5dGVzVG9VdWlkKGIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHYxOyIsInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcblxudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQocm5kcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjQ7IiwidmFyIHNjb3BlID0gdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwgfHwgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZiB8fCB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7IC8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuXG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcblxuZXhwb3J0cy5jbGVhclRpbWVvdXQgPSBleHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbiAoKSB7fTtcblxuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTsgLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5cblxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbiAoaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuXG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dCkgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59OyAvLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5cblxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTsgLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cblxuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlIHx8IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSB8fCB0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUgfHwgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUgfHwgdGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlOyIsInZhciBnOyAvLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuXG5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0oKTtcblxudHJ5IHtcbiAgLy8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG4gIGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG4gIC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufSAvLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZzsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgaWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG4gICAgbW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgbW9kdWxlLnBhdGhzID0gW107IC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXG4gICAgaWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5sO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLmk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG4gIH1cblxuICByZXR1cm4gbW9kdWxlO1xufTsiLCJpbXBvcnQge1xuICBBREQsXG4gIFNVQlRSQUNULFxuICBNVUxUSVBMWSxcbiAgRElWSURFLFxufSBmcm9tICcuLi9zaGFyZWQvY29uc3RhbnRzJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAxLFxuICBzaXplOiA5LFxuICBkaWZmaWN1bHR5OiAnaGFyZCcsXG4gIG9wZXJhdGlvbnM6IFtBREQsIFNVQlRSQUNULCBNVUxUSVBMWSwgRElWSURFXSxcbiAgY2FnZXM6IFtcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzEsIDBdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogRElWSURFLFxuICAgICAgcmVzdWx0OiAyXG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFswLCAxXSxcbiAgICAgICAgWzEsIDFdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogU1VCVFJBQ1QsXG4gICAgICByZXN1bHQ6IDFcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzAsIDJdLFxuICAgICAgICBbMSwgMl0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBESVZJREUsXG4gICAgICByZXN1bHQ6IDNcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzAsIDNdLFxuICAgICAgICBbMSwgM10sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBNVUxUSVBMWSxcbiAgICAgIHJlc3VsdDogNTZcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzAsIDRdLFxuICAgICAgICBbMCwgNV0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBTVUJUUkFDVCxcbiAgICAgIHJlc3VsdDogNFxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbMCwgNl0sXG4gICAgICAgIFsxLCA2XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IEFERCxcbiAgICAgIHJlc3VsdDogMTFcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzAsIDddLFxuICAgICAgICBbMCwgOF0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBESVZJREUsXG4gICAgICByZXN1bHQ6IDJcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzEsIDRdLFxuICAgICAgICBbMiwgNF0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBTVUJUUkFDVCxcbiAgICAgIHJlc3VsdDogMlxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbMSwgNV0sXG4gICAgICAgIFsyLCA1XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IE1VTFRJUExZLFxuICAgICAgcmVzdWx0OiA3MlxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbMiwgNl0sXG4gICAgICAgIFszLCA2XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IERJVklERSxcbiAgICAgIHJlc3VsdDogMlxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbMSwgN10sXG4gICAgICAgIFsyLCA3XSxcbiAgICAgICAgWzMsIDddLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogQURELFxuICAgICAgcmVzdWx0OiAxN1xuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbMSwgOF0sXG4gICAgICAgIFsyLCA4XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IERJVklERSxcbiAgICAgIHJlc3VsdDogM1xuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbMiwgMF0sXG4gICAgICAgIFsyLCAxXSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IFNVQlRSQUNULFxuICAgICAgcmVzdWx0OiA3XG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFsyLCAyXSxcbiAgICAgICAgWzIsIDNdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogTVVMVElQTFksXG4gICAgICByZXN1bHQ6IDI0XG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFszLCAwXSxcbiAgICAgICAgWzQsIDBdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogQURELFxuICAgICAgcmVzdWx0OiAxNFxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbMywgMV0sXG4gICAgICAgIFs0LCAxXSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IE1VTFRJUExZLFxuICAgICAgcmVzdWx0OiAxMlxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbMywgMl0sXG4gICAgICAgIFszLCAzXSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IEFERCxcbiAgICAgIHJlc3VsdDogMTFcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzMsIDRdLFxuICAgICAgICBbMywgNV0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBBREQsXG4gICAgICByZXN1bHQ6IDlcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzMsIDhdLFxuICAgICAgICBbNCwgOF0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBNVUxUSVBMWSxcbiAgICAgIHJlc3VsdDogNTRcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzQsIDJdLFxuICAgICAgICBbNSwgMV0sXG4gICAgICAgIFs1LCAyXSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IE1VTFRJUExZLFxuICAgICAgcmVzdWx0OiA5MFxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbNCwgM10sXG4gICAgICAgIFs0LCA0XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IEFERCxcbiAgICAgIHJlc3VsdDogMTFcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzQsIDVdLFxuICAgICAgICBbNSwgNV0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBESVZJREUsXG4gICAgICByZXN1bHQ6IDNcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzQsIDZdLFxuICAgICAgICBbNCwgN10sXG4gICAgICAgIFs1LCA3XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IE1VTFRJUExZLFxuICAgICAgcmVzdWx0OiAzMjBcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzUsIDBdLFxuICAgICAgICBbNiwgMF0sXG4gICAgICAgIFs2LCAxXSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IEFERCxcbiAgICAgIHJlc3VsdDogMTVcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzUsIDNdLFxuICAgICAgICBbNSwgNF0sXG4gICAgICAgIFs2LCA0XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IE1VTFRJUExZLFxuICAgICAgcmVzdWx0OiAxNlxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbNSwgNl0sXG4gICAgICAgIFs2LCA2XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IFNVQlRSQUNULFxuICAgICAgcmVzdWx0OiA1XG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFs1LCA4XSxcbiAgICAgICAgWzYsIDhdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogQURELFxuICAgICAgcmVzdWx0OiA5XG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFs2LCAyXSxcbiAgICAgICAgWzYsIDNdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogTVVMVElQTFksXG4gICAgICByZXN1bHQ6IDdcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzYsIDVdLFxuICAgICAgICBbNywgNV0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBESVZJREUsXG4gICAgICByZXN1bHQ6IDNcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzYsIDddLFxuICAgICAgICBbNywgNl0sXG4gICAgICAgIFs3LCA3XSxcbiAgICAgICAgWzcsIDhdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogTVVMVElQTFksXG4gICAgICByZXN1bHQ6IDQ1XG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFs3LCAwXSxcbiAgICAgICAgWzgsIDBdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogU1VCVFJBQ1QsXG4gICAgICByZXN1bHQ6IDRcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzcsIDFdLFxuICAgICAgICBbNywgMl0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBTVUJUUkFDVCxcbiAgICAgIHJlc3VsdDogMlxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbNywgM10sXG4gICAgICAgIFs3LCA0XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IEFERCxcbiAgICAgIHJlc3VsdDogMTNcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzgsIDFdLFxuICAgICAgICBbOCwgMl0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBESVZJREUsXG4gICAgICByZXN1bHQ6IDJcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzgsIDNdLFxuICAgICAgICBbOCwgNF0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBTVUJUUkFDVCxcbiAgICAgIHJlc3VsdDogMVxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbOCwgNV0sXG4gICAgICAgIFs4LCA2XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IFNVQlRSQUNULFxuICAgICAgcmVzdWx0OiAzXG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFs4LCA3XSxcbiAgICAgICAgWzgsIDhdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogU1VCVFJBQ1QsXG4gICAgICByZXN1bHQ6IDFcbiAgICB9LFxuICBdLFxuICBzb2x1dGlvbjogW1xuICAgIFsxLCA3LCAzLCA4LCA5LCA1LCA2LCAyLCA0XSxcbiAgICBbMiwgNiwgOSwgNywgMywgOCwgNSwgNCwgMV0sXG4gICAgWzgsIDEsIDQsIDYsIDUsIDksIDIsIDcsIDNdLFxuICAgIFs1LCA0LCA4LCAzLCAyLCA3LCAxLCA2LCA5XSxcbiAgICBbOSwgMywgMiwgNCwgNywgMSwgOCwgNSwgNl0sXG4gICAgWzYsIDksIDUsIDIsIDEsIDMsIDQsIDgsIDddLFxuICAgIFs0LCA1LCA3LCAxLCA4LCA2LCA5LCAzLCAyXSxcbiAgICBbNywgOCwgNiwgOSwgNCwgMiwgMywgMSwgNV0sXG4gICAgWzMsIDIsIDEsIDUsIDYsIDQsIDcsIDksIDhdLFxuICBdXG59XG4iLCJpbXBvcnQge1xuICBBREQsXG4gIFNVQlRSQUNULFxuICBNVUxUSVBMWSxcbiAgRElWSURFLFxufSBmcm9tICcuLi9zaGFyZWQvY29uc3RhbnRzJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAyLFxuICBzaXplOiA5LFxuICBkaWZmaWN1bHR5OiAnaGFyZCcsXG4gIG9wZXJhdGlvbnM6IFtBREQsIFNVQlRSQUNULCBNVUxUSVBMWSwgRElWSURFXSxcbiAgY2FnZXM6IFtcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzEsIDBdLFxuICAgICAgICBbMiwgMF0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBNVUxUSVBMWSxcbiAgICAgIHJlc3VsdDogMTVcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzAsIDFdLFxuICAgICAgICBbMSwgMV0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBESVZJREUsXG4gICAgICByZXN1bHQ6IDJcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzAsIDJdLFxuICAgICAgICBbMSwgMl0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBESVZJREUsXG4gICAgICByZXN1bHQ6IDJcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzAsIDNdLFxuICAgICAgICBbMCwgNF0sXG4gICAgICAgIFswLCA1XSxcbiAgICAgICAgWzAsIDZdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogQURELFxuICAgICAgcmVzdWx0OiAyNVxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbMCwgN10sXG4gICAgICAgIFswLCA4XSxcbiAgICAgICAgWzEsIDhdLFxuICAgICAgICBbMiwgOF0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBNVUxUSVBMWSxcbiAgICAgIHJlc3VsdDogMzIwXG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFsxLCAzXSxcbiAgICAgICAgWzIsIDNdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogQURELFxuICAgICAgcmVzdWx0OiAxMVxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbMSwgNF0sXG4gICAgICAgIFsyLCA0XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IEFERCxcbiAgICAgIHJlc3VsdDogNVxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbMSwgNV0sXG4gICAgICAgIFsyLCA1XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IFNVQlRSQUNULFxuICAgICAgcmVzdWx0OiAxXG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFsxLCA2XSxcbiAgICAgICAgWzEsIDddLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogU1VCVFJBQ1QsXG4gICAgICByZXN1bHQ6IDNcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzIsIDFdLFxuICAgICAgICBbMywgMV0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBNVUxUSVBMWSxcbiAgICAgIHJlc3VsdDogNDVcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzIsIDJdLFxuICAgICAgICBbMywgMl0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBNVUxUSVBMWSxcbiAgICAgIHJlc3VsdDogNDJcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzIsIDZdLFxuICAgICAgICBbMywgNl0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBESVZJREUsXG4gICAgICByZXN1bHQ6IDJcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzIsIDddLFxuICAgICAgICBbMywgN10sXG4gICAgICAgIFszLCA4XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IEFERCxcbiAgICAgIHJlc3VsdDogMTRcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzMsIDBdLFxuICAgICAgICBbNCwgMF0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBNVUxUSVBMWSxcbiAgICAgIHJlc3VsdDogMTRcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzMsIDNdLFxuICAgICAgICBbMywgNF0sXG4gICAgICAgIFs0LCA0XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IE1VTFRJUExZLFxuICAgICAgcmVzdWx0OiA4MFxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbMywgNV0sXG4gICAgICAgIFs0LCA1XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IEFERCxcbiAgICAgIHJlc3VsdDogNVxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbNCwgMV0sXG4gICAgICAgIFs0LCAyXSxcbiAgICAgICAgWzQsIDNdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogQURELFxuICAgICAgcmVzdWx0OiAxMlxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbNCwgNl0sXG4gICAgICAgIFs1LCA2XSxcbiAgICAgICAgWzYsIDZdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogTVVMVElQTFksXG4gICAgICByZXN1bHQ6IDE0XG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFs0LCA3XSxcbiAgICAgICAgWzUsIDddLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogTVVMVElQTFksXG4gICAgICByZXN1bHQ6IDQ1XG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFs0LCA4XSxcbiAgICAgICAgWzUsIDhdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogRElWSURFLFxuICAgICAgcmVzdWx0OiAyXG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFs1LCAwXSxcbiAgICAgICAgWzYsIDBdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogRElWSURFLFxuICAgICAgcmVzdWx0OiAyXG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFs1LCAxXSxcbiAgICAgICAgWzYsIDFdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogQURELFxuICAgICAgcmVzdWx0OiAxM1xuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbNSwgMl0sXG4gICAgICAgIFs2LCAyXSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IFNVQlRSQUNULFxuICAgICAgcmVzdWx0OiAxXG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFs1LCAzXSxcbiAgICAgICAgWzYsIDNdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogU1VCVFJBQ1QsXG4gICAgICByZXN1bHQ6IDFcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzUsIDRdLFxuICAgICAgICBbNSwgNV0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBNVUxUSVBMWSxcbiAgICAgIHJlc3VsdDogMTRcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzYsIDRdLFxuICAgICAgICBbNiwgNV0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBTVUJUUkFDVCxcbiAgICAgIHJlc3VsdDogNlxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbNiwgN10sXG4gICAgICAgIFs2LCA4XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IFNVQlRSQUNULFxuICAgICAgcmVzdWx0OiA1XG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFs3LCAwXSxcbiAgICAgICAgWzcsIDFdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogQURELFxuICAgICAgcmVzdWx0OiAxMVxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbNywgMl0sXG4gICAgICAgIFs4LCAyXSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IERJVklERSxcbiAgICAgIHJlc3VsdDogM1xuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbNywgM10sXG4gICAgICAgIFs4LCAzXSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IE1VTFRJUExZLFxuICAgICAgcmVzdWx0OiAyOFxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbNywgNF0sXG4gICAgICAgIFs4LCA0XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IERJVklERSxcbiAgICAgIHJlc3VsdDogNFxuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbNywgNV0sXG4gICAgICAgIFs4LCA1XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IEFERCxcbiAgICAgIHJlc3VsdDogMTFcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzcsIDZdLFxuICAgICAgICBbOCwgNl0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBTVUJUUkFDVCxcbiAgICAgIHJlc3VsdDogM1xuICAgIH0sXG4gICAge1xuICAgICAgc3F1YXJlczogW1xuICAgICAgICBbNywgN10sXG4gICAgICAgIFs3LCA4XSxcbiAgICAgIF0sXG4gICAgICBvcGVyYXRpb246IFNVQlRSQUNULFxuICAgICAgcmVzdWx0OiAxXG4gICAgfSxcbiAgICB7XG4gICAgICBzcXVhcmVzOiBbXG4gICAgICAgIFs4LCAwXSxcbiAgICAgICAgWzgsIDFdLFxuICAgICAgXSxcbiAgICAgIG9wZXJhdGlvbjogU1VCVFJBQ1QsXG4gICAgICByZXN1bHQ6IDVcbiAgICB9LFxuICAgIHtcbiAgICAgIHNxdWFyZXM6IFtcbiAgICAgICAgWzgsIDddLFxuICAgICAgICBbOCwgOF0sXG4gICAgICBdLFxuICAgICAgb3BlcmF0aW9uOiBTVUJUUkFDVCxcbiAgICAgIHJlc3VsdDogMVxuICAgIH0sXG5cbiAgXSxcbiAgc29sdXRpb246IFtcbiAgICBbNSwgNCwgMSwgMywgNiwgNywgOSwgMiwgOF0sXG4gICAgWzEsIDgsIDIsIDYsIDMsIDksIDQsIDcsIDVdLFxuICAgIFszLCA5LCA3LCA1LCAyLCA4LCA2LCAxLCA0XSxcbiAgICBbNywgNSwgNiwgMiwgOCwgMSwgMywgNCwgOV0sXG4gICAgWzIsIDMsIDgsIDEsIDUsIDQsIDcsIDksIDZdLFxuICAgIFs4LCA2LCA0LCA5LCA3LCAyLCAxLCA1LCAzXSxcbiAgICBbNCwgNywgNSwgOCwgOSwgMywgMiwgNiwgMV0sXG4gICAgWzksIDIsIDMsIDQsIDEsIDYsIDUsIDgsIDddLFxuICAgIFs2LCAxLCA5LCA3LCA0LCA1LCA4LCAzLCAyXSxcbiAgXVxufSIsImltcG9ydCBwMSBmcm9tICcuL3B1enpsZV8wMS5qcydcbmltcG9ydCBwMiBmcm9tICcuL3B1enpsZV8wMi5qcydcblxuZXhwb3J0IGRlZmF1bHQgW1xuXHRwMSxcblx0cDIsXG5dIiwiaW1wb3J0IHJlbW90ZWRldiBmcm9tICdyZW1vdGVkZXYnXG5pbXBvcnQge1xuICB1bnByb3RlY3QsXG4gIGFwcGx5U25hcHNob3QsXG4gIGdldFNuYXBzaG90XG59IGZyb20gJ21vYngtc3RhdGUtdHJlZSdcbmltcG9ydCB7IGNvbm5lY3RSZWR1eERldnRvb2xzIH0gZnJvbSAnbXN0LW1pZGRsZXdhcmVzJ1xuaW1wb3J0IExSVUNhY2hlIGZyb20gJy4vc2hhcmVkL2xydV9jYWNoZSdcbmltcG9ydCAnLi9zaGFyZWQvc3BvdGxpZ2h0J1xuaW1wb3J0IFNwb3RsaWdodCBmcm9tICcuL3NoYXJlZC9zcG90bGlnaHQnXG5cbmxldCBkZXZGbGFnID0gZmFsc2VcbmV4cG9ydCBjb25zdCBhY3RpdmF0ZURldkZsYWcgPSAoKSA9PiBkZXZGbGFnID0gdHJ1ZVxuXG5leHBvcnQgY29uc3Qgc2V0dXBEZXYgPSAoZ2FtZSkgPT4ge1xuICBpZiAoIWRldkZsYWcpIHJldHVyblxuXG4gIGNvbm5lY3RSZWR1eERldnRvb2xzKHJlbW90ZWRldiwgZ2FtZS5nYW1lU3RvcmUpXG4gIHVucHJvdGVjdChnYW1lLmdhbWVTdG9yZSlcbiAgc2V0dXBQYWxldHRlKClcblxuICB3aW5kb3cuZ3MgPSBnYW1lLmdhbWVTdG9yZVxuICB3aW5kb3cubHJ1ID0gTFJVQ2FjaGVcbiAgd2luZG93LmdldFNuYXAgPSBnZXRTbmFwc2hvdFxuICB3aW5kb3cuYXBwbHlTbmFwID0gYXBwbHlTbmFwc2hvdFxufVxuXG5leHBvcnQgY29uc3QgZGV2TG9nID0gKC4uLmFyZ3MpID0+IHtcbiAgaWYgKCFkZXZGbGFnKSByZXR1cm5cbiAgY29uc29sZS5sb2coLi4uYXJncylcbn1cblxuZnVuY3Rpb24gc2V0dXBQYWxldHRlKCkge1xuICBjb25zdCBDT0xPUlMgPSBbXG4gICAgJ2xpZ2h0LWJyaWNrLTEnLFxuICAgICdsaWdodC1icmljay0yJyxcbiAgICAnbGlnaHQtYnJpY2stMycsXG4gICAgJ2xpZ2h0LWJyaWNrLTQnLFxuICAgICdsaWdodC1icmljay01JyxcbiAgICAnbGlnaHQtYnJpY2stNicsXG4gICAgJ2xpZ2h0LWJyaWNrLTcnLFxuICAgICdicmljay0xJyxcbiAgICAnYnJpY2stMicsXG4gICAgJ3Zpb2xldC0xJyxcbiAgICAndmlvbGV0LTInLFxuICAgICd2aW9sZXQtMycsXG4gICAgJ3Zpb2xldC00JyxcbiAgICAnbGlnaHQtb2NlYW4tMScsXG4gICAgJ2xpZ2h0LW9jZWFuLTInLFxuICAgICdsaWdodC1vY2Vhbi0yLXRyYW5zcGFyZW50JyxcbiAgICAnbGlnaHQtb2NlYW4tMi1zZW1pLXRyYW5zcGFyZW50JyxcbiAgICAnbGlnaHQtb2NlYW4tMycsXG4gICAgJ2xpZ2h0LW9jZWFuLTQnLFxuICAgICdsaWdodC1vY2Vhbi01JyxcbiAgICAnb2NlYW4tMScsXG4gICAgJ29jZWFuLTInLFxuICAgICdvY2Vhbi0yLXNlbWktdHJhbnNsdWNlbnQnLFxuICAgICdncmV5LW9jZWFuLTEnLFxuICAgICdncmV5LW9jZWFuLTInLFxuICAgICdncmV5LW9jZWFuLTMnLFxuICAgICdncmV5LW9jZWFuLTQnLFxuICAgICdncmV5LW9jZWFuLTUnLFxuICAgICdncmV5LW9jZWFuLTYnLFxuICAgICdncmVlbi0xJyxcbiAgICAnZ3JlZW4tMS10cmFuc3BhcmVudCcsXG4gICAgJ2dyZWVuLTInLFxuICAgICdncmVlbi0zJyxcbiAgICAnZ3JlZW4tNCcsXG4gICAgJ2NyZWFtLTEnLFxuICAgICdjcmVhbS0yJyxcbiAgICAnY3JlYW0tMycsXG4gICAgJ2NyZWFtLTQnLFxuICAgICdjcmVhbS01JyxcbiAgICAnY3JlYW0tNicsXG4gICAgJ2NyZWFtLTcnLFxuICAgICdjcmVhbS04JyxcbiAgICAnY2FwcHVjY2luby0xJyxcbiAgICAnY2FwcHVjY2luby0yJyxcbiAgICAnY2FwcHVjY2luby0zJyxcbiAgXVxuXG4gIGNvbnN0IHRvZ2dsZVBhbGV0dGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKVxuICB0b2dnbGVQYWxldHRlLmlubmVyVGV4dCA9ICdUb2dnbGUgUGFsZXR0ZSdcblxuICBjb25zdCBwYWxldHRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VjdGlvbicpXG4gIHBhbGV0dGUuY2xhc3NOYW1lID0gJ2hpZGRlbidcbiAgcGFsZXR0ZS5pZCA9ICdjb2xvci1wYWxldHRlJ1xuXG4gIENPTE9SUy5mb3JFYWNoKGNvbG9yID0+IHtcbiAgICBsZXQgY29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGNvbG9yRGl2LmNsYXNzTmFtZSA9IGBjb2xvci1kaXYgJHtjb2xvcn1gXG5cbiAgICBsZXQgY29sb3JMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgIGNvbG9yTGFiZWwuY2xhc3NOYW1lID0gYGNvbG9yLWxhYmVsYFxuICAgIGNvbG9yTGFiZWwuaW5uZXJUZXh0ID0gY29sb3JcbiAgICBjb2xvckRpdi5hcHBlbmRDaGlsZChjb2xvckxhYmVsKVxuXG4gICAgcGFsZXR0ZS5hcHBlbmRDaGlsZChjb2xvckRpdilcbiAgfSlcblxuICBsZXQgdGVzdERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIHRlc3REaXYuY2xhc3NOYW1lID0gYGNvbG9yLWRpdiBicmljay0xYFxuXG4gIGxldCBjb2xvckxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gIGNvbG9yTGFiZWwuY2xhc3NOYW1lID0gYGNvbG9yLWxhYmVsYFxuICBjb2xvckxhYmVsLmlubmVyVGV4dCA9ICd0ZXN0RGl2J1xuICB0ZXN0RGl2LmFwcGVuZENoaWxkKGNvbG9yTGFiZWwpXG4gIHBhbGV0dGUuYXBwZW5kQ2hpbGQodGVzdERpdilcbiAgdGVzdERpdi5vbmNsaWNrID0gKCkgPT4gdGVzdERpdi5jbGFzc0xpc3QudG9nZ2xlKCd0ZXN0LWNvbG9yLWRpdicpXG5cbiAgdG9nZ2xlUGFsZXR0ZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBwYWxldHRlLmNsYXNzTGlzdC50b2dnbGUoJ2hpZGRlbicpXG4gIH0pXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kKHRvZ2dsZVBhbGV0dGUsIHBhbGV0dGUpXG59XG5cbiIsImltcG9ydCAnLi4vc3R5bGVzL2luZGV4LnNjc3MnXG5pbXBvcnQgeyBnZXROZXdFbnYgfSBmcm9tICcuL3NldHVwL3NldHVwX2VudidcbmltcG9ydCBzZXR1cERPTSBmcm9tICcuL3NldHVwL3NldHVwX2RvbSdcbmltcG9ydCBzZXR1cEdhbWUgZnJvbSAnLi9zZXR1cC9zZXR1cF9nYW1lJ1xuaW1wb3J0IHsgYWN0aXZhdGVEZXZGbGFnLCBzZXR1cERldiB9IGZyb20gJy4vZGV2J1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgYWN0aXZhdGVEZXZGbGFnKClcbn1cblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGFzeW5jICgpID0+IHtcbiAgY29uc3QgZW52ID0gYXdhaXQgZ2V0TmV3RW52KClcbiAgY29uc3QgZWxlbWVudHMgPSBzZXR1cERPTShlbnYpXG4gIGNvbnN0IGdhbWVTdG9yZSA9IGF3YWl0IHNldHVwR2FtZSh7IGVudiwgZWxlbWVudHMgfSlcbiAgc2V0dXBEZXYoeyBlbnYsIGVsZW1lbnRzLCBnYW1lU3RvcmUgfSlcbn0pIiwiaW1wb3J0IHsgZXh0cmFjdFBvc0Zyb21TcXVhcmUgfSBmcm9tICcuLi8uLi9zaGFyZWQvZG9tX3V0aWwnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1vdW50Q2xpY2tMaXN0ZW5lcnMoe1xuICBnYW1lU3RvcmUsXG4gIGVsZW1lbnRzOiB7XG4gICAgcHV6emxlRWxlLFxuICAgIGluZm9FbGVcbiAgfVxufSkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgIGlmIChcbiAgICAgICFlLnBhdGguaW5jbHVkZXMocHV6emxlRWxlKVxuICAgICAgJiYgIWUucGF0aC5pbmNsdWRlcyhpbmZvRWxlKVxuICAgICkge1xuICAgICAgZ2FtZVN0b3JlLmNsZWFyRm9jdXMoKVxuICAgICAgZ2FtZVN0b3JlLnVpLmNsZWFyU2VsZWN0ZWRTcXVhcmVzKClcbiAgICB9XG4gIH0pXG5cbiAgcHV6emxlRWxlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgY29uc3Qgc3F1YXJlID0gZS50YXJnZXQuY2xvc2VzdCgnLnNxdWFyZScpXG4gICAgaWYgKCFzcXVhcmUpIHJldHVyblxuXG4gICAgY29uc3Qgc3F1YXJlSWQgPSBzcXVhcmUuZGF0YXNldC5pZFxuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICBnYW1lU3RvcmUudWkuc2VsZWN0VGhyb3VnaFNxdWFyZShzcXVhcmVJZClcbiAgICB9IGVsc2UgaWYgKGUubWV0YUtleSkge1xuICAgICAgZ2FtZVN0b3JlLnVpLnRvZ2dsZVNlbGVjdGVkU3F1YXJlKHNxdWFyZUlkKVxuICAgIH0gZWxzZSB7XG4gICAgICBnYW1lU3RvcmUuc2VsZWN0U3F1YXJlQnlJZChzcXVhcmVJZClcbiAgICB9XG4gIH0pXG59IiwiaW1wb3J0IHsgQVJST1dfUkVHRVgsIE5VTV9SRUdFWCwgTEVGVF9PUl9SSUdIVF9SRUdFWCB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMnXG5pbXBvcnQge1xuICBnZXREaXJGcm9tQ29kZSxcbiAgZ2V0TnVtRnJvbUNvZGUsXG4gIHN0cmluZ1N3aXRjaCxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2dlbmVyYWxfdXRpbCdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbW91bnRLZXlib2FyZExpc3RlbmVycyh7IGdhbWVTdG9yZSB9KSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBlID0+IHtcbiAgICBpZiAoIWdhbWVTdG9yZS51aS5jdXJTcXVhcmUpIHJldHVyblxuXG4gICAgc3RyaW5nU3dpdGNoKGUuY29kZSwgKHsgX2Nhc2UsIF9lbnN1cmUgfSkgPT4ge1xuICAgICAgX2Nhc2UoIWUubWV0YUtleSwgIWUuY3RybEtleSwgL15BbHQvLCAoKSA9PlxuICAgICAgICBnYW1lU3RvcmUuYmVnaW5TdGFnaW5nKCkpXG4gICAgICBfY2FzZSghZS5hbHRLZXksIGUuY3RybEtleSwgTlVNX1JFR0VYLCAoKSA9PlxuICAgICAgICBnYW1lU3RvcmUudG9nZ2xlRm9jdXNlZFNxdWFyZVBvc3NpYmlsaXR5KGdldE51bUZyb21Db2RlKGUuY29kZSkpKVxuICAgICAgX2Nhc2UoIWUuYWx0S2V5LCBlLnNoaWZ0S2V5LCBOVU1fUkVHRVgsICgpID0+XG4gICAgICAgIGdhbWVTdG9yZS50b2dnbGVGaWx0ZXJQb3NzaWJpbGl0eShnZXROdW1Gcm9tQ29kZShlLmNvZGUpKSlcbiAgICAgIF9jYXNlKCFlLmFsdEtleSwgTlVNX1JFR0VYLCAoKSA9PlxuICAgICAgICBnYW1lU3RvcmUuc2V0Rm9jdXNlZFNxdWFyZShnZXROdW1Gcm9tQ29kZShlLmNvZGUpKSlcbiAgICAgIF9jYXNlKGUuYWx0S2V5LCBOVU1fUkVHRVgsICgpID0+XG4gICAgICAgIGdhbWVTdG9yZS50b2dnbGVTdGFnZWRQb3NzaWJpbGl0eShnZXROdW1Gcm9tQ29kZShlLmNvZGUpKSlcbiAgICAgIF9jYXNlKCFlLmFsdEtleSwgIWUuc2hpZnRLZXksIEFSUk9XX1JFR0VYLCAoKSA9PlxuICAgICAgICBnYW1lU3RvcmUuc2VsZWN0U3F1YXJlQnlEaXIoZ2V0RGlyRnJvbUNvZGUoZS5jb2RlKSkpXG4gICAgICBfY2FzZShlLmN0cmxLZXksIFsnRGVsZXRlJywgJ0JhY2tzcGFjZSddLCAoKSA9PlxuICAgICAgICBnYW1lU3RvcmUucmVzZXRGb2N1c2VkU3F1YXJlUG9zc2liaWxpdGllcygpKVxuICAgICAgX2Nhc2UoZS5zaGlmdEtleSwgWydEZWxldGUnLCAnQmFja3NwYWNlJ10sICgpID0+XG4gICAgICAgIGdhbWVTdG9yZS5jbGVhckZpbHRlcigpKVxuICAgICAgX2Nhc2UoIWUuYWx0S2V5LCBbJ0RlbGV0ZScsICdCYWNrc3BhY2UnXSwgKCkgPT5cbiAgICAgICAgZ2FtZVN0b3JlLmNsZWFyRm9jdXNlZFNxdWFyZSgpKVxuICAgICAgX2Nhc2UoZS5hbHRLZXksIFsnRGVsZXRlJywgJ0JhY2tzcGFjZSddLCAoKSA9PlxuICAgICAgICBnYW1lU3RvcmUuY2xlYXJTdGFnZWRQb3NzaWJpbGl0aWVzKCkpXG4gICAgICBfY2FzZSghZS5hbHRLZXksIGUuc2hpZnRLZXksIExFRlRfT1JfUklHSFRfUkVHRVgsICgpID0+XG4gICAgICAgIGdhbWVTdG9yZS51aS5jaGFuZ2VGaWx0ZXJNb2RlQnlEaXIoZ2V0RGlyRnJvbUNvZGUoZS5jb2RlKSkpXG4gICAgICBfY2FzZSgnS2V5QScsICgpID0+IGdhbWVTdG9yZS51aS5zZXRGaWx0ZXJNb2RlKCdhbmQnKSlcbiAgICAgIF9jYXNlKCdLZXlFJywgKCkgPT4gZ2FtZVN0b3JlLnVpLnNldEZpbHRlck1vZGUoJ25vdCcpKVxuICAgICAgX2Nhc2UoJ0tleU8nLCAoKSA9PiBnYW1lU3RvcmUudWkuc2V0RmlsdGVyTW9kZSgnb3InKSlcbiAgICAgIF9lbnN1cmUoKCkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZSA9PiB7XG4gICAgc3RyaW5nU3dpdGNoKGUuY29kZSwgKHsgX2Nhc2UsIF9lbnN1cmUgfSkgPT4ge1xuICAgICAgX2Nhc2UoW2UubWV0YUtleSwgZS5jdHJsS2V5XSwgJ0tleVonLCAoKSA9PiB7XG4gICAgICAgIGdhbWVTdG9yZS51bmRvKClcbiAgICAgIH0pXG4gICAgICBfY2FzZShbZS5tZXRhS2V5LCBlLmN0cmxLZXldLCAnS2V5WScsICgpID0+IHtcbiAgICAgICAgZ2FtZVN0b3JlLnJlZG8oKVxuICAgICAgfSlcbiAgICAgIF9lbnN1cmUoKCkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGUgPT4ge1xuICAgIGlmIChlLmtleSA9PT0gJ0FsdCcpIHtcbiAgICAgIGdhbWVTdG9yZS5zdG9wU3RhZ2luZygpXG4gICAgfVxuICB9KVxufSIsImltcG9ydCB7IElDT05TIH0gZnJvbSBcIi4uL3NoYXJlZC9jb25zdGFudHNcIlxuaW1wb3J0IHsga2ViYWJUb0NhbWVsIH0gZnJvbSBcIi4uL3NoYXJlZC9nZW5lcmFsX3V0aWxcIlxuaW1wb3J0IHsgZ2V0VGVtcGxhdGVCeUlkIH0gZnJvbSAnLi4vc2hhcmVkL2RvbV91dGlsJ1xuaW1wb3J0IHsgZ2V0SGVhZGVyRWxlbWVudHMgfSBmcm9tICcuLi92aWV3cy9oZWFkZXJfdmlldydcbmltcG9ydCB7IGdldE9wdGlvbnNFbGVtZW50cyB9IGZyb20gJy4uL3ZpZXdzL29wdGlvbnNfdmlldydcbmltcG9ydCB7IGdldENvbGxlY3Rpb25JbmZvRWxlbWVudHMgfSBmcm9tICcuLi92aWV3cy9pbmZvX2NvbGxlY3Rpb25fdmlldydcbmltcG9ydCB7IGdldFNxdWFyZUluZm9FbGVtZW50cyB9IGZyb20gJy4uL3ZpZXdzL2luZm9fc3F1YXJlX3ZpZXcnXG5pbXBvcnQgeyBnZXRTcXVhcmVFbGVtZW50LCBnZXRTcXVhcmVFbGVtZW50c0Zyb21JZCB9IGZyb20gJy4uL3ZpZXdzL3NxdWFyZV92aWV3J1xuaW1wb3J0IHsgZGV2TG9nIH0gZnJvbSBcIi4uL2RldlwiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwRE9NKHsgZ2xvYmFscywgdGVtcGxhdGVzIH0pIHtcbiAgc2V0dXBPcHRpb25zKHRlbXBsYXRlcylcbiAgc2V0dXBTcXVhcmVUZW1wbGF0ZShnbG9iYWxzLCB0ZW1wbGF0ZXMpXG4gIHNldHVwU3F1YXJlUG9zc2liaWxpdGllcyhnbG9iYWxzLCB0ZW1wbGF0ZXMpXG4gIHNldHVwRmlsdGVyUG9zc2liaWxpdGllcyhnbG9iYWxzLCB0ZW1wbGF0ZXMpXG4gIHNldHVwTGFiZWxzKHRlbXBsYXRlcylcbiAgc2V0dXBJY29ucygpXG4gIHNldHVwTG9jYWxpemF0aW9ucygpXG5cbiAgcmV0dXJuIGdldEVsZW1lbnRzKClcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudHMoKSB7XG4gIHJldHVybiB7XG4gICAgcHV6emxlRWxlOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucHV6emxlJyksXG4gICAgaW5mb0VsZTogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmluZm8tYm94JyksXG4gICAgc3F1YXJlSW5mb0VsZTogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNxdWFyZS1pbmZvJyksXG4gICAgY29sbGVjdGlvbkluZm9FbGU6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb2xsZWN0aW9uLWluZm8nKSxcbiAgICBoZWFkZXJFbGU6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5oZWFkZXInKSxcbiAgICBzcXVhcmVJbmZvRWxlczogZ2V0U3F1YXJlSW5mb0VsZW1lbnRzKCksXG4gICAgY29sbGVjdGlvbkluZm9FbGVzOiBnZXRDb2xsZWN0aW9uSW5mb0VsZW1lbnRzKCksXG4gICAgaGVhZGVyRWxlczogZ2V0SGVhZGVyRWxlbWVudHMoKSxcbiAgICBvcHRpb25zRWxlczogZ2V0T3B0aW9uc0VsZW1lbnRzKCksXG4gICAgc3F1YXJlRWxlOiBnZXRTcXVhcmVFbGVtZW50LFxuICAgIHNxdWFyZUVsZXM6IGdldFNxdWFyZUVsZW1lbnRzRnJvbUlkLFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldHVwSWNvbnMoKSB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2knKS5mb3JFYWNoKGljb24gPT4ge1xuICAgIGljb24uY2xhc3NOYW1lID0gSUNPTlNba2ViYWJUb0NhbWVsKGljb24uY2xhc3NOYW1lKV1cbiAgfSlcbn1cblxuZnVuY3Rpb24gc2V0dXBTcXVhcmVUZW1wbGF0ZShnbG9iYWxzLCB0ZW1wbGF0ZXMpIHtcbiAgY29uc3QgbW9kZWxQb3NzaWJpbGl0eSA9IHRlbXBsYXRlcy5zcXVhcmUucXVlcnlTZWxlY3RvcignLnNxdWFyZV9wb3NzaWJpbGl0eScpXG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZ2xvYmFscy5zaXplOyBpKyspIHtcbiAgICBjb25zdCBwb3NzaWJpbGl0eSA9IG1vZGVsUG9zc2liaWxpdHkuY2xvbmVOb2RlKHRydWUpXG4gICAgcG9zc2liaWxpdHkuZGF0YXNldC52YWwgPSBpXG4gICAgcG9zc2liaWxpdHkuaW5uZXJUZXh0ID0gaVxuICAgIG1vZGVsUG9zc2liaWxpdHkuYmVmb3JlKHBvc3NpYmlsaXR5KVxuICB9XG5cbiAgbW9kZWxQb3NzaWJpbGl0eS5yZW1vdmUoKVxufVxuXG5mdW5jdGlvbiBzZXR1cFNxdWFyZVBvc3NpYmlsaXRpZXMoZ2xvYmFscywgdGVtcGxhdGVzKSB7XG4gIGNvbnN0IHNxdWFyZVBvc3NpYmlsaXRpZXMgPSBuZXcgRG9jdW1lbnRGcmFnbWVudCgpXG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZ2xvYmFscy5zaXplOyBpKyspIHtcbiAgICBjb25zdCBwb3NzaWJpbGl0eSA9IHRlbXBsYXRlcy5zcXVhcmVJbmZvUG9zc2liaWxpdHkuY2xvbmVOb2RlKHRydWUpXG4gICAgcG9zc2liaWxpdHkuZGF0YXNldC52YWwgPSBpXG4gICAgcG9zc2liaWxpdHkucXVlcnlTZWxlY3RvcignLnNxdWFyZS1pbmZvX3Bvc3NpYmlsaXR5LXZhbCcpLmlubmVyVGV4dCA9IGlcbiAgICBzcXVhcmVQb3NzaWJpbGl0aWVzLmFwcGVuZENoaWxkKHBvc3NpYmlsaXR5KVxuICB9XG5cbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNxdWFyZS1pbmZvJylcbiAgICAucHJlcGVuZChzcXVhcmVQb3NzaWJpbGl0aWVzKVxufVxuXG5mdW5jdGlvbiBzZXR1cEZpbHRlclBvc3NpYmlsaXRpZXMoZ2xvYmFscywgdGVtcGxhdGVzKSB7XG4gIGNvbnN0IGZpbHRlclBvc3NpYmlsaXRpZXMgPSBuZXcgRG9jdW1lbnRGcmFnbWVudCgpXG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZ2xvYmFscy5zaXplOyBpKyspIHtcbiAgICBjb25zdCBwb3NzaWJpbGl0eSA9IHRlbXBsYXRlcy5maWx0ZXJQb3NzaWJpbGl0eS5jbG9uZU5vZGUodHJ1ZSlcbiAgICBwb3NzaWJpbGl0eS5kYXRhc2V0LnZhbCA9IGlcbiAgICBwb3NzaWJpbGl0eS5xdWVyeVNlbGVjdG9yKCcuZmlsdGVyLXBvc3NpYmlsaXR5X3ZhbCcpLmlubmVyVGV4dCA9IGlcbiAgICBmaWx0ZXJQb3NzaWJpbGl0aWVzLmFwcGVuZENoaWxkKHBvc3NpYmlsaXR5KVxuICB9XG5cbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZpbHRlci1wb3NzaWJpbGl0aWVzJylcbiAgICAucHJlcGVuZChmaWx0ZXJQb3NzaWJpbGl0aWVzKVxufVxuXG5mdW5jdGlvbiBzZXR1cExvY2FsaXphdGlvbnMoKSB7XG4gIGNvbnN0IG1ldGFLZXkgPSB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtLnN0YXJ0c1dpdGgoJ1dpbicpID8gJ+KMgycgOiAn4oyYJ1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaGVhZGVyLXVuZG8gLmtleWJvYXJkJykuaW5uZXJUZXh0ID0gYCR7bWV0YUtleX16YFxuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaGVhZGVyLXJlZG8gLmtleWJvYXJkJykuaW5uZXJUZXh0ID0gYCR7bWV0YUtleX15YFxufVxuXG5mdW5jdGlvbiBzZXR1cExhYmVscyh0ZW1wbGF0ZXMpIHtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmluZm8tYm94JykucHJlcGVuZChcbiAgICBjcmVhdGVMYWJlbCh0ZW1wbGF0ZXMuaW5mb0xhYmVsLCB7XG4gICAgICB0ZXh0OiAnU3F1YXJlJyxcbiAgICAgIGlkOiAnc3F1YXJlLWxhYmVsJ1xuICAgIH0pLFxuICAgIGNyZWF0ZUxhYmVsKHRlbXBsYXRlcy5pbmZvTGFiZWwsIHtcbiAgICAgIHRleHQ6ICdDYWdlJyxcbiAgICAgIGlkOiAnY2FnZS1sYWJlbCdcbiAgICB9KSxcbiAgKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMYWJlbCh0ZW1wbGF0ZSwgeyB0ZXh0LCBpZCB9KSB7XG4gIGNvbnN0IGxhYmVsID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpXG4gIGxhYmVsLnNldEF0dHJpYnV0ZSgnaWQnLCBpZClcbiAgbGFiZWwucXVlcnlTZWxlY3RvcigndGV4dCcpLnRleHRDb250ZW50ID0gdGV4dFxuICByZXR1cm4gbGFiZWxcbn1cblxuZnVuY3Rpb24gc2V0dXBPcHRpb25zKHRlbXBsYXRlcykge1xuICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlcy5vcHRpb25cbiAgY29uc3QgdG9nZ2xlVGVtcGxhdGUgPSB0ZW1wbGF0ZXMub3B0aW9uVG9nZ2xlXG4gIGNvbnN0IG51bVRlbXBsYXRlID0gdGVtcGxhdGVzLm9wdGlvbk51bVxuXG4gIGNvbnN0IG9wdGlvbnNEYXRhID0gW1xuICAgIHtcbiAgICAgIGlucHV0SWQ6ICdvcHRpb24tYXV0by1ibG9jaycsXG4gICAgICBpbnB1dFRlbXBsYXRlOiB0b2dnbGVUZW1wbGF0ZSxcbiAgICAgIGluZm9UZXh0OiAnYmxvY2sgY29udHJhZGljdG9yeSBtb3ZlcycsXG4gICAgICBob3ZlclRleHQ6IFwicHJldmVudHMgeW91IGZyb20gZW50ZXJpbmcgYSBudW1iZXIgdGhhdCdzIGVsaW1pbmF0ZWQgYXMgYSBwb3NzaWJpbGl0eVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgaW5wdXRJZDogJ29wdGlvbi1hdXRvLWVsaW0nLFxuICAgICAgaW5wdXRUZW1wbGF0ZTogdG9nZ2xlVGVtcGxhdGUsXG4gICAgICBpbmZvVGV4dDogJ2F1dG8tZWxpbWluYXRlIHBvc3NpYmlsaXRpZXMnLFxuICAgICAgaG92ZXJUZXh0OiBcIndoZW4geW91IGVudGVyIGEgbnVtYmVyLCByZW1vdmUgdGhhdCBudW1iZXIgYXMgYSBwb3NzaWJpbGl0eSBmcm9tIGFsbCB0aGUgc3F1YXJlcyBpbiB0aGUgc2FtZSByb3cgb3IgY29sdW1uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICBpbnB1dElkOiAnb3B0aW9uLWF1dG8tZWxpbS1tYXRoLWltcG9zc2liaWxpdGllcycsXG4gICAgICBpbnB1dFRlbXBsYXRlOiB0b2dnbGVUZW1wbGF0ZSxcbiAgICAgIGluZm9UZXh0OiAnYXV0by1lbGltaW5hdGUgbWF0aGVtYXRpY2FsIGltcG9zc2liaWxpdGllcycsXG4gICAgICBob3ZlclRleHQ6IFwib25seSBjZXJ0YWluIGNvbWJpbmF0aW9ucyBvZiBudW1iZXJzIGNhbiBtYXRoZW1hdGljYWxseSBhcHBlYXIgaW4gYSBjYWdlOyBlbGltaW5hdGUgdGhvc2UgdGhhdCBjYW4ndFwiLFxuICAgIH0sXG4gICAge1xuICAgICAgaW5wdXRJZDogJ29wdGlvbi13YWxrdGhyb3VnaCcsXG4gICAgICBpbnB1dFRlbXBsYXRlOiB0b2dnbGVUZW1wbGF0ZSxcbiAgICAgIGluZm9UZXh0OiAnYWx3YXlzIHNob3cgd2Fsa3Rocm91Z2gnLFxuICAgICAgaG92ZXJUZXh0OiBcImFsd2F5cyBzaG93IHRoZSB3YWxrdGhyb3VnaCB1cG9uIHJlZnJlc2ggb3IgcmV2aXNpdGluZyB0aGlzIHBhZ2VcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIGlucHV0SWQ6ICdvcHRpb24tbWF4LXBvc3NpYmlsaXRpZXMnLFxuICAgICAgaW5wdXRUZW1wbGF0ZTogbnVtVGVtcGxhdGUsXG4gICAgICBpbmZvVGV4dDogJ21heCBwb3NzaWJpbGl0aWVzIHRvIGRpc3BsYXkgaW4gc3F1YXJlJyxcbiAgICAgIGhvdmVyVGV4dDogXCJkb24ndCBkaXNwbGF5IHRoZSBwb3NzaWJpbGl0ZXMgaW4gdGhlIHNxdWFyZSBpdHNlbGYsIHVubGVzcyB5b3UndmUgbmFycm93ZWQgaXQgZG93biB0byB0aGlzIG51bWJlciBvciBsZXNzXCIsXG4gICAgfSxcbiAgXVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25zRGF0YS5tYXAoZGF0YSA9PiBjcmVhdGVPcHRpb24odGVtcGxhdGUsIGRhdGEpKVxuXG4gIGRvY3VtZW50XG4gICAgLnF1ZXJ5U2VsZWN0b3IoJyNoZWFkZXItb3B0aW9ucyAuaGVhZGVyX2Ryb3Bkb3duJylcbiAgICAuYXBwZW5kKC4uLm9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbih0ZW1wbGF0ZSwge1xuICBpbmZvVGV4dCxcbiAgaG92ZXJUZXh0LFxuICBpbnB1dFRlbXBsYXRlLFxuICBpbnB1dElkLFxufSkge1xuICBjb25zdCBvcHRpb24gPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSlcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKVxuICBvcHRpb24ucXVlcnlTZWxlY3RvcignLm9wdGlvbl9pbmZvLXRleHQnKS5pbm5lclRleHQgPSBpbmZvVGV4dFxuICBvcHRpb24ucXVlcnlTZWxlY3RvcignLm9wdGlvbl9ob3Zlci10ZXh0JykuaW5uZXJUZXh0ID0gaG92ZXJUZXh0XG4gIGlucHV0LnNldEF0dHJpYnV0ZSgnaWQnLCBpbnB1dElkKVxuXG4gIG9wdGlvbi5hcHBlbmQoaW5wdXQpXG4gIHJldHVybiBvcHRpb25cbn0iLCJpbXBvcnQgTFJVQ2FjaGUgZnJvbSAnLi4vc2hhcmVkL2xydV9jYWNoZSdcbmltcG9ydCB7IGdldFRlbXBsYXRlQnlJZCB9IGZyb20gJy4uL3NoYXJlZC9kb21fdXRpbCdcbmltcG9ydCBwdXp6bGVzIGZyb20gJy4uL2RhdGEvcHV6emxlcydcbmltcG9ydCB7IGdldEhlYWRlckVsZW1lbnRzIH0gZnJvbSAnLi4vdmlld3MvaGVhZGVyX3ZpZXcnXG5pbXBvcnQgeyBnZXRPcHRpb25zRWxlbWVudHMgfSBmcm9tICcuLi92aWV3cy9vcHRpb25zX3ZpZXcnXG5pbXBvcnQgeyBnZXRDb2xsZWN0aW9uSW5mb0VsZW1lbnRzIH0gZnJvbSAnLi4vdmlld3MvaW5mb19jb2xsZWN0aW9uX3ZpZXcnXG5pbXBvcnQgeyBnZXRTcXVhcmVJbmZvRWxlbWVudHMgfSBmcm9tICcuLi92aWV3cy9pbmZvX3NxdWFyZV92aWV3J1xuaW1wb3J0IHsgZ2V0U3F1YXJlRWxlbWVudCwgZ2V0U3F1YXJlRWxlbWVudHNGcm9tSWQgfSBmcm9tICcuLi92aWV3cy9zcXVhcmVfdmlldydcbmltcG9ydCB7IGRlZmluZUxhenlQcm9wZXJ0aWVzIH0gZnJvbSAnLi4vc2hhcmVkL2dlbmVyYWxfdXRpbCdcbmltcG9ydCB7IGRiR2V0IH0gZnJvbSAnLi4vc2hhcmVkL3N0b3JhZ2VfdXRpbCdcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE5ld0VudigpIHtcbiAgY29uc3QgZW52ID0ge1xuICAgIC4uLmdldFN0YXRpY0VudigpLFxuICAgIC4uLmdldERlZmF1bHREeW5hbWljRW52KCksXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IG9sZEVudiA9IGF3YWl0IGRiR2V0KCdlbnYnKVxuICAgIGNvbnNvbGUubG9nKCdoZXJlJywgb2xkRW52KVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGVudiwgb2xkRW52KVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5sb2coZSlcbiAgICByZXR1cm4gZW52XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0RW52KGVudikge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihlbnYsIGdldERlZmF1bHREeW5hbWljRW52KCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGF0aWNFbnYoKSB7XG4gIHJldHVybiB7XG4gICAgcHV6emxlcyxcbiAgICBnbG9iYWxzOiB7XG4gICAgICBzaXplOiA5LFxuICAgICAgbWlzdGFrZVRpbWVvdXRNczogNjAwLFxuICAgIH0sXG4gICAgdGVtcGxhdGVzOiB7XG4gICAgICBvcHRpb246IGdldFRlbXBsYXRlQnlJZCgnb3B0aW9uLXRlbXBsYXRlJyksXG4gICAgICBvcHRpb25Ub2dnbGU6IGdldFRlbXBsYXRlQnlJZCgnb3B0aW9uLXRvZ2dsZS10ZW1wbGF0ZScpLFxuICAgICAgb3B0aW9uTnVtOiBnZXRUZW1wbGF0ZUJ5SWQoJ29wdGlvbi1udW0tdGVtcGxhdGUnKSxcbiAgICAgIHNxdWFyZTogZ2V0VGVtcGxhdGVCeUlkKCdzcXVhcmUtdGVtcGxhdGUnKSxcbiAgICAgIGNvbWJvOiBnZXRUZW1wbGF0ZUJ5SWQoJ2NvbWJvLXRlbXBsYXRlJyksXG4gICAgICBzcXVhcmVJbmZvUG9zc2liaWxpdHk6IGdldFRlbXBsYXRlQnlJZCgnc3F1YXJlLWluZm9fcG9zc2liaWxpdHktdGVtcGxhdGUnKSxcbiAgICAgIGZpbHRlclBvc3NpYmlsaXR5OiBnZXRUZW1wbGF0ZUJ5SWQoJ2ZpbHRlci1wb3NzaWJpbGl0eS10ZW1wbGF0ZScpLFxuICAgICAgaW5mb0xhYmVsOiBnZXRUZW1wbGF0ZUJ5SWQoJ2luZm8tbGFiZWwtdGVtcGxhdGUnKSxcbiAgICAgIHNwb3RsaWdodDogZ2V0VGVtcGxhdGVCeUlkKCdzcG90bGlnaHQtdGVtcGxhdGUnKSxcbiAgICAgIHNwb3RsaWdodENhcHRpb246IGdldFRlbXBsYXRlQnlJZCgnc3BvdGxpZ2h0LWNhcHRpb24tdGVtcGxhdGUnKSxcbiAgICAgIHB1enpsZUNhcHRpb25Db250ZW50OiBnZXRUZW1wbGF0ZUJ5SWQoJ2NhcHRpb24tY29udGVudC1wdXp6bGUtdGVtcGxhdGUnKSxcbiAgICAgIGNhZ2VDYXB0aW9uQ29udGVudDogZ2V0VGVtcGxhdGVCeUlkKCdjYXB0aW9uLWNvbnRlbnQtY2FnZS10ZW1wbGF0ZScpLFxuICAgICAgaW5mb0NhcHRpb25Db250ZW50OiBnZXRUZW1wbGF0ZUJ5SWQoJ2NhcHRpb24tY29udGVudC1pbmZvLXRlbXBsYXRlJyksXG4gICAgICBzcXVhcmVJbmZvQ2FwdGlvbkNvbnRlbnQ6IGdldFRlbXBsYXRlQnlJZCgnY2FwdGlvbi1jb250ZW50LXNxdWFyZS1pbmZvLXRlbXBsYXRlJyksXG4gICAgICBjb2xsZWN0aW9uSW5mb0NhcHRpb25Db250ZW50OiBnZXRUZW1wbGF0ZUJ5SWQoJ2NhcHRpb24tY29udGVudC1jb2xsZWN0aW9uLWluZm8tdGVtcGxhdGUnKSxcbiAgICAgIGluc3RydWN0aW9uc0NhcHRpb25Db250ZW50OiBnZXRUZW1wbGF0ZUJ5SWQoJ2NhcHRpb24tY29udGVudC1pbnN0cnVjdGlvbnMtdGVtcGxhdGUnKSxcbiAgICB9LFxuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREeW5hbWljRW52KCkge1xuICByZXR1cm4ge1xuICAgIHNuYXBzaG90czoge30sXG4gICAgaGlzdG9yeTogW10sXG4gICAgZnV0dXJlOiBbXSxcbiAgICBwdXp6bGVDYWNoZTogbmV3IExSVUNhY2hlKDUwLCAxMCAqIDYwICogMTAwMCksXG4gIH1cbn1cbiIsImltcG9ydCB7IHNldHVwSGVhZGVyIH0gZnJvbSAnLi4vdmlld3MvaGVhZGVyX3ZpZXcnXG5pbXBvcnQgeyBzZXR1cE9wdGlvbnMgfSBmcm9tICcuLi92aWV3cy9vcHRpb25zX3ZpZXcnXG5pbXBvcnQgeyBzZXR1cENvbGxlY3Rpb25JbmZvIH0gZnJvbSAnLi4vdmlld3MvaW5mb19jb2xsZWN0aW9uX3ZpZXcnXG5pbXBvcnQgeyBzZXR1cFNxdWFyZUluZm8gfSBmcm9tICcuLi92aWV3cy9pbmZvX3NxdWFyZV92aWV3J1xuaW1wb3J0IG1vdW50S2V5Ym9hcmRMaXN0ZW5lcnMgZnJvbSAnLi9saXN0ZW5lcnMva2V5Ym9hcmRfbGlzdGVuZXJzJ1xuaW1wb3J0IG1vdW50Q2xpY2tMaXN0ZW5lcnMgZnJvbSAnLi9saXN0ZW5lcnMvY2xpY2tfbGlzdGVuZXJzJ1xuaW1wb3J0IHsgcmVzZXRQdXp6bGUsIHJlc3RvcmVQdXp6bGUsIHNldHVwUHV6emxlIH0gZnJvbSAnLi9zZXR1cF9wdXp6bGUnXG5pbXBvcnQgd2Fsa3Rocm91Z2ggZnJvbSAnLi93YWxrdGhyb3VnaCdcbmltcG9ydCB7IGFwcGx5U25hcHNob3QsIG9uQWN0aW9uLCBvblNuYXBzaG90IH0gZnJvbSAnbW9ieC1zdGF0ZS10cmVlJ1xuaW1wb3J0IEdhbWUgZnJvbSAnLi4vc3RvcmUvZ2FtZSdcblxuLy8gY29uc3QgUkVTVE9SRV9GTEFHID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdyZXN0b3JlRmxhZycpXG5jb25zdCBSRVNUT1JFX0ZMQUcgPSB0cnVlXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHNldHVwR2FtZSh7IGVudiwgZWxlbWVudHMgfSkge1xuICBjb25zdCBnYW1lU3RvcmUgPSBhd2FpdCBjcmVhdGVHYW1lU3RvcmUoZW52KVxuICBjb25zdCBnYW1lID0geyBnYW1lU3RvcmUsIGVudiwgZWxlbWVudHMgfVxuXG4gIHNldHVwT3B0aW9ucyhnYW1lKVxuICBzZXR1cFNxdWFyZUluZm8oZ2FtZSlcbiAgc2V0dXBDb2xsZWN0aW9uSW5mbyhnYW1lKVxuICBzZXR1cFB1enpsZShnYW1lKVxuXG4gIGlmIChnYW1lU3RvcmUuc3RvcmVkU25hcHNob3QgJiYgZ2FtZVN0b3JlLm9wdGlvbnMud2Fsa3Rocm91Z2gpIHtcbiAgICBhd2FpdCB3YWxrdGhyb3VnaChnYW1lKVxuICB9XG5cbiAgc2V0dXBIZWFkZXIoZ2FtZSlcbiAgbW91bnRDbGlja0xpc3RlbmVycyhnYW1lKVxuICBtb3VudEtleWJvYXJkTGlzdGVuZXJzKGdhbWUpXG5cbiAgaWYgKFJFU1RPUkVfRkxBRykge1xuICAgIGF3YWl0IGdhbWVTdG9yZS5hcHBseVN0b3JlZFNuYXBzaG90KClcbiAgfVxuXG4gIGdhbWVTdG9yZS5hdHRhY2hIb29rcygpXG4gIHJldHVybiBnYW1lU3RvcmVcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlR2FtZVN0b3JlKGVudikge1xuICBjb25zdCBnYW1lU3RvcmUgPSBHYW1lLmNyZWF0ZSh7fSwgZW52KVxuICBpZiAoUkVTVE9SRV9GTEFHKSB7XG4gICAgYXdhaXQgZ2FtZVN0b3JlLnJlc2V0VG9TdG9yZWRTbmFwc2hvdCgpXG4gIH0gZWxzZSB7XG4gICAgZ2FtZVN0b3JlLmluaXRpYWxpemUoKVxuICB9XG5cbiAgcmV0dXJuIGdhbWVTdG9yZVxufSIsImltcG9ydCB7IHJlc2V0RW52IH0gZnJvbSAnLi9zZXR1cF9lbnYnXG5pbXBvcnQgeyBzZXR1cFNxdWFyZXMgfSBmcm9tICcuLi92aWV3cy9zcXVhcmVfdmlldydcblxubGV0IGRpc3Bvc2VyRnVuY1xuXG5leHBvcnQgZnVuY3Rpb24gbmV3UHV6emxlKGdhbWUpIHtcbiAgZGlzcG9zZXJGdW5jPy4oKVxuICBnYW1lLmdhbWVTdG9yZS5uZXdQdXp6bGUoKVxuICByZXNldEVudihnYW1lLmVudilcbiAgZGlzcG9zZXJGdW5jID0gc2V0dXBTcXVhcmVzKGdhbWUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cFB1enpsZShnYW1lKSB7XG4gIGRpc3Bvc2VyRnVuYyA9IHNldHVwU3F1YXJlcyhnYW1lKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRQdXp6bGUoZ2FtZSkge1xuICBnYW1lLmdhbWVTdG9yZS5yZXNldFB1enpsZSgpXG4gIHJlc2V0RW52KGdhbWUuZW52KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZVB1enpsZShnYW1lKSB7XG4gIGRpc3Bvc2VyRnVuYz8uKClcbiAgZGlzcG9zZXJGdW5jID0gc2V0dXBTcXVhcmVzKGdhbWUpXG59IiwiaW1wb3J0IHsgYWRkTm9Gb2N1c0NsaWNrTGlzdGVuZXIsIGNyZWF0ZVNWR0VsZW1lbnQsIGdldFRlbXBsYXRlQnlJZCB9IGZyb20gXCIuLi9zaGFyZWQvZG9tX3V0aWxcIlxuaW1wb3J0IHsgc3RyaW5nU3dpdGNoIH0gZnJvbSBcIi4uL3NoYXJlZC9nZW5lcmFsX3V0aWxcIlxuaW1wb3J0IFNwb3RsaWdodCBmcm9tIFwiLi4vc2hhcmVkL3Nwb3RsaWdodFwiXG5cbmV4cG9ydCBkZWZhdWx0ICh7IGdhbWVTdG9yZSwgZW52LCBlbGVtZW50cyB9KSA9PiB7XG4gIGNvbnN0IGNhcHRpb24gPSBlbnYudGVtcGxhdGVzLnNwb3RsaWdodENhcHRpb24uY2xvbmVOb2RlKHRydWUpXG4gIGNvbnN0IHN2ZyA9IGVudi50ZW1wbGF0ZXMuc3BvdGxpZ2h0LmNsb25lTm9kZSh0cnVlKVxuXG4gIGxldCBjbGVhbnVwID0gKCkgPT4geyB9XG5cbiAgY29uc3Qgc3RlcHMgPSBnZXRTcG90bGlnaHRzKHsgZ2FtZVN0b3JlLCBlbnYsIGVsZW1lbnRzIH0pLm1hcChzcG90bGlnaHQgPT4gKCkgPT4ge1xuICAgIGNsZWFudXAoKVxuXG4gICAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgICAgc3BvdGxpZ2h0LnVwZGF0ZVNWRyh7IGVsZW1lbnQ6IHN2ZywgcmVnZW5lcmF0ZTogdHJ1ZSB9KVxuICAgICAgc3BvdGxpZ2h0LnVwZGF0ZUNhcHRpb24oeyBlbGVtZW50OiBjYXB0aW9uLCByZWdlbmVyYXRlOiBmYWxzZSB9KVxuICAgIH1cblxuICAgIGlmIChzcG90bGlnaHQuY2FwdGlvbkNvbnRlbnQpIHtcbiAgICAgIGNhcHRpb24ucXVlcnlTZWxlY3RvcignLmNhcHRpb24tY29udGVudCcpPy5yZW1vdmUoKVxuICAgICAgY2FwdGlvbi5wcmVwZW5kKHNwb3RsaWdodC5jYXB0aW9uQ29udGVudClcbiAgICB9XG5cbiAgICBjb25zdCBjbGVhbnVwU2hvdyA9IHNwb3RsaWdodC5vblNob3coKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpXG4gICAgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpXG4gICAgICBjbGVhbnVwU2hvdygpXG4gICAgfVxuICAgIC8vIGRlYnVnZ2VyXG4gICAgdXBkYXRlKClcbiAgICBhcHBlbmRJZlJlbW92ZWQoc3ZnLCBjYXB0aW9uKVxuICB9KVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGZpbmlzaCA9ICgpID0+IHtcbiAgICAgIGNsZWFudXAoKVxuICAgICAgc3ZnLnJlbW92ZSgpXG4gICAgICBjYXB0aW9uLnJlbW92ZSgpXG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlkb3duLCB0cnVlKVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuICAgIHN0ZXBzLnB1c2goZmluaXNoKVxuXG4gICAgY29uc3QgeyBuZXh0QnRuLCBwcmV2aW91c0J0biwgZmluaXNoQnRuIH0gPSBnZXRDYXB0aW9uRWxlbWVudHMoY2FwdGlvbilcbiAgICBsZXQgY3VyU3RlcCA9IDBcblxuICAgIGNvbnN0IG5leHQgPSAoKSA9PiBzdGVwc1srK2N1clN0ZXBdKClcblxuICAgIGNvbnN0IHByZXYgPSAoKSA9PiB7XG4gICAgICBpZiAoY3VyU3RlcCA+IDApIHN0ZXBzWy0tY3VyU3RlcF0oKVxuICAgIH1cblxuICAgIGFkZE5vRm9jdXNDbGlja0xpc3RlbmVyKG5leHRCdG4sIG5leHQpXG4gICAgYWRkTm9Gb2N1c0NsaWNrTGlzdGVuZXIocHJldmlvdXNCdG4sIHByZXYpXG4gICAgYWRkTm9Gb2N1c0NsaWNrTGlzdGVuZXIoZmluaXNoQnRuLCBmaW5pc2gpXG5cbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlkb3duKGUpIHtcbiAgICAgIHN0cmluZ1N3aXRjaChlLmNvZGUsICh7IF9jYXNlIH0pID0+IHtcbiAgICAgICAgX2Nhc2UoJ0tleU4nLCBuZXh0KVxuICAgICAgICBfY2FzZSgnS2V5UCcsIHByZXYpXG4gICAgICAgIF9jYXNlKCdLZXlGJywgZmluaXNoKVxuICAgICAgICAvLyBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlkb3duLCB0cnVlKVxuXG4gICAgc3RlcHNbY3VyU3RlcF0oKVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRTcG90bGlnaHRzKHtcbiAgZ2FtZVN0b3JlLFxuICBlbnY6IHtcbiAgICB0ZW1wbGF0ZXM6IHtcbiAgICAgIHB1enpsZUNhcHRpb25Db250ZW50LFxuICAgICAgaW5mb0NhcHRpb25Db250ZW50LFxuICAgICAgc3F1YXJlSW5mb0NhcHRpb25Db250ZW50LFxuICAgICAgY29sbGVjdGlvbkluZm9DYXB0aW9uQ29udGVudCxcbiAgICAgIGluc3RydWN0aW9uc0NhcHRpb25Db250ZW50LFxuICAgIH1cbiAgfSxcbiAgZWxlbWVudHM6IHtcbiAgICBwdXp6bGVFbGUsXG4gICAgaW5mb0VsZSxcbiAgICBzcXVhcmVJbmZvRWxlLFxuICAgIGNvbGxlY3Rpb25JbmZvRWxlLFxuICAgIGhlYWRlckVsZXM6IHtcbiAgICAgIGluc3RydWN0aW9uc0J1dHRvbixcbiAgICAgIGluc3RydWN0aW9uc0Ryb3Bkb3duLFxuICAgIH0sXG4gIH1cbn0pIHtcbiAgY29uc3QgY2FnZVNxdWFyZXMgPSBnZXRDYWdlU3F1YXJlcyhnYW1lU3RvcmUpXG4gIGNvbnN0IHNxdWFyZUVsZSA9IGNhZ2VTcXVhcmVzWzBdXG5cbiAgcmV0dXJuIFtcbiAgICBTcG90bGlnaHQuZnJvbUVsZShwdXp6bGVFbGUsIHtcbiAgICAgIHBhZGRpbmc6IDUsXG4gICAgICBib3JkZXJSYWRpdXM6IDgsXG4gICAgICBjYXB0aW9uQ29udGVudDogcHV6emxlQ2FwdGlvbkNvbnRlbnQuY2xvbmVOb2RlKHRydWUpLFxuICAgIH0pLFxuICAgIFNwb3RsaWdodC5mcm9tRWxlKGluZm9FbGUsIHtcbiAgICAgIHBhZGRpbmc6IHsgZGVmYXVsdDogNiwgbGVmdDogOCB9LFxuICAgICAgYm9yZGVyUmFkaXVzOiA4LFxuICAgICAgYmx1cjogMS41LFxuICAgICAgY2FwdGlvblBvc2l0aW9uOiAnbGVmdCcsXG4gICAgICBjYXB0aW9uT2Zmc2V0WDogJy0xMHB4JyxcbiAgICAgIGNhcHRpb25PZmZzZXRZOiAnNTBweCcsXG4gICAgICBjYXB0aW9uQ29udGVudDogaW5mb0NhcHRpb25Db250ZW50LmNsb25lTm9kZSh0cnVlKSxcbiAgICB9KSxcbiAgICBTcG90bGlnaHQuZnJvbUVsZXMoW3NxdWFyZUVsZSwgc3F1YXJlSW5mb0VsZV0sIHtcbiAgICAgIHBhZGRpbmc6IFswLCB7IGRlZmF1bHQ6IDAsIHRvcDogLTEwLCBib3R0b206IC0yMCB9XSxcbiAgICAgIGJvcmRlclJhZGl1czogMixcbiAgICAgIGJsdXI6IDEsXG4gICAgICBjYXB0aW9uUG9zaXRpb246ICdib3R0b20nLFxuICAgICAgY2FwdGlvbkNvbnRlbnQ6IHNxdWFyZUluZm9DYXB0aW9uQ29udGVudC5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICBvblNob3c6ICgpID0+IHtcbiAgICAgICAgZ2FtZVN0b3JlLnNlbGVjdFNxdWFyZUJ5SWQoc3F1YXJlRWxlLmRhdGFzZXQuaWQpXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgZ2FtZVN0b3JlLmNsZWFyRm9jdXMoKVxuICAgICAgICAgIGdhbWVTdG9yZS51aS5jbGVhclNlbGVjdGVkU3F1YXJlcygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICBTcG90bGlnaHQuZnJvbUVsZXMoWy4uLmNhZ2VTcXVhcmVzLCBjb2xsZWN0aW9uSW5mb0VsZV0sIHtcbiAgICAgIHBhZGRpbmc6IFtcbiAgICAgICAgLi4uQXJyYXkoY2FnZVNxdWFyZXMubGVuZ3RoKS5maWxsKDAuNSksXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBkZWZhdWx0OiAwLFxuICAgICAgICAgIHRvcDogMjYsXG4gICAgICAgICAgYm90dG9tOiAtMTAsXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBib3JkZXJSYWRpdXM6IDIsXG4gICAgICBibHVyOiAxLFxuICAgICAgY2FwdGlvblBvc2l0aW9uOiAnYm90dG9tJyxcbiAgICAgIGNhcHRpb25Db250ZW50OiBjb2xsZWN0aW9uSW5mb0NhcHRpb25Db250ZW50LmNsb25lTm9kZSh0cnVlKSxcbiAgICAgIG9uU2hvdzogKCkgPT4ge1xuICAgICAgICBnYW1lU3RvcmUuc2VsZWN0U3F1YXJlQnlJZChzcXVhcmVFbGUuZGF0YXNldC5pZClcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBnYW1lU3RvcmUuY2xlYXJGb2N1cygpXG4gICAgICAgICAgZ2FtZVN0b3JlLnVpLmNsZWFyU2VsZWN0ZWRTcXVhcmVzKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIFNwb3RsaWdodC5mcm9tRWxlcyhbaW5zdHJ1Y3Rpb25zQnV0dG9uLCBpbnN0cnVjdGlvbnNEcm9wZG93bl0sIHtcbiAgICAgIHBhZGRpbmc6IFt7IHJpZ2h0OiA3LCBib3R0b206IDcsIGRlZmF1bHQ6IDQgfSwgeyBkZWZhdWx0OiA2LCB0b3A6IDQgfV0sXG4gICAgICBib3JkZXJSYWRpdXM6IDgsXG4gICAgICBibHVyOiAyLFxuICAgICAgY2FwdGlvblBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgY2FwdGlvbkNvbnRlbnQ6IGluc3RydWN0aW9uc0NhcHRpb25Db250ZW50LmNsb25lTm9kZSh0cnVlKSxcbiAgICAgIG9uU2hvdzogKCkgPT4ge1xuICAgICAgICBpbnN0cnVjdGlvbnNEcm9wZG93bi5jbGFzc0xpc3QuYWRkKCdzaG93JylcbiAgICAgICAgcmV0dXJuICgpID0+IGluc3RydWN0aW9uc0Ryb3Bkb3duLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKVxuICAgICAgfSxcbiAgICB9KSxcbiAgXVxufVxuXG5mdW5jdGlvbiBnZXRDYXB0aW9uRWxlbWVudHMoY2FwdGlvbkVsZSkge1xuICByZXR1cm4ge1xuICAgIG5leHRCdG46IGNhcHRpb25FbGUucXVlcnlTZWxlY3RvcignI3Nwb3RsaWdodC1uZXh0JyksXG4gICAgcHJldmlvdXNCdG46IGNhcHRpb25FbGUucXVlcnlTZWxlY3RvcignI3Nwb3RsaWdodC1wcmV2aW91cycpLFxuICAgIGZpbmlzaEJ0bjogY2FwdGlvbkVsZS5xdWVyeVNlbGVjdG9yKCcjc3BvdGxpZ2h0LWZpbmlzaCcpLFxuICB9XG59XG5cbmZ1bmN0aW9uIGdldENhZ2VTcXVhcmVzKGdhbWVTdG9yZSkge1xuICBjb25zdCBjb3JuZXJDYWdlID0gZ2FtZVN0b3JlLnB1enpsZS5jYWdlc0FycmF5XG4gICAgLmZpbmQoY2FnZSA9PiBjYWdlLm51bVBvc3NpYmxlUmVwZWF0cyA+IDApXG5cbiAgcmV0dXJuIEFycmF5LmZyb20oY29ybmVyQ2FnZS5zcXVhcmVzLm1hcChzcXVhcmUgPT5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAuc3F1YXJlW2RhdGEtaWQ9XCIke3NxdWFyZS5pZH1cIl1gKVxuICApKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTVkcoKSB7XG4gIHJldHVybiBnZXRUZW1wbGF0ZUJ5SWQoJ3Nwb3RsaWdodC10ZW1wbGF0ZScpLmNsb25lTm9kZSh0cnVlKVxufVxuXG5mdW5jdGlvbiBhcHBlbmRJZlJlbW92ZWQoLi4uZWxlcykge1xuICBjb25zdCByZW1vdmVkRWxlcyA9IGVsZXMuZmlsdGVyKGVsZSA9PiAhZG9jdW1lbnQuYm9keS5jb250YWlucyhlbGUpKVxuICBkb2N1bWVudC5ib2R5LmFwcGVuZCguLi5yZW1vdmVkRWxlcylcbn0iLCJleHBvcnQgY29uc3QgQUREID0gJysnO1xuZXhwb3J0IGNvbnN0IFNVQlRSQUNUID0gJ+KIkic7XG5leHBvcnQgY29uc3QgTVVMVElQTFkgPSAn4qiJJztcbmV4cG9ydCBjb25zdCBESVZJREUgPSAnw7cnO1xuXG5leHBvcnQgY29uc3QgQVJST1dfUkVHRVggPSAvXkFycm93KD88ZGlyPi4qKS9cbmV4cG9ydCBjb25zdCBVUF9PUl9ET1dOX1JFR0VYID0gL15BcnJvdyg/PGRpcj5VcHxEb3duKS9cbmV4cG9ydCBjb25zdCBMRUZUX09SX1JJR0hUX1JFR0VYID0gL15BcnJvdyg/PGRpcj5MZWZ0fFJpZ2h0KS9cbmV4cG9ydCBjb25zdCBOVU1fUkVHRVggPSAvXihEaWdpdHxOdW1wYWQpKD88bnVtPlxcZCkvXG5cbmV4cG9ydCBjb25zdCBJQ09OUyA9IHtcbiAgaW5mbzogJ2ZhcyBmYS1pbmZvLWNpcmNsZScsXG4gIGJhbjogJ2ZhcyBmYS1iYW4nLFxuICBjaXJjbGU6ICdmYXIgZmEtY2lyY2xlJyxcbiAgY2lyY2xlRmlsbGVkOiAnZmFzIGZhLWNpcmNsZScsXG4gIHNxdWFyZTogJ2ZhciBmYS1zcXVhcmUnLFxuICBzbGFzaDogJ2ZhcyBmYS1zbGFzaCcsXG4gIGNsZWFyOiAnZmFzIGZhLWVyYXNlcicsXG4gIHJlc2V0OiAnZmFzIGZhLXVuZG8tYWx0JyxcbiAgc2VsZWN0OiAnZmFyIGZhLWNoZWNrLWNpcmNsZScsXG4gIGNvbmZpcm06ICdmYXMgZmEtY2hlY2stY2lyY2xlJyxcbn0iLCJpbXBvcnQgeyBJQ09OUyB9IGZyb20gXCIuL2NvbnN0YW50c1wiXG5pbXBvcnQgeyBnZW5lcmF0ZUNsYXNzTmFtZSB9IGZyb20gXCIuL2dlbmVyYWxfdXRpbFwiXG5cbmNvbnN0IGNyZWF0ZUJhc2ljSWNvbiA9IChpY29uTmFtZSkgPT4ge1xuICBjb25zdCBpY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpXG4gIGljb24uY2xhc3NOYW1lID0gSUNPTlNbaWNvbk5hbWVdXG4gIHJldHVybiBpY29uXG59XG5cbmNvbnN0IGNyZWF0ZUljb24gPSAoaWNvbk5hbWUsIC4uLmZsYWdzKSA9PiB7XG4gIGNvbnN0IGljb25TcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gIGljb25TcGFuLmFwcGVuZENoaWxkKGNyZWF0ZUJhc2ljSWNvbihpY29uTmFtZSkpXG4gIGljb25TcGFuLmNsYXNzTmFtZSA9IGdlbmVyYXRlQ2xhc3NOYW1lKCdwb3NzaWJpbGl0eS1pY29uJywgZmxhZ3MpXG5cbiAgcmV0dXJuIGljb25TcGFuXG59XG5cbmV4cG9ydCBjb25zdCBiYXNlSWNvbnMgPSAoKSA9PiAoW1xuICBjcmVhdGVJY29uKCdzcXVhcmUnKSxcbl0pXG5cbmV4cG9ydCBjb25zdCBlbGltaW5hdGVkSWNvbnMgPSAoKSA9PiAoW1xuICBjcmVhdGVJY29uKCdzcXVhcmUnLCAnZWxpbWluYXRlZCcpLFxuICBjcmVhdGVJY29uKCdzbGFzaCcsICdzbWFsbCcpLFxuXSlcblxuZXhwb3J0IGNvbnN0IGFsdGVybmF0aXZlSWNvbnMgPSAoKSA9PiAoW1xuICBjcmVhdGVJY29uKCdzcXVhcmUnLCAnYWx0ZXJuYXRpdmUnKSxcbiAgY3JlYXRlSWNvbignc3F1YXJlJywgJ2FsdGVybmF0aXZlLWlubmVyJyksXG5dKVxuXG5leHBvcnQgY29uc3QgcmVxdWlyZWRJY29ucyA9ICgpID0+IChbXG4gIGNyZWF0ZUljb24oJ3NxdWFyZScsICdyZXF1aXJlZCcpLFxuXSkiLCJpbXBvcnQgeyBhcmVFcXVhbEFycmF5cywgZnVuY1N3aXRjaCwgZ2VuZXJhdGVDbGFzc05hbWUsIGdlblN0ZXBwZXIsIHN0cmluZ1N3aXRjaCB9IGZyb20gXCIuL2dlbmVyYWxfdXRpbFwiXG5cbmV4cG9ydCBjb25zdCBleHRyYWN0UG9zRnJvbVNxdWFyZSA9IHNxdWFyZSA9PlxuICBzcXVhcmU/LmRhdGFzZXQucG9zLnNwbGl0KCcsJylcblxuZXhwb3J0IGNvbnN0IG1vdW50RHJvcGRvd24gPSAoYnV0dG9uLCBkcm9wZG93biwgc2hvd0NsYXNzKSA9PiB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XG4gICAgY29uc3Qgb3V0c2lkZURyb3Bkb3duID0gIWRyb3Bkb3duLmNvbnRhaW5zKGUudGFyZ2V0KVxuICAgIGNvbnN0IG9uQnV0dG9uID0gb3V0c2lkZURyb3Bkb3duICYmIGJ1dHRvbi5jb250YWlucyhlLnRhcmdldClcbiAgICBjb25zdCBpc1Nob3dpbmcgPSBkcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoc2hvd0NsYXNzKVxuXG4gICAgaWYgKFxuICAgICAgKGlzU2hvd2luZyAmJiBvdXRzaWRlRHJvcGRvd24pXG4gICAgICB8fCAoIWlzU2hvd2luZyAmJiBvbkJ1dHRvbilcbiAgICApIHtcbiAgICAgIGlmIChpc1Nob3dpbmcpIGJ1dHRvbi5ibHVyKClcbiAgICAgIGRyb3Bkb3duLmNsYXNzTGlzdC50b2dnbGUoc2hvd0NsYXNzKVxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IGFkZE5vRm9jdXNDbGlja0xpc3RlbmVyID0gKGVsZW1lbnQsIGxpc3RlbmVyKSA9PlxuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGUgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGxpc3RlbmVyKGUpXG4gIH0pXG5cbmV4cG9ydCBjb25zdCBnZXRUZW1wbGF0ZU5vZGUgPSAodGVtcGxhdGUsIGZpcnN0Q2hpbGQgPSB0cnVlKSA9PlxuICBmaXJzdENoaWxkID8gdGVtcGxhdGUuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZCA6IHRlbXBsYXRlLmNvbnRlbnRcblxuZXhwb3J0IGNvbnN0IGdldFRlbXBsYXRlQnlJZCA9IChpZCwgZmlyc3RDaGlsZCA9IHRydWUpID0+XG4gIGdldFRlbXBsYXRlTm9kZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksIGZpcnN0Q2hpbGQpXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWl2YWxlbnROb2RlKG5vZGVBLCBub2RlQiwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiAoXG4gICAgbm9kZUEubm9kZU5hbWUgPT09IG5vZGVCLm5vZGVOYW1lXG4gICAgJiYgaGF2ZUVxdWl2YWxlbnRBdHRyaWJ1dGVzKG5vZGVBLCBub2RlQiwgb3B0aW9ucylcbiAgICAmJiBoYXZlRXF1aXZhbGVudENoaWxkcmVuKG5vZGVBLCBub2RlQiwgb3B0aW9ucylcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGF2ZUVxdWl2YWxlbnRDaGlsZHJlbihub2RlT3JMaXN0QSwgbm9kZU9yTGlzdEIsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBjaGlsZHJlbkEgPSBub2RlT3JMaXN0QSBpbnN0YW5jZW9mIE5vZGVcbiAgICA/IEFycmF5LmZyb20obm9kZU9yTGlzdEEuY2hpbGROb2RlcylcbiAgICA6IG5vZGVPckxpc3RBXG4gIGNvbnN0IGNoaWxkcmVuQiA9IG5vZGVPckxpc3RCIGluc3RhbmNlb2YgTm9kZVxuICAgID8gQXJyYXkuZnJvbShub2RlT3JMaXN0Qi5jaGlsZE5vZGVzKVxuICAgIDogbm9kZU9yTGlzdEJcblxuICBpZiAoY2hpbGRyZW5BLmxlbmd0aCAhPT0gY2hpbGRyZW5CLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKGNoaWxkcmVuQS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW5BLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgY2hpbGRBID0gY2hpbGRyZW5BW2ldXG4gICAgICBsZXQgY2hpbGRCID0gY2hpbGRyZW5CW2ldXG5cbiAgICAgIGlmICghaXNFcXVpdmFsZW50Tm9kZShjaGlsZEEsIGNoaWxkQiwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXZlRXF1aXZhbGVudEF0dHJpYnV0ZXMobm9kZUEsIG5vZGVCLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGF0dHJpYnV0ZXNBID0gbm9kZUEuZ2V0QXR0cmlidXRlTmFtZXMoKVxuICBsZXQgYXR0cmlidXRlc0IgPSBub2RlQi5nZXRBdHRyaWJ1dGVOYW1lcygpXG5cbiAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgIGF0dHJpYnV0ZXNBID0gYXR0cmlidXRlc0EuZmlsdGVyKGF0dHIgPT4gb3B0aW9ucy5hdHRyaWJ1dGVzLmluY2x1ZGVzKGF0dHIpKVxuICAgIGF0dHJpYnV0ZXNCID0gYXR0cmlidXRlc0IuZmlsdGVyKGF0dHIgPT4gb3B0aW9ucy5hdHRyaWJ1dGVzLmluY2x1ZGVzKGF0dHIpKVxuICB9XG5cbiAgaWYgKGF0dHJpYnV0ZXNBLmxlbmd0aCAhPT0gYXR0cmlidXRlc0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gYXR0cmlidXRlc0EuZXZlcnkoYXR0ciA9PlxuICAgIG5vZGVBLmdldEF0dHJpYnV0ZShhdHRyKSA9PT0gbm9kZUIuZ2V0QXR0cmlidXRlKGF0dHIpXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuVG9NYXRjaChub2RlQSwgbm9kZU9yTGlzdEIsIGNvbXBhcmF0b3IpIHtcbiAgY29uc3QgY2hpbGRyZW5CID0gbm9kZU9yTGlzdEIgaW5zdGFuY2VvZiBOb2RlXG4gICAgPyBBcnJheS5mcm9tKG5vZGVPckxpc3RCLmNoaWxkcmVuKVxuICAgIDogbm9kZU9yTGlzdEJcbiAgY29uc3QgZ2V0TmV4dEFDaGlsZCA9IGdlblN0ZXBwZXIoQXJyYXkuZnJvbShub2RlQS5jaGlsZHJlbikpXG4gIGNvbnN0IGdldE5leHRCQ2hpbGQgPSBnZW5TdGVwcGVyKGNoaWxkcmVuQilcblxuICBsZXQgY2hpbGRBID0gZ2V0TmV4dEFDaGlsZCgpXG4gIGxldCBjaGlsZEIgPSBnZXROZXh0QkNoaWxkKClcbiAgd2hpbGUgKHR5cGVvZiBjaGlsZEEgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBjaGlsZEIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBjaGlsZEEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBub2RlQS5hcHBlbmQoY2hpbGRCKVxuICAgICAgY2hpbGRCID0gZ2V0TmV4dEJDaGlsZCgpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGRCID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY2hpbGRBLnJlbW92ZSgpXG4gICAgICBjaGlsZEEgPSBnZXROZXh0QUNoaWxkKClcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjb21wYXJhdG9yKGNoaWxkQSwgY2hpbGRCKSkge1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgIGNoaWxkQS5yZW1vdmUoKVxuICAgICAgICAgIGNoaWxkQSA9IGdldE5leHRBQ2hpbGQoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGVzVG9NYXRjaChjaGlsZEEsIGNoaWxkQilcbiAgICAgICAgICBjaGlsZEEgPSBnZXROZXh0QUNoaWxkKClcbiAgICAgICAgICBjaGlsZEIgPSBnZXROZXh0QkNoaWxkKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbm9kZUEuaW5zZXJ0QmVmb3JlKGNoaWxkQi5jbG9uZU5vZGUodHJ1ZSksIGNoaWxkQSlcbiAgICAgICAgICBjaGlsZEIgPSBnZXROZXh0QkNoaWxkKClcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVBdHRyaWJ1dGVzVG9NYXRjaChub2RlQSwgbm9kZUIpIHtcbiAgbm9kZUEuZ2V0QXR0cmlidXRlTmFtZXMoKS5mb3JFYWNoKGF0dHIgPT4ge1xuICAgIGNvbnN0IFt2YWxBLCB2YWxCXSA9IFtub2RlQSwgbm9kZUJdLm1hcChub2RlID0+IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpKVxuICAgIGlmICh2YWxBICE9PSB2YWxCKSBub2RlQS5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsQilcbiAgfSlcbn1cblxuLy8gZnVuY3Rpb24gX2hpZ2hsaWdodEVsZShlbGUsIHtcbi8vICAgcGFkZGluZyA9IDAsXG4vLyAgIHBhZGRpbmdMZWZ0LFxuLy8gICBwYWRkaW5nUmlnaHQsXG4vLyAgIHBhZGRpbmdUb3AsXG4vLyAgIHBhZGRpbmdCb3R0b20sXG4vLyAgIGNhcHRpb25UZW1wbGF0ZSA9IG51bGwsXG4vLyAgIGNhcHRpb25BbmNob3IgPSBbMSwgMF0sXG4vLyAgIGNlbnRlckNhcHRpb24gPSB0cnVlLFxuLy8gICBmdXp6eSA9IHRydWUsXG4vLyAgIHRvcCxcbi8vICAgbGVmdCxcbi8vICAgcmlnaHQsXG4vLyAgIGJvdHRvbSxcbi8vIH0gPSB7fSkge1xuLy8gICBwYWRkaW5nTGVmdCA9IHBhZGRpbmdMZWZ0IHx8IHBhZGRpbmdcbi8vICAgcGFkZGluZ1JpZ2h0ID0gcGFkZGluZ1JpZ2h0IHx8IHBhZGRpbmdcbi8vICAgcGFkZGluZ1RvcCA9IHBhZGRpbmdUb3AgfHwgcGFkZGluZ1xuLy8gICBwYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbSB8fCBwYWRkaW5nXG5cbi8vICAgY29uc3Qge1xuLy8gICAgIHRvcDogZWxlVG9wLFxuLy8gICAgIHJpZ2h0OiBlbGVSaWdodCxcbi8vICAgICBsZWZ0OiBlbGVMZWZ0LFxuLy8gICAgIGJvdHRvbTogZWxlQm90dG9tLFxuLy8gICAgIGhlaWdodDogZWxlSGVpZ2h0LFxuLy8gICAgIHdpZHRoOiBlbGVXaWR0aCxcbi8vICAgfSA9IGVsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4vLyAgIGNvbnN0IHBhZGRlZFRvcCA9IHRvUGl4ZWxzKGVsZVRvcCAtIHBhZGRpbmdUb3ApXG4vLyAgIGNvbnN0IHBhZGRlZFJpZ2h0ID0gdG9QaXhlbHMoZWxlUmlnaHQgKyBwYWRkaW5nUmlnaHQpXG4vLyAgIGNvbnN0IHBhZGRlZEJvdHRvbSA9IHRvUGl4ZWxzKGVsZUJvdHRvbSArIHBhZGRpbmdCb3R0b20pXG4vLyAgIGNvbnN0IHBhZGRlZExlZnQgPSB0b1BpeGVscyhlbGVMZWZ0IC0gcGFkZGluZ0xlZnQpXG4vLyAgIGNvbnN0IHBhZGRlZEhlaWdodCA9IHRvUGl4ZWxzKGVsZUhlaWdodCArIHBhZGRpbmdUb3AgKyBwYWRkaW5nQm90dG9tKVxuLy8gICBjb25zdCBwYWRkZWRXaWR0aCA9IHRvUGl4ZWxzKGVsZVdpZHRoICsgcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQpXG5cbi8vICAgY29uc3QgYWJvdmUgPSB7XG4vLyAgICAgdG9wOiAwLFxuLy8gICAgIGxlZnQ6IDAsXG4vLyAgICAgcmlnaHQ6IDAsXG4vLyAgICAgaGVpZ2h0OiBwYWRkZWRUb3AsXG4vLyAgIH1cblxuLy8gICBjb25zdCBiZWxvdyA9IHtcbi8vICAgICB0b3A6IHBhZGRlZEJvdHRvbSxcbi8vICAgICBsZWZ0OiAwLFxuLy8gICAgIHJpZ2h0OiAwLFxuLy8gICAgIGJvdHRvbTogMCxcbi8vICAgfVxuXG4vLyAgIGNvbnN0IHRvTGVmdCA9IHtcbi8vICAgICB0b3A6IHBhZGRlZFRvcCxcbi8vICAgICBoZWlnaHQ6IHBhZGRlZEhlaWdodCxcbi8vICAgICBsZWZ0OiAwLFxuLy8gICAgIHdpZHRoOiBwYWRkZWRMZWZ0LFxuLy8gICB9XG5cbi8vICAgY29uc3QgdG9SaWdodCA9IHtcbi8vICAgICB0b3A6IHBhZGRlZFRvcCxcbi8vICAgICBoZWlnaHQ6IHBhZGRlZEhlaWdodCxcbi8vICAgICByaWdodDogMCxcbi8vICAgICBsZWZ0OiBwYWRkZWRSaWdodCxcbi8vICAgfVxuXG4vLyAgIGNvbnN0IFtcbi8vICAgICBhYm92ZUVsZSxcbi8vICAgICBiZWxvd0VsZSxcbi8vICAgICB0b0xlZnRFbGUsXG4vLyAgICAgdG9SaWdodEVsZSxcbi8vICAgXSA9IFthYm92ZSwgYmVsb3csIHRvTGVmdCwgdG9SaWdodF0ubWFwKHN0eWxlID0+IHtcbi8vICAgICBjb25zdCBlbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4vLyAgICAgZWxlLmNsYXNzTmFtZSA9ICdkaW0nXG4vLyAgICAgT2JqZWN0LmVudHJpZXMoc3R5bGUpLmZvckVhY2goKFtwcm9wLCB2YWxdKSA9PiB7XG4vLyAgICAgICBlbGUuc3R5bGVbcHJvcF0gPSB2YWxcbi8vICAgICB9KVxuXG4vLyAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZWxlKVxuLy8gICAgIHJldHVybiBlbGVcbi8vICAgfSlcblxuLy8gICBsZXQgZnV6enlFbGVcbi8vICAgaWYgKGZ1enp5KSB7XG4vLyAgICAgZnV6enlFbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuLy8gICAgIGZ1enp5RWxlLmNsYXNzTmFtZSA9ICdoaWdobGlnaHQtc2hhZG93J1xuLy8gICAgIGZ1enp5RWxlLnN0eWxlLnRvcCA9IHBhZGRlZFRvcFxuLy8gICAgIGZ1enp5RWxlLnN0eWxlLmxlZnQgPSBwYWRkZWRMZWZ0XG4vLyAgICAgZnV6enlFbGUuc3R5bGUuaGVpZ2h0ID0gcGFkZGVkSGVpZ2h0XG4vLyAgICAgZnV6enlFbGUuc3R5bGUud2lkdGggPSBwYWRkZWRXaWR0aFxuLy8gICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGZ1enp5RWxlKVxuLy8gICB9XG5cbi8vICAgY29uc3QgcmVtb3ZlRWxlcyA9ICgpID0+IFtcbi8vICAgICBhYm92ZUVsZSxcbi8vICAgICBiZWxvd0VsZSxcbi8vICAgICB0b0xlZnRFbGUsXG4vLyAgICAgdG9SaWdodEVsZSxcbi8vICAgICBmdXp6eUVsZSxcbi8vICAgXS5mb3JFYWNoKGVsZSA9PiBlbGUgJiYgZWxlLnJlbW92ZSgpKVxuXG4vLyAgIGlmIChjYXB0aW9uVGVtcGxhdGUgJiYgY2FwdGlvbkFuY2hvcikge1xuLy8gICAgIHRyeSB7XG4vLyAgICAgICBjb25zdCBbYW5jaG9yLCBzdHlsZSwgZGF0YVNoaWZ0XSA9IHByZXBhcmVDYXB0aW9uRWxlKHtcbi8vICAgICAgICAgYWJvdmVFbGUsXG4vLyAgICAgICAgIGJlbG93RWxlLFxuLy8gICAgICAgICB0b0xlZnRFbGUsXG4vLyAgICAgICAgIHRvUmlnaHRFbGUsXG4vLyAgICAgICAgIGNhcHRpb25BbmNob3IsXG4vLyAgICAgICAgIHRvcCxcbi8vICAgICAgICAgcmlnaHQsXG4vLyAgICAgICAgIGJvdHRvbSxcbi8vICAgICAgICAgbGVmdCxcbi8vICAgICAgICAgbWlkWDogdG9QaXhlbHMoZWxlUmlnaHQgLSAoZWxlV2lkdGggLyAyKSlcbi8vICAgICAgIH0pXG5cbi8vICAgICAgIGNvbnN0IGNhcHRpb25FbGUgPSBjYXB0aW9uVGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpXG5cbi8vICAgICAgIE9iamVjdC5lbnRyaWVzKHN0eWxlKS5mb3JFYWNoKChbcHJvcCwgdmFsXSkgPT4ge1xuLy8gICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIGNhcHRpb25FbGUuc3R5bGVbcHJvcF0gPSB2YWxcbi8vICAgICAgIH0pXG5cbi8vICAgICAgIGlmIChjZW50ZXJDYXB0aW9uKSBjYXB0aW9uRWxlLmNsYXNzTGlzdC5hZGQoJ2NhcHRpb24nKVxuLy8gICAgICAgaWYgKGRhdGFTaGlmdCkgY2FwdGlvbkVsZS5kYXRhc2V0LnNoaWZ0ID0gZGF0YVNoaWZ0XG5cbi8vICAgICAgIGFuY2hvci5hcHBlbmQoY2FwdGlvbkVsZSlcbi8vICAgICB9IGNhdGNoIChlKSB7XG4vLyAgICAgICByZW1vdmVFbGVzKClcbi8vICAgICAgIHRocm93IGVcbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICByZXR1cm4gcmVtb3ZlRWxlc1xuLy8gfVxuXG4vLyBmdW5jdGlvbiBfcHJlcGFyZUNhcHRpb25FbGUoe1xuLy8gICBhYm92ZUVsZSxcbi8vICAgYmVsb3dFbGUsXG4vLyAgIHRvTGVmdEVsZSxcbi8vICAgdG9SaWdodEVsZSxcbi8vICAgY2FwdGlvbkFuY2hvcixcbi8vICAgdG9wLFxuLy8gICByaWdodCxcbi8vICAgYm90dG9tLFxuLy8gICBsZWZ0LFxuLy8gICBtaWRYXG4vLyB9KSB7XG4vLyAgIGNvbnN0IGFuY2hvck1hcCA9IHtcbi8vICAgICB0b3A6IFswLCAtMV0sXG4vLyAgICAgdG9wUmlnaHQ6IFsxLCAtMV0sXG4vLyAgICAgcmlnaHQ6IFsxLCAwXSxcbi8vICAgICBib3R0b21SaWdodDogWzEsIDFdLFxuLy8gICAgIGJvdHRvbTogWzAsIDFdLFxuLy8gICAgIGJvdHRvbUxlZnQ6IFstMSwgMV0sXG4vLyAgICAgbGVmdDogWy0xLCAwXSxcbi8vICAgICB0b3BMZWZ0OiBbLTEsIC0xXSxcbi8vICAgfVxuXG4vLyAgIGlmICh0eXBlb2YgY2FwdGlvbkFuY2hvciA9PT0gJ3N0cmluZycpIHtcbi8vICAgICBjYXB0aW9uQW5jaG9yID0gYW5jaG9yTWFwW2NhcHRpb25BbmNob3JdXG4vLyAgIH1cblxuLy8gICBpZiAoIShjYXB0aW9uQW5jaG9yIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4vLyAgICAgdGhyb3cgbmV3IEVycm9yKCdjYXB0aW9uQW5jaG9yIG11c3QgYmUgYW4gb3JkZXJlZCBwYWlyIGFycmF5IG9yIHZhbGlkIHN0cmluZycpXG4vLyAgIH1cblxuLy8gICBjb25zdCBbYW5jaG9yLCB7XG4vLyAgICAgdG9wOiBkZWZhdWx0VG9wLFxuLy8gICAgIHJpZ2h0OiBkZWZhdWx0UmlnaHQsXG4vLyAgICAgYm90dG9tOiBkZWZhdWx0Qm90dG9tLFxuLy8gICAgIGxlZnQ6IGRlZmF1bHRMZWZ0LFxuLy8gICB9LCBkYXRhU2hpZnRdID0gZnVuY1N3aXRjaChjYXB0aW9uQW5jaG9yLCBhcmVFcXVhbEFycmF5cywgKHsgX2Nhc2UgfSkgPT4ge1xuLy8gICAgIF9jYXNlKFtbMCwgLTFdXSwgKCkgPT4gW2Fib3ZlRWxlLCB7IGJvdHRvbTogMCwgbGVmdDogbWlkWCB9LCAnbGVmdCddKVxuLy8gICAgIF9jYXNlKFtbMSwgLTFdXSwgKCkgPT4gW3RvUmlnaHRFbGUsIHsgYm90dG9tOiAnMTAwJScsIGxlZnQ6IDAgfV0pXG4vLyAgICAgX2Nhc2UoW1sxLCAwXV0sICgpID0+IFt0b1JpZ2h0RWxlLCB7IHRvcDogJzUwJScsIGxlZnQ6IDAgfSwgJ3VwJ10pXG4vLyAgICAgX2Nhc2UoW1sxLCAxXV0sICgpID0+IFt0b1JpZ2h0RWxlLCB7IHRvcDogJzEwMCUnLCBsZWZ0OiAwIH1dKVxuLy8gICAgIF9jYXNlKFtbMCwgMV1dLCAoKSA9PiBbYmVsb3dFbGUsIHsgdG9wOiAwLCBsZWZ0OiBtaWRYIH0sICdsZWZ0J10pXG4vLyAgICAgX2Nhc2UoW1stMSwgMV1dLCAoKSA9PiBbdG9MZWZ0RWxlLCB7IHRvcDogJzEwMCUnLCByaWdodDogMCB9XSlcbi8vICAgICBfY2FzZShbWy0xLCAwXV0sICgpID0+IFt0b0xlZnRFbGUsIHsgdG9wOiAnNTAlJywgcmlnaHQ6IDAgfSwgJ3VwJ10pXG4vLyAgICAgX2Nhc2UoW1stMSwgLTFdXSwgKCkgPT4gW3RvTGVmdEVsZSwgeyBib3R0b206ICcxMDAlJywgcmlnaHQ6IDAgfV0pXG4vLyAgIH0pXG5cbi8vICAgcmV0dXJuIFthbmNob3IsIHtcbi8vICAgICB0b3A6IG1lcmdlUHJvcChkZWZhdWx0VG9wLCB0b3ApLFxuLy8gICAgIHJpZ2h0OiBtZXJnZVByb3AoZGVmYXVsdFJpZ2h0LCByaWdodCksXG4vLyAgICAgYm90dG9tOiBtZXJnZVByb3AoZGVmYXVsdEJvdHRvbSwgYm90dG9tKSxcbi8vICAgICBsZWZ0OiBtZXJnZVByb3AoZGVmYXVsdExlZnQsIGxlZnQpLFxuLy8gICB9LCBkYXRhU2hpZnRdXG4vLyB9XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUhpZ2hsaWdodEZ1bmNzID0gKC4uLmVsZXMpID0+IHtcbiAgbGV0IHVuaGlnaGxpZ2h0ID0gbnVsbFxuXG4gIHJldHVybiBbXG4gICAgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgaWYgKCF1bmhpZ2hsaWdodCkge1xuICAgICAgICB1bmhpZ2hsaWdodCA9IGhpZ2hsaWdodEVsZXMoLi4uZWxlcywgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9LFxuICAgICgpID0+IHtcbiAgICAgIGlmICh1bmhpZ2hsaWdodCkge1xuICAgICAgICB1bmhpZ2hsaWdodCgpXG4gICAgICAgIHVuaGlnaGxpZ2h0ID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgXVxufVxuXG5mdW5jdGlvbiBoaWdobGlnaHRFbGVzKC4uLmFyZ3MpIHtcbiAgLy8gcGFyc2UgYXJnc1xuICBjb25zdCBsYXN0QXJnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdXG4gIGNvbnN0IGVsZXMgPSBsYXN0QXJnIGluc3RhbmNlb2YgTm9kZSA/IGFyZ3MgOiBhcmdzLnNsaWNlKDAsIC0xKVxuICBjb25zdCB7XG4gICAgcGFkZGluZyA9IDAsXG4gICAgcGFkZGluZ1RvcCwgcGFkZGluZ1JpZ2h0LCBwYWRkaW5nQm90dG9tLCBwYWRkaW5nTGVmdCxcbiAgICBjYXB0aW9uVGVtcGxhdGUgPSBudWxsLFxuICAgIGNhcHRpb25Qb3MgPSAncmlnaHQnLFxuICAgIC4uLmNhcHRpb25BdHRyc1xuICB9ID0gbGFzdEFyZyBpbnN0YW5jZW9mIE5vZGUgPyB7fSA6IGxhc3RBcmdcblxuICAvLyBjcmVhdGUgaGlnaGxpZ2h0IHdyYXBwZXJzIHRvIGZyYW1lIGhpZ2hsaWdodGVkIGVsZXNcbiAgY29uc3QgW3dyYXBwZXJTdHlsZXMsIG91dGVyV3JhcHBlclN0eWxlXSA9IGdldFBvc2l0aW9uU3R5bGVzKGVsZXMsIHtcbiAgICBwYWRkaW5nVG9wOiBwYWRkaW5nVG9wIHx8IHBhZGRpbmcsXG4gICAgcGFkZGluZ1JpZ2h0OiBwYWRkaW5nUmlnaHQgfHwgcGFkZGluZyxcbiAgICBwYWRkaW5nQm90dG9tOiBwYWRkaW5nQm90dG9tIHx8IHBhZGRpbmcsXG4gICAgcGFkZGluZ0xlZnQ6IHBhZGRpbmdMZWZ0IHx8IHBhZGRpbmcsXG4gIH0pXG5cbiAgY29uc3Qgd3JhcHBlcnMgPSB3cmFwcGVyU3R5bGVzLm1hcChzdHlsZSA9PiB7XG4gICAgY29uc3Qgd3JhcHBlciA9IGdlbmVyYXRlRGl2V2l0aFN0eWxlKHN0eWxlKVxuICAgIHdyYXBwZXIuY2xhc3NOYW1lID0gZ2VuZXJhdGVDbGFzc05hbWUoJ2hpZ2hsaWdodC13cmFwcGVyJywgW1xuICAgICAgW2VsZXMubGVuZ3RoID09PSAxLCAnZnV6enknXVxuICAgIF0pXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmQod3JhcHBlcilcbiAgICByZXR1cm4gd3JhcHBlclxuICB9KVxuXG4gIC8vIGlmIG11bHRpcGxlIGhpZ2hsaWdodCBlbGVtZW50cywgY3JlYXRlIG91dGVyIHdyYXBwZXIgdG8gYW5jaG9yIGNhcHRpb24gdG9cbiAgbGV0IG91dGVyV3JhcHBlciA9IHdyYXBwZXJzWzBdXG4gIGlmICh3cmFwcGVycy5sZW5ndGggPiAxKSB7XG4gICAgb3V0ZXJXcmFwcGVyID0gZ2VuZXJhdGVEaXZXaXRoU3R5bGUob3V0ZXJXcmFwcGVyU3R5bGUpXG4gICAgb3V0ZXJXcmFwcGVyLmNsYXNzTmFtZSA9ICdoaWdobGlnaHQtb3V0ZXItd3JhcHBlcidcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChvdXRlcldyYXBwZXIpXG4gIH1cblxuICAvLyBjcmVhdGUgYmFja2dyb3VuZCBkaW1taW5nIGVsZW1lbnRcbiAgY29uc3QgZGltRWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgZGltRWxlLmNsYXNzTmFtZSA9ICdkaW0gZGltLS1mdWxsJ1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZChkaW1FbGUpXG5cbiAgLy8gbGlmdCBoaWdobGlnaHRlZCBlbGVzIGFib3ZlIGhpZ2hsaWdodCB3cmFwcGVyc1xuICBlbGVzLmZvckVhY2goZWxlID0+IHtcbiAgICBlbGUuc3R5bGUuekluZGV4ID0gOFxuICAgIGNvbnN0IGVsZVBvc2l0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGUpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJylcbiAgICBpZiAoZWxlUG9zaXRpb24gPT09ICdzdGF0aWMnKSBlbGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnXG4gIH0pXG5cbiAgLy8gY2xlYW51cCBhbGwgRE9NIG11dGF0aW9uc1xuICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgIHdyYXBwZXJzLmZvckVhY2god3JhcHBlciA9PiB3cmFwcGVyLnJlbW92ZSgpKVxuICAgIGRpbUVsZS5yZW1vdmUoKVxuICAgIG91dGVyV3JhcHBlci5yZW1vdmUoKVxuXG4gICAgZWxlcy5mb3JFYWNoKGVsZSA9PiB7XG4gICAgICBlbGUuc3R5bGUuekluZGV4ID0gbnVsbFxuICAgICAgZWxlLnN0eWxlLnBvc2l0aW9uID0gbnVsbFxuICAgIH0pXG4gIH1cblxuICAvLyBpZiBjYXB0aW9uIHByb3ZpZGVkLCBwcmVwYXJlIGFuZCBhdHRhY2hcbiAgaWYgKGNhcHRpb25UZW1wbGF0ZSAmJiBjYXB0aW9uQW5jaG9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IFtzdHlsZSwgc2hpZnRdID0gcHJlcGFyZUNhcHRpb25FbGUoeyBjYXB0aW9uQW5jaG9yLCAuLi5hdHRycyB9KVxuICAgICAgY29uc3QgY2FwdGlvbkVsZSA9IGNhcHRpb25UZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSlcblxuICAgICAgT2JqZWN0LmVudHJpZXMoc3R5bGUpLmZvckVhY2goKFtwcm9wLCB2YWxdKSA9PiB7XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkgY2FwdGlvbkVsZS5zdHlsZVtwcm9wXSA9IHZhbFxuICAgICAgfSlcblxuICAgICAgaWYgKGNlbnRlckNhcHRpb24gJiYgc2hpZnQpIGNhcHRpb25FbGUuZGF0YXNldC5zaGlmdCA9IHNoaWZ0XG4gICAgICBjYXB0aW9uRWxlLmNsYXNzTGlzdC5hZGQoJ2NhcHRpb24nKVxuXG4gICAgICBvdXRlcldyYXBwZXIuYXBwZW5kKGNhcHRpb25FbGUpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2xlYW51cCgpXG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsZWFudXBcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUNhcHRpb25FbGUoe1xuICBjYXB0aW9uQW5jaG9yLFxuICB0b3AsXG4gIHJpZ2h0LFxuICBib3R0b20sXG4gIGxlZnQsXG59KSB7XG4gIGNvbnN0IHtcbiAgICB0b3A6IGRlZmF1bHRUb3AsXG4gICAgcmlnaHQ6IGRlZmF1bHRSaWdodCxcbiAgICBib3R0b206IGRlZmF1bHRCb3R0b20sXG4gICAgbGVmdDogZGVmYXVsdExlZnQsXG4gICAgc2hpZnRcbiAgfSA9IHN0cmluZ1N3aXRjaChjYXB0aW9uQW5jaG9yLCAoeyBfY2FzZSB9KSA9PiB7XG4gICAgX2Nhc2UoJ3RvcCcsICgpID0+ICh7IGJvdHRvbTogJzEwMCUnLCBsZWZ0OiAnNTAlJywgc2hpZnQ6ICdsZWZ0JyB9KSlcbiAgICBfY2FzZSgndG9wUmlnaHQnLCAoKSA9PiAoeyBib3R0b206ICcxMDAlJywgbGVmdDogJzEwMCUnIH0pKVxuICAgIF9jYXNlKCdyaWdodCcsICgpID0+ICh7IHRvcDogJzUwJScsIGxlZnQ6ICcxMDAlJywgc2hpZnQ6ICd1cCcgfSkpXG4gICAgX2Nhc2UoJ2JvdHRvbVJpZ2h0JywgKCkgPT4gKHsgdG9wOiAnMTAwJScsIGxlZnQ6ICcxMDAlJyB9KSlcbiAgICBfY2FzZSgnYm90dG9tJywgKCkgPT4gKHsgdG9wOiAnMTAwJScsIGxlZnQ6ICc1MCUnLCBzaGlmdDogJ2xlZnQnIH0pKVxuICAgIF9jYXNlKCdib3R0b21MZWZ0JywgKCkgPT4gKHsgdG9wOiAnMTAwJScsIHJpZ2h0OiAnMTAwJScgfSkpXG4gICAgX2Nhc2UoJ2xlZnQnLCAoKSA9PiAoeyB0b3A6ICc1MCUnLCByaWdodDogJzEwMCUnLCBzaGlmdDogJ3VwJyB9KSlcbiAgICBfY2FzZSgndG9wTGVmdCcsICgpID0+ICh7IGJvdHRvbTogJzEwMCUnLCByaWdodDogJzEwMCUnIH0pKVxuICAgIF9kZWZhdWx0KCgpID0+IHsgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNhcHRpb25BbmNob3IgJykgfSlcbiAgfSlcblxuICByZXR1cm4gW3tcbiAgICB0b3A6IG1lcmdlUHJvcChkZWZhdWx0VG9wLCB0b3ApLFxuICAgIHJpZ2h0OiBtZXJnZVByb3AoZGVmYXVsdFJpZ2h0LCByaWdodCksXG4gICAgYm90dG9tOiBtZXJnZVByb3AoZGVmYXVsdEJvdHRvbSwgYm90dG9tKSxcbiAgICBsZWZ0OiBtZXJnZVByb3AoZGVmYXVsdExlZnQsIGxlZnQpLFxuICB9LCBzaGlmdF1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVEaXZXaXRoU3R5bGUoc3R5bGUpIHtcbiAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICBPYmplY3QuZW50cmllcyhzdHlsZSkuZm9yRWFjaCgoW3Byb3AsIHZhbF0pID0+IHtcbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIGRpdi5zdHlsZVtwcm9wXSA9IHZhbFxuICB9KVxuXG4gIHJldHVybiBkaXZcbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25TdHlsZXMoZWxlcywge1xuICBwYWRkaW5nVG9wID0gMCxcbiAgcGFkZGluZ1JpZ2h0ID0gMCxcbiAgcGFkZGluZ0JvdHRvbSA9IDAsXG4gIHBhZGRpbmdMZWZ0ID0gMCxcbn0gPSB7fSkge1xuICBjb25zdCB0b1B4ID0gbnVtID0+IGAke251bX1weGBcblxuICBsZXQgb3V0ZXJUb3AsIG91dGVyUmlnaHQsIG91dGVyQm90dG9tLCBvdXRlckxlZnRcbiAgY29uc3QgYXR0cmlidXRlcyA9IGVsZXMubWFwKGVsZSA9PiB7XG4gICAgY29uc3QgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgfSA9IGVsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgaWYgKG91dGVyVG9wID09PSB1bmRlZmluZWQgfHwgdG9wIDwgb3V0ZXJUb3ApIG91dGVyVG9wID0gdG9wXG4gICAgaWYgKG91dGVyUmlnaHQgPT09IHVuZGVmaW5lZCB8fCByaWdodCA+IG91dGVyUmlnaHQpIG91dGVyUmlnaHQgPSByaWdodFxuICAgIGlmIChvdXRlckJvdHRvbSA9PT0gdW5kZWZpbmVkIHx8IGJvdHRvbSA+IG91dGVyQm90dG9tKSBvdXRlckJvdHRvbSA9IGJvdHRvbVxuICAgIGlmIChvdXRlckxlZnQgPT09IHVuZGVmaW5lZCB8fCBsZWZ0IDwgb3V0ZXJMZWZ0KSBvdXRlckxlZnQgPSBsZWZ0XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiB0b1B4KHRvcCAtIHBhZGRpbmdUb3ApLFxuICAgICAgbGVmdDogdG9QeChsZWZ0IC0gcGFkZGluZ0xlZnQpLFxuICAgICAgaGVpZ2h0OiB0b1B4KGJvdHRvbSAtIHRvcCArIHBhZGRpbmdUb3AgKyBwYWRkaW5nQm90dG9tKSxcbiAgICAgIHdpZHRoOiB0b1B4KHJpZ2h0IC0gbGVmdCArIHBhZGRpbmdSaWdodCArIHBhZGRpbmdMZWZ0KSxcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIFthdHRyaWJ1dGVzLCB7XG4gICAgdG9wOiB0b1B4KG91dGVyVG9wIC0gcGFkZGluZ1RvcCksXG4gICAgbGVmdDogdG9QeChvdXRlckxlZnQgLSBwYWRkaW5nTGVmdCksXG4gICAgaGVpZ2h0OiB0b1B4KG91dGVyQm90dG9tIC0gb3V0ZXJUb3AgKyBwYWRkaW5nVG9wICsgcGFkZGluZ0JvdHRvbSksXG4gICAgd2lkdGg6IHRvUHgob3V0ZXJSaWdodCAtIG91dGVyTGVmdCArIHBhZGRpbmdSaWdodCArIHBhZGRpbmdMZWZ0KSxcbiAgfV1cbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wKGRlZmF1bHRQcm9wLCBhcmdQcm9wKSB7XG4gIGlmIChkZWZhdWx0UHJvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFyZ1Byb3BcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXJnUHJvcCA/IGBjYWxjKCR7ZGVmYXVsdFByb3B9ICsgJHthcmdQcm9wfSlgIDogZGVmYXVsdFByb3BcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlU1ZHRWxlbWVudCA9IHRhZyA9PlxuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgdGFnKVxuXG5leHBvcnQgY29uc3QgYXBwbHlTdHlsZSA9IChlbGUsIHN0eWxlLCBjbGVhciA9IGZhbHNlKSA9PiB7XG4gIGlmIChjbGVhcikgZWxlLnN0eWxlID0gbnVsbFxuICBPYmplY3QuZW50cmllcyhzdHlsZSkuZm9yRWFjaCgoW2F0dHIsIHZhbF0pID0+IGVsZS5zdHlsZVthdHRyXSA9IHZhbClcbn1cblxud2luZG93LmNhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG53aW5kb3cuY2FwLnN0eWxlLndpZHRoID0gJzIwMHB4J1xud2luZG93LmNhcC5zdHlsZS5oZWlnaHQgPSAnMjAwcHgnXG53aW5kb3cuY2FwLnN0eWxlLmJhY2tncm91bmQgPSAncmVkJ1xud2luZG93LmNhcC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbndpbmRvdy5jYXAuc3R5bGUuekluZGV4ID0gMTAwXG53aW5kb3cub3B0cyA9IHsgY2FwdGlvblRlbXBsYXRlOiBjYXAsIGNhcHRpb25BbmNob3I6ICdib3R0b20nIH1cbndpbmRvdy5naGYgPSBnZW5lcmF0ZUhpZ2hsaWdodEZ1bmNzXG53aW5kb3cuaGggPSBoaWdobGlnaHRFbGVzXG53aW5kb3cuc2EgPSAoKSA9PiBbXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zcXVhcmVbZGF0YS1pZD1cIjcxXCJdJyksXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zcXVhcmVbZGF0YS1pZD1cIjcyXCJdJyksXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zcXVhcmVbZGF0YS1pZD1cIjczXCJdJyksXG5dIiwiaW1wb3J0IHsgQVJST1dfUkVHRVgsIE5VTV9SRUdFWCB9IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmV4cG9ydCBjb25zdCBpc1RydXRoeSA9IGEgPT4gYVxuXG5leHBvcnQgY29uc3QgY29tYm9zID0gKG51bUVsZW1lbnRzLCB7XG4gIG1pbiA9IDEsXG4gIG1heCA9IDksXG4gIG51bVJlcGVhdHNBbGxvd2VkID0gMCxcbn0pID0+IHtcbiAgY29uc3QgcmFuZ2VTaXplID0gbWF4IC0gbWluICsgMVxuICBjb25zdCBuZXh0T3B0aW9ucyA9IHsgbWluOiBtaW4gKyAxLCBtYXgsIG51bVJlcGVhdHNBbGxvd2VkIH1cblxuICBpZiAobnVtRWxlbWVudHMgPT09IDApIHtcbiAgICAvLyAwIGVsZW1lbnRzOyByZXR1cm4gdGhlIGVtcHR5IGNvbWJvXG4gICAgcmV0dXJuIFtbXV1cbiAgfSBlbHNlIGlmIChyYW5nZVNpemUgPD0gMCB8fCBudW1FbGVtZW50cyA+IHJhbmdlU2l6ZSArIG51bVJlcGVhdHNBbGxvd2VkKSB7XG4gICAgLy8gaW1wb3NzaWJsZSByZXF1ZXN0OyByZXR1cm4gbm8gY29tYm9zXG4gICAgcmV0dXJuIFtdXG4gIH0gZWxzZSB7XG4gICAgLy8gcmVjdXJzaXZlIHN0ZXBcbiAgICBjb25zdCB3aXRoUmVwZWF0ZWRNaW4gPSBudW1SZXBlYXRzQWxsb3dlZCA+IDAgJiYgbnVtRWxlbWVudHMgPj0gMlxuICAgICAgPyBjb21ib3MobnVtRWxlbWVudHMgLSAyLCB7XG4gICAgICAgIC4uLm5leHRPcHRpb25zLFxuICAgICAgICBudW1SZXBlYXRzQWxsb3dlZDogbnVtUmVwZWF0c0FsbG93ZWQgLSAxXG4gICAgICB9KS5tYXAoY29tYm8gPT4gW21pbiwgbWluLCAuLi5jb21ib10pXG4gICAgICA6IFtdXG5cbiAgICBjb25zdCB3aXRoTWluID0gY29tYm9zKG51bUVsZW1lbnRzIC0gMSwgbmV4dE9wdGlvbnMpXG4gICAgICAubWFwKGNvbWJvID0+IFttaW4sIC4uLmNvbWJvXSlcblxuICAgIGNvbnN0IHdpdGhvdXRNaW4gPSBjb21ib3MobnVtRWxlbWVudHMsIG5leHRPcHRpb25zKVxuXG4gICAgcmV0dXJuIFsuLi53aXRoUmVwZWF0ZWRNaW4sIC4uLndpdGhNaW4sIC4uLndpdGhvdXRNaW5dXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1heFBvc3NpYmxlUmVwZWF0cyA9IChcbiAgcG9zaXRpb25zLFxuICBjdXJJZHggPSAwLFxuICBmaWxsZWQgPSB7fSxcbiAgbmV4dEZpbGxWYWwgPSAwXG4pID0+IHtcbiAgaWYgKGN1cklkeCArIDEgPiBwb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZmlsbGVkKVxuICAgICAgLm1hcCgoeyByb3dzIH0pID0+IHJvd3MubGVuZ3RoKVxuICAgICAgLmZpbHRlcihudW1TcXVhcmVzV2l0aFZhbCA9PiBudW1TcXVhcmVzV2l0aFZhbCA9PT0gMilcbiAgICAgIC5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbbmV4dFJvdywgbmV4dENvbF0gPSBwb3NpdGlvbnNbY3VySWR4XVxuXG4gICAgY29uc3QgcG9zc2libGVWYWxzID0gT2JqZWN0LmtleXMoZmlsbGVkKVxuICAgICAgLmZpbHRlcih2YWwgPT4ge1xuICAgICAgICBjb25zdCB7IHJvd3MsIGNvbHMgfSA9IGZpbGxlZFt2YWxdXG4gICAgICAgIHJldHVybiAhcm93cy5pbmNsdWRlcyhuZXh0Um93KSAmJiAhY29scy5pbmNsdWRlcyhuZXh0Q29sKVxuICAgICAgfSlcbiAgICAgIC5jb25jYXQobmV4dEZpbGxWYWwpXG5cbiAgICByZXR1cm4gcG9zc2libGVWYWxzLnJlZHVjZSgobWF4UmVwZWF0cywgdmFsKSA9PiB7XG4gICAgICBjb25zdCBmaWxsZWRDbG9uZSA9IGRlZXBDbG9uZShmaWxsZWQpXG4gICAgICBmaWxsZWRDbG9uZVt2YWxdID0gZmlsbGVkQ2xvbmVbdmFsXSB8fCB7IHJvd3M6IFtdLCBjb2xzOiBbXSB9XG4gICAgICBmaWxsZWRDbG9uZVt2YWxdLnJvd3MucHVzaChuZXh0Um93KVxuICAgICAgZmlsbGVkQ2xvbmVbdmFsXS5jb2xzLnB1c2gobmV4dENvbClcblxuICAgICAgY29uc3QgbWF4UmVwZWF0c1dpdGhWYWwgPSBtYXhQb3NzaWJsZVJlcGVhdHMoXG4gICAgICAgIHBvc2l0aW9ucyxcbiAgICAgICAgY3VySWR4ICsgMSxcbiAgICAgICAgZmlsbGVkQ2xvbmUsXG4gICAgICAgIG5leHRGaWxsVmFsICsgMVxuICAgICAgKVxuXG4gICAgICByZXR1cm4gbWF4UmVwZWF0c1dpdGhWYWwgPiBtYXhSZXBlYXRzID8gbWF4UmVwZWF0c1dpdGhWYWwgOiBtYXhSZXBlYXRzXG4gICAgfSwgMClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYXJlRXF1YWxBcnJheXMgPSAoYSwgYikgPT4gKFxuICBhLmxlbmd0aCA9PT0gYi5sZW5ndGhcbiAgJiYgYS5ldmVyeSgoZWxlLCBpZHgpID0+IGVsZSA9PT0gYltpZHhdKVxuKVxuXG5leHBvcnQgY29uc3QgYXJyYXlVbmlvbiA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGFDb3VudHMgPSB7fVxuICBhLmZvckVhY2goZWxlID0+IGFDb3VudHNbZWxlXSA9IGFDb3VudHNbZWxlXSA/IGFDb3VudHNbZWxlXSArIDEgOiAxKVxuXG4gIGNvbnN0IHVuaW9uID0gW11cbiAgYi5mb3JFYWNoKGVsZSA9PiB7XG4gICAgaWYgKGFDb3VudHNbZWxlXSAmJiBhQ291bnRzW2VsZV0gPiAwKSB7XG4gICAgICBhQ291bnRzW2VsZV0tLVxuICAgICAgdW5pb24ucHVzaChlbGUpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB1bmlvblxufVxuXG5leHBvcnQgY29uc3QgaW5jbHVkZXNBcnJheSA9IChvdXRlckFycmF5LCBpbm5lckFycmF5KSA9PlxuICBvdXRlckFycmF5LnNvbWUoc3ViQXJyYXkgPT4gYXJlRXF1YWxBcnJheXMoc3ViQXJyYXksIGlubmVyQXJyYXkpKVxuXG5leHBvcnQgY29uc3QgaW5kZXhPZkFycmF5ID0gKG91dGVyQXJyYXksIGlubmVyQXJyYXkpID0+XG4gIG91dGVyQXJyYXkuZmluZEluZGV4KHN1YkFycmF5ID0+IGFyZUVxdWFsQXJyYXlzKHN1YkFycmF5LCBpbm5lckFycmF5KSlcblxuZXhwb3J0IGNvbnN0IGluY2x1ZGVzRGlzdGluY3QgPSAoYXJyYXksIC4uLnJlcXVpcmVkRWxlbWVudHMpID0+IHtcbiAgY29uc3QgdmlzaXRlZEluZGljZXMgPSB7fVxuICByZXR1cm4gcmVxdWlyZWRFbGVtZW50cy5ldmVyeShyZXF1aXJlZEVsZSA9PiB7XG4gICAgY29uc3QgZWxlSW5kZXggPSBhcnJheS5maW5kSW5kZXgoKGVsZSwgaWR4KSA9PlxuICAgICAgZWxlID09PSByZXF1aXJlZEVsZSAmJiAhdmlzaXRlZEluZGljZXNbaWR4XVxuICAgIClcblxuICAgIGlmIChlbGVJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB2aXNpdGVkSW5kaWNlc1tlbGVJbmRleF0gPSB0cnVlXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IG5leHRJZCA9ICgoKSA9PiB7XG4gIGxldCBpZCA9IDBcbiAgcmV0dXJuICgpID0+IGAke2lkKyt9YFxufSkoKVxuXG5leHBvcnQgY29uc3QgY2xhc3NlcyA9ICguLi5hcmdzKSA9PiBhcmdzXG4gIC5tYXAoYXJnID0+IHtcbiAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHJldHVybiBhcmdbMF1cbiAgICAgICAgPyBhcmdbMV1cbiAgICAgICAgOiBhcmdbMl1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFyZ1xuICAgIH1cbiAgfSlcbiAgLmZpbHRlcihhcmcgPT4gYXJnKVxuICAuam9pbignICcpXG5cbmZ1bmN0aW9uIGV2YWxDbGFzc05hbWVDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiBjb21wb25lbnRbMF0gPyBjb21wb25lbnRbMV0gOiBjb21wb25lbnRbMl1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29tcG9uZW50XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZhbENsYXNzTmFtZUNvbXBvbmVudHMoY29tcG9uZW50cykge1xuICByZXR1cm4gY29tcG9uZW50c1xuICAgIC5tYXAoZXZhbENsYXNzTmFtZUNvbXBvbmVudClcbiAgICAuZmlsdGVyKGlzVHJ1dGh5KVxufVxuXG5mdW5jdGlvbiBldmFsQ2xhc3NOYW1lRmxhZ3MoYmFzZSwgZmxhZ3MpIHtcbiAgcmV0dXJuIGV2YWxDbGFzc05hbWVDb21wb25lbnRzKGZsYWdzKVxuICAgIC5tYXAoZmxhZyA9PiBgJHtiYXNlfS0tJHtmbGFnfWApXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ2xhc3NOYW1lRnJvbUFycmF5KGNvbXBvbmVudHMpIHtcbiAgcmV0dXJuIGV2YWxDbGFzc05hbWVDb21wb25lbnRzKGNvbXBvbmVudHMpLmpvaW4oJyAnKVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUNsYXNzTmFtZUZyb21CYXNlQW5kRmxhZ3MoYmFzZSwgZmxhZ3MpIHtcbiAgcmV0dXJuIFtiYXNlLCAuLi5ldmFsQ2xhc3NOYW1lRmxhZ3MoYmFzZSwgZmxhZ3MpXS5qb2luKCcgJylcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVDbGFzc05hbWVGcm9tT3B0aW9ucyh7XG4gIGJhc2UgPSBudWxsLFxuICBmbGFncyA9IFtdLFxuICBjbGFzc2VzID0gW11cbn0pIHtcbiAgY29uc3QgY2xhc3NOYW1lcyA9IGV2YWxDbGFzc05hbWVDb21wb25lbnRzKFtiYXNlLCAuLi5jbGFzc2VzXSlcbiAgY29uc3QgZmxhZ05hbWVzID0gZXZhbENsYXNzTmFtZUZsYWdzKGJhc2UsIGZsYWdzKVxuXG4gIHJldHVybiBbLi4uY2xhc3NOYW1lcywgLi4uZmxhZ05hbWVzXS5qb2luKCcgJylcbn1cblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlQ2xhc3NOYW1lID0gKGR5bmFtaWNBcmcsIGZsYWdzKSA9PiB7XG4gIGlmIChkeW5hbWljQXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVDbGFzc05hbWVGcm9tQXJyYXkoZHluYW1pY0FyZylcbiAgfSBlbHNlIGlmICh0eXBlb2YgZHluYW1pY0FyZyA9PT0gJ3N0cmluZycgJiYgZmxhZ3MgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiBnZW5lcmF0ZUNsYXNzTmFtZUZyb21CYXNlQW5kRmxhZ3MoZHluYW1pY0FyZywgZmxhZ3MpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlQ2xhc3NOYW1lRnJvbU9wdGlvbnMoZHluYW1pY0FyZylcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY29weVB1enpsZSA9IHB1enpsZSA9PiB7XG4gIGNvbnN0IGNvcHkgPSBwdXp6bGUuY2xvbmUoKVxuICBjb3B5LnJlc2V0VXVpZCgpXG4gIHJldHVybiBjb3B5XG59XG5cbmV4cG9ydCBjb25zdCB3YWl0ID0gbXMgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB3aW5kb3cuc2V0VGltZW91dChyZXNvbHZlLCBtcykpXG5cbmV4cG9ydCBjb25zdCBwcm9kdWN0ID0gbnVtQXJyYXkgPT4ge1xuICByZXR1cm4gbnVtQXJyYXkucmVkdWNlKChwcm9kdWN0LCBudW0pID0+IHByb2R1Y3QgKiBudW0sIDEpXG59XG5cbmV4cG9ydCBjb25zdCBzdW0gPSBudW1BcnJheSA9PiB7XG4gIHJldHVybiBudW1BcnJheS5yZWR1Y2UoKHN1bSwgbnVtKSA9PiBzdW0gKyBudW0sIDApXG59XG5cbmV4cG9ydCBjb25zdCBkaWZmZXJlbmNlID0gKFthLCBiXSkgPT4ge1xuICBjb25zdCBbbGFyZ2VyLCBzbWFsbGVyXSA9IGEgPiBiID8gW2EsIGJdIDogW2IsIGFdXG4gIHJldHVybiBsYXJnZXIgLSBzbWFsbGVyXG59XG5cbmV4cG9ydCBjb25zdCBxdW90aWVudCA9IChbYSwgYl0pID0+IHtcbiAgY29uc3QgW2xhcmdlciwgc21hbGxlcl0gPSBhID4gYiA/IFthLCBiXSA6IFtiLCBhXVxuICByZXR1cm4gbGFyZ2VyIC8gc21hbGxlclxufVxuXG4vLyBleHBvcnQgY29uc3Qgc3RyaW5nU3dpdGNoID0gKFxuLy8gICBpbnB1dCxcbi8vICAgY2FzZXNGbixcbi8vICAge1xuLy8gICAgIGZhbGx0aHJvdWdoID0gZmFsc2UsXG4vLyAgICAgbXVsdGlwbGVNYXRjaGVzID0gZmFsc2Vcbi8vICAgfSA9IHt9XG4vLyApID0+IHtcbi8vICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbi8vICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHN0cmluZ1N3aXRjaCBtdXN0IGJlIGEgc3RyaW5nJylcbi8vICAgfSBlbHNlIGlmICh0eXBlb2YgY2FzZXNGbiAhPT0gJ2Z1bmN0aW9uJykge1xuLy8gICAgIHRocm93IG5ldyBFcnJvcignU2Vjb25kIGFyZ3VtZW50IHRvIHN0cmluZ1N3aXRjaCBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuLy8gICB9XG4vLyAgIGxldCBtYXRjaGVkID0gZmFsc2Vcbi8vICAgbGV0IHJlc3VsdFxuXG4vLyAgIGZ1bmN0aW9uIF9jYXNlKC4uLmFyZ3MpIHtcbi8vICAgICBjb25zdCB7IGV4ZWMsIGlzTWF0Y2ggfSA9IF9wYXJzZUNhc2VBcmdzKGFyZ3MpXG5cbi8vICAgICBjb25zdCBzaG91bGRFeGVjQnlNYXRjaCA9IGlzTWF0Y2goaW5wdXQpICYmICghbWF0Y2hlZCB8fCBtdWx0aXBsZU1hdGNoZXMpXG4vLyAgICAgY29uc3Qgc2hvdWxkRXhlY0J5RmFsbHRocm91Z2ggPSBtYXRjaGVkICYmIGZhbGx0aHJvdWdoXG5cbi8vICAgICBpZiAoc2hvdWxkRXhlY0J5TWF0Y2ggfHwgc2hvdWxkRXhlY0J5RmFsbHRocm91Z2gpIHtcbi8vICAgICAgIG1hdGNoZWQgPSB0cnVlXG4vLyAgICAgICByZXN1bHQgPSBleGVjKGlucHV0KVxuLy8gICAgIH1cbi8vICAgfVxuXG4vLyAgIGZ1bmN0aW9uIF9kZWZhdWx0KGV4ZWMpIHtcbi8vICAgICBpZiAodHlwZW9mIGV4ZWMgIT09ICdmdW5jdGlvbicpIHtcbi8vICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgdG8gZGVmYXVsdCBmdW5jdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuLy8gICAgIH1cblxuLy8gICAgIGlmICghbWF0Y2hlZCB8fCBmYWxsdGhyb3VnaCkge1xuLy8gICAgICAgcmVzdWx0ID0gZXhlYyhpbnB1dClcbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICBmdW5jdGlvbiBfZW5zdXJlKGV4ZWMpIHtcbi8vICAgICBpZiAodHlwZW9mIGV4ZWMgIT09ICdmdW5jdGlvbicpIHtcbi8vICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgdG8gZW5zdXJlIGZ1bmN0aW9uIG11c3QgYmUgYSBmdW5jdGlvbicpXG4vLyAgICAgfVxuXG4vLyAgICAgaWYgKG1hdGNoZWQpIHtcbi8vICAgICAgIGV4ZWMoaW5wdXQpXG4vLyAgICAgfVxuLy8gICB9XG5cbi8vICAgY2FzZXNGbih7IF9jYXNlLCBfZGVmYXVsdCwgX2Vuc3VyZSB9KVxuLy8gICByZXR1cm4gcmVzdWx0XG4vLyB9XG5cbi8vIGZ1bmN0aW9uIF9wYXJzZUNhc2VBcmdzKGFyZ3MpIHtcbi8vICAgY29uc3QgZXhlYyA9IGFyZ3MucG9wKClcbi8vICAgaWYgKHR5cGVvZiBleGVjICE9PSAnZnVuY3Rpb24nKSB7XG4vLyAgICAgdGhyb3cgbmV3IEVycm9yKCdMYXN0IGFyZ3VtZW50IHRvIGNhc2UgZnVuY3Rpb24gbXVzdCBiZSBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgaWYgdGhlIGNhc2UgbWF0Y2hlcycpXG4vLyAgIH1cblxuLy8gICBjb25zdCBpc01hdGNoID0gaW5wdXQgPT4gYXJncy5ldmVyeShtYXRjaGVyID0+IF9wYXJzZU1hdGNoZXIobWF0Y2hlcikoaW5wdXQpKVxuLy8gICByZXR1cm4geyBleGVjLCBpc01hdGNoIH1cbi8vIH1cbi8vIGZ1bmN0aW9uIF9wYXJzZU1hdGNoZXIobWF0Y2hlcikge1xuLy8gICBjb25zdCBtYXRjaGVyVHlwZSA9IG1hdGNoZXIuY29uc3RydWN0b3IubmFtZVxuLy8gICBzd2l0Y2ggKG1hdGNoZXJUeXBlKSB7XG4vLyAgICAgY2FzZSAnQmFiZWxSZWdFeHAnOlxuLy8gICAgIGNhc2UgJ1JlZ0V4cCc6XG4vLyAgICAgICByZXR1cm4gaW5wdXQgPT4gbWF0Y2hlci50ZXN0KGlucHV0KVxuLy8gICAgIGNhc2UgJ1N0cmluZyc6XG4vLyAgICAgICByZXR1cm4gaW5wdXQgPT4gbWF0Y2hlciA9PT0gaW5wdXRcbi8vICAgICBjYXNlICdCb29sZWFuJzpcbi8vICAgICAgIHJldHVybiAoKSA9PiBtYXRjaGVyXG4vLyAgICAgY2FzZSAnQXJyYXknOlxuLy8gICAgICAgcmV0dXJuIGlucHV0ID0+IG1hdGNoZXIuc29tZShzdWIgPT4gX3BhcnNlTWF0Y2hlcihzdWIpKGlucHV0KSlcbi8vICAgICBkZWZhdWx0OlxuLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXRjaGVyIGFyZ3VtZW50cyB0byBjYXNlIGZ1bmN0aW9uIG11c3QgYmUgYSBzdHJpbmcsIHJlZ3VsYXIgZXhwcmVzc2lvbiwgYm9vbGVhbiwgb3IgYXJyYXkgb2Ygc3VjaC4gSW5zdGVhZCwgcmVjZWl2ZWQgJHttYXRjaGVyVHlwZX1gKVxuLy8gICB9XG4vLyB9XG5cblxuXG5leHBvcnQgY29uc3QgZ2V0TnVtRnJvbUNvZGUgPSBjb2RlID0+IHBhcnNlSW50KE5VTV9SRUdFWC5leGVjKGNvZGUpPy5ncm91cHMubnVtKVxuXG5leHBvcnQgY29uc3QgZ2V0RGlyRnJvbUNvZGUgPSBjb2RlID0+IEFSUk9XX1JFR0VYLmV4ZWMoY29kZSk/Lmdyb3Vwcz8uZGlyXG5cbmV4cG9ydCBjb25zdCBrZWJhYlRvQ2FtZWwgPSBzdHJpbmcgPT4ge1xuICByZXR1cm4gc3RyaW5nXG4gICAgLnNwbGl0KCctJylcbiAgICAubWFwKChzZWdtZW50LCBpZHgpID0+IGlkeCA+IDBcbiAgICAgID8gc2VnbWVudFswXS50b1VwcGVyQ2FzZSgpICsgc2VnbWVudC5zbGljZSgxKVxuICAgICAgOiBzZWdtZW50XG4gICAgKVxuICAgIC5qb2luKCcnKVxufVxuXG5leHBvcnQgY29uc3QgZ2VuU3RlcHBlciA9IGl0ZXJhYmxlID0+IHtcbiAgY29uc3QgYmFzaWNTdGVwcGVyID0gZ2VuQmFzaWNTdGVwcGVyKGl0ZXJhYmxlKVxuICByZXR1cm4gKCkgPT4gYmFzaWNTdGVwcGVyLm5leHQoKS52YWx1ZVxufVxuXG5mdW5jdGlvbiogZ2VuQmFzaWNTdGVwcGVyKGl0ZXJhYmxlKSB7XG4gIHlpZWxkKiBpdGVyYWJsZVxufVxuXG5mdW5jdGlvbiBkZWVwQ2xvbmUob2JqKSB7XG4gIHN3aXRjaCAob2JqLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICBjYXNlICdPYmplY3QnOlxuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMob2JqKS5tYXAoKFtrZXksIHZhbF0pID0+IChba2V5LCBkZWVwQ2xvbmUodmFsKV0pKVxuICAgICAgKVxuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiBvYmoubWFwKGVsZSA9PiBkZWVwQ2xvbmUoZWxlKSlcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG9ialxuICB9XG59XG5cblxuZXhwb3J0IGNvbnN0IHRocm90dGxlID0gKGZ1bmMsIG1zID0gMjAwKSA9PiB7XG4gIGxldCBsYXN0RmlyZWQgPSBEYXRlLm5vdygpXG5cbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuXG4gICAgaWYgKG5vdyAtIGxhc3RGaXJlZCA+PSBtcykge1xuICAgICAgbGFzdEZpcmVkID0gbm93XG4gICAgICBmdW5jKC4uLmFyZ3MpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVQcmVzZW5jZUluQXJyYXkgPSAoXG4gIGFycmF5LFxuICBlbGUsXG4gIGluZGV4T2ZGdW5jID0gKGFycmF5LCBlbGUpID0+IGFycmF5LmluZGV4T2YoZWxlKVxuKSA9PiB7XG4gIGNvbnN0IGlkeCA9IGluZGV4T2ZGdW5jKGFycmF5LCBlbGUpXG5cbiAgaWYgKGlkeCA+PSAwKSB7XG4gICAgYXJyYXkuc3BsaWNlKGlkeCwgMSlcbiAgfSBlbHNlIHtcbiAgICBhcnJheS5wdXNoKGVsZSlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcHVzaElmTm90SW5jbHVkZWQgPSAoXG4gIGFycmF5LFxuICBlbGUsXG4gIGluY2x1ZGVzRnVuYyA9IChhcnJheSwgZWxlKSA9PiBhcnJheS5pbmNsdWRlcyhlbGUpXG4pID0+IHtcbiAgaWYgKCFpbmNsdWRlc0Z1bmMoYXJyYXksIGVsZSkpIGFycmF5LnB1c2goZWxlKVxufVxuXG5leHBvcnQgY29uc3QgcmVtb3ZlSWZJbmNsdWRlZCA9IChcbiAgYXJyYXksXG4gIGVsZSxcbiAgaW5kZXhPZkZ1bmMgPSAoYXJyYXksIGVsZSkgPT4gYXJyYXkuaW5kZXhPZihlbGUpXG4pID0+IHtcbiAgY29uc3QgaWR4ID0gaW5kZXhPZkZ1bmMoYXJyYXksIGVsZSlcblxuICBpZiAoaWR4ID49IDApIHtcbiAgICBhcnJheS5zcGxpY2UoaWR4LCAxKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRJbnRlcnZlbmluZ1Bvc2l0aW9ucyA9IChbc3RhcnRYLCBzdGFydFldLCBbZW5kWCwgZW5kWV0pID0+IHtcbiAgY29uc3QgeFJhbmdlID0gZ2V0UmFuZ2Uoc3RhcnRYLCBlbmRYKVxuICBjb25zdCB5UmFuZ2UgPSBnZXRSYW5nZShzdGFydFksIGVuZFkpXG5cbiAgcmV0dXJuIHhSYW5nZS5yZWR1Y2UoKHBvc2l0aW9ucywgeCkgPT4ge1xuICAgIGNvbnN0IG5ld1Bvc2l0aW9ucyA9IHlSYW5nZS5tYXAoeSA9PiBbeCwgeV0pXG4gICAgcmV0dXJuIHBvc2l0aW9ucy5jb25jYXQobmV3UG9zaXRpb25zKVxuICB9LCBbXSlcbn1cblxuZnVuY3Rpb24gZ2V0UmFuZ2UoYSwgYikge1xuICBjb25zdCBtYXBwZXIgPSBhIDwgYlxuICAgID8gKF8sIGlkeCkgPT4gaWR4ICsgYVxuICAgIDogKF8sIGlkeCkgPT4gYSAtIGlkeFxuXG4gIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBNYXRoLmFicyhhIC0gYikgKyAxIH0pLm1hcChtYXBwZXIpXG59XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdTd2l0Y2ggPSAoaW5wdXQsIGNhc2VzRm4sIG9wdGlvbnMpID0+IHtcbiAgdmFsaWRhdGVTdHJpbmdTd2l0Y2hBcmdzKHsgaW5wdXQsIGNhc2VzRm4gfSlcblxuICBjb25zdCBjYXNlQXJnUGFyc2VyID0gKGFyZ3MpID0+IHN0cmluZ1N3aXRjaENhc2VBcmdQYXJzZXIoaW5wdXQsIGFyZ3MpXG4gIHJldHVybiBiYXNlU3dpdGNoKGNhc2VBcmdQYXJzZXIsIGNhc2VzRm4sIG9wdGlvbnMpXG59XG5cbmV4cG9ydCBjb25zdCBmdW5jU3dpdGNoID0gKGlucHV0LCBjb21wYXJhdG9yLCBjYXNlc0ZuLCBvcHRpb25zKSA9PiB7XG4gIHZhbGlkYXRlRnVuY1N3aXRjaEFyZ3MoeyBjb21wYXJhdG9yLCBjYXNlc0ZuIH0pXG4gIGNvbnN0IGNhc2VBcmdQYXJzZXIgPSAoYXJncykgPT4gZnVuY1N3aXRjaENhc2VBcmdQYXJzZXIoaW5wdXQsIGNvbXBhcmF0b3IsIGFyZ3MpXG4gIHJldHVybiBiYXNlU3dpdGNoKGNhc2VBcmdQYXJzZXIsIGNhc2VzRm4sIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGJhc2VTd2l0Y2goXG4gIGNhc2VBcmdQYXJzZXIsXG4gIGNhc2VzRm4sXG4gIHtcbiAgICBmYWxsdGhyb3VnaCA9IGZhbHNlLFxuICAgIG11bHRpcGxlTWF0Y2hlcyA9IGZhbHNlXG4gIH0gPSB7fVxuKSB7XG4gIGxldCBtYXRjaGVkID0gZmFsc2VcbiAgbGV0IHJlc3VsdFxuXG4gIGZ1bmN0aW9uIF9jYXNlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB7IGV4ZWMsIGlzTWF0Y2ggfSA9IGNhc2VBcmdQYXJzZXIoYXJncylcblxuICAgIGNvbnN0IHNob3VsZEV4ZWNCeU1hdGNoID0gaXNNYXRjaCgpICYmICghbWF0Y2hlZCB8fCBtdWx0aXBsZU1hdGNoZXMpXG4gICAgY29uc3Qgc2hvdWxkRXhlY0J5RmFsbHRocm91Z2ggPSBtYXRjaGVkICYmIGZhbGx0aHJvdWdoXG5cbiAgICBpZiAoc2hvdWxkRXhlY0J5TWF0Y2ggfHwgc2hvdWxkRXhlY0J5RmFsbHRocm91Z2gpIHtcbiAgICAgIG1hdGNoZWQgPSB0cnVlXG4gICAgICByZXN1bHQgPSBleGVjKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmYXVsdChleGVjKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IHRvIGRlZmF1bHQgZnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoIW1hdGNoZWQgfHwgZmFsbHRocm91Z2gpIHtcbiAgICAgIHJlc3VsdCA9IGV4ZWMoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbnN1cmUoZXhlYykge1xuICAgIGlmICh0eXBlb2YgZXhlYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCB0byBlbnN1cmUgZnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG5cbiAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgZXhlYygpXG4gICAgfVxuICB9XG5cbiAgY2FzZXNGbih7IF9jYXNlLCBfZGVmYXVsdCwgX2Vuc3VyZSB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nU3dpdGNoQXJncyh7IGlucHV0LCBjYXNlc0ZuIH0pIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHN0cmluZ1N3aXRjaCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2FzZXNGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignU2Vjb25kIGFyZ3VtZW50IHRvIHN0cmluZ1N3aXRjaCBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY1N3aXRjaEFyZ3MoeyBjb21wYXJhdG9yLCBjYXNlc0ZuIH0pIHtcbiAgaWYgKHR5cGVvZiBjb21wYXJhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTZWNvbmQgYXJndW1lbnQgdG8gZnVuY1N3aXRjaCBtdXN0IGJlIGEgY29tcGFyYXRvciBmdW5jdGlvbicpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGNhc2VzRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXJkIGFyZ3VtZW50IHRvIGZ1bmNTd2l0Y2ggbXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyB5b3VyIGNhc2Ugc3RhdGVtZW50cycpXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5nU3dpdGNoQ2FzZUFyZ1BhcnNlcihpbnB1dCwgYXJncykge1xuICBjb25zdCBleGVjID0gYXJncy5wb3AoKVxuICBpZiAodHlwZW9mIGV4ZWMgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xhc3QgYXJndW1lbnQgdG8gY2FzZSBmdW5jdGlvbiBtdXN0IGJlIGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSBpZiB0aGUgY2FzZSBtYXRjaGVzJylcbiAgfVxuXG4gIGNvbnN0IGlzTWF0Y2ggPSAoKSA9PiBhcmdzLmV2ZXJ5KG1hdGNoZXIgPT4gcGFyc2VNYXRjaGVyKG1hdGNoZXIpKGlucHV0KSlcbiAgcmV0dXJuIHsgZXhlYywgaXNNYXRjaCB9XG59XG5cbmZ1bmN0aW9uIGZ1bmNTd2l0Y2hDYXNlQXJnUGFyc2VyKGlucHV0LCBjb21wYXJhdG9yLCBhcmdzKSB7XG4gIGNvbnN0IGV4ZWMgPSBhcmdzLnBvcCgpXG4gIGlmICh0eXBlb2YgZXhlYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignTGFzdCBhcmd1bWVudCB0byBjYXNlIGZ1bmN0aW9uIG11c3QgYmUgYSBjYWxsYmFjayB0byBleGVjdXRlIGlmIHRoZSBjYXNlIG1hdGNoZXMnKVxuICB9XG5cbiAgY29uc3QgaXNNYXRjaCA9ICgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgY29tcGFyYXRvcihpbnB1dCwgLi4uYXJnc1swXSlcbiAgICAgICYmIGFyZ3Muc2xpY2UoMSkuZXZlcnkobWF0Y2hlciA9PiBwYXJzZU1hdGNoZXIobWF0Y2hlcikoaW5wdXQpKVxuICAgIClcbiAgfVxuXG4gIHJldHVybiB7IGV4ZWMsIGlzTWF0Y2ggfVxufVxuXG5mdW5jdGlvbiBwYXJzZU1hdGNoZXIobWF0Y2hlcikge1xuICBjb25zdCBpc01hdGNoZXJUeXBlID0gKHR5cGUpID0+IG1hdGNoZXIgaW5zdGFuY2VvZiB0eXBlXG5cbiAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBpbnB1dCA9PiBtYXRjaGVyID09PSBpbnB1dFxuICB9IGVsc2UgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gKCkgPT4gbWF0Y2hlclxuICB9IGVsc2UgaWYgKGlzTWF0Y2hlclR5cGUoUmVnRXhwKSkge1xuICAgIHJldHVybiBpbnB1dCA9PiBtYXRjaGVyLnRlc3QoaW5wdXQpXG4gIH0gZWxzZSBpZiAoaXNNYXRjaGVyVHlwZShBcnJheSkpIHtcbiAgICByZXR1cm4gaW5wdXQgPT4gbWF0Y2hlci5zb21lKHN1YiA9PiBwYXJzZU1hdGNoZXIoc3ViKShpbnB1dCkpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNYXRjaGVyIGFyZ3VtZW50cyB0byBjYXNlIGZ1bmN0aW9uIG11c3QgYmUgYSBzdHJpbmcsIHJlZ3VsYXIgZXhwcmVzc2lvbiwgYm9vbGVhbiwgb3IgYXJyYXkgb2Ygc3VjaC4gSW5zdGVhZCwgcmVjZWl2ZWQgJHttYXRjaGVyfWApXG4gIH1cbn1cbiIsImNvbnN0IG5ld05vZGUgPSAob3B0aW9ucykgPT4gKHtcbiAga2V5OiBudWxsLFxuICB2YWx1ZTogbnVsbCxcbiAgcHJldjogbnVsbCxcbiAgbmV4dDogbnVsbCxcbiAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCksXG4gIC4uLm9wdGlvbnMsXG59KVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMUlVDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKG1heCwgdGltZUJlZm9yZUNsZWFyID0gbnVsbCkge1xuICAgIHRoaXMubWF4ID0gbWF4XG4gICAgdGhpcy5oZWFkID0gbmV3Tm9kZSgpXG4gICAgdGhpcy50YWlsID0gbmV3Tm9kZSgpXG4gICAgdGhpcy50aW1lQmVmb3JlQ2xlYXIgPSB0aW1lQmVmb3JlQ2xlYXJcblxuICAgIHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLl9yZW1vdmVCZWZvcmUodGhpcy50aW1lQmVmb3JlQ2xlYXIpXG4gICAgfSwgMTAwMDApXG5cbiAgICB0aGlzLnJlc2V0KClcbiAgfVxuXG4gIGdldChrZXkpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5tYXBba2V5XVxuICAgIGlmIChub2RlKSBub2RlLmxhc3RVcGRhdGVkID0gbmV3IERhdGUoKVxuICAgIHJldHVybiBub2RlPy52YWx1ZVxuICB9XG5cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBwcmV2aW91c0xhc3QgPSB0aGlzLnRhaWwucHJldlxuXG4gICAgY29uc3Qgbm9kZSA9IG5ld05vZGUoe1xuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBwcmV2OiBwcmV2aW91c0xhc3QsXG4gICAgICBuZXh0OiB0aGlzLnRhaWxcbiAgICB9KVxuXG4gICAgcHJldmlvdXNMYXN0Lm5leHQgPSBub2RlXG4gICAgdGhpcy50YWlsLnByZXYgPSBub2RlXG5cbiAgICB0aGlzLnNpemUrK1xuICAgIGlmICh0aGlzLnNpemUgPiB0aGlzLm1heCkgdGhpcy5fcmVtb3ZlT2xkZXN0KClcblxuICAgIHRoaXMubWFwW2tleV0gPSBub2RlXG4gICAgcmV0dXJuIG5vZGU/LnZhbHVlXG4gIH1cblxuICByZW1vdmUoa2V5KSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMubWFwW2tleV1cbiAgICByZXR1cm4gdGhpcy5fcmVtb3ZlKG5vZGUpXG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG4gICAgdGhpcy5zaXplID0gMFxuXG4gICAgdGhpcy5oZWFkLm5leHQgPSB0aGlzLnRhaWxcbiAgICB0aGlzLnRhaWwucHJldiA9IHRoaXMuaGVhZFxuICB9XG5cbiAgX3JlbW92ZShub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgbm9kZSAhPT0gdGhpcy5oZWFkICYmIG5vZGUgIT09IHRoaXMudGFpbCkge1xuICAgICAgY29uc3QgeyBwcmV2OiBiZWZvcmVOb2RlLCBuZXh0OiBhZnRlck5vZGUgfSA9IG5vZGVcbiAgICAgIGJlZm9yZU5vZGUubmV4dCA9IGFmdGVyTm9kZVxuICAgICAgYWZ0ZXJOb2RlLnByZXYgPSBiZWZvcmVOb2RlXG4gICAgICB0aGlzLnNpemUtLVxuXG4gICAgICBkZWxldGUgdGhpcy5tYXBbbm9kZS5rZXldXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU/LnZhbHVlXG4gIH1cblxuICBfcmVtb3ZlT2xkZXN0KCkge1xuICAgIGNvbnN0IG9sZGVzdCA9IHRoaXMuaGVhZC5uZXh0XG4gICAgcmV0dXJuIHRoaXMuX3JlbW92ZShvbGRlc3QpXG4gIH1cblxuICBfcmVtb3ZlQmVmb3JlKG1zKSB7XG4gICAgaWYgKCFtcykgcmV0dXJuXG5cbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgY29uc3QgbmV3TWFwID0ge31cbiAgICBsZXQgdmFsaWROb2RlID0gdGhpcy5oZWFkXG5cbiAgICB3aGlsZSAoXG4gICAgICB2YWxpZE5vZGUubmV4dCAhPT0gdGhpcy50YWlsXG4gICAgICAmJiAobm93IC0gdmFsaWROb2RlLm5leHQubGFzdFVwZGF0ZWQpIDwgbXNcbiAgICApIHtcbiAgICAgIHZhbGlkTm9kZSA9IHZhbGlkTm9kZS5uZXh0XG4gICAgICBuZXdNYXBbdmFsaWROb2RlLmtleV0gPSB2YWxpZE5vZGVcbiAgICB9XG5cbiAgICB2YWxpZE5vZGUubmV4dCA9IHRoaXMudGFpbFxuICAgIHRoaXMudGFpbC5wcmV2ID0gdmFsaWROb2RlXG4gICAgdGhpcy5tYXAgPSBuZXdNYXBcbiAgfVxufSIsImltcG9ydCB7IGFwcGx5U3R5bGUsIGNyZWF0ZVNWR0VsZW1lbnQsIGdldFRlbXBsYXRlQnlJZCB9IGZyb20gXCIuL2RvbV91dGlsXCJcbmltcG9ydCB7IGFyZUVxdWFsQXJyYXlzLCBzdHJpbmdTd2l0Y2ggfSBmcm9tIFwiLi9nZW5lcmFsX3V0aWxcIlxuXG5jb25zdCBjbG9ja3dpc2VPcmRlciA9IFtcbiAgJ3RvcCcsXG4gICdyaWdodCcsXG4gICdib3R0b20nLFxuICAnbGVmdCcsXG5dXG5cbmNvbnN0IHNpZGVTaWducyA9IHtcbiAgdG9wOiAtMSxcbiAgcmlnaHQ6IDEsXG4gIGJvdHRvbTogMSxcbiAgbGVmdDogLTEsXG59XG5cbmNvbnN0IG92ZXJmbG93UHggPSAyMFxuXG5jbGFzcyBTcG90bGlnaHQge1xuICBzdGF0aWMgZnJvbUVsZXMoZWxlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3BvdGxpZ2h0KHsgZWxlcywgLi4ub3B0aW9ucyB9KVxuICB9XG5cbiAgc3RhdGljIGZyb21FbGUoZWxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTcG90bGlnaHQoeyBlbGVzOiBbZWxlXSwgLi4ub3B0aW9ucyB9KVxuICB9XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbihcbiAgICAgIHRoaXMsXG4gICAgICB7XG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIGJsdXI6IDIsXG4gICAgICAgIGNhcHRpb25PZmZzZXRYOiAwLFxuICAgICAgICBjYXB0aW9uT2Zmc2V0WTogMCxcbiAgICAgICAgY2FwdGlvblBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICBvblNob3c6ICgpID0+ICgpID0+IHsgfSxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKVxuXG4gICAgdGhpcy5nZW5lcmF0ZSgpXG4gIH1cblxuICBnZW5lcmF0ZSgpIHtcbiAgICB0aGlzLmJvdW5kcyA9IHRoaXMuZWxlcy5tYXAoKGVsZSwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5wYWRkaW5nIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgPyB0aGlzLnBhZGRpbmdbaWR4XVxuICAgICAgICA6IHRoaXMucGFkZGluZ1xuXG4gICAgICByZXR1cm4gZ2V0UGFkZGVkQm91bmRpbmdSZWN0KGVsZSwgcGFkZGluZylcbiAgICB9KVxuXG4gICAgdGhpcy5zdWJQYXRocyA9IFtdXG4gICAgdGhpcy52aXNpdGVkID0ge31cbiAgICB0aGlzLl9hbmNob3JCb3VuZHMgPSBudWxsXG5cbiAgICBsZXQgaSA9IDBcbiAgICB3aGlsZSAoIXRoaXMuaXNDb21wbGV0ZSAmJiBpIDwgNSkge1xuICAgICAgdGhpcy5fYWRkTmV4dFN1YlBhdGgoKVxuICAgICAgaSsrXG4gICAgfVxuICB9XG5cbiAgX2FkZE5leHRTdWJQYXRoKCkge1xuICAgIGNvbnN0IHN1YlBhdGggPSBbXVxuICAgIHRoaXMuX2JlZ2luU3ViUGF0aChzdWJQYXRoKVxuXG4gICAgbGV0IGkgPSAwXG4gICAgd2hpbGUgKCF0aGlzLl9pc0NvbXBsZXRlU3ViUGF0aChzdWJQYXRoKSAmJiBpIDwgMTAwKSB7XG4gICAgICB0aGlzLl9hZGROZXh0UG9pbnQoc3ViUGF0aClcbiAgICAgIGkrK1xuICAgIH1cblxuICAgIGNvbnN0IG92ZXJmbG93T2Zmc2V0U3ViUGF0aCA9IHN1YlBhdGgubWFwKHBvaW50ID0+XG4gICAgICBwb2ludC5tYXAoaSA9PiBpICsgb3ZlcmZsb3dQeCAvIDIpXG4gICAgKVxuXG4gICAgdGhpcy5zdWJQYXRocy5wdXNoKG92ZXJmbG93T2Zmc2V0U3ViUGF0aClcbiAgfVxuXG4gIF9hZGROZXh0UG9pbnQoc3ViUGF0aCkge1xuICAgIGNvbnN0IFtzdGF0aWNJZHgsIGNoYW5naW5nSWR4XSA9XG4gICAgICBzdHJpbmdTd2l0Y2godGhpcy5jdXJCb3VuZFNpZGUsICh7IF9jYXNlIH0pID0+IHtcbiAgICAgICAgX2Nhc2UoWydsZWZ0JywgJ3JpZ2h0J10sICgpID0+IFswLCAxXSlcbiAgICAgICAgX2Nhc2UoWyd0b3AnLCAnYm90dG9tJ10sICgpID0+IFsxLCAwXSlcbiAgICAgIH0pXG5cbiAgICBjb25zdCBjdXJQb2ludCA9IHRoaXMuX2dldExhc3RQb2ludChzdWJQYXRoKVxuICAgIGNvbnN0IGN1clN0YXRpY0RpbSA9IGN1clBvaW50W3N0YXRpY0lkeF1cbiAgICBjb25zdCBjdXJDaGFuZ2luZ0RpbSA9IGN1clBvaW50W2NoYW5naW5nSWR4XVxuXG4gICAgY29uc3QgbmV4dEN1ckJvdW5kU2lkZSA9IGdldE5leHRTaWRlKHRoaXMuY3VyQm91bmRTaWRlKVxuICAgIGxldCBjbG9zZXN0RGltID0gdGhpcy5fZ2V0RGltKHRoaXMuY3VyQm91bmRJZHgsIG5leHRDdXJCb3VuZFNpZGUpXG5cbiAgICBpZiAoY3VyQ2hhbmdpbmdEaW0gPT09IGNsb3Nlc3REaW0pIHtcbiAgICAgIHRoaXMuY3VyQm91bmRTaWRlID0gbmV4dEN1ckJvdW5kU2lkZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGNsb3Nlc3RCb3VuZElkeCA9IHRoaXMuY3VyQm91bmRJZHhcbiAgICBjb25zdCBpbnRlcmNlcHRTaWRlID0gZ2V0T3Bwb3NpdGVTaWRlKG5leHRDdXJCb3VuZFNpZGUpXG5cbiAgICB0aGlzLmJvdW5kc0luZGljZXMuZm9yRWFjaChpZHggPT4ge1xuICAgICAgY29uc3QgW3N0YXRpY0RpbUxvd2VyLCBzdGF0aWNEaW1VcHBlcl0gPVxuICAgICAgICB0aGlzLl9nZXRPdGhlckRpbVJhbmdlKGlkeCwgaW50ZXJjZXB0U2lkZSlcblxuICAgICAgaWYgKGN1clN0YXRpY0RpbSA8IHN0YXRpY0RpbUxvd2VyIHx8IGN1clN0YXRpY0RpbSA+IHN0YXRpY0RpbVVwcGVyKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnRlcmNlcHREaW0gPSB0aGlzLl9nZXREaW0oaWR4LCBpbnRlcmNlcHRTaWRlKVxuXG4gICAgICBpZiAoXG4gICAgICAgIE1hdGguc2lnbihpbnRlcmNlcHREaW0gLSBjdXJDaGFuZ2luZ0RpbSkgPT09IHNpZGVTaWduc1tuZXh0Q3VyQm91bmRTaWRlXVxuICAgICAgICAmJiBNYXRoLnNpZ24oY2xvc2VzdERpbSAtIGludGVyY2VwdERpbSkgPT09IHNpZGVTaWduc1tuZXh0Q3VyQm91bmRTaWRlXVxuICAgICAgKSB7XG4gICAgICAgIGNsb3Nlc3REaW0gPSBpbnRlcmNlcHREaW1cbiAgICAgICAgY2xvc2VzdEJvdW5kSWR4ID0gaWR4XG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IG5leHRQb2ludCA9IFtudWxsLCBudWxsXVxuICAgIG5leHRQb2ludFtzdGF0aWNJZHhdID0gY3VyU3RhdGljRGltXG4gICAgbmV4dFBvaW50W2NoYW5naW5nSWR4XSA9IGNsb3Nlc3REaW1cblxuICAgIC8vIHNpZGUgZWZmZWN0c1xuICAgIHN1YlBhdGgucHVzaChuZXh0UG9pbnQpXG4gICAgdGhpcy52aXNpdGVkW2Nsb3Nlc3RCb3VuZElkeF0gPSB0cnVlXG4gICAgdGhpcy5jdXJCb3VuZFNpZGUgPSBjbG9zZXN0Qm91bmRJZHggIT09IHRoaXMuY3VyQm91bmRJZHhcbiAgICAgID8gaW50ZXJjZXB0U2lkZVxuICAgICAgOiBuZXh0Q3VyQm91bmRTaWRlXG4gICAgdGhpcy5jdXJCb3VuZElkeCA9IGNsb3Nlc3RCb3VuZElkeFxuICB9XG5cbiAgX2dldERpbShib3VuZE9ySWR4LCBzaWRlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBib3VuZE9ySWR4ID09PSAnbnVtYmVyJ1xuICAgICAgPyB0aGlzLmJvdW5kc1tib3VuZE9ySWR4XVtzaWRlXVxuICAgICAgOiBib3VuZE9ySWR4W3NpZGVdXG4gIH1cblxuICBfZ2V0TmV4dEJvdW5kSWR4KCkge1xuICAgIHJldHVybiB0aGlzLmJvdW5kc0luZGljZXMuZmluZChpZHggPT4gIXRoaXMudmlzaXRlZFtpZHhdKVxuICB9XG5cbiAgX2JlZ2luU3ViUGF0aChzdWJQYXRoKSB7XG4gICAgdGhpcy5jdXJCb3VuZElkeCA9IHRoaXMuX2dldE5leHRCb3VuZElkeCgpXG4gICAgdGhpcy52aXNpdGVkW3RoaXMuY3VyQm91bmRJZHhdID0gdHJ1ZVxuXG4gICAgdGhpcy5jdXJCb3VuZFNpZGUgPSAndG9wJ1xuXG4gICAgY29uc3QgeyBsZWZ0LCB0b3AgfSA9IHRoaXMuY3VyQm91bmRcbiAgICBzdWJQYXRoLnB1c2goW2xlZnQsIHRvcF0pXG4gIH1cblxuICBfZ2V0Rmlyc3RQb2ludChzdWJQYXRoKSB7XG4gICAgcmV0dXJuIHN1YlBhdGhbMF1cbiAgfVxuXG4gIF9nZXRMYXN0UG9pbnQoc3ViUGF0aCkge1xuICAgIHJldHVybiBzdWJQYXRoW3N1YlBhdGgubGVuZ3RoIC0gMV1cbiAgfVxuXG4gIF9nZXRPdGhlckRpbVJhbmdlKGJvdW5kSWR4LCBzaWRlKSB7XG4gICAgY29uc3QgYm91bmQgPSB0aGlzLmJvdW5kc1tib3VuZElkeF1cblxuICAgIHJldHVybiBzdHJpbmdTd2l0Y2goc2lkZSwgKHsgX2Nhc2UgfSkgPT4ge1xuICAgICAgX2Nhc2UoWydsZWZ0JywgJ3JpZ2h0J10sICgpID0+IFtib3VuZC50b3AsIGJvdW5kLmJvdHRvbV0pXG4gICAgICBfY2FzZShbJ3RvcCcsICdib3R0b20nXSwgKCkgPT4gW2JvdW5kLmxlZnQsIGJvdW5kLnJpZ2h0XSlcbiAgICB9KVxuICB9XG5cbiAgX2lzQ29tcGxldGVTdWJQYXRoKHN1YlBhdGgpIHtcbiAgICByZXR1cm4gc3ViUGF0aC5sZW5ndGggPiAxICYmIGFyZUVxdWFsQXJyYXlzKFxuICAgICAgdGhpcy5fZ2V0Rmlyc3RQb2ludChzdWJQYXRoKSxcbiAgICAgIHRoaXMuX2dldExhc3RQb2ludChzdWJQYXRoKVxuICAgIClcbiAgfVxuXG4gIF9nZXRTdWJQYXRoRChzdWJQYXRoKSB7XG4gICAgY29uc3QgbSA9IGBNICR7c3ViUGF0aFswXS5qb2luKCl9YFxuICAgIGNvbnN0IGwgPSBgTCAke3N1YlBhdGguc2xpY2UoMSkubWFwKHAgPT4gcC5qb2luKCkpLmpvaW4oJyAnKX1gXG4gICAgcmV0dXJuIGAke219ICR7bH1gXG4gIH1cblxuICBnZXREKHZidywgdmJoKSB7XG4gICAgcmV0dXJuIGBNIDAsMCBMICR7dmJ3fSwwICR7dmJ3fSwke3ZiaH0gMCwke3ZiaH0gMCwwICR7dGhpcy5pbm5lclBhdGh9YFxuICB9XG4gIC8vIGdldEQodmJ3LCB2YmgpIHtcbiAgLy8gICBjb25zdCBnZXRTdWJQYXRoRCA9IHRoaXMuYm9yZGVyUmFkaXVzXG4gIC8vICAgICA/IHRoaXMuX2dldFJvdW5kZWRTdWJQYXRoRFxuICAvLyAgICAgOiB0aGlzLl9nZXRTdWJQYXRoRFxuXG4gIC8vICAgY29uc3Qgb3V0ZXJQYXRoID0gYE0gMCwwIEwgJHt2Ynd9LDAgJHt2Ynd9LCR7dmJofSAwLCR7dmJofSAwLDBgXG4gIC8vICAgY29uc3QgaW5uZXJQYXRocyA9IHRoaXMuc3ViUGF0aHMubWFwKGdldFN1YlBhdGhELmJpbmQodGhpcykpLmpvaW4oJyAnKVxuICAvLyAgIHJldHVybiBgJHtvdXRlclBhdGh9ICR7aW5uZXJQYXRoc30gemBcbiAgLy8gfVxuXG4gIHVwZGF0ZVNWRyh7XG4gICAgZWxlbWVudDogc3ZnLFxuICAgIHJlZ2VuZXJhdGUgPSB0cnVlLFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXN2ZykgcmV0dXJuXG4gICAgaWYgKHJlZ2VuZXJhdGUpIHRoaXMuZ2VuZXJhdGUoKVxuXG4gICAgY29uc3QgdmJ3ID0gd2luZG93LmlubmVyV2lkdGggKyBvdmVyZmxvd1B4XG4gICAgY29uc3QgdmJoID0gd2luZG93LmlubmVySGVpZ2h0ICsgb3ZlcmZsb3dQeFxuXG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIGAwIDAgJHt2Ynd9ICR7dmJofWApXG4gICAgc3ZnLnF1ZXJ5U2VsZWN0b3IoJ3BhdGgnKS5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLmdldEQodmJ3LCB2YmgpKVxuICAgIHN2Zy5xdWVyeVNlbGVjdG9yKCdmZUdhdXNzaWFuQmx1cicpLnNldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJywgdGhpcy5ibHVyKVxuICAgIHJldHVybiBzdmdcbiAgfVxuXG4gIHVwZGF0ZUNhcHRpb24oe1xuICAgIGVsZW1lbnQ6IGNhcHRpb24sXG4gICAgcmVnZW5lcmF0ZSA9IHRydWUsXG4gIH0gPSB7fSkge1xuICAgIGlmICghY2FwdGlvbikgcmV0dXJuXG4gICAgaWYgKHJlZ2VuZXJhdGUpIHRoaXMuZ2VuZXJhdGUoKVxuXG4gICAgYXBwbHlTdHlsZShjYXB0aW9uLCB0aGlzLmNhcHRpb25TdHlsZSwgdHJ1ZSlcblxuICAgIHJldHVybiBjYXB0aW9uXG4gIH1cbiAgLy8wIDAgMVxuXG4gIF9nZXRSb3VuZGVkU3ViUGF0aEQoc3ViUGF0aCkge1xuICAgIC8vIGNvbnN0IG0gPSBgTSAke3RoaXMuX2dldE51ZGdlZFBvaW50KHN1YlBhdGhbMF0sIHN1YlBhdGhbMV0pfWBcbiAgICBjb25zdCBob29rUG9pbnRzID0gWy4uLnN1YlBhdGgsIHN1YlBhdGhbMV1dXG4gICAgY29uc3QgcGF0aFBhcnRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogaG9va1BvaW50cy5sZW5ndGggLSAyIH0pXG4gICAgICAucmVkdWNlKChwYXJ0cywgXywgaWR4KSA9PiBwYXJ0cy5jb25jYXQodGhpcy5fZ2V0UGF0aEhvb2soaG9va1BvaW50cy5zbGljZShpZHgsIGlkeCArIDMpKSksIFtdKVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICdNJywgcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXSwgLi4ucGF0aFBhcnRzXG4gICAgXS5qb2luKCcgJylcblxuICAgIHJldHVybiBgJHttfSAke2hvb2tzLmpvaW4oJyAnKX1gXG4gIH1cblxuICBfZ2V0UGF0aEhvb2soW3ByZXYsIGN1ciwgbmV4dF0pIHtcbiAgICAvLyBjb25zdCBbc3RhcnRQb2ludCwgZW5kUG9pbnRdID0gdGhpcy5fZ2V0TnVkZ2VkUG9pbnRzKHByZXYsIGN1ciwgbmV4dClcbiAgICAvLyBjb25zdCAgPSB0aGlzLl9nZXROdWRnZWRQb2ludChjdXIsIG5leHQpXG4gICAgY29uc3Qgc3RhcnRQb2ludCA9IHRoaXMuX2dldE51ZGdlZFBvaW50KGN1ciwgcHJldilcbiAgICBjb25zdCBlbmRQb2ludCA9IHRoaXMuX2dldE51ZGdlZFBvaW50KGN1ciwgbmV4dClcbiAgICBjb25zdCByYWRpaSA9IGdldEFic0RpZmYoc3RhcnRQb2ludCwgZW5kUG9pbnQpXG5cbiAgICBjb25zdCBjbG9ja3dpc2UgPVxuICAgICAgTWF0aC5zaWduKG5leHRbMV0gLSBwcmV2WzFdKVxuICAgICAgPT09IE1hdGguc2lnbihjdXJbMF0gKiAyIC0gcHJldlswXSAtIG5leHRbMF0pXG5cbiAgICAvLyAgIGNvbnN0IGwgPSBgTCAke3N0YXJ0UG9pbnQuam9pbigpfWBcbiAgICAvLyBjb25zdCBhID0gYEEgJHtyYWRpaS5qb2luKCcgJyl9IDAgMCAke2Nsb2Nrd2lzZSA/ICcxJyA6ICcwJ30gJHtlbmRQb2ludC5qb2luKCcgJyl9YFxuICAgIC8vIHJldHVybiBgJHtsfSAke2F9YFxuICAgIHJldHVybiBbXG4gICAgICAnTCcsIHN0YXJ0UG9pbnQsXG4gICAgICAnQScsIHJhZGlpLCAwLCAwLCBjbG9ja3dpc2UgPyAxIDogMCwgZW5kUG9pbnRcbiAgICBdXG4gIH1cblxuICBfZ2V0TnVkZ2VkUG9pbnQoYSwgYikge1xuICAgIHJldHVybiBbMCwgMV0ubWFwKGkgPT4ge1xuICAgICAgY29uc3QgZGlmZiA9IGJbaV0gLSBhW2ldXG4gICAgICBjb25zdCBtYWcgPSBNYXRoLm1pbih0aGlzLmJvcmRlclJhZGl1cywgTWF0aC5hYnMoZGlmZikgLyAyKVxuICAgICAgcmV0dXJuIGFbaV0gKyBtYWcgKiBNYXRoLnNpZ24oZGlmZilcbiAgICB9KVxuICB9XG5cbiAgLy8gX2dldE51ZGdlZFBvaW50cyhwcmV2LCBjdXIsIG5leHQpIHtcbiAgLy8gICBsZXQgbWFnID0gdGhpcy5ib3JkZXJSYWRpdXNcbiAgLy8gICBjb25zdCBkaXJzID0gW3ByZXYsIG5leHRdLm1hcChwb3MgPT5cbiAgLy8gICAgIFswLCAxXS5tYXAoaSA9PiB7XG4gIC8vICAgICAgIGNvbnN0IGRpZmYgPSBwb3NbaV0gLSBjdXJbaV1cblxuICAvLyAgICAgICBjb25zdCBtYXhEaWZmUmFkaXVzID0gTWF0aC5hYnMoZGlmZikgLyAyXG4gIC8vICAgICAgIGlmIChtYXhEaWZmUmFkaXVzID4gMCAmJiBtYXhEaWZmUmFkaXVzIDwgbWFnKSB7XG4gIC8vICAgICAgICAgbWFnID0gbWF4RGlmZlJhZGl1c1xuICAvLyAgICAgICB9XG5cbiAgLy8gICAgICAgcmV0dXJuIE1hdGguc2lnbihkaWZmKVxuICAvLyAgICAgfSlcbiAgLy8gICApXG4gIC8vICAgcmV0dXJuIGRpcnMubWFwKGRpciA9PiBkaXIubWFwKChzaWduLCBpZHgpID0+IGN1cltpZHhdICsgc2lnbiAqIG1hZykpXG4gIC8vICAgY29uc3QgcHJldkRpciA9IFswLCAxXS5tYXAoaSA9PiBNYXRoLnNpZ24ocHJldltpXSAtIGN1cltpXSkpXG4gIC8vICAgY29uc3QgbmV4dERpciA9IFswLCAxXS5tYXAoaSA9PiBNYXRoLnNpZ24obmV4dFtpXSAtIGN1cltpXSkpXG5cbiAgLy8gICByZXR1cm4gWzAsIDFdLm1hcChpID0+IHtcbiAgLy8gICAgIGNvbnN0IGRpZmYgPSBiW2ldIC0gYVtpXVxuICAvLyAgICAgY29uc3QgbWFnID0gTWF0aC5taW4odGhpcy5ib3JkZXJSYWRpdXMsIE1hdGguYWJzKGRpZmYpIC8gMilcbiAgLy8gICAgIHJldHVybiBhW2ldICsgbWFnICogTWF0aC5zaWduKGRpZmYpXG4gIC8vICAgfSlcbiAgLy8gfVxuXG4gIGdldCBpbm5lclBhdGgoKSB7XG4gICAgY29uc3QgZ2V0U3ViUGF0aEQgPSB0aGlzLmJvcmRlclJhZGl1c1xuICAgICAgPyB0aGlzLl9nZXRSb3VuZGVkU3ViUGF0aERcbiAgICAgIDogdGhpcy5fZ2V0U3ViUGF0aERcblxuICAgIHJldHVybiB0aGlzLnN1YlBhdGhzLm1hcChnZXRTdWJQYXRoRC5iaW5kKHRoaXMpKS5qb2luKCcgJykgKyAnIHonXG4gIH1cblxuICBnZXQgYW5jaG9yQm91bmRzKCkge1xuICAgIGlmICghdGhpcy5fYW5jaG9yQm91bmRzKSB7XG4gICAgICBpZiAodGhpcy5ib3VuZHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgdGhpcy5hbmNob3JFbGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuX2FuY2hvckJvdW5kcyA9IHRoaXMuYm91bmRzW3RoaXMuYW5jaG9yRWxlXVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmJvdW5kcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMuX2FuY2hvckJvdW5kcyA9IHRoaXMuYm91bmRzLnJlZHVjZSgoYW5jaG9yQm91bmRzLCBib3VuZCkgPT4gKHtcbiAgICAgICAgICB0b3A6IE1hdGgubWluKGFuY2hvckJvdW5kcy50b3AsIGJvdW5kLnRvcCksXG4gICAgICAgICAgbGVmdDogTWF0aC5taW4oYW5jaG9yQm91bmRzLmxlZnQsIGJvdW5kLmxlZnQpLFxuICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChhbmNob3JCb3VuZHMucmlnaHQsIGJvdW5kLnJpZ2h0KSxcbiAgICAgICAgICBib3R0b206IE1hdGgubWF4KGFuY2hvckJvdW5kcy5ib3R0b20sIGJvdW5kLmJvdHRvbSksXG4gICAgICAgIH0pKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYW5jaG9yQm91bmRzID0gdGhpcy5ib3VuZHNbMF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fYW5jaG9yQm91bmRzXG4gIH1cblxuICBnZXQgcG9zaXRpb25TdHlsZXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdG9wOiBib3VuZHNUb3AsXG4gICAgICByaWdodDogYm91bmRzUmlnaHQsXG4gICAgICBsZWZ0OiBib3VuZHNMZWZ0LFxuICAgICAgYm90dG9tOiBib3VuZHNCb3R0b20sXG4gICAgfSA9IHRoaXMuYW5jaG9yQm91bmRzXG5cbiAgICBjb25zdCB1cHBlclRvcCA9IHRvUGl4ZWxzKGJvdW5kc1RvcClcbiAgICBjb25zdCBtaWRUb3AgPSB0b1BpeGVscygoYm91bmRzVG9wICsgYm91bmRzQm90dG9tKSAvIDIpXG4gICAgY29uc3QgbG93ZXJUb3AgPSB0b1BpeGVscyhib3VuZHNCb3R0b20pXG4gICAgY29uc3Qgc3RhcnRMZWZ0ID0gdG9QaXhlbHMoYm91bmRzTGVmdClcbiAgICBjb25zdCBtaWRMZWZ0ID0gdG9QaXhlbHMoKGJvdW5kc0xlZnQgKyBib3VuZHNSaWdodCkgLyAyKVxuICAgIGNvbnN0IGVuZExlZnQgPSB0b1BpeGVscyhib3VuZHNSaWdodClcblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHsgdG9wOiB1cHBlclRvcCwgbGVmdDogbWlkTGVmdCB9LFxuICAgICAgdG9wUmlnaHQ6IHsgdG9wOiB1cHBlclRvcCwgbGVmdDogZW5kTGVmdCB9LFxuICAgICAgcmlnaHQ6IHsgdG9wOiBtaWRUb3AsIGxlZnQ6IGVuZExlZnQgfSxcbiAgICAgIGJvdHRvbVJpZ2h0OiB7IHRvcDogbG93ZXJUb3AsIGxlZnQ6IGVuZExlZnQgfSxcbiAgICAgIGJvdHRvbTogeyB0b3A6IGxvd2VyVG9wLCBsZWZ0OiBtaWRMZWZ0IH0sXG4gICAgICBib3R0b21MZWZ0OiB7IHRvcDogbG93ZXJUb3AsIGxlZnQ6IHN0YXJ0TGVmdCB9LFxuICAgICAgbGVmdDogeyB0b3A6IG1pZFRvcCwgbGVmdDogc3RhcnRMZWZ0IH0sXG4gICAgICB0b3BMZWZ0OiB7IHRvcDogdXBwZXJUb3AsIGxlZnQ6IHN0YXJ0TGVmdCB9LFxuICAgIH1cbiAgfVxuXG4gIGdldCBjYXB0aW9uU3R5bGUoKSB7XG4gICAgY29uc3QgcG9zaXRpb25TdHlsZSA9IHRoaXMucG9zaXRpb25TdHlsZXNbdGhpcy5jYXB0aW9uUG9zaXRpb25dXG5cbiAgICBjb25zdCB4U2hpZnQgPSBzdHJpbmdTd2l0Y2godGhpcy5jYXB0aW9uUG9zaXRpb24sICh7IF9jYXNlLCBfZGVmYXVsdCB9KSA9PiB7XG4gICAgICBfY2FzZSgvKEx8bCllZnQvLCAoKSA9PiAnLTEwMCUnKVxuICAgICAgX2Nhc2UoWyd0b3AnLCAnYm90dG9tJ10sICgpID0+ICctNTAlJylcbiAgICAgIF9kZWZhdWx0KCgpID0+ICcwJylcbiAgICB9KVxuXG4gICAgY29uc3QgeVNoaWZ0ID0gc3RyaW5nU3dpdGNoKHRoaXMuY2FwdGlvblBvc2l0aW9uLCAoeyBfY2FzZSwgX2RlZmF1bHQgfSkgPT4ge1xuICAgICAgX2Nhc2UoL3RvcC8sICgpID0+ICctMTAwJScpXG4gICAgICBfY2FzZShbJ2xlZnQnLCAncmlnaHQnXSwgKCkgPT4gJy01MCUnKVxuICAgICAgX2RlZmF1bHQoKCkgPT4gJzAnKVxuICAgIH0pXG5cbiAgICBjb25zdCB0cmFuc2xhdGVYID0gYGNhbGMoJHt4U2hpZnR9ICsgJHt0aGlzLmNhcHRpb25PZmZzZXRYfSlgXG4gICAgY29uc3QgdHJhbnNsYXRlWSA9IGBjYWxjKCR7eVNoaWZ0fSArICR7dGhpcy5jYXB0aW9uT2Zmc2V0WX0pYFxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBvc2l0aW9uU3R5bGUsXG4gICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7dHJhbnNsYXRlWH0pIHRyYW5zbGF0ZVkoJHt0cmFuc2xhdGVZfSlgXG4gICAgfVxuICB9XG5cbiAgZ2V0IGN1ckJvdW5kKCkge1xuICAgIHJldHVybiB0aGlzLmJvdW5kc1t0aGlzLmN1ckJvdW5kSWR4XVxuICB9XG5cbiAgZ2V0IGlzQ29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldE5leHRCb3VuZElkeCgpID09PSB1bmRlZmluZWRcbiAgfVxuXG4gIGdldCBib3VuZHNJbmRpY2VzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiB0aGlzLmJvdW5kcy5sZW5ndGggfSkubWFwKChfLCBpZHgpID0+IGlkeClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROZXh0U2lkZShjdXJTaWRlKSB7XG4gIGNvbnN0IGlkeCA9IGNsb2Nrd2lzZU9yZGVyLmluZGV4T2YoY3VyU2lkZSlcbiAgY29uc3QgbmV4dFNpZGVJZHggPSAoaWR4ICsgMSArIDQpICUgNFxuICByZXR1cm4gY2xvY2t3aXNlT3JkZXJbbmV4dFNpZGVJZHhdXG59XG5cbmZ1bmN0aW9uIGdldE9wcG9zaXRlU2lkZShzaWRlKSB7XG4gIGNvbnN0IGlkeCA9IGNsb2Nrd2lzZU9yZGVyLmluZGV4T2Yoc2lkZSlcbiAgY29uc3Qgb3Bwb3NpdGVJZHggPSAoaWR4ICsgMikgJSA0XG4gIHJldHVybiBjbG9ja3dpc2VPcmRlcltvcHBvc2l0ZUlkeF1cbn1cblxuZnVuY3Rpb24gdG9QaXhlbHMobnVtKSB7XG4gIHJldHVybiBgJHtudW19cHhgXG59XG5cbmZ1bmN0aW9uIGdldFBhZGRlZEJvdW5kaW5nUmVjdChlbGUsIHBhZGRpbmcpIHtcbiAgY29uc3QgYm91bmQgPSBlbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgY29uc3QgZGVmYXVsdFBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ29iamVjdCdcbiAgICA/IHBhZGRpbmcuZGVmYXVsdCA/PyAwXG4gICAgOiBwYWRkaW5nXG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IGJvdW5kLnRvcCAtIChwYWRkaW5nLnRvcCA/PyBkZWZhdWx0UGFkZGluZyksXG4gICAgbGVmdDogYm91bmQubGVmdCAtIChwYWRkaW5nLmxlZnQgPz8gZGVmYXVsdFBhZGRpbmcpLFxuICAgIHJpZ2h0OiBib3VuZC5yaWdodCArIChwYWRkaW5nLnJpZ2h0ID8/IGRlZmF1bHRQYWRkaW5nKSxcbiAgICBib3R0b206IGJvdW5kLmJvdHRvbSArIChwYWRkaW5nLmJvdHRvbSA/PyBkZWZhdWx0UGFkZGluZyksXG4gIH1cbn1cblxuLy8gX2dldFJvdW5kZWRTdWJQYXRoRChzdWJQYXRoKSB7XG4vLyAgIGNvbnN0IG0gPSBgTSAke3N1YlBhdGhbMF0uam9pbigpfWBcbi8vICAgY29uc3QgbCA9IGBMICR7c3ViUGF0aC5zbGljZSgxKS5tYXAocCA9PiBwLmpvaW4oKSkuam9pbignICcpfWBcbi8vICAgcmV0dXJuIGAke219ICR7bH1gXG4vLyB9XG5cbi8vIGZ1bmN0aW9uIGdldE51ZGdlRGlmZihhLCBiLCBweCkge1xuLy8gICByZXR1cm4gWzAsIDFdLm1hcChpID0+IHtcbi8vICAgICBjb25zdCBkaWZmID0gYltpXSAtIGFbaV1cbi8vICAgICBjb25zdCBtYWcgPSBNYXRoLm1pbihweCwgTWF0aC5hYnMoZGlmZikgLyAyKVxuLy8gICAgIHJldHVybiBtYWcgKiBNYXRoLnNpZ24oZGlmZilcbi8vICAgfSlcbi8vIH1cblxuLy8gZnVuY3Rpb24gZ2V0TnVkZ2VkUG9pbnQoYSwgYikge1xuLy8gICByZXR1cm4gWzAsIDFdLm1hcChpID0+IHtcbi8vICAgICBjb25zdCBkaWZmID0gYltpXSAtIGFbaV1cbi8vICAgICBjb25zdCBtYWcgPSBNYXRoLm1pbih0aGlzLmJvcmRlclJhZGl1cywgTWF0aC5hYnMoZGlmZikgLyAyKVxuLy8gICAgIHJldHVybiBhW2ldICsgbWFnICogTWF0aC5zaWduKGRpZmYpXG4vLyAgIH0pXG4vLyB9XG5cbmZ1bmN0aW9uIGdldEFic0RpZmYoYSwgYikge1xuICByZXR1cm4gWzAsIDFdLm1hcChpID0+IE1hdGguYWJzKGFbaV0gLSBiW2ldKSlcbn1cblxuLy8gZnVuY3Rpb24gZ2V0UGF0aEhvb2socHJldiwgY3VyLCBuZXh0LCByYWRpdXMpIHtcbi8vICAgY29uc3Qgc3RhcnRQb2ludCA9IGdldE51ZGdlZFBvaW50KGN1ciwgcHJldiwgcmFkaXVzKVxuLy8gICBjb25zdCBlbmRQb2ludCA9IGdldE51ZGdlZFBvaW50KGN1ciwgbmV4dCwgcmFkaXVzKVxuLy8gICBjb25zdCByYWRpaSA9IGdldEFic0RpZmYoc3RhcnRQb2ludCwgZW5kUG9pbnQpXG5cbi8vICAgY29uc3QgbCA9IGBMICR7c3RhcnRQb2ludC5qb2luKCl9YFxuLy8gICBjb25zdCBhID0gYEEgJHtyYWRpaS5qb2luKCcgJyl9IDAgMCAxICR7ZW5kUG9pbnQuam9pbignICcpfWBcbi8vICAgcmV0dXJuIGAke2x9ICR7YX1gXG4vLyB9XG5cblxuLy8gZnVuY3Rpb24gdmVjQWRkKC4uLnZlY3MpIHtcbi8vICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IHZlY3NbMF0ubGVuZ3RoIH0pXG4vLyAgICAgLm1hcCgoXywgaWR4KSA9PiB2ZWNzLnJlZHVjZSgoc3VtLCB2ZWMpID0+IHZlY1tpZHhdICsgc3VtLCAwKSlcbi8vIH1cblxuXG5leHBvcnQgZGVmYXVsdCBTcG90bGlnaHRcblxuLy8gY2xvY2t3aXNlXG4vLyBwb3MsIHBvcyAtPiBoaWdoZXJ4LCBsb3dlcnlcbi8vIG5lZywgcG9zIC0+IGhpZ2hlcngsIGhpZ2hlcnlcbi8vIHBvcywgbmVnIC0+IGxvd2VyeCwgbG93ZXJ5XG4vLyBuZWcsIG5lZyAtPiBsb3dlcngsIGhpZ2hlcnlcblxuLy8gaWYgc2lnbiBvZiBzZWNvbmQgbWF0Y2hlcyBzaWduIG9mIHggZGlmZiIsImV4cG9ydCBsZXQgZGJBZGRcbmV4cG9ydCBsZXQgZGJHZXRcbmlmIChXb3JrZXIgJiYgaW5kZXhlZERCKSB7XG4gIGNvbnN0IHN0b3JhZ2VXb3JrZXIgPSBuZXcgV29ya2VyKCcuL2Rpc3Qvd29ya2VyLmpzJylcbiAgY29uc3QgcmVzb2x1dGlvblJlZ2lzdHJ5ID0ge31cblxuICBzdG9yYWdlV29ya2VyLm9ubWVzc2FnZSA9IG1zZyA9PiB7XG4gICAgY29uc3QgeyByZXF1ZXN0SWQsIC4uLm90aGVyRGF0YSB9ID0gbXNnLmRhdGFcbiAgICBjb25zdCByZXNvbHZlID0gcmVzb2x1dGlvblJlZ2lzdHJ5W3JlcXVlc3RJZF1cblxuICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKG90aGVyRGF0YSlcbiAgICAgIGRlbGV0ZSByZXNvbHV0aW9uUmVnaXN0cnlbcmVxdWVzdElkXVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGZpbmQgbWF0Y2hpbmcgcmVxdWVzdCBmb3I6ICcsIG1zZylcbiAgICB9XG4gIH1cblxuICBkYkFkZCA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHNlbmQoe1xuICAgICAgdHlwZTogJ0FERCcsXG4gICAgICBrZXksXG4gICAgICB2YWx1ZVxuICAgIH0pLnRoZW4oKHsgc3RhdHVzIH0pID0+IHN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKVxuICB9XG5cbiAgZGJHZXQgPSBrZXkgPT4ge1xuICAgIHJldHVybiBzZW5kKHtcbiAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAga2V5LFxuICAgIH0pLnRoZW4oKHsgcmVzdWx0IH0pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKHJlc3VsdClcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gc2VuZChtZXNzYWdlLCB0aW1lb3V0KSB7XG4gICAgY29uc3QgcmVxdWVzdElkID0gTWF0aC5yYW5kb20oKVxuICAgIHN0b3JhZ2VXb3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgLi4ubWVzc2FnZSxcbiAgICAgIHJlcXVlc3RJZCxcbiAgICB9KVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlamVjdCgnUmVxdWVzdCB0aW1lZCBvdXQnKVxuICAgICAgICB9LCB0aW1lb3V0KVxuXG4gICAgICAgIHJlc29sdXRpb25SZWdpc3RyeVtyZXF1ZXN0SWRdID0gKGRhdGEpID0+IHtcbiAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICAgICAgICByZXNvbHZlKGRhdGEpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdXRpb25SZWdpc3RyeVtyZXF1ZXN0SWRdID0gcmVzb2x2ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn0gZWxzZSB7XG4gIGRiQWRkID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gIH1cblxuICBkYkdldCA9IGtleSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoaXRlbSlcbiAgfVxufVxuXG53aW5kb3cuZGJBZGQgPSBkYkFkZFxud2luZG93LmRiR2V0ID0gZGJHZXQiLCJpbXBvcnQgeyB0eXBlcywgZ2V0Um9vdCwgZ2V0RW52IH0gZnJvbSAnbW9ieC1zdGF0ZS10cmVlJ1xuaW1wb3J0IHsgbmV4dElkIH0gZnJvbSAnLi4vc2hhcmVkL2dlbmVyYWxfdXRpbCdcblxuZXhwb3J0IGNvbnN0IElkID0gdHlwZXMub3B0aW9uYWwodHlwZXMuaWRlbnRpZmllciwgbmV4dElkKVxuXG5leHBvcnQgY29uc3QgUG9zaXRpb24gPSB0eXBlcy5yZWZpbmVtZW50KFxuICAnUG9zaXRpb24nLFxuICB0eXBlcy5hcnJheSh0eXBlcy5pbnRlZ2VyKSxcbiAgYXJyYXkgPT4gYXJyYXkubGVuZ3RoID09PSAyXG4pXG5cbmV4cG9ydCBjb25zdCBHYW1lQmFzZSA9IHR5cGVzXG4gIC5tb2RlbCgnR2FtZUJhc2UnKVxuICAudmlld3Moc2VsZiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldCByb290KCkge1xuICAgICAgICByZXR1cm4gZ2V0Um9vdChzZWxmKVxuICAgICAgfSxcbiAgICAgIGdldCByb290T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucm9vdD8ub3B0aW9uc1xuICAgICAgfSxcbiAgICAgIGdldCByb290VWkoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJvb3Q/LnVpXG4gICAgICB9LFxuICAgICAgZ2V0IHJvb3RQdXp6bGUoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJvb3QucHV6emxlXG4gICAgICB9LFxuICAgICAgZ2V0IGVudigpIHtcbiAgICAgICAgcmV0dXJuIGdldEVudihzZWxmKVxuICAgICAgfSxcbiAgICB9XG4gIH0pIiwiLy8gaW1wb3J0IHsgdHlwZXMgfSBmcm9tICdtb2J4LXN0YXRlLXRyZWUnXG4vLyBpbXBvcnQgeyBjcmVhdGVJY29uLCBnZXRUZW1wbGF0ZUJ5SWQgfSBmcm9tICcuLi9zaGFyZWQvZG9tX3V0aWwnXG4vLyBpbXBvcnQge1xuLy8gICBjb21ib3MsXG4vLyAgIGluY2x1ZGVzQXJyYXksXG4vLyAgIGluZGV4T2ZBcnJheSxcbi8vICAgcHJvZHVjdCxcbi8vICAgc3VtLFxuLy8gICBxdW90aWVudCxcbi8vICAgZGlmZmVyZW5jZSxcbi8vICAgaW5jbHVkZXNEaXN0aW5jdCxcbi8vICAgbWF4UG9zc2libGVSZXBlYXRzLFxuLy8gICBzdHJpbmdTd2l0Y2gsXG4vLyB9IGZyb20gJy4uL3NoYXJlZC9nZW5lcmFsX3V0aWwnXG4vLyBpbXBvcnQgeyBJZCwgR2FtZUJhc2UgfSBmcm9tICcuL2Jhc2UnXG4vLyBpbXBvcnQgUnVsZXMgZnJvbSAnLi9ydWxlcydcbi8vIGltcG9ydCBTcXVhcmUgZnJvbSAnLi9zcXVhcmUnXG5cbi8vIGNvbnN0IENvbGxlY3Rpb24gPSBHYW1lQmFzZVxuLy8gICAubmFtZWQoJ0NvbGxlY3Rpb24nKVxuLy8gICAucHJvcHMoe1xuLy8gICAgIGlkOiBJZCxcbi8vICAgICBzcXVhcmVzOiB0eXBlcy5hcnJheSh0eXBlcy5yZWZlcmVuY2UodHlwZXMubGF0ZSgoKSA9PiBTcXVhcmUpKSksXG4vLyAgICAgcnVsZXM6IHR5cGVzLm9wdGlvbmFsKFJ1bGVzLCAoKSA9PiBSdWxlcy5jcmVhdGUoKSksXG4vLyAgICAgZWxpbWluYXRlZENvbWJvczogdHlwZXMub3B0aW9uYWwoXG4vLyAgICAgICB0eXBlcy5hcnJheSh0eXBlcy5hcnJheSh0eXBlcy5pbnRlZ2VyKSksXG4vLyAgICAgICAoKSA9PiBbXVxuLy8gICAgICksXG4vLyAgIH0pXG4vLyAgIC52aWV3cyhzZWxmID0+IHtcbi8vICAgICByZXR1cm4ge1xuLy8gICAgICAgZ2V0IG51bVNxdWFyZXMoKSB7XG4vLyAgICAgICAgIHJldHVybiBzZWxmLnNxdWFyZXMubGVuZ3RoXG4vLyAgICAgICB9LFxuLy8gICAgICAgZ2V0IHBvc2l0aW9ucygpIHtcbi8vICAgICAgICAgcmV0dXJuIHNlbGYuc3F1YXJlcy5tYXAoc3F1YXJlID0+IHNxdWFyZS5wb3NpdGlvbilcbi8vICAgICAgIH0sXG4vLyAgICAgICBnZXQgc3F1YXJlVmFsdWVzKCkge1xuLy8gICAgICAgICByZXR1cm4gc2VsZi5zcXVhcmVzXG4vLyAgICAgICAgICAgLm1hcChzcXVhcmUgPT4gc3F1YXJlLnZhbHVlKVxuLy8gICAgICAgICAgIC5maWx0ZXIodmFsID0+IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuLy8gICAgICAgfSxcbi8vICAgICAgIC8vIGdldCBib3VuZGluZ0JveCgpIHtcbi8vICAgICAgIC8vICAgY29uc3Qgc29ydGVkU3F1YXJlUm93cyA9IHNlbGYuc3F1YXJlcy5tYXAoc3EgPT4gc3Eucm93KS5zb3J0KClcbi8vICAgICAgIC8vICAgY29uc3Qgc29ydGVkU3F1YXJlQ29scyA9IHNlbGYuc3F1YXJlcy5tYXAoc3EgPT4gc3EuY29sKS5zb3J0KClcbi8vICAgICAgIC8vICAgY29uc3QgbWluUm93ID0gc29ydGVkU3F1YXJlUm93c1swXVxuLy8gICAgICAgLy8gICBjb25zdCBtaW5Db2wgPSBzb3J0ZWRTcXVhcmVDb2xzWzBdXG4vLyAgICAgICAvLyAgIGNvbnN0IG1heFJvdyA9IHNvcnRlZFNxdWFyZVJvd3Nbc29ydGVkU3F1YXJlUm93cy5sZW5ndGggLSAxXVxuLy8gICAgICAgLy8gICBjb25zdCBtYXhDb2wgPSBzb3J0ZWRTcXVhcmVDb2xzW3NvcnRlZFNxdWFyZUNvbHMubGVuZ3RoIC0gMV1cblxuLy8gICAgICAgLy8gICByZXR1cm4gW1ttaW5Sb3csIG1pbkNvbF0sIFttYXhSb3csIG1heENvbF1dXG4vLyAgICAgICAvLyB9LFxuLy8gICAgICAgZ2V0IGFsbENvbWJvcygpIHtcbi8vICAgICAgICAgcmV0dXJuIGNvbWJvcyhzZWxmLm51bVNxdWFyZXMsICh7XG4vLyAgICAgICAgICAgbWluOiAxLFxuLy8gICAgICAgICAgIG1heDogc2VsZi5lbnYuZ2xvYmFscy5zaXplLFxuLy8gICAgICAgICAgIG51bVJlcGVhdHNBbGxvd2VkOiBzZWxmLm51bVBvc3NpYmxlUmVwZWF0c1xuLy8gICAgICAgICB9KSlcbi8vICAgICAgIH0sXG4vLyAgICAgICBnZXQgZmlsdGVyZWRDb21ib3MoKSB7XG4vLyAgICAgICAgIHJldHVybiBzZWxmLmFsbENvbWJvc1xuLy8gICAgICAgICAgIC5maWx0ZXIoc2VsZi5pc0ZpbHRlcmVkQ29tYm8pXG4vLyAgICAgICB9LFxuLy8gICAgICAgZ2V0IHBvc3NpYmxlQ29tYm9zKCkge1xuLy8gICAgICAgICByZXR1cm4gc2VsZi5hbGxDb21ib3Ncbi8vICAgICAgICAgICAuZmlsdGVyKHNlbGYuaXNQb3NzaWJsZUNvbWJvKVxuLy8gICAgICAgfSxcbi8vICAgICAgIGdldCBudW1Qb3NzaWJsZVJlcGVhdHMoKSB7XG4vLyAgICAgICAgIHJldHVybiBtYXhQb3NzaWJsZVJlcGVhdHMoc2VsZi5wb3NpdGlvbnMpXG4vLyAgICAgICB9LFxuLy8gICAgICAgZ2V0IGNvbWJvRWxlcygpIHtcbi8vICAgICAgICAgcmV0dXJuIHNlbGYuZmlsdGVyZWRDb21ib3MubWFwKGNvbWJvID0+IHtcbi8vICAgICAgICAgICBjb25zdCBjb21ib0VsZSA9IHNlbGYuZW52LnRlbXBsYXRlcy5jb21iby5jbG9uZU5vZGUodHJ1ZSlcbi8vICAgICAgICAgICBjb21ib0VsZS5kYXRhc2V0LmNvbWJvID0gY29tYm8uam9pbignLCcpXG4vLyAgICAgICAgICAgY29tYm9FbGUuaW5uZXJUZXh0ID0gY29tYm8uam9pbignIHwgJylcblxuLy8gICAgICAgICAgIGlmIChzZWxmLmlzRWxpbWluYXRlZENvbWJvKGNvbWJvKSkge1xuLy8gICAgICAgICAgICAgY29tYm9FbGUuY2xhc3NMaXN0LmFkZCgnY29tYm8tLWVsaW1pbmF0ZWQnKVxuLy8gICAgICAgICAgIH1cblxuLy8gICAgICAgICAgIHJldHVybiBjb21ib0VsZVxuLy8gICAgICAgICB9KVxuLy8gICAgICAgfSxcbi8vICAgICAgIGNvbXBhcmVDb21ib0VsZXMoY29tYm9BLCBjb21ib0IpIHtcbi8vICAgICAgICAgY29uc3QgY29tYm9TdHJBID0gY29tYm9BLmRhdGFzZXQuY29tYm9cbi8vICAgICAgICAgY29uc3QgY29tYm9TdHJCID0gY29tYm9CLmRhdGFzZXQuY29tYm9cbi8vICAgICAgICAgaWYgKGNvbWJvU3RyQSA9PT0gY29tYm9TdHJCKSB7XG4vLyAgICAgICAgICAgcmV0dXJuIDBcbi8vICAgICAgICAgfSBlbHNlIGlmIChjb21ib1N0ckEgPCBjb21ib1N0ckIpIHtcbi8vICAgICAgICAgICByZXR1cm4gLTFcbi8vICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICByZXR1cm4gMVxuLy8gICAgICAgICB9XG4vLyAgICAgICB9LFxuLy8gICAgICAgaXNGaWx0ZXJlZENvbWJvKGNvbWJvKSB7XG4vLyAgICAgICAgIHJldHVybiBzZWxmLnJ1bGVzLmlzUG9zc2libGVDb21ibyhjb21ibylcbi8vICAgICAgIH0sXG4vLyAgICAgICBpc0VsaW1pbmF0ZWRDb21ibyhjb21ibykge1xuLy8gICAgICAgICByZXR1cm4gaW5jbHVkZXNBcnJheShzZWxmLmVsaW1pbmF0ZWRDb21ib3MsIGNvbWJvKVxuLy8gICAgICAgfSxcbi8vICAgICAgIGlzUG9zc2libGVDb21ibyhjb21ibykge1xuLy8gICAgICAgICByZXR1cm4gKFxuLy8gICAgICAgICAgIHNlbGYuaXNGaWx0ZXJlZENvbWJvKGNvbWJvKVxuLy8gICAgICAgICAgICYmICFzZWxmLmlzRWxpbWluYXRlZENvbWJvKGNvbWJvKVxuLy8gICAgICAgICApXG4vLyAgICAgICB9LFxuLy8gICAgICAgaXNQb3NzaWJsZVZhbHVlKHZhbHVlKSB7XG4vLyAgICAgICAgIHJldHVybiBzZWxmLnBvc3NpYmxlQ29tYm9zLnNvbWUoY29tYm8gPT5cbi8vICAgICAgICAgICBpbmNsdWRlc0Rpc3RpbmN0KGNvbWJvLCAuLi5zZWxmLnNxdWFyZVZhbHVlcywgdmFsdWUpKVxuLy8gICAgICAgfSxcbi8vICAgICB9XG4vLyAgIH0pXG4vLyAgIC5hY3Rpb25zKHNlbGYgPT4ge1xuLy8gICAgIHJldHVybiB7XG4vLyAgICAgICBhZGRTcXVhcmUoc3F1YXJlKSB7XG4vLyAgICAgICAgIHNlbGYuc3F1YXJlcy5wdXNoKHNxdWFyZS5pZClcbi8vICAgICAgIH0sXG4vLyAgICAgICB0b2dnbGVDb21ibyhjb21ibykge1xuLy8gICAgICAgICBjb25zdCBjb21ib0luZGV4ID0gaW5kZXhPZkFycmF5KHNlbGYuZWxpbWluYXRlZENvbWJvcywgY29tYm8pXG5cbi8vICAgICAgICAgaWYgKGNvbWJvSW5kZXggPj0gMCkge1xuLy8gICAgICAgICAgIHNlbGYuZWxpbWluYXRlZENvbWJvcy5zcGxpY2UoY29tYm9JbmRleCwgMSlcbi8vICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICBzZWxmLmVsaW1pbmF0ZWRDb21ib3MucHVzaChjb21ibylcbi8vICAgICAgICAgfVxuLy8gICAgICAgfSxcbi8vICAgICAgIC8vIGVsaW1pbmF0ZUNvbWJvKGNvbWJvKSB7XG4vLyAgICAgICAvLyAgIGlmICghaW5jbHVkZXNBcnJheShzZWxmLmVsaW1pbmF0ZWRDb21ib3MsIGNvbWJvKSkge1xuLy8gICAgICAgLy8gICAgIHNlbGYuZWxpbWluYXRlZENvbWJvcy5wdXNoKGNvbWJvKVxuLy8gICAgICAgLy8gICB9XG4vLyAgICAgICAvLyB9LFxuLy8gICAgICAgLy8gdW5lbGltaW5hdGVDb21ibyhjb21ibykge1xuLy8gICAgICAgLy8gICBjb25zdCBjb21ib0luZGV4ID0gaW5kZXhPZkFycmF5KHNlbGYuZWxpbWluYXRlZENvbWJvcywgY29tYm8pXG5cbi8vICAgICAgIC8vICAgaWYgKGNvbWJvSW5kZXggPj0gMCkge1xuLy8gICAgICAgLy8gICAgIHNlbGYuZWxpbWluYXRlZENvbWJvcy5zcGxpY2UoY29tYm9JbmRleCwgMSlcbi8vICAgICAgIC8vICAgfVxuLy8gICAgICAgLy8gfSxcbi8vICAgICAgIHNldENvbWJvcyhjb21ib3MpIHtcbi8vICAgICAgICAgY29uc3Qgc29ydGVkQ29tYm9zID0gY29tYm9zLm1hcChjb21ibyA9PiBjb21iby5zb3J0KCkpXG5cbi8vICAgICAgICAgc2VsZi5lbGltaW5hdGVkQ29tYm9zID0gc2VsZi5hbGxDb21ib3Ncbi8vICAgICAgICAgICAuZmlsdGVyKGNvbWJvID0+ICFpbmNsdWRlc0FycmF5KHNvcnRlZENvbWJvcywgY29tYm8pKVxuLy8gICAgICAgfSxcbi8vICAgICB9XG4vLyAgIH0pXG5cblxuLy8gZXhwb3J0IGNvbnN0IENhZ2UgPSBDb2xsZWN0aW9uXG4vLyAgIC5uYW1lZCgnQ2FnZScpXG4vLyAgIC5wcm9wcyh7XG4vLyAgICAgb3BlcmF0aW9uOiB0eXBlcy5lbnVtZXJhdGlvbignT3BlcmF0aW9uJywgWycrJywgJ+KIkicsICfiqIknLCAnw7cnXSksXG4vLyAgICAgcmVzdWx0OiB0eXBlcy5pbnRlZ2VyLFxuLy8gICAgIGF1dG9FbGltTWF0aEltcG9zc2liaWxpdGllczogdHlwZXMub3B0aW9uYWwodHlwZXMuYm9vbGVhbiwgKCkgPT4gZmFsc2UpLFxuLy8gICB9KVxuLy8gICAudmlld3Moc2VsZiA9PiB7XG4vLyAgICAgY29uc3Qgc3VwZXJJc1J1bGVQb3NzaWJsZUNvbWJvID0gc2VsZi5pc0ZpbHRlcmVkQ29tYm9cblxuLy8gICAgIHJldHVybiB7XG4vLyAgICAgICBnZXQgYm91bmRzKCkge1xuLy8gICAgICAgICBjb25zdCBib3VuZHMgPSB7XG4vLyAgICAgICAgICAgdG9wU3F1YXJlczogW10sXG4vLyAgICAgICAgICAgbGVmdFNxdWFyZXM6IFtdLFxuLy8gICAgICAgICAgIGFuY2hvcjogc2VsZi5zcXVhcmVzWzBdLFxuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgc2VsZi5zcXVhcmVzLmZvckVhY2goc3F1YXJlID0+IHtcbi8vICAgICAgICAgICBjb25zdCBpc1RvcCA9ICFzZWxmLnNxdWFyZXMuc29tZShzcXVhcmUuaXNCZWxvdylcbi8vICAgICAgICAgICBjb25zdCBpc0xlZnQgPSAhc2VsZi5zcXVhcmVzLnNvbWUoc3F1YXJlLmlzUmlnaHRPZilcblxuLy8gICAgICAgICAgIGlmIChpc1RvcCkgYm91bmRzLnRvcFNxdWFyZXMucHVzaChzcXVhcmUpXG4vLyAgICAgICAgICAgaWYgKGlzTGVmdCkgYm91bmRzLmxlZnRTcXVhcmVzLnB1c2goc3F1YXJlKVxuLy8gICAgICAgICAgIGlmIChpc1RvcCAmJiBpc0xlZnQgJiYgc3F1YXJlLmNvbWVzQmVmb3JlKGJvdW5kcy5hbmNob3IpKSB7XG4vLyAgICAgICAgICAgICBib3VuZHMuYW5jaG9yID0gc3F1YXJlXG4vLyAgICAgICAgICAgfVxuLy8gICAgICAgICB9KVxuXG4vLyAgICAgICAgIHJldHVybiBib3VuZHM7XG4vLyAgICAgICB9LFxuLy8gICAgICAgZ2V0IGFuY2hvcigpIHtcbi8vICAgICAgICAgcmV0dXJuIHNlbGYuYm91bmRzLmFuY2hvclxuLy8gICAgICAgfSxcbi8vICAgICAgIGdldCBsYWJlbFRleHQoKSB7XG4vLyAgICAgICAgIHJldHVybiBgJHtzZWxmLnJlc3VsdH0gJHtzZWxmLm9wZXJhdGlvbn1gXG4vLyAgICAgICB9LFxuLy8gICAgICAgaXNGaWx0ZXJlZENvbWJvKGNvbWJvKSB7XG4vLyAgICAgICAgIHJldHVybiAoXG4vLyAgICAgICAgICAgc2VsZi5yb290T3B0aW9ucy5hdXRvRWxpbU1hdGhJbXBvc3NpYmlsaXRpZXNcbi8vICAgICAgICAgICB8fCBzZWxmLmF1dG9FbGltTWF0aEltcG9zc2liaWxpdGllc1xuLy8gICAgICAgICApID8gKFxuLy8gICAgICAgICAgIHN1cGVySXNSdWxlUG9zc2libGVDb21ibyhjb21ibylcbi8vICAgICAgICAgICAmJiBzZWxmLmlzTWF0aGVtYXRpY2FsUG9zc2liaWxpdHkoY29tYm8pXG4vLyAgICAgICAgICkgOiBzdXBlcklzUnVsZVBvc3NpYmxlQ29tYm8oY29tYm8pXG4vLyAgICAgICB9LFxuLy8gICAgICAgaXNNYXRoZW1hdGljYWxQb3NzaWJpbGl0eShjb21ibykge1xuLy8gICAgICAgICBzd2l0Y2ggKHNlbGYub3BlcmF0aW9uKSB7XG4vLyAgICAgICAgICAgY2FzZSAnKyc6XG4vLyAgICAgICAgICAgICByZXR1cm4gc3VtKGNvbWJvKSA9PT0gc2VsZi5yZXN1bHRcbi8vICAgICAgICAgICBjYXNlICfiiJInOlxuLy8gICAgICAgICAgICAgcmV0dXJuIGRpZmZlcmVuY2UoY29tYm8pID09PSBzZWxmLnJlc3VsdFxuLy8gICAgICAgICAgIGNhc2UgJ+KoiSc6XG4vLyAgICAgICAgICAgICByZXR1cm4gcHJvZHVjdChjb21ibykgPT09IHNlbGYucmVzdWx0XG4vLyAgICAgICAgICAgY2FzZSAnw7cnOlxuLy8gICAgICAgICAgICAgcmV0dXJuIHF1b3RpZW50KGNvbWJvKSA9PT0gc2VsZi5yZXN1bHRcbi8vICAgICAgICAgICBkZWZhdWx0OlxuLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcGVyYXRpb24gJHtzZWxmLm9wZXJhdGlvbn0gZG9lc24ndCBtYXRjaCBvbmUgb2YgKywgLSwg4qiJLCBvciDDt2ApXG4vLyAgICAgICAgIH1cbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH0pXG5cbi8vIGV4cG9ydCBjb25zdCBHcm91cCA9IENvbGxlY3Rpb25cbi8vICAgLm5hbWVkKCdHcm91cCcpXG5cbmltcG9ydCB7IHR5cGVzIH0gZnJvbSAnbW9ieC1zdGF0ZS10cmVlJ1xuaW1wb3J0IHtcbiAgY29tYm9zLFxuICBpbmNsdWRlc0FycmF5LFxuICBpbmRleE9mQXJyYXksXG4gIHByb2R1Y3QsXG4gIHN1bSxcbiAgcXVvdGllbnQsXG4gIGRpZmZlcmVuY2UsXG4gIGluY2x1ZGVzRGlzdGluY3QsXG4gIG1heFBvc3NpYmxlUmVwZWF0cyxcbiAgc3RyaW5nU3dpdGNoLFxuICB0b2dnbGVQcmVzZW5jZUluQXJyYXksXG59IGZyb20gJy4uL3NoYXJlZC9nZW5lcmFsX3V0aWwnXG5pbXBvcnQgeyBJZCwgR2FtZUJhc2UgfSBmcm9tICcuL2Jhc2UnXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0IFNxdWFyZSBmcm9tICcuL3NxdWFyZSdcblxuY29uc3QgQ29sbGVjdGlvbiA9IEdhbWVCYXNlXG4gIC5uYW1lZCgnQ29sbGVjdGlvbicpXG4gIC5wcm9wcyh7XG4gICAgaWQ6IElkLFxuICAgIHNxdWFyZXM6IHR5cGVzLmFycmF5KHR5cGVzLnJlZmVyZW5jZSh0eXBlcy5sYXRlKCgpID0+IFNxdWFyZSkpKSxcbiAgICBmaWx0ZXI6IHR5cGVzLm9wdGlvbmFsKEZpbHRlciwgKCkgPT4gRmlsdGVyLmNyZWF0ZSgpKSxcbiAgICBlbGltaW5hdGVkQ29tYm9zOiB0eXBlcy5vcHRpb25hbChcbiAgICAgIHR5cGVzLmFycmF5KHR5cGVzLmFycmF5KHR5cGVzLmludGVnZXIpKSxcbiAgICAgICgpID0+IFtdXG4gICAgKSxcbiAgfSlcbiAgLnZpZXdzKHNlbGYgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQgbnVtU3F1YXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc3F1YXJlcy5sZW5ndGhcbiAgICAgIH0sXG4gICAgICBnZXQgcG9zaXRpb25zKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5zcXVhcmVzLm1hcChzcXVhcmUgPT4gc3F1YXJlLnBvc2l0aW9uKVxuICAgICAgfSxcbiAgICAgIGdldCBzcXVhcmVWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNxdWFyZXNcbiAgICAgICAgICAubWFwKHNxdWFyZSA9PiBzcXVhcmUudmFsdWUpXG4gICAgICAgICAgLmZpbHRlcih2YWwgPT4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXG4gICAgICB9LFxuICAgICAgLy8gZ2V0IGJvdW5kaW5nQm94KCkge1xuICAgICAgLy8gICBjb25zdCBzb3J0ZWRTcXVhcmVSb3dzID0gc2VsZi5zcXVhcmVzLm1hcChzcSA9PiBzcS5yb3cpLnNvcnQoKVxuICAgICAgLy8gICBjb25zdCBzb3J0ZWRTcXVhcmVDb2xzID0gc2VsZi5zcXVhcmVzLm1hcChzcSA9PiBzcS5jb2wpLnNvcnQoKVxuICAgICAgLy8gICBjb25zdCBtaW5Sb3cgPSBzb3J0ZWRTcXVhcmVSb3dzWzBdXG4gICAgICAvLyAgIGNvbnN0IG1pbkNvbCA9IHNvcnRlZFNxdWFyZUNvbHNbMF1cbiAgICAgIC8vICAgY29uc3QgbWF4Um93ID0gc29ydGVkU3F1YXJlUm93c1tzb3J0ZWRTcXVhcmVSb3dzLmxlbmd0aCAtIDFdXG4gICAgICAvLyAgIGNvbnN0IG1heENvbCA9IHNvcnRlZFNxdWFyZUNvbHNbc29ydGVkU3F1YXJlQ29scy5sZW5ndGggLSAxXVxuXG4gICAgICAvLyAgIHJldHVybiBbW21pblJvdywgbWluQ29sXSwgW21heFJvdywgbWF4Q29sXV1cbiAgICAgIC8vIH0sXG4gICAgICBnZXQgYWxsQ29tYm9zKCkge1xuICAgICAgICByZXR1cm4gY29tYm9zKHNlbGYubnVtU3F1YXJlcywgKHtcbiAgICAgICAgICBtaW46IDEsXG4gICAgICAgICAgbWF4OiBzZWxmLmVudi5nbG9iYWxzLnNpemUsXG4gICAgICAgICAgbnVtUmVwZWF0c0FsbG93ZWQ6IHNlbGYubnVtUG9zc2libGVSZXBlYXRzXG4gICAgICAgIH0pKVxuICAgICAgfSxcbiAgICAgIGdldCBmaWx0ZXJlZENvbWJvcygpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuYWxsQ29tYm9zXG4gICAgICAgICAgLmZpbHRlcihzZWxmLmlzRmlsdGVyZWRDb21ibylcbiAgICAgIH0sXG4gICAgICBnZXQgcG9zc2libGVDb21ib3MoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmFsbENvbWJvc1xuICAgICAgICAgIC5maWx0ZXIoc2VsZi5pc1Bvc3NpYmxlQ29tYm8pXG4gICAgICB9LFxuICAgICAgZ2V0IG51bVBvc3NpYmxlUmVwZWF0cygpIHtcbiAgICAgICAgcmV0dXJuIG1heFBvc3NpYmxlUmVwZWF0cyhzZWxmLnBvc2l0aW9ucylcbiAgICAgIH0sXG4gICAgICBnZXQgY29tYm9FbGVzKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5maWx0ZXJlZENvbWJvcy5tYXAoY29tYm8gPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbWJvRWxlID0gc2VsZi5lbnYudGVtcGxhdGVzLmNvbWJvLmNsb25lTm9kZSh0cnVlKVxuICAgICAgICAgIGNvbWJvRWxlLmRhdGFzZXQuY29tYm8gPSBjb21iby5qb2luKCcsJylcbiAgICAgICAgICBjb21ib0VsZS5pbm5lclRleHQgPSBjb21iby5qb2luKCcgfCAnKVxuXG4gICAgICAgICAgaWYgKHNlbGYuaXNFbGltaW5hdGVkQ29tYm8oY29tYm8pKSB7XG4gICAgICAgICAgICBjb21ib0VsZS5jbGFzc0xpc3QuYWRkKCdjb21iby0tZWxpbWluYXRlZCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbWJvRWxlXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgY29tcGFyZUNvbWJvRWxlcyhjb21ib0EsIGNvbWJvQikge1xuICAgICAgICBjb25zdCBjb21ib1N0ckEgPSBjb21ib0EuZGF0YXNldC5jb21ib1xuICAgICAgICBjb25zdCBjb21ib1N0ckIgPSBjb21ib0IuZGF0YXNldC5jb21ib1xuICAgICAgICBpZiAoY29tYm9TdHJBID09PSBjb21ib1N0ckIpIHtcbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9IGVsc2UgaWYgKGNvbWJvU3RyQSA8IGNvbWJvU3RyQikge1xuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc0ZpbHRlcmVkQ29tYm8oY29tYm8pIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZmlsdGVyLmlzUG9zc2libGVDb21ibyhjb21ibylcbiAgICAgIH0sXG4gICAgICBpc0VsaW1pbmF0ZWRDb21ibyhjb21ibykge1xuICAgICAgICByZXR1cm4gaW5jbHVkZXNBcnJheShzZWxmLmVsaW1pbmF0ZWRDb21ib3MsIGNvbWJvKVxuICAgICAgfSxcbiAgICAgIGlzUG9zc2libGVDb21ibyhjb21ibykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHNlbGYuaXNGaWx0ZXJlZENvbWJvKGNvbWJvKVxuICAgICAgICAgICYmICFzZWxmLmlzRWxpbWluYXRlZENvbWJvKGNvbWJvKVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgaXNQb3NzaWJsZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnBvc3NpYmxlQ29tYm9zLnNvbWUoY29tYm8gPT5cbiAgICAgICAgICBpbmNsdWRlc0Rpc3RpbmN0KGNvbWJvLCAuLi5zZWxmLnNxdWFyZVZhbHVlcywgdmFsdWUpKVxuICAgICAgfSxcbiAgICB9XG4gIH0pXG4gIC5hY3Rpb25zKHNlbGYgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRTcXVhcmUoc3F1YXJlKSB7XG4gICAgICAgIHNlbGYuc3F1YXJlcy5wdXNoKHNxdWFyZS5pZClcbiAgICAgIH0sXG4gICAgICB0b2dnbGVDb21ibyhjb21ibykge1xuICAgICAgICB0b2dnbGVQcmVzZW5jZUluQXJyYXkoc2VsZi5lbGltaW5hdGVkQ29tYm9zLCBjb21ibywgaW5kZXhPZkFycmF5KVxuICAgICAgfSxcbiAgICAgIHNldENvbWJvcyhjb21ib3MpIHtcbiAgICAgICAgY29uc3Qgc29ydGVkQ29tYm9zID0gY29tYm9zLm1hcChjb21ibyA9PiBjb21iby5zb3J0KCkpXG5cbiAgICAgICAgc2VsZi5lbGltaW5hdGVkQ29tYm9zID0gc2VsZi5hbGxDb21ib3NcbiAgICAgICAgICAuZmlsdGVyKGNvbWJvID0+ICFpbmNsdWRlc0FycmF5KHNvcnRlZENvbWJvcywgY29tYm8pKVxuICAgICAgfSxcbiAgICAgIHJlc2V0KCkge1xuICAgICAgICBzZWxmLmZpbHRlci5yZXNldCgpXG4gICAgICAgIHNlbGYuZWxpbWluYXRlZENvbWJvcyA9IFtdXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG5cbmV4cG9ydCBjb25zdCBDYWdlID0gQ29sbGVjdGlvblxuICAubmFtZWQoJ0NhZ2UnKVxuICAucHJvcHMoe1xuICAgIG9wZXJhdGlvbjogdHlwZXMuZW51bWVyYXRpb24oJ09wZXJhdGlvbicsIFsnKycsICfiiJInLCAn4qiJJywgJ8O3J10pLFxuICAgIHJlc3VsdDogdHlwZXMuaW50ZWdlcixcbiAgICBhdXRvRWxpbU1hdGhJbXBvc3NpYmlsaXRpZXM6IHR5cGVzLm9wdGlvbmFsKHR5cGVzLmJvb2xlYW4sICgpID0+IGZhbHNlKSxcbiAgfSlcbiAgLnZpZXdzKHNlbGYgPT4ge1xuICAgIGNvbnN0IHN1cGVySXNSdWxlUG9zc2libGVDb21ibyA9IHNlbGYuaXNGaWx0ZXJlZENvbWJvXG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0IGJvdW5kcygpIHtcbiAgICAgICAgY29uc3QgYm91bmRzID0ge1xuICAgICAgICAgIHRvcFNxdWFyZXM6IFtdLFxuICAgICAgICAgIGxlZnRTcXVhcmVzOiBbXSxcbiAgICAgICAgICBhbmNob3I6IHNlbGYuc3F1YXJlc1swXSxcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc3F1YXJlcy5mb3JFYWNoKHNxdWFyZSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNUb3AgPSAhc2VsZi5zcXVhcmVzLnNvbWUoc3F1YXJlLmlzQmVsb3cpXG4gICAgICAgICAgY29uc3QgaXNMZWZ0ID0gIXNlbGYuc3F1YXJlcy5zb21lKHNxdWFyZS5pc1JpZ2h0T2YpXG5cbiAgICAgICAgICBpZiAoaXNUb3ApIGJvdW5kcy50b3BTcXVhcmVzLnB1c2goc3F1YXJlKVxuICAgICAgICAgIGlmIChpc0xlZnQpIGJvdW5kcy5sZWZ0U3F1YXJlcy5wdXNoKHNxdWFyZSlcbiAgICAgICAgICBpZiAoaXNUb3AgJiYgaXNMZWZ0ICYmIHNxdWFyZS5jb21lc0JlZm9yZShib3VuZHMuYW5jaG9yKSkge1xuICAgICAgICAgICAgYm91bmRzLmFuY2hvciA9IHNxdWFyZVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfSxcbiAgICAgIGdldCBhbmNob3IoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmJvdW5kcy5hbmNob3JcbiAgICAgIH0sXG4gICAgICBnZXQgbGFiZWxUZXh0KCkge1xuICAgICAgICByZXR1cm4gYCR7c2VsZi5yZXN1bHR9ICR7c2VsZi5vcGVyYXRpb259YFxuICAgICAgfSxcbiAgICAgIGlzRmlsdGVyZWRDb21ibyhjb21ibykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHNlbGYucm9vdE9wdGlvbnMuYXV0b0VsaW1NYXRoSW1wb3NzaWJpbGl0aWVzXG4gICAgICAgICAgfHwgc2VsZi5hdXRvRWxpbU1hdGhJbXBvc3NpYmlsaXRpZXNcbiAgICAgICAgKSA/IChcbiAgICAgICAgICBzdXBlcklzUnVsZVBvc3NpYmxlQ29tYm8oY29tYm8pXG4gICAgICAgICAgJiYgc2VsZi5pc01hdGhlbWF0aWNhbFBvc3NpYmlsaXR5KGNvbWJvKVxuICAgICAgICApIDogc3VwZXJJc1J1bGVQb3NzaWJsZUNvbWJvKGNvbWJvKVxuICAgICAgfSxcbiAgICAgIGlzTWF0aGVtYXRpY2FsUG9zc2liaWxpdHkoY29tYm8pIHtcbiAgICAgICAgc3dpdGNoIChzZWxmLm9wZXJhdGlvbikge1xuICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgcmV0dXJuIHN1bShjb21ibykgPT09IHNlbGYucmVzdWx0XG4gICAgICAgICAgY2FzZSAn4oiSJzpcbiAgICAgICAgICAgIHJldHVybiBkaWZmZXJlbmNlKGNvbWJvKSA9PT0gc2VsZi5yZXN1bHRcbiAgICAgICAgICBjYXNlICfiqIknOlxuICAgICAgICAgICAgcmV0dXJuIHByb2R1Y3QoY29tYm8pID09PSBzZWxmLnJlc3VsdFxuICAgICAgICAgIGNhc2UgJ8O3JzpcbiAgICAgICAgICAgIHJldHVybiBxdW90aWVudChjb21ibykgPT09IHNlbGYucmVzdWx0XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT3BlcmF0aW9uICR7c2VsZi5vcGVyYXRpb259IGRvZXNuJ3QgbWF0Y2ggb25lIG9mICssIC0sIOKoiSwgb3Igw7dgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuXG5leHBvcnQgY29uc3QgR3JvdXAgPSBDb2xsZWN0aW9uXG4gIC5uYW1lZCgnR3JvdXAnKVxuIiwiaW1wb3J0IHsgdHlwZXMgfSBmcm9tICdtb2J4LXN0YXRlLXRyZWUnXG5pbXBvcnQge1xuICBhbHRlcm5hdGl2ZUljb25zLFxuICBiYXNlSWNvbnMsXG4gIHJlcXVpcmVkSWNvbnMsXG4gIGVsaW1pbmF0ZWRJY29ucyxcbn0gZnJvbSAnLi4vc2hhcmVkL2RvbV9wYXJ0aWFscydcbmltcG9ydCB7IGdlbmVyYXRlQ2xhc3NOYW1lLCBzdHJpbmdTd2l0Y2ggfSBmcm9tICcuLi9zaGFyZWQvZ2VuZXJhbF91dGlsJ1xuaW1wb3J0IHsgR2FtZUJhc2UgfSBmcm9tICcuL2Jhc2UnXG5cbmNvbnN0IEZpbHRlclBvc3NpYmlsaXR5ID0gR2FtZUJhc2VcbiAgLm5hbWVkKCdGaWx0ZXJQb3NzaWJpbGl0eScpXG4gIC5wcm9wcyh7XG4gICAgdmFsdWU6IHR5cGVzLmludGVnZXIsXG4gICAgc3RhdHVzOiB0eXBlcy5vcHRpb25hbChcbiAgICAgIHR5cGVzLmVudW1lcmF0aW9uKCdTdGF0dXMnLCBbXG4gICAgICAgICdub25lJyxcbiAgICAgICAgJ3JlcXVpcmVkJyxcbiAgICAgICAgJ2VsaW1pbmF0ZWQnLFxuICAgICAgICAnYWx0ZXJuYXRpdmUnXG4gICAgICBdKSxcbiAgICAgICgpID0+ICdub25lJ1xuICAgICksXG4gIH0pXG4gIC52aWV3cyhzZWxmID0+IHtcbiAgICBjb25zdCBtb2RlU3RhdHVzTWFwID0ge1xuICAgICAgYW5kOiAncmVxdWlyZWQnLFxuICAgICAgbm90OiAnZWxpbWluYXRlZCcsXG4gICAgICBvcjogJ2FsdGVybmF0aXZlJyxcbiAgICB9XG5cbiAgICBjb25zdCBob3ZlckZsYWcgPSBtb2RlID0+IHtcbiAgICAgIGlmIChzZWxmLnN0YXR1cyA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHJldHVybiBgaG92ZXItJHttb2RlU3RhdHVzTWFwW21vZGVdfWBcbiAgICAgIH0gZWxzZSBpZiAoIXNlbGYubWF0Y2hlc01vZGUobW9kZSkpIHtcbiAgICAgICAgcmV0dXJuICdub3QtYWxsb3dlZCdcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBnZXRTdGF0dXNJY29uID0gc3RhdHVzID0+IHN0cmluZ1N3aXRjaChzdGF0dXMsICh7IF9jYXNlIH0pID0+IHtcbiAgICAgIF9jYXNlKCdyZXF1aXJlZCcsICgpID0+IHJlcXVpcmVkSWNvbnMoKSlcbiAgICAgIF9jYXNlKCdlbGltaW5hdGVkJywgKCkgPT4gZWxpbWluYXRlZEljb25zKCkpXG4gICAgICBfY2FzZSgnYWx0ZXJuYXRpdmUnLCAoKSA9PiBhbHRlcm5hdGl2ZUljb25zKCkpXG4gICAgICBfY2FzZSgnbm9uZScsICgpID0+IGJhc2VJY29ucygpKVxuICAgIH0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0IG5vSG92ZXJJY29ucygpIHtcbiAgICAgICAgcmV0dXJuIGdldFN0YXR1c0ljb24oc2VsZi5zdGF0dXMpXG4gICAgICB9LFxuICAgICAgbWF0Y2hlc01vZGUobW9kZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5zdGF0dXMgPT09IG1vZGVTdGF0dXNNYXBbbW9kZV1cbiAgICAgIH0sXG4gICAgICBob3Zlckljb25zKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc3RhdHVzID09PSAnbm9uZSdcbiAgICAgICAgICA/IGdldFN0YXR1c0ljb24obW9kZVN0YXR1c01hcFttb2RlXSlcbiAgICAgICAgICA6IGdldFN0YXR1c0ljb24oc2VsZi5zdGF0dXMpXG4gICAgICB9LFxuICAgICAgY2xhc3NOYW1lKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlQ2xhc3NOYW1lKCdmaWx0ZXItcG9zc2liaWxpdHknLCBbXG4gICAgICAgICAgc2VsZi5zdGF0dXMsXG4gICAgICAgICAgaG92ZXJGbGFnKG1vZGUpLFxuICAgICAgICBdKVxuICAgICAgfSxcbiAgICB9XG4gIH0pXG4gIC5hY3Rpb25zKHNlbGYgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGUoc3RhdHVzKSB7XG4gICAgICAgIGlmIChzZWxmLnN0YXR1cyA9PT0gc3RhdHVzKSB7XG4gICAgICAgICAgc2VsZi5zdGF0dXMgPSAnbm9uZSdcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLnN0YXR1cyA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgc2VsZi5zdGF0dXMgPSBzdGF0dXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ2Fubm90IHRvZ2dsZSBmcm9tICR7c2VsZi5zdGF0dXN9IHRvICR7c3RhdHVzfWApXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfVxuICB9KVxuXG5jb25zdCBGaWx0ZXIgPSBHYW1lQmFzZVxuICAubmFtZWQoJ0ZpbHRlcicpXG4gIC5wcm9wcyh7XG4gICAgcG9zc2liaWxpdGllczogdHlwZXMub3B0aW9uYWwoXG4gICAgICB0eXBlcy5hcnJheShGaWx0ZXJQb3NzaWJpbGl0eSksXG4gICAgICAoKSA9PiBbXVxuICAgICksXG4gIH0pXG4gIC52aWV3cyhzZWxmID0+ICh7XG4gICAgZ2V0IHJlcXVpcmVkKCkge1xuICAgICAgcmV0dXJuIHNlbGYucG9zc2liaWxpdGllc1xuICAgICAgICAuZmlsdGVyKHBvc3NpYmlsaXR5ID0+IHBvc3NpYmlsaXR5LnN0YXR1cyA9PT0gJ3JlcXVpcmVkJylcbiAgICB9LFxuICAgIGdldCByZXF1aXJlZFZhbHVlcygpIHtcbiAgICAgIHJldHVybiBzZWxmLnJlcXVpcmVkLm1hcChwb3NzaWJpbGl0eSA9PiBwb3NzaWJpbGl0eS52YWx1ZSlcbiAgICB9LFxuICAgIGdldCBlbGltaW5hdGVkKCkge1xuICAgICAgcmV0dXJuIHNlbGYucG9zc2liaWxpdGllc1xuICAgICAgICAuZmlsdGVyKHBvc3NpYmlsaXR5ID0+IHBvc3NpYmlsaXR5LnN0YXR1cyA9PT0gJ2VsaW1pbmF0ZWQnKVxuICAgIH0sXG4gICAgZ2V0IGVsaW1pbmF0ZWRWYWx1ZXMoKSB7XG4gICAgICByZXR1cm4gc2VsZi5lbGltaW5hdGVkLm1hcChwb3NzaWJpbGl0eSA9PiBwb3NzaWJpbGl0eS52YWx1ZSlcbiAgICB9LFxuICAgIGdldCBhbHRlcm5hdGl2ZXMoKSB7XG4gICAgICByZXR1cm4gc2VsZi5wb3NzaWJpbGl0aWVzXG4gICAgICAgIC5maWx0ZXIocG9zc2liaWxpdHkgPT4gcG9zc2liaWxpdHkuc3RhdHVzID09PSAnYWx0ZXJuYXRpdmUnKVxuICAgIH0sXG4gICAgZ2V0IGFsdGVybmF0aXZlVmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHNlbGYuYWx0ZXJuYXRpdmVzLm1hcChwb3NzaWJpbGl0eSA9PiBwb3NzaWJpbGl0eS52YWx1ZSlcbiAgICB9LFxuICAgIGdldFBvc3NpYmlsaXR5QnlWYWx1ZSh2YWwpIHtcbiAgICAgIHJldHVybiBzZWxmLnBvc3NpYmlsaXRpZXMuZmluZChwb3NzaWJpbGl0eSA9PiBwb3NzaWJpbGl0eS52YWx1ZSA9PT0gdmFsKVxuICAgIH0sXG4gICAgZmlsdGVyUG9zc2liaWxpdHlTdGF0dXModmFsKSB7XG4gICAgICByZXR1cm4gc2VsZi5nZXRQb3NzaWJpbGl0eUJ5VmFsdWUodmFsKS5zdGF0dXNcbiAgICB9LFxuICAgIGlzUmVxdWlyZWRWYWx1ZSh2YWwpIHtcbiAgICAgIHJldHVybiBzZWxmLmZpbHRlclBvc3NpYmlsaXR5U3RhdHVzKHZhbCkgPT09ICdyZXF1aXJlZCdcbiAgICB9LFxuICAgIGlzRWxpbWluYXRlZFZhbHVlKHZhbCkge1xuICAgICAgcmV0dXJuIHNlbGYuZmlsdGVyUG9zc2liaWxpdHlTdGF0dXModmFsKSA9PT0gJ2VsaW1pbmF0ZWQnXG4gICAgfSxcbiAgICBpc0FsdGVybmF0aXZlVmFsdWUodmFsKSB7XG4gICAgICByZXR1cm4gc2VsZi5maWx0ZXJQb3NzaWJpbGl0eVN0YXR1cyh2YWwpID09PSAnYWx0ZXJuYXRpdmUnXG4gICAgfSxcbiAgICBpc1N0YW5kYXJkVmFsdWUodmFsKSB7XG4gICAgICByZXR1cm4gc2VsZi5maWx0ZXJQb3NzaWJpbGl0eVN0YXR1cyh2YWwpID09PSAnbm9uZSdcbiAgICB9LFxuICAgIGlzUG9zc2libGVDb21ibyhjb21ibykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgc2VsZi5yZXF1aXJlZFZhbHVlcy5ldmVyeSh2YWwgPT4gY29tYm8uaW5jbHVkZXModmFsKSlcbiAgICAgICAgJiYgc2VsZi5lbGltaW5hdGVkVmFsdWVzLmV2ZXJ5KHZhbCA9PiAhY29tYm8uaW5jbHVkZXModmFsKSlcbiAgICAgICAgJiYgKFxuICAgICAgICAgIHNlbGYuYWx0ZXJuYXRpdmVWYWx1ZXMubGVuZ3RoID09PSAwXG4gICAgICAgICAgfHwgc2VsZi5hbHRlcm5hdGl2ZVZhbHVlcy5zb21lKHZhbCA9PiBjb21iby5pbmNsdWRlcyh2YWwpKVxuICAgICAgICApXG4gICAgICApXG4gICAgfSxcbiAgICBub0hvdmVySWNvbnModmFsKSB7XG4gICAgICByZXR1cm4gc2VsZi5nZXRQb3NzaWJpbGl0eUJ5VmFsdWUodmFsKS5ub0hvdmVySWNvbnNcbiAgICB9LFxuICAgIGhvdmVySWNvbnModmFsLCBtb2RlKSB7XG4gICAgICByZXR1cm4gc2VsZi5nZXRQb3NzaWJpbGl0eUJ5VmFsdWUodmFsKS5ob3Zlckljb25zKG1vZGUpXG4gICAgfSxcbiAgICBjbGFzc05hbWUodmFsLCBtb2RlKSB7XG4gICAgICByZXR1cm4gc2VsZi5nZXRQb3NzaWJpbGl0eUJ5VmFsdWUodmFsKS5jbGFzc05hbWUobW9kZSlcbiAgICB9LFxuICB9KSlcbiAgLmFjdGlvbnMoc2VsZiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXRpYWxpemUoc2l6ZSkge1xuICAgICAgICBzZWxmLnBvc3NpYmlsaXRpZXMgPSBBcnJheS5mcm9tKFxuICAgICAgICAgIEFycmF5KHNpemUpLFxuICAgICAgICAgIChfLCBpZHgpID0+IEZpbHRlclBvc3NpYmlsaXR5LmNyZWF0ZSh7IHZhbHVlOiBpZHggKyAxIH0pXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB0b2dnbGUodmFsLCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHN0cmluZ1N3aXRjaChtb2RlLCAoeyBfY2FzZSB9KSA9PiB7XG4gICAgICAgICAgX2Nhc2UoJ2FuZCcsICgpID0+ICdyZXF1aXJlZCcpXG4gICAgICAgICAgX2Nhc2UoJ25vdCcsICgpID0+ICdlbGltaW5hdGVkJylcbiAgICAgICAgICBfY2FzZSgnb3InLCAoKSA9PiAnYWx0ZXJuYXRpdmUnKVxuICAgICAgICB9KVxuICAgICAgICBzZWxmLmdldFBvc3NpYmlsaXR5QnlWYWx1ZSh2YWwpLnRvZ2dsZShzdGF0dXMpXG4gICAgICB9LFxuICAgICAgY2xlYXJNb2RlKG1vZGUpIHtcbiAgICAgICAgc2VsZi5wb3NzaWJpbGl0aWVzLmZvckVhY2gocG9zc2liaWxpdHkgPT4ge1xuICAgICAgICAgIGlmIChwb3NzaWJpbGl0eS5tYXRjaGVzTW9kZShtb2RlKSkge1xuICAgICAgICAgICAgcG9zc2liaWxpdHkuc3RhdHVzID0gJ25vbmUnXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHJlc2V0KCkge1xuICAgICAgICBzZWxmLnBvc3NpYmlsaXRpZXMuZm9yRWFjaChwb3NzaWJpbGl0eSA9PiBwb3NzaWJpbGl0eS5zdGF0dXMgPSAnbm9uZScpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG5leHBvcnQgZGVmYXVsdCBGaWx0ZXIiLCJpbXBvcnQgeyBhcHBseVNuYXBzaG90LCBmbG93LCBnZXRTbmFwc2hvdCwgb25BY3Rpb24sIG9uU25hcHNob3QsIHR5cGVzIH0gZnJvbSAnbW9ieC1zdGF0ZS10cmVlJ1xuaW1wb3J0IHsgR2FtZUJhc2UgfSBmcm9tICcuL2Jhc2UnXG5pbXBvcnQgVUkgZnJvbSAnLi91aSdcbmltcG9ydCBPcHRpb25zIGZyb20gJy4vb3B0aW9ucydcbmltcG9ydCBQdXp6bGUgZnJvbSAnLi9wdXp6bGUnXG5pbXBvcnQgTWV0YSBmcm9tICcuL21ldGEnXG5pbXBvcnQgeyBuZXh0SWQgfSBmcm9tICcuLi9zaGFyZWQvZ2VuZXJhbF91dGlsJ1xuaW1wb3J0IHsgZGJBZGQsIGRiR2V0IH0gZnJvbSAnLi4vc2hhcmVkL3N0b3JhZ2VfdXRpbCdcblxuY29uc3QgR2FtZSA9IEdhbWVCYXNlXG4gIC5uYW1lZCgnR2FtZScpXG4gIC5wcm9wcyh7XG4gICAgcHV6emxlOiB0eXBlcy5vcHRpb25hbChQdXp6bGUsICgpID0+IFB1enpsZS5jcmVhdGUoKSksXG4gICAgY3VyUHV6emxlSWR4OiB0eXBlcy5vcHRpb25hbCh0eXBlcy5pbnRlZ2VyLCAwKSxcbiAgICBtZXRhOiB0eXBlcy5vcHRpb25hbChNZXRhLCAoKSA9PiBNZXRhLmNyZWF0ZSgpKSxcbiAgICBvcHRpb25zOiB0eXBlcy5vcHRpb25hbChPcHRpb25zLCAoKSA9PiBPcHRpb25zLmNyZWF0ZSgpKSxcbiAgICB1aTogdHlwZXMub3B0aW9uYWwoVUksICgpID0+IFVJLmNyZWF0ZSgpKSxcbiAgfSlcbiAgLnZvbGF0aWxlKHNlbGYgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzdG9yZWRTbmFwc2hvdDogbnVsbFxuICAgIH1cbiAgfSlcbiAgLmV4dGVuZChzZWxmID0+IHtcbiAgICBjb25zdCB0YWtlUHV6emxlU25hcHNob3QgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzbmFwc2hvdElkID0gcGFyc2VJbnQobmV4dElkKCkpXG4gICAgICBjb25zdCBwdXp6bGUgPSBnZXRTbmFwc2hvdChzZWxmLnB1enpsZSlcbiAgICAgIHNlbGYuZW52LnNuYXBzaG90c1tzbmFwc2hvdElkXSA9IHB1enpsZVxuICAgICAgcmV0dXJuIHNuYXBzaG90SWRcbiAgICB9XG5cbiAgICBjb25zdCBnZXRPclNldFB1enpsZSA9IChpZCkgPT4ge1xuICAgICAgY29uc3QgY2FjaGVkR2FtZSA9IHNlbGYuZW52LnB1enpsZUNhY2hlLmdldChpZClcbiAgICAgIGlmIChjYWNoZWRHYW1lKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRHYW1lLnB1enpsZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHV6emxlID0gUHV6emxlLmNyZWF0ZShzZWxmLmVudi5zbmFwc2hvdHNbaWRdKVxuICAgICAgICBzZWxmLmVudi5wdXp6bGVDYWNoZS5zZXQoaWQsIEdhbWUuY3JlYXRlKHsgcHV6emxlIH0sIHNlbGYuZW52KSlcbiAgICAgICAgcmV0dXJuIHB1enpsZVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGdldE5ld1B1enpsZUlkeCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHB1enpsZXMgPSBzZWxmLmVudi5wdXp6bGVzXG4gICAgICBjb25zdCByYW5kb21JZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwdXp6bGVzLmxlbmd0aClcbiAgICAgIHJldHVybiByYW5kb21JZHggPT09IHNlbGYuY3VyUHV6emxlSWR4XG4gICAgICAgID8gZ2V0TmV3UHV6emxlSWR4KClcbiAgICAgICAgOiByYW5kb21JZHhcbiAgICB9XG5cbiAgICBjb25zdCBub0hpc3RvcnkgPSAoKSA9PiB7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNlbGYuZW52Lmhpc3RvcnkucG9wKClcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgY29uc3QgaWZDdXJTcXVhcmVFbXB0eSA9IGNiID0+IHtcbiAgICAgIGlmIChzZWxmLnVpLmN1clNxdWFyZS5oYXNWYWx1ZSkge1xuICAgICAgICBub0hpc3RvcnkoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGdldFN0b3JlZFNuYXBzaG90ID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHNlbGYuc3RvcmVkU25hcHNob3RcbiAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoc2VsZi5zdG9yZWRTbmFwc2hvdClcbiAgICAgICAgOiBkYkdldCgnZ2FtZVN0b3JlJykudGhlbihzbmFwc2hvdCA9PiB7XG4gICAgICAgICAgc2VsZi5zZXRTdG9yZWRTbmFwc2hvdChzbmFwc2hvdClcbiAgICAgICAgICByZXR1cm4gc25hcHNob3RcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCByZWNvcmRlZEFjdGlvbnMgPSB7XG4gICAgICBzZXRGb2N1c2VkU3F1YXJlKHZhbHVlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzZWxmLm9wdGlvbnMuYXV0b0Jsb2NrXG4gICAgICAgICAgJiYgIXNlbGYudWkuY3VyU3F1YXJlLmlzUG9zc2libGVWYWx1ZSh2YWx1ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgc2VsZi51aS5jdXJTcXVhcmUuY29uZmxpY3RpbmdTcXVhcmVzKHZhbHVlKVxuICAgICAgICAgICAgLmZvckVhY2goc3F1YXJlID0+IHNxdWFyZS5zZXRDb25mbGljdCgpKVxuXG4gICAgICAgICAgc2VsZi51aS5jdXJTcXVhcmUuc2V0TWlzdGFrZSh2YWx1ZSlcbiAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzZWxmLmVudi5oaXN0b3J5LnBvcCgpXG4gICAgICAgICAgfSwgMClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnVpLmN1clNxdWFyZS52YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgc2VsZi51aS5pc1N0YWdpbmcgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9nZ2xlRm9jdXNlZFNxdWFyZVBvc3NpYmlsaXR5KHZhbCkge1xuICAgICAgICBpZkN1clNxdWFyZUVtcHR5KCgpID0+IHNlbGYudWkuY3VyU3F1YXJlLnRvZ2dsZVBvc3NpYmlsaXR5KHZhbCkpXG4gICAgICB9LFxuICAgICAgcmVzZXRGb2N1c2VkU3F1YXJlUG9zc2liaWxpdGllcygpIHtcbiAgICAgICAgY29uc3Qgc3F1YXJlID0gc2VsZi51aS5jdXJTcXVhcmVcbiAgICAgICAgaWYgKCFzcXVhcmUuaGFzRWxpbWluYXRpb25zICYmICFzcXVhcmUuaGFzVmFsdWUpIHtcbiAgICAgICAgICBub0hpc3RvcnkoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYudWkuY3VyU3F1YXJlLmVsaW1pbmF0ZWRQb3NzaWJpbGl0aWVzID0gW11cbiAgICAgICAgICBzZWxmLnVpLmN1clNxdWFyZS52YWx1ZSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldFN0YWdlZFBvc3NpYmlsaXRpZXMoKSB7XG4gICAgICAgIGlmQ3VyU3F1YXJlRW1wdHkoKCkgPT4ge1xuICAgICAgICAgIHNlbGYudWkuY3VyU3F1YXJlLnNldFN0YWdlZFBvc3NpYmlsaXRpZXMoKVxuICAgICAgICAgIHNlbGYudWkuY2xlYXJTdGFnZWRQb3NzaWJpbGl0aWVzKClcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBjbGVhckZvY3VzZWRTcXVhcmUoKSB7XG4gICAgICAgIHNlbGYuc2V0Rm9jdXNlZFNxdWFyZShudWxsKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZVNlbGVjdGlvblBvc3NpYmlsaXR5KHZhbCkge1xuICAgICAgICBzZWxmLnVpLnRvZ2dsZVNlbGVjdGlvblBvc3NpYmlsaXR5KHZhbClcbiAgICAgIH0sXG4gICAgICB0b2dnbGVDdXJDYWdlQ29tYm8oY29tYm8pIHtcbiAgICAgICAgc2VsZi51aS5jdXJDYWdlLnRvZ2dsZUNvbWJvKGNvbWJvKVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUZpbHRlclBvc3NpYmlsaXR5KHZhbCkge1xuICAgICAgICBzZWxmLnVpLnRvZ2dsZUZpbHRlclBvc3NpYmlsaXR5KHZhbClcbiAgICAgIH0sXG4gICAgICBjbGVhckZpbHRlck1vZGUoKSB7XG4gICAgICAgIHNlbGYudWkuY2xlYXJGaWx0ZXJNb2RlKClcbiAgICAgIH0sXG4gICAgICBjbGVhckZpbHRlcigpIHtcbiAgICAgICAgc2VsZi51aS5jbGVhckZpbHRlcigpXG4gICAgICB9LFxuICAgICAgZW50ZXJJZigpIHtcbiAgICAgICAgY29uc3QgbWFpblNuYXBzaG90SWQgPSB0YWtlUHV6emxlU25hcHNob3QoKVxuICAgICAgICBzZWxmLm1ldGEuZW50ZXJJZihtYWluU25hcHNob3RJZClcbiAgICAgIH0sXG4gICAgICBlbnRlclRoZW4oKSB7XG4gICAgICAgIGNvbnN0IGlmU25hcHNob3RJZCA9IHRha2VQdXp6bGVTbmFwc2hvdCgpXG4gICAgICAgIHNlbGYubWV0YS5lbnRlclRoZW4oaWZTbmFwc2hvdElkKVxuICAgICAgfSxcbiAgICAgIGZpbmlzaEltcGxpY2F0aW9uKCkge1xuICAgICAgICBjb25zdCB0aGVuU25hcHNob3RJZCA9IHRha2VQdXp6bGVTbmFwc2hvdCgpXG4gICAgICAgIHNlbGYubWV0YS5zZXRJbXBsaWNhdGlvbih0aGVuU25hcHNob3RJZClcbiAgICAgICAgc2VsZi5leGl0SW1wbGljYXRpb24oKVxuICAgICAgfSxcbiAgICAgIGV4aXRJbXBsaWNhdGlvbigpIHtcbiAgICAgICAgYXBwbHlTbmFwc2hvdChzZWxmLnB1enpsZSwgc2VsZi5tZXRhLm1haW5TbmFwc2hvdClcbiAgICAgICAgc2VsZi5tZXRhLmNsZWFySW1wbGljYXRpb24oKVxuICAgICAgfSxcbiAgICB9XG5cbiAgICBjb25zdCBzaWxlbnRBY3Rpb25zID0ge1xuICAgICAgbmV3UHV6emxlKCkge1xuICAgICAgICBjb25zdCBuZXdJZHggPSBnZXROZXdQdXp6bGVJZHgoKVxuICAgICAgICBzZWxmLmN1clB1enpsZUlkeCA9IG5ld0lkeFxuXG4gICAgICAgIHNlbGYudWkucmVzZXQoKVxuICAgICAgICBzZWxmLnB1enpsZSA9IFB1enpsZS5jcmVhdGUoKVxuICAgICAgICBzZWxmLmluaXRpYWxpemUoKVxuICAgICAgfSxcbiAgICAgIHJlc2V0UHV6emxlKCkge1xuICAgICAgICBzZWxmLnVpLnJlc2V0KClcbiAgICAgICAgc2VsZi5wdXp6bGUucmVzZXQoKVxuICAgICAgfSxcbiAgICAgIHJlc2V0VG9TdG9yZWRTbmFwc2hvdDogZmxvdyhmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHlpZWxkIGdldFN0b3JlZFNuYXBzaG90KClcbiAgICAgICAgY29uc29sZS5sb2coc25hcHNob3QpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXBwbHlTbmFwc2hvdChzZWxmLCBzbmFwc2hvdClcbiAgICAgICAgICBzZWxmLnJlc2V0UHV6emxlKClcbiAgICAgICAgICBzZWxmLm9wdGlvbnMucmVzZXQoKVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBzZWxmLmluaXRpYWxpemUoKVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGFwcGx5U3RvcmVkU25hcHNob3Q6IGZsb3coZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSB5aWVsZCBnZXRTdG9yZWRTbmFwc2hvdCgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXBwbHlTbmFwc2hvdChzZWxmLCBzbmFwc2hvdClcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBhcHBseSBzdG9yZWQgc25hcHNob3QnKVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHNldFN0b3JlZFNuYXBzaG90KHNuYXBzaG90KSB7XG4gICAgICAgIHNlbGYuc3RvcmVkU25hcHNob3QgPSBzbmFwc2hvdFxuICAgICAgfSxcbiAgICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHsgY2FnZXMsIHNvbHV0aW9uIH0gPSBzZWxmLmVudi5wdXp6bGVzW3NlbGYuY3VyUHV6emxlSWR4XVxuXG4gICAgICAgIGNhZ2VzLmZvckVhY2goKHsgb3BlcmF0aW9uLCByZXN1bHQsIHNxdWFyZXMgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhZ2UgPSBzZWxmLnB1enpsZS5jYWdlcy5wdXQoeyBvcGVyYXRpb24sIHJlc3VsdCB9KVxuICAgICAgICAgIGNhZ2UuZmlsdGVyLmluaXRpYWxpemUoc2VsZi5lbnYuZ2xvYmFscy5zaXplKVxuXG4gICAgICAgICAgc3F1YXJlcy5mb3JFYWNoKHBvc2l0aW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNxdWFyZSA9IHNlbGYucHV6emxlLnNxdWFyZXMucHV0KHtcbiAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgIHNvbHV0aW9uOiBzb2x1dGlvbltwb3NpdGlvblswXV1bcG9zaXRpb25bMV1dLFxuICAgICAgICAgICAgICBjYWdlOiBjYWdlLmlkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgY2FnZS5hZGRTcXVhcmUoc3F1YXJlKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgYXR0YWNoSG9va3MoKSB7XG4gICAgICAgIG9uQWN0aW9uKHNlbGYsIGFjdGlvbiA9PiB7XG4gICAgICAgICAgaWYgKHNlbGYuc2hvdWxkUmVjb3JkQWN0aW9uKGFjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGYuZW52LmZ1dHVyZSA9IFtdXG4gICAgICAgICAgICBzZWxmLmVudi5oaXN0b3J5LnB1c2goc2VsZi5jdXJyZW50U3RhdGUpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIG9uU25hcHNob3Qoc2VsZiwgc25hcHNob3QgPT4ge1xuICAgICAgICAgIGRiQWRkKCdnYW1lU3RvcmUnLCBzbmFwc2hvdClcbiAgICAgICAgICBjb25zdCB7IGhpc3RvcnksIHNuYXBzaG90cywgZnV0dXJlIH0gPSBzZWxmLmVudlxuICAgICAgICAgIGRiQWRkKCdlbnYnLCB7IGhpc3RvcnksIHNuYXBzaG90cywgZnV0dXJlIH0pXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgYmVnaW5TdGFnaW5nKCkge1xuICAgICAgICBpZiAoIXNlbGYudWkuY3VyU3F1YXJlLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgc2VsZi51aS5pc1N0YWdpbmcgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdG9wU3RhZ2luZygpIHtcbiAgICAgICAgc2VsZi51aS5pc1N0YWdpbmcgPSBmYWxzZVxuXG4gICAgICAgIGlmIChzZWxmLnVpLmhhc1N0YWdlZFBvc3NpYmlsaXRpZXMpIHtcbiAgICAgICAgICBzZWxmLnNldFN0YWdlZFBvc3NpYmlsaXRpZXMoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9nZ2xlU3RhZ2VkUG9zc2liaWxpdHkodmFsKSB7XG4gICAgICAgIHNlbGYudWkudG9nZ2xlU3RhZ2VkUG9zc2liaWxpdHkodmFsKVxuICAgICAgfSxcbiAgICAgIGNsZWFyU3RhZ2VkUG9zc2liaWxpdGllcygpIHtcbiAgICAgICAgc2VsZi51aS5jbGVhclN0YWdlZFBvc3NpYmlsaXRpZXMoKVxuICAgICAgfSxcbiAgICAgIHNlbGVjdFNxdWFyZUJ5RGlyKGRpcikge1xuICAgICAgICBzZWxmLnVpLnNlbGVjdFNxdWFyZUJ5RGlyKGRpcilcbiAgICAgIH0sXG4gICAgICBzZWxlY3RTcXVhcmVCeVBvcyhwb3MpIHtcbiAgICAgICAgc2VsZi51aS5zZWxlY3RTcXVhcmVCeVBvcyhwb3MpXG4gICAgICB9LFxuICAgICAgc2VsZWN0U3F1YXJlQnlJZChpZCkge1xuICAgICAgICBzZWxmLnVpLnNlbGVjdFNxdWFyZUJ5SWQoaWQpXG4gICAgICB9LFxuICAgICAgY2xlYXJGb2N1cygpIHtcbiAgICAgICAgc2VsZi51aS5jdXJTcXVhcmUgPSBudWxsXG4gICAgICB9LFxuICAgICAgdW5kb09yUmVkbyh7IHBvcEZyb20sIHB1c2hUbyB9KSB7XG4gICAgICAgIGlmIChwb3BGcm9tLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwdXNoVG8ucHVzaChzZWxmLmN1cnJlbnRTdGF0ZSlcbiAgICAgICAgICBjb25zdCBuZXh0U3RhdGUgPSBwb3BGcm9tLnBvcCgpXG4gICAgICAgICAgYXBwbHlTbmFwc2hvdChzZWxmLnB1enpsZSwgbmV4dFN0YXRlLnB1enpsZSlcbiAgICAgICAgICBhcHBseVNuYXBzaG90KHNlbGYubWV0YSwgbmV4dFN0YXRlLm1ldGEpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bmRvKCkge1xuICAgICAgICBzZWxmLnVuZG9PclJlZG8oe1xuICAgICAgICAgIHBvcEZyb206IHNlbGYuZW52Lmhpc3RvcnksXG4gICAgICAgICAgcHVzaFRvOiBzZWxmLmVudi5mdXR1cmVcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICByZWRvKCkge1xuICAgICAgICBzZWxmLnVuZG9PclJlZG8oe1xuICAgICAgICAgIHBvcEZyb206IHNlbGYuZW52LmZ1dHVyZSxcbiAgICAgICAgICBwdXNoVG86IHNlbGYuZW52Lmhpc3RvcnlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlld3M6IHtcbiAgICAgICAgZ2V0IHJlY29yZGVkQWN0aW9ucygpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVjb3JkZWRBY3Rpb25zKVxuICAgICAgICB9LFxuICAgICAgICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwdXp6bGU6IGdldFNuYXBzaG90KHNlbGYucHV6emxlKSxcbiAgICAgICAgICAgIG1ldGE6IGdldFNuYXBzaG90KHNlbGYubWV0YSlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZFJlY29yZEFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5yZWNvcmRlZEFjdGlvbnMuaW5jbHVkZXMoYWN0aW9uLm5hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIGltcGxpY2F0aW9uUHV6emxlcygpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5tZXRhLmltcGxpY2F0aW9uc1xuICAgICAgICAgICAgLm1hcChzZWxmLmdldFB1enpsZXNGcm9tSW1wbGljYXRpb24pXG4gICAgICAgIH0sXG4gICAgICAgIHBvc3NpYmxlSW1wbGljYXRpb25zKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmltcGxpY2F0aW9uUHV6emxlcygpXG4gICAgICAgICAgICAuZmlsdGVyKCh7IHRoZW5QdXp6bGUgfSkgPT4gc2VsZi5pc1Bvc3NpYmxlUHV6emxlKHRoZW5QdXp6bGUpKVxuICAgICAgICB9LFxuICAgICAgICBmdWxmaWxsZWRJbXBsaWNhdGlvbnMoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYucG9zc2libGVJbXBsaWNhdGlvbnMoKVxuICAgICAgICAgICAgLmZpbHRlcigoeyBpZlB1enpsZSB9KSA9PiBzZWxmLmlzRnVsZmlsbGVkUHV6emxlKGlmUHV6emxlKSlcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UHV6emxlc0Zyb21JbXBsaWNhdGlvbihbaWZJZCwgdGhlbklkXSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZlB1enpsZTogZ2V0T3JTZXRQdXp6bGUoaWZJZCksXG4gICAgICAgICAgICB0aGVuUHV6emxlOiBnZXRPclNldFB1enpsZSh0aGVuSWQpLFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXNQb3NzaWJsZVB1enpsZShwdXp6bGUpIHtcbiAgICAgICAgICByZXR1cm4gcHV6emxlLnNxdWFyZXNBcnJheS5ldmVyeShzcXVhcmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VyU3F1YXJlID0gc2VsZi5wdXp6bGUuc3F1YXJlcy5nZXQoc3F1YXJlLmlkKVxuICAgICAgICAgICAgcmV0dXJuIGN1clNxdWFyZS5pc0NvbnNpc3RlbnRXaXRoKHNxdWFyZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBpc0Z1bGZpbGxlZFB1enpsZShwdXp6bGUpIHtcbiAgICAgICAgICByZXR1cm4gcHV6emxlLnNxdWFyZXNBcnJheS5ldmVyeShzcXVhcmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VyU3F1YXJlID0gc2VsZi5wdXp6bGUuc3F1YXJlcy5nZXQoc3F1YXJlLmlkKVxuICAgICAgICAgICAgcmV0dXJuIGN1clNxdWFyZS5pc0xvZ2ljYWxTdWJzZXRPZihzcXVhcmUpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIC4uLnJlY29yZGVkQWN0aW9ucyxcbiAgICAgICAgLi4uc2lsZW50QWN0aW9ucyxcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbmV4cG9ydCBkZWZhdWx0IEdhbWUiLCJpbXBvcnQgeyB0eXBlcyB9IGZyb20gXCJtb2J4LXN0YXRlLXRyZWVcIjtcbmltcG9ydCB7IEdhbWVCYXNlIH0gZnJvbSBcIi4vYmFzZVwiO1xuaW1wb3J0IFB1enpsZSBmcm9tICcuL3B1enpsZSdcblxuY29uc3QgTWV0YSA9IEdhbWVCYXNlXG4gIC5uYW1lZCgnTWV0YScpXG4gIC5wcm9wcyh7XG4gICAgaW1wbGljYXRpb25zOiB0eXBlcy5vcHRpb25hbChcbiAgICAgIHR5cGVzLmFycmF5KHR5cGVzLmFycmF5KHR5cGVzLm51bWJlcikpLFxuICAgICAgKCkgPT4gW11cbiAgICApLFxuICAgIG1haW5JZDogdHlwZXMubWF5YmVOdWxsKHR5cGVzLmludGVnZXIpLFxuICAgIGlmSWQ6IHR5cGVzLm1heWJlTnVsbCh0eXBlcy5pbnRlZ2VyKSxcbiAgICBtb2RlOiB0eXBlcy5vcHRpb25hbChcbiAgICAgIHR5cGVzLmVudW1lcmF0aW9uKCdNb2RlJywgWydtYWluJywgJ2lmJywgJ3RoZW4nXSksXG4gICAgICAoKSA9PiAnbWFpbidcbiAgICApXG4gIH0pXG4gIC52b2xhdGlsZShzZWxmID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgX3N0YWdlZE1haW46IHsgaWQ6IG51bGwsIHB1enpsZTogbnVsbCB9LFxuICAgICAgX3N0YWdlZElmOiB7IGlkOiBudWxsLCBwdXp6bGU6IG51bGwgfVxuICAgIH1cbiAgfSlcbiAgLnZpZXdzKHNlbGYgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXQgbWFpblNuYXBzaG90KCkge1xuICAgICAgICByZXR1cm4gc2VsZi5lbnYuc25hcHNob3RzW3NlbGYubWFpbklkXVxuICAgICAgfSxcbiAgICAgIGdldCBpZlNuYXBzaG90KCkge1xuICAgICAgICByZXR1cm4gc2VsZi5lbnYuc25hcHNob3RzW3NlbGYuaWZJZF1cbiAgICAgIH0sXG4gICAgICBnZXQgc3RhZ2VkTWFpbigpIHtcbiAgICAgICAgY29uc3QgeyBpZCwgcHV6emxlIH0gPSBzZWxmLl9zdGFnZWRNYWluXG4gICAgICAgIGlmIChzZWxmLm1vZGUgIT09ICdpZicgJiYgc2VsZi5tb2RlICE9PSAndGhlbicpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9IGVsc2UgaWYgKGlkID09PSBzZWxmLm1haW5JZCAmJiBwdXp6bGUpIHtcbiAgICAgICAgICByZXR1cm4gcHV6emxlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcHV6emxlID0gUHV6emxlLmNyZWF0ZShzZWxmLm1haW5TbmFwc2hvdClcbiAgICAgICAgICBzZWxmLl9zdGFnZWRNYWluID0geyBpZDogc2VsZi5tYWluSWQsIHB1enpsZSB9XG4gICAgICAgICAgcmV0dXJuIHB1enpsZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0IHN0YWdlZElmKCkge1xuICAgICAgICBjb25zdCB7IGlkLCBwdXp6bGUgfSA9IHNlbGYuX3N0YWdlZElmXG4gICAgICAgIGlmIChzZWxmLm1vZGUgIT09ICd0aGVuJykge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0gZWxzZSBpZiAoaWQgPT09IHNlbGYuaWZJZCAmJiBwdXp6bGUpIHtcbiAgICAgICAgICByZXR1cm4gcHV6emxlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcHV6emxlID0gUHV6emxlLmNyZWF0ZShzZWxmLmlmU25hcHNob3QpXG4gICAgICAgICAgc2VsZi5fc3RhZ2VkSWYgPSB7IGlkOiBzZWxmLmlmSWQsIHB1enpsZSB9XG4gICAgICAgICAgcmV0dXJuIHB1enpsZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH1cbiAgfSlcbiAgLmFjdGlvbnMoc2VsZiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVySWYobWFpbklkKSB7XG4gICAgICAgIHNlbGYubWFpbklkID0gbWFpbklkXG4gICAgICAgIHNlbGYubW9kZSA9ICdpZidcbiAgICAgIH0sXG4gICAgICBlbnRlclRoZW4oaWZJZCkge1xuICAgICAgICBzZWxmLmlmSWQgPSBpZklkXG4gICAgICAgIHNlbGYubW9kZSA9ICd0aGVuJ1xuICAgICAgfSxcbiAgICAgIHNldEltcGxpY2F0aW9uKHRoZW5JZCkge1xuICAgICAgICBjb25zdCBpbXBsaWNhdGlvbiA9IFtzZWxmLmlmSWQsIHRoZW5JZF1cbiAgICAgICAgc2VsZi5pbXBsaWNhdGlvbnMucHVzaChpbXBsaWNhdGlvbilcbiAgICAgIH0sXG4gICAgICBjbGVhckltcGxpY2F0aW9uKCkge1xuICAgICAgICBzZWxmLl9zdGFnZWRNYWluID0geyBpZDogbnVsbCwgcHV6emxlOiBudWxsIH1cbiAgICAgICAgc2VsZi5fc3RhZ2VkSWYgPSB7IGlkOiBudWxsLCBwdXp6bGU6IG51bGwgfVxuICAgICAgICBzZWxmLm1haW5JZCA9IG51bGxcbiAgICAgICAgc2VsZi5pZklkID0gbnVsbFxuICAgICAgICBzZWxmLm1vZGUgPSAnbWFpbidcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbmV4cG9ydCBkZWZhdWx0IE1ldGEiLCJpbXBvcnQgeyBnZW5lcmF0ZUNsYXNzTmFtZSB9IGZyb20gJy4uL3NoYXJlZC9nZW5lcmFsX3V0aWwnXG5pbXBvcnQgeyBHYW1lQmFzZSB9IGZyb20gJy4vYmFzZSdcblxuY29uc3QgT3B0aW9ucyA9IEdhbWVCYXNlXG4gIC5uYW1lZCgnT3B0aW9ucycpXG4gIC5wcm9wcyh7XG4gICAgYXV0b0Jsb2NrOiB0cnVlLFxuICAgIGF1dG9FbGltaW5hdGU6IHRydWUsXG4gICAgYXV0b0VsaW1NYXRoSW1wb3NzaWJpbGl0aWVzOiB0cnVlLFxuICAgIG1heERpc3BsYXllZFBvc3NpYmlsaXRpZXM6IDksXG4gICAgd2Fsa3Rocm91Z2g6IGZhbHNlLFxuICB9KVxuICAudmlld3Moc2VsZiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldCBhdXRvQmxvY2tDbGFzc05hbWUoKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUNsYXNzTmFtZSgndG9nZ2xlJywgW1xuICAgICAgICAgIFtzZWxmLmF1dG9CbG9jaywgJ29uJ11cbiAgICAgICAgXSlcbiAgICAgIH0sXG4gICAgICBnZXQgYXV0b0VsaW1DbGFzc05hbWUoKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUNsYXNzTmFtZSgndG9nZ2xlJywgW1xuICAgICAgICAgIFtzZWxmLmF1dG9FbGltaW5hdGUsICdvbiddXG4gICAgICAgIF0pXG4gICAgICB9LFxuICAgICAgZ2V0IGF1dG9FbGltTWF0aEltcG9zc2liaWxpdGllc0NsYXNzTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlQ2xhc3NOYW1lKCd0b2dnbGUnLCBbXG4gICAgICAgICAgW3NlbGYuYXV0b0VsaW1NYXRoSW1wb3NzaWJpbGl0aWVzLCAnb24nXVxuICAgICAgICBdKVxuICAgICAgfSxcbiAgICAgIGdldCB3YWxrdGhyb3VnaENsYXNzTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlQ2xhc3NOYW1lKCd0b2dnbGUnLCBbXG4gICAgICAgICAgW3NlbGYud2Fsa3Rocm91Z2gsICdvbiddXG4gICAgICAgIF0pXG4gICAgICB9LFxuICAgIH1cbiAgfSlcbiAgLmFjdGlvbnMoc2VsZiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldE9wdGlvbihvcHRpb24sIHZhbCkge1xuICAgICAgICBzZWxmW29wdGlvbl0gPSB2YWxcbiAgICAgIH0sXG4gICAgICB0b2dnbGVBdXRvQmxvY2soKSB7XG4gICAgICAgIHNlbGYuYXV0b0Jsb2NrID0gIXNlbGYuYXV0b0Jsb2NrXG4gICAgICB9LFxuICAgICAgdG9nZ2xlQXV0b0VsaW1pbmF0ZSgpIHtcbiAgICAgICAgc2VsZi5hdXRvRWxpbWluYXRlID0gIXNlbGYuYXV0b0VsaW1pbmF0ZVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUF1dG9FbGltTWF0aEltcG9zc2liaWxpdGllcygpIHtcbiAgICAgICAgc2VsZi5hdXRvRWxpbU1hdGhJbXBvc3NpYmlsaXRpZXMgPSAhc2VsZi5hdXRvRWxpbU1hdGhJbXBvc3NpYmlsaXRpZXNcbiAgICAgIH0sXG4gICAgICB0b2dnbGVXYWxrdGhyb3VnaCgpIHtcbiAgICAgICAgc2VsZi53YWxrdGhyb3VnaCA9ICFzZWxmLndhbGt0aHJvdWdoXG4gICAgICB9LFxuICAgICAgc2V0TWF4RGlzcGxheWVkUG9zc2liaWxpdGllcyhudW0pIHtcbiAgICAgICAgaWYgKG51bSA8IDIgfHwgbnVtID4gOSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYubWF4RGlzcGxheWVkUG9zc2liaWxpdGllcyA9IG51bVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNldCgpIHtcbiAgICAgICAgc2VsZi5hdXRvQmxvY2sgPSB0cnVlXG4gICAgICAgIHNlbGYuYXV0b0VsaW1pbmF0ZSA9IHRydWVcbiAgICAgICAgc2VsZi5hdXRvRWxpbU1hdGhJbXBvc3NpYmlsaXRpZXMgPSB0cnVlXG4gICAgICAgIHNlbGYubWF4RGlzcGxheWVkUG9zc2liaWxpdGllcyA9IDlcbiAgICAgICAgc2VsZi5hbHdheXNTaG93V2Fsa3Rocm91Z2ggPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuZXhwb3J0IGRlZmF1bHQgT3B0aW9ucyIsImltcG9ydCB7IHR5cGVzIH0gZnJvbSAnbW9ieC1zdGF0ZS10cmVlJ1xuaW1wb3J0IHsgbmV4dElkIH0gZnJvbSAnLi4vc2hhcmVkL2dlbmVyYWxfdXRpbCdcbmltcG9ydCB7IElkLCBHYW1lQmFzZSB9IGZyb20gJy4vYmFzZSdcbmltcG9ydCB7IENhZ2UsIEdyb3VwIH0gZnJvbSAnLi9jb2xsZWN0aW9ucydcbmltcG9ydCBTcXVhcmUgZnJvbSAnLi9zcXVhcmUnXG5cbmNvbnN0IFB1enpsZSA9IEdhbWVCYXNlXG4gIC5uYW1lZCgnUHV6emxlJylcbiAgLnByb3BzKHtcbiAgICBpZDogSWQsXG4gICAgdXVpZDogdHlwZXMub3B0aW9uYWwodHlwZXMuc3RyaW5nLCBuZXh0SWQpLFxuICAgIHNxdWFyZXM6IHR5cGVzLm1hcChTcXVhcmUpLFxuICAgIGNhZ2VzOiB0eXBlcy5tYXAoQ2FnZSksXG4gICAgZ3JvdXBzOiB0eXBlcy5tYXAoR3JvdXApLFxuICB9KVxuICAudmlld3Moc2VsZiA9PiB7XG4gICAgY29uc3QgcG9zVG9JZE1hcCA9IHt9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0IGNvbGxlY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gWy4uLnNlbGYuY2FnZXMudmFsdWVzKCksIC4uLnNlbGYuZ3JvdXBzLnZhbHVlcygpXVxuICAgICAgfSxcbiAgICAgIGdldCBzcXVhcmVzQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHNlbGYuc3F1YXJlcy52YWx1ZXMoKSlcbiAgICAgIH0sXG4gICAgICBnZXQgY2FnZXNBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc2VsZi5jYWdlcy52YWx1ZXMoKSlcbiAgICAgIH0sXG4gICAgICBnZXQgZ3JvdXBzQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHNlbGYuZ3JvdXBzLnZhbHVlcygpKVxuICAgICAgfSxcbiAgICAgIGdldFNxdWFyZUJ5UG9zKHBvcykge1xuICAgICAgICBpZiAoIXNlbGYuaXNWYWxpZFBvcyhwb3MpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCBzdHJQb3MgPSBwb3Muam9pbignLCcpXG4gICAgICAgIGlmICghcG9zVG9JZE1hcFtzdHJQb3NdKSB7XG4gICAgICAgICAgcG9zVG9JZE1hcFtzdHJQb3NdID0gc2VsZi5zcXVhcmVzQXJyYXlcbiAgICAgICAgICAgIC5maW5kKHNxID0+IHNxLnBvc2l0aW9uLmpvaW4oJywnKSA9PT0gc3RyUG9zKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc1RvSWRNYXBbc3RyUG9zXVxuICAgICAgfSxcbiAgICAgIGdldFNxdWFyZXNCeVJvdyhyb3cpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc3F1YXJlc0FycmF5XG4gICAgICAgICAgLmZpbHRlcihzcXVhcmUgPT4gc3F1YXJlLnJvdyA9PT0gcm93KVxuICAgICAgfSxcbiAgICAgIGdldFNxdWFyZXNCeUNvbChjb2wpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc3F1YXJlc0FycmF5XG4gICAgICAgICAgLmZpbHRlcihzcXVhcmUgPT4gc3F1YXJlLmNvbCA9PT0gY29sKVxuICAgICAgfSxcbiAgICAgIGdldENvbGxlY3Rpb25zQnlTcXVhcmUoc3F1YXJlKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNvbGxlY3Rpb25zLmZpbHRlcihjID0+IGMuc3F1YXJlcy5pbmNsdWRlcyhzcXVhcmUpKVxuICAgICAgfSxcbiAgICAgIGlzVmFsaWRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MuZXZlcnkobiA9PiBuID49IDAgJiYgbiA8PSA5KVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgLmFjdGlvbnMoc2VsZiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc2V0VXVpZCgpIHtcbiAgICAgICAgc2VsZi51dWlkID0gbmV4dElkKClcbiAgICAgIH0sXG4gICAgICByZXNldCgpIHtcbiAgICAgICAgc2VsZi5zcXVhcmVzQXJyYXkuZm9yRWFjaChzcXVhcmUgPT4gc3F1YXJlLnJlc2V0KCkpXG4gICAgICAgIHNlbGYuY29sbGVjdGlvbnMuZm9yRWFjaChjb2xsZWN0aW9uID0+IGNvbGxlY3Rpb24ucmVzZXQoKSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbmV4cG9ydCBkZWZhdWx0IFB1enpsZSIsImltcG9ydCB7IGZsb3csIHNldExpdmVsaW5lc3NDaGVja2luZywgdHlwZXMgfSBmcm9tICdtb2J4LXN0YXRlLXRyZWUnXG5pbXBvcnQgeyBJQ09OUyB9IGZyb20gJy4uL3NoYXJlZC9jb25zdGFudHMnXG5pbXBvcnQgeyB3YWl0LCBjbGFzc2VzLCBhcnJheVVuaW9uLCB0b2dnbGVQcmVzZW5jZUluQXJyYXksIHB1c2hJZk5vdEluY2x1ZGVkLCByZW1vdmVJZkluY2x1ZGVkLCBnZW5lcmF0ZUNsYXNzTmFtZSB9IGZyb20gJy4uL3NoYXJlZC9nZW5lcmFsX3V0aWwnXG5pbXBvcnQgeyBJZCwgUG9zaXRpb24sIEdhbWVCYXNlIH0gZnJvbSAnLi9iYXNlJ1xuaW1wb3J0IHsgQ2FnZSB9IGZyb20gJy4vY29sbGVjdGlvbnMnXG5cbmNvbnN0IFNxdWFyZSA9IEdhbWVCYXNlXG4gIC5uYW1lZCgnU3F1YXJlJylcbiAgLnByb3BzKHtcbiAgICBpZDogSWQsXG4gICAgcG9zaXRpb246IFBvc2l0aW9uLFxuICAgIGNhZ2U6IHR5cGVzLm1heWJlTnVsbCh0eXBlcy5yZWZlcmVuY2UodHlwZXMubGF0ZSgoKSA9PiBDYWdlKSkpLFxuICAgIHZhbHVlOiB0eXBlcy5tYXliZU51bGwodHlwZXMuaW50ZWdlciksXG4gICAgbWlzdGFrZVZhbHVlOiB0eXBlcy5tYXliZU51bGwodHlwZXMuaW50ZWdlciksXG4gICAgc29sdXRpb246IHR5cGVzLmludGVnZXIsXG4gICAgZWxpbWluYXRlZFBvc3NpYmlsaXRpZXM6IHR5cGVzLm9wdGlvbmFsKHR5cGVzLmFycmF5KHR5cGVzLmludGVnZXIpLCAoKSA9PiBbXSksXG4gICAgc3RhdHVzOiB0eXBlcy5vcHRpb25hbChcbiAgICAgIHR5cGVzLmVudW1lcmF0aW9uKCdTdGF0dXMnLCBbJ25vbmUnLCAnbWlzdGFrZScsICdjb25mbGljdCddKSxcbiAgICAgICgpID0+ICdub25lJ1xuICAgICksXG4gIH0pXG4gIC5leHRlbmQoc2VsZiA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFBvc3NpYmlsaXRpZXMgPSBBcnJheS5mcm9tKEFycmF5KDkpLCAoXywgaWR4KSA9PiBpZHggKyAxKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZXdzOiB7XG4gICAgICAgIGdldCBjb2xsZWN0aW9ucygpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5yb290UHV6emxlLmdldENvbGxlY3Rpb25zQnlTcXVhcmUoc2VsZilcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHJvd1NxdWFyZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYucm9vdFB1enpsZS5nZXRTcXVhcmVzQnlSb3coc2VsZi5yb3cpXG4gICAgICAgICAgICAuZmlsdGVyKHNxdWFyZSA9PiBzcXVhcmUgIT09IHNlbGYpXG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjb2xTcXVhcmVzKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLnJvb3RQdXp6bGUuZ2V0U3F1YXJlc0J5Q29sKHNlbGYuY29sKVxuICAgICAgICAgICAgLmZpbHRlcihzcXVhcmUgPT4gc3F1YXJlICE9PSBzZWxmKVxuICAgICAgICB9LFxuICAgICAgICBnZXQgcm93Q29sU3F1YXJlcygpIHtcbiAgICAgICAgICByZXR1cm4gWy4uLnNlbGYucm93U3F1YXJlcywgLi4uc2VsZi5jb2xTcXVhcmVzXVxuICAgICAgICB9LFxuICAgICAgICBnZXQgcm93Q29sVmFsdWVzKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLnJvd0NvbFNxdWFyZXNcbiAgICAgICAgICAgIC5tYXAoc3F1YXJlID0+IHNxdWFyZS52YWx1ZSlcbiAgICAgICAgICAgIC5maWx0ZXIodmFsID0+IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuICAgICAgICB9LFxuICAgICAgICBnZXQgY29sbGVjdGlvblBvc3NpYmlsaXRpZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxQb3NzaWJpbGl0aWVzLmZpbHRlcih2YWwgPT5cbiAgICAgICAgICAgIHNlbGYuY29sbGVjdGlvbnMuZXZlcnkoYyA9PiBjLmlzUG9zc2libGVWYWx1ZSh2YWwpKVxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNxdWFyZVBvc3NpYmxpdGllcygpIHtcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbFBvc3NpYmlsaXRpZXMuZmlsdGVyKHZhbCA9PlxuICAgICAgICAgICAgIXNlbGYuZWxpbWluYXRlZFBvc3NpYmlsaXRpZXMuaW5jbHVkZXModmFsKVxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNxdWFyZUFuZENvbGxlY3Rpb25Qb3NzaWJpbGl0aWVzKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmNvbGxlY3Rpb25Qb3NzaWJpbGl0aWVzXG4gICAgICAgICAgICAuZmlsdGVyKHZhbCA9PiBzZWxmLnNxdWFyZVBvc3NpYmxpdGllcy5pbmNsdWRlcyh2YWwpKVxuICAgICAgICB9LFxuICAgICAgICBnZXQgcG9zc2liaWxpdGllcygpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5oYXNWYWx1ZVxuICAgICAgICAgICAgPyBbc2VsZi52YWx1ZV1cbiAgICAgICAgICAgIDogc2VsZi5zcXVhcmVBbmRDb2xsZWN0aW9uUG9zc2liaWxpdGllc1xuICAgICAgICAgICAgICAuZmlsdGVyKHZhbCA9PiAhc2VsZi5pc0F1dG9FbGltaW5hdGVkVmFsdWUodmFsKSlcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGRhdGFQb3MoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYucG9zaXRpb24uam9pbignLCcpXG4gICAgICAgIH0sXG4gICAgICAgIGdldCByb3coKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYucG9zaXRpb25bMF1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNvbCgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5wb3NpdGlvblsxXVxuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNDb3JyZWN0KCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLnZhbHVlID09PSBzZWxmLnNvbHV0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc0NhZ2VUb3AoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYucm93ID4gMCAmJiBzZWxmLmNhZ2UuYm91bmRzLnRvcFNxdWFyZXMuaW5jbHVkZXMoc2VsZilcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGlzQ2FnZUxlZnQoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuY29sID4gMCAmJiBzZWxmLmNhZ2UuYm91bmRzLmxlZnRTcXVhcmVzLmluY2x1ZGVzKHNlbGYpXG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc0ZvY3VzZWQoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYucm9vdFVpLmN1clNxdWFyZSA9PT0gc2VsZlxuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNTZWxlY3RlZCgpIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgIXNlbGYuaXNGb2N1c2VkXG4gICAgICAgICAgICAmJiBzZWxmLnJvb3RVaS5zZWxlY3RlZFNxdWFyZXMuaW5jbHVkZXMoc2VsZilcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpc1N0YWdpbmcoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuaXNGb2N1c2VkICYmIHNlbGYucm9vdFVpLmlzU3RhZ2luZ1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaGFzRWxpbWluYXRpb25zKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmVsaW1pbmF0ZWRQb3NzaWJpbGl0aWVzLmxlbmd0aCA+IDBcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGhhc1ZhbHVlKCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2Ygc2VsZi52YWx1ZSA9PT0gJ251bWJlcidcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGxhYmVsKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmNhZ2UuYW5jaG9yID09PSBzZWxmID8gc2VsZi5jYWdlLmxhYmVsVGV4dCA6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIGdldCBkaXNwbGF5ZWRWYWx1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5zdGF0dXMgPT09ICdtaXN0YWtlJ1xuICAgICAgICAgICAgPyBzZWxmLm1pc3Rha2VWYWx1ZVxuICAgICAgICAgICAgOiBzZWxmLnZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIGdldCBkaXNwbGF5ZWRQb3NzaWJpbGl0aWVzKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmlzU3RhZ2luZ1xuICAgICAgICAgICAgPyBzZWxmLnJvb3RVaS5zdGFnZWRQb3NzaWJpbGl0aWVzXG4gICAgICAgICAgICA6IHNlbGYucG9zc2liaWxpdGllc1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2xhc3NOYW1lKCkge1xuICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUNsYXNzTmFtZSgnc3F1YXJlJywgW1xuICAgICAgICAgICAgW3NlbGYuc3RhdHVzICE9PSAnbm9uZScsIHNlbGYuc3RhdHVzXSxcbiAgICAgICAgICAgIFtzZWxmLmlzRm9jdXNlZCwgJ2ZvY3VzZWQnXSxcbiAgICAgICAgICAgIFtzZWxmLmlzU2VsZWN0ZWQsICdzZWxlY3RlZCddXG4gICAgICAgICAgXSlcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNob3VsZFNob3dQb3NzaWJpbGl0aWVzKCkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBzZWxmLnJvb3RPcHRpb25zLm1heERpc3BsYXllZFBvc3NpYmlsaXRpZXMgPj1cbiAgICAgICAgICAgIHNlbGYuZGlzcGxheWVkUG9zc2liaWxpdGllcy5sZW5ndGhcbiAgICAgICAgICAgICYmIHNlbGYudmFsdWUgPT09IG51bGxcbiAgICAgICAgICAgICYmIHNlbGYubWlzdGFrZVZhbHVlID09PSBudWxsXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICAgICAgICBnZXQgaW5pdGlhbEh0bWwoKSB7XG4gICAgICAgICAgY29uc3QgZWxlID0gc2VsZi5lbnYudGVtcGxhdGVzLnNxdWFyZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgICBlbGUuZGF0YXNldC5wb3MgPSBzZWxmLmRhdGFQb3NcbiAgICAgICAgICByZXR1cm4gZWxlXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZsaWN0aW5nU3F1YXJlcyh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdmFsID09PSBudWxsXG4gICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICA6IHNlbGYucm93Q29sU3F1YXJlcy5maWx0ZXIoc3F1YXJlID0+IHNxdWFyZS52YWx1ZSA9PT0gdmFsKVxuICAgICAgICB9LFxuICAgICAgICBwb3NzaWJpbGl0eVN0YXR1c2VzKHZhbCkge1xuICAgICAgICAgIGlmIChzZWxmLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi52YWx1ZSA9PT0gdmFsID8gWydjaG9zZW4nXSA6IFsndW5jaG9zZW4nXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3RhdHVzZXMgPSBbXVxuXG4gICAgICAgICAgICBpZiAoc2VsZi5pc1NxdWFyZUVsaW1pbmF0ZWRWYWx1ZSh2YWwpKSB7XG4gICAgICAgICAgICAgIHN0YXR1c2VzLnB1c2goJ3NxdWFyZS1lbGltaW5hdGVkJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmlzQ29sbGVjdGlvbkVsaW1pbmF0ZWRWYWx1ZSh2YWwpKSB7XG4gICAgICAgICAgICAgIHN0YXR1c2VzLnB1c2goJ2NvbGxlY3Rpb24tZWxpbWluYXRlZCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0F1dG9FbGltaW5hdGVkVmFsdWUodmFsKSkge1xuICAgICAgICAgICAgICBzdGF0dXNlcy5wdXNoKCdhdXRvLWVsaW1pbmF0ZWQnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzZXMubGVuZ3RoID4gMCA/IHN0YXR1c2VzIDogWydwb3NzaWJsZSddXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc1Bvc3NpYmxlVmFsdWUodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHNlbGYudmFsdWVcbiAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgOiBzZWxmLnBvc3NpYmlsaXRpZXMuaW5jbHVkZXModmFsKVxuICAgICAgICB9LFxuICAgICAgICBpc1NxdWFyZUVsaW1pbmF0ZWRWYWx1ZSh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5lbGltaW5hdGVkUG9zc2liaWxpdGllcy5pbmNsdWRlcyh2YWwpXG4gICAgICAgIH0sXG4gICAgICAgIGlzQ29sbGVjdGlvbkVsaW1pbmF0ZWRWYWx1ZSh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gIXNlbGYuY29sbGVjdGlvblBvc3NpYmlsaXRpZXMuaW5jbHVkZXModmFsKVxuICAgICAgICB9LFxuICAgICAgICBpc0F1dG9FbGltaW5hdGVkVmFsdWUodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHNlbGYucm9vdE9wdGlvbnMuYXV0b0VsaW1pbmF0ZVxuICAgICAgICAgICAgJiYgc2VsZi5yb3dDb2xWYWx1ZXMuaW5jbHVkZXModmFsKVxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgaXNBY3RpdmVNaXN0YWtlKHZhbCkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBzZWxmLnN0YXR1cyA9PT0gJ21pc3Rha2UnXG4gICAgICAgICAgICAmJiBzZWxmLm1pc3Rha2VWYWx1ZSA9PT0gdmFsXG4gICAgICAgICAgICAmJiAhc2VsZi5pc0F1dG9FbGltaW5hdGVkVmFsdWUodmFsKVxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgaXNTdGFnZWRQb3NzaWJpbGl0eSh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5yb290VWkuc3RhZ2VkUG9zc2liaWxpdGllcy5pbmNsdWRlcyh2YWwpXG4gICAgICAgIH0sXG4gICAgICAgIGlzVmlzaWJsZVBvc3NpYmlsaXR5KHZhbCkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBzZWxmLnNob3VsZFNob3dQb3NzaWJpbGl0aWVzXG4gICAgICAgICAgICAmJiBzZWxmLmRpc3BsYXllZFBvc3NpYmlsaXRpZXMuaW5jbHVkZXModmFsKVxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgcG9zc2liaWxpdHlDbGFzc05hbWUodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGdlbmVyYXRlQ2xhc3NOYW1lKCdzcXVhcmVfcG9zc2liaWxpdHknLCBbXG4gICAgICAgICAgICBbc2VsZi5pc1Zpc2libGVQb3NzaWJpbGl0eSh2YWwpLCAnc2hvdyddXG4gICAgICAgICAgXSlcbiAgICAgICAgfSxcbiAgICAgICAgaW5mb1Bvc3NpYmlsaXR5U3RhZ2luZ0NsYXNzTmFtZSh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5pc1N0YWdlZFBvc3NpYmlsaXR5KHZhbClcbiAgICAgICAgICAgID8gJ3Bvc3NpYmxlJ1xuICAgICAgICAgICAgOiAnc3RhZ2VkLWVsaW1pbmF0ZWQnXG4gICAgICAgIH0sXG4gICAgICAgIGluZm9Qb3NzaWJpbGl0eUNsYXNzTmFtZSh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVDbGFzc05hbWUoJ3NxdWFyZS1pbmZvX3Bvc3NpYmlsaXR5JyxcbiAgICAgICAgICAgIHNlbGYuaXNTdGFnaW5nXG4gICAgICAgICAgICAgID8gW3NlbGYuaW5mb1Bvc3NpYmlsaXR5U3RhZ2luZ0NsYXNzTmFtZSh2YWwpXVxuICAgICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICBbc2VsZi5pc0FjdGl2ZU1pc3Rha2UodmFsKSwgJ21pc3Rha2UnXSxcbiAgICAgICAgICAgICAgICAuLi5zZWxmLnBvc3NpYmlsaXR5U3RhdHVzZXModmFsKVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICAgICAgICBpbmZvUG9zc2liaWxpdHlJY29uQ2xhc3NOYW1lcyh2YWwpIHtcbiAgICAgICAgICBpZiAoc2VsZi5pc1N0YWdpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmlzU3RhZ2VkUG9zc2liaWxpdHkodmFsKVxuICAgICAgICAgICAgICA/IHsgaG92ZXI6IElDT05TLmJhbiwgbm9Ib3ZlcjogSUNPTlMuY2lyY2xlIH1cbiAgICAgICAgICAgICAgOiB7IGhvdmVyOiBJQ09OUy5jaXJjbGUsIG5vSG92ZXI6IElDT05TLmJhbiB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmlzU3F1YXJlRWxpbWluYXRlZFZhbHVlKHZhbCkgJiYgIXNlbGYuaGFzVmFsdWVcbiAgICAgICAgICAgICAgPyB7IGhvdmVyOiBJQ09OUy5iYW4sIG5vSG92ZXI6IElDT05TLmJhbiB9XG4gICAgICAgICAgICAgIDogeyBob3ZlcjogSUNPTlMuYmFuLCBub0hvdmVyOiBJQ09OUy5jaXJjbGUgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXNCZWxvdyhvdGhlclNxdWFyZSkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBvdGhlclNxdWFyZS5yb3cgPT09IHNlbGYucm93IC0gMVxuICAgICAgICAgICAgJiYgb3RoZXJTcXVhcmUuY29sID09PSBzZWxmLmNvbFxuICAgICAgICAgIClcbiAgICAgICAgfSxcbiAgICAgICAgaXNSaWdodE9mKG90aGVyU3F1YXJlKSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG90aGVyU3F1YXJlLnJvdyA9PT0gc2VsZi5yb3dcbiAgICAgICAgICAgICYmIG90aGVyU3F1YXJlLmNvbCA9PT0gc2VsZi5jb2wgLSAxXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICAgICAgICBpc0Fib3ZlKG90aGVyU3F1YXJlKSB7XG4gICAgICAgICAgcmV0dXJuIG90aGVyU3F1YXJlLmlzQmVsb3coc2VsZilcbiAgICAgICAgfSxcbiAgICAgICAgaXNMZWZ0T2Yob3RoZXJTcXVhcmUpIHtcbiAgICAgICAgICByZXR1cm4gb3RoZXJTcXVhcmUuaXNSaWdodE9mKHNlbGYpXG4gICAgICAgIH0sXG4gICAgICAgIGNvbWVzQmVmb3JlKG90aGVyU3F1YXJlKSB7XG4gICAgICAgICAgc3dpdGNoIChNYXRoLnNpZ24ob3RoZXJTcXVhcmUucm93IC0gc2VsZi5yb3cpKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJldHVybiBvdGhlclNxdWFyZS5jb2wgPiBzZWxmLmNvbFxuICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc0xvZ2ljYWxTdXBlcnNldE9mKG90aGVyU3F1YXJlKSB7XG4gICAgICAgICAgcmV0dXJuIG90aGVyU3F1YXJlLnBvc3NpYmlsaXRpZXMuZXZlcnkoc2VsZi5pc1Bvc3NpYmxlVmFsdWUpXG4gICAgICAgIH0sXG4gICAgICAgIGlzTG9naWNhbFN1YnNldE9mKG90aGVyU3F1YXJlKSB7XG4gICAgICAgICAgcmV0dXJuIG90aGVyU3F1YXJlLmlzTG9naWNhbFN1cGVyc2V0T2Yoc2VsZilcbiAgICAgICAgfSxcbiAgICAgICAgaXNDb25zaXN0ZW50V2l0aChvdGhlclNxdWFyZSkge1xuICAgICAgICAgIGNvbnN0IHBvc3NpYmlsaXR5T3ZlcmxhcCA9IGFycmF5VW5pb24oXG4gICAgICAgICAgICBvdGhlclNxdWFyZS5wb3NzaWJpbGl0aWVzLFxuICAgICAgICAgICAgc2VsZi5wb3NzaWJpbGl0aWVzXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgcmV0dXJuIHBvc3NpYmlsaXR5T3ZlcmxhcC5sZW5ndGggPiAwXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgIHNldE1pc3Rha2U6IGZsb3coZnVuY3Rpb24qICh2YWwpIHtcbiAgICAgICAgICBzZWxmLm1pc3Rha2VWYWx1ZSA9IHZhbFxuICAgICAgICAgIHNlbGYuc3RhdHVzID0gJ21pc3Rha2UnXG4gICAgICAgICAgeWllbGQgd2FpdChzZWxmLmVudi5nbG9iYWxzLm1pc3Rha2VUaW1lb3V0TXMpXG4gICAgICAgICAgc2VsZi5zdGF0dXMgPSAnbm9uZSdcbiAgICAgICAgICBzZWxmLm1pc3Rha2VWYWx1ZSA9IG51bGxcbiAgICAgICAgfSksXG4gICAgICAgIHNldENvbmZsaWN0OiBmbG93KGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgc2VsZi5zdGF0dXMgPSAnY29uZmxpY3QnXG4gICAgICAgICAgeWllbGQgd2FpdChzZWxmLmVudi5nbG9iYWxzLm1pc3Rha2VUaW1lb3V0TXMpXG4gICAgICAgICAgc2VsZi5zdGF0dXMgPSAnbm9uZSdcbiAgICAgICAgfSksXG4gICAgICAgIHRvZ2dsZVBvc3NpYmlsaXR5KHZhbCkge1xuICAgICAgICAgIHRvZ2dsZVByZXNlbmNlSW5BcnJheShzZWxmLmVsaW1pbmF0ZWRQb3NzaWJpbGl0aWVzLCB2YWwpXG4gICAgICAgIH0sXG4gICAgICAgIGVsaW1pbmF0ZVBvc3NpYmlsaXR5KHZhbCkge1xuICAgICAgICAgIHB1c2hJZk5vdEluY2x1ZGVkKHNlbGYuZWxpbWluYXRlZFBvc3NpYmlsaXRpZXMsIHZhbClcbiAgICAgICAgfSxcbiAgICAgICAgdW5lbGltaW5hdGVQb3NzaWJpbGl0eSh2YWwpIHtcbiAgICAgICAgICByZW1vdmVJZkluY2x1ZGVkKHNlbGYuZWxpbWluYXRlZFBvc3NpYmlsaXRpZXMsIHZhbClcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U3RhZ2VkUG9zc2liaWxpdGllcygpIHtcbiAgICAgICAgICBzZWxmLmVsaW1pbmF0ZWRQb3NzaWJpbGl0aWVzID0gaW5pdGlhbFBvc3NpYmlsaXRpZXNcbiAgICAgICAgICAgIC5maWx0ZXIobnVtID0+ICFzZWxmLnJvb3RVaS5zdGFnZWRQb3NzaWJpbGl0aWVzLmluY2x1ZGVzKG51bSkpXG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgIHNlbGYuc3RhdHVzID0gJ25vbmUnXG4gICAgICAgICAgc2VsZi52YWx1ZSA9IG51bGxcbiAgICAgICAgICBzZWxmLm1pc3Rha2VWYWx1ZSA9IG51bGxcbiAgICAgICAgICBzZWxmLmVsaW1pbmF0ZWRQb3NzaWJpbGl0aWVzID0gW11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuZXhwb3J0IGRlZmF1bHQgU3F1YXJlIiwiaW1wb3J0IHsgdHlwZXMgfSBmcm9tICdtb2J4LXN0YXRlLXRyZWUnXG5pbXBvcnQgeyBJQ09OUyB9IGZyb20gJy4uL3NoYXJlZC9jb25zdGFudHMnXG5pbXBvcnQgeyBiYXNlSWNvbnMgfSBmcm9tICcuLi9zaGFyZWQvZG9tX3BhcnRpYWxzJ1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVDbGFzc05hbWUsXG4gIGdldEludGVydmVuaW5nUG9zaXRpb25zLFxuICBzdHJpbmdTd2l0Y2gsXG4gIHRvZ2dsZVByZXNlbmNlSW5BcnJheVxufSBmcm9tICcuLi9zaGFyZWQvZ2VuZXJhbF91dGlsJ1xuaW1wb3J0IHsgR2FtZUJhc2UgfSBmcm9tICcuL2Jhc2UnXG5pbXBvcnQgeyBDYWdlLCBHcm91cCB9IGZyb20gJy4vY29sbGVjdGlvbnMnXG5pbXBvcnQgU3F1YXJlIGZyb20gJy4vc3F1YXJlJ1xuXG5jb25zdCBVSSA9IEdhbWVCYXNlXG4gIC5uYW1lZCgnVUknKVxuICAucHJvcHMoe1xuICAgIGN1clNxdWFyZTogdHlwZXMubWF5YmVOdWxsKHR5cGVzLnJlZmVyZW5jZShTcXVhcmUpKSxcbiAgICBjdXJDb2xsZWN0aW9uOiB0eXBlcy5tYXliZU51bGwodHlwZXMudW5pb24oXG4gICAgICB0eXBlcy5yZWZlcmVuY2UoR3JvdXApLFxuICAgICAgdHlwZXMucmVmZXJlbmNlKENhZ2UpLFxuICAgICkpLFxuICAgIGlzU3RhZ2luZzogdHlwZXMub3B0aW9uYWwoXG4gICAgICB0eXBlcy5ib29sZWFuLFxuICAgICAgKCkgPT4gZmFsc2VcbiAgICApLFxuICAgIHN0YWdlZFBvc3NpYmlsaXRpZXM6IHR5cGVzLm9wdGlvbmFsKHR5cGVzLmFycmF5KHR5cGVzLmludGVnZXIpLCAoKSA9PiBbXSksXG4gICAgZmlsdGVyTW9kZTogdHlwZXMub3B0aW9uYWwoXG4gICAgICB0eXBlcy5lbnVtZXJhdGlvbignRmlsdGVyTW9kZScsIFsnYW5kJywgJ25vdCcsICdvciddKSxcbiAgICAgICgpID0+ICdhbmQnXG4gICAgKSxcbiAgICBzZWxlY3RlZFNxdWFyZXM6IHR5cGVzLm9wdGlvbmFsKFxuICAgICAgdHlwZXMuYXJyYXkodHlwZXMucmVmZXJlbmNlKFNxdWFyZSkpLFxuICAgICAgKCkgPT4gW11cbiAgICApXG4gIH0pXG4gIC52aWV3cyhzZWxmID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0IGN1clBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5jdXJTcXVhcmU/LnBvc2l0aW9uXG4gICAgICB9LFxuICAgICAgZ2V0IGN1ckNhZ2UoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmN1clNxdWFyZT8uY2FnZVxuICAgICAgfSxcbiAgICAgIGdldCBjdXJDYWdlRmlsdGVyZWRDb21ib3MoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmN1ckNhZ2U/LmZpbHRlcmVkQ29tYm9zIHx8IFtdXG4gICAgICB9LFxuICAgICAgZ2V0IGN1ckNhZ2VQb3NzaWJsZUNvbWJvcygpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY3VyQ2FnZT8ucG9zc2libGVDb21ib3MgfHwgW11cbiAgICAgIH0sXG4gICAgICBnZXQgaGFzU3RhZ2VkUG9zc2liaWxpdGllcygpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc3RhZ2VkUG9zc2liaWxpdGllcy5sZW5ndGggPiAwXG4gICAgICB9LFxuICAgICAgZ2V0IHNxdWFyZUluZm9TZWxlY3RDbGFzc05hbWUoKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUNsYXNzTmFtZSgnc3F1YXJlLWluZm9fYnRuJywgW1xuICAgICAgICAgIFshc2VsZi5jdXJTcXVhcmUgfHwgc2VsZi5jdXJTcXVhcmUuaGFzVmFsdWUsICdkaXNhYmxlZCddXG4gICAgICAgIF0pXG4gICAgICB9LFxuICAgICAgZ2V0IHNxdWFyZUluZm9DbGVhckNsYXNzTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlQ2xhc3NOYW1lKCdzcXVhcmUtaW5mb19idG4nLCBbXG4gICAgICAgICAgWyFzZWxmLmN1clNxdWFyZSwgJ2Rpc2FibGVkJ11cbiAgICAgICAgXSlcbiAgICAgIH0sXG4gICAgICBnZXQgc3F1YXJlSW5mb1NlbGVjdEljb25DbGFzc05hbWUoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmlzU3RhZ2luZyA/IElDT05TLmNvbmZpcm0gOiBJQ09OUy5zZWxlY3RcbiAgICAgIH0sXG4gICAgICBnZXQgc3F1YXJlSW5mb0NsZWFySWNvbkNsYXNzTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaXNTdGFnaW5nID8gSUNPTlMucmVzZXQgOiBJQ09OUy5jbGVhclxuICAgICAgfSxcbiAgICAgIGdldCBsYXN0U2VsZWN0ZWRTcXVhcmUoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNlbGVjdGVkU3F1YXJlc1tzZWxmLnNlbGVjdGVkU3F1YXJlcy5sZW5ndGggLSAxXVxuICAgICAgfSxcbiAgICAgIGdldCBoYXNTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNlbGVjdGVkU3F1YXJlcy5sZW5ndGggPiAxXG4gICAgICB9LFxuICAgICAgZ2V0IHNob3VsZFNob3dDb2xsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5jdXJDYWdlICYmICFzZWxmLmhhc1NlbGVjdGlvblxuICAgICAgfSxcbiAgICAgIGdldCBjb2xsZWN0aW9uQ2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGVDbGFzc05hbWUoJ2NvbGxlY3Rpb24taW5mbycsIFtcbiAgICAgICAgICBbc2VsZi5zaG91bGRTaG93Q29sbGVjdGlvbiwgc2VsZi5maWx0ZXJNb2RlLCAnbm9uZSddXG4gICAgICAgIF0pXG4gICAgICB9LFxuICAgICAgaXNWYWxpZFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcy5ldmVyeShjb29yZCA9PiBjb29yZCA+PSAwICYmIGNvb3JkIDwgc2VsZi5lbnYuZ2xvYmFscy5zaXplKVxuICAgICAgfSxcbiAgICAgIGlzU2VsZWN0aW9uRWxpbWluYXRlZFZhbHVlKHZhbCkge1xuICAgICAgICByZXR1cm4gc2VsZi5zZWxlY3RlZFNxdWFyZXMuZXZlcnkoc3F1YXJlID0+XG4gICAgICAgICAgc3F1YXJlLmlzU3F1YXJlRWxpbWluYXRlZFZhbHVlKHZhbCkpXG4gICAgICB9LFxuICAgICAgc2VsZWN0aW9uUG9zc2liaWxpdHlTdGF0dXNlcyh2YWwpIHtcbiAgICAgICAgY29uc3Qgc3F1YXJlU3RhdHVzZXMgPSBzZWxmLnNlbGVjdGVkU3F1YXJlc1xuICAgICAgICAgIC5tYXAoc3F1YXJlID0+IHNxdWFyZS5wb3NzaWJpbGl0eVN0YXR1c2VzKHZhbCkpXG5cbiAgICAgICAgY29uc3Qgc2hhcmVkU3RhdHVzZXMgPSBbXG4gICAgICAgICAgJ3NxdWFyZS1lbGltaW5hdGVkJyxcbiAgICAgICAgICAnY29sbGVjdGlvbi1lbGltaW5hdGVkJyxcbiAgICAgICAgICAnYXV0by1lbGltaW5hdGVkJyxcbiAgICAgICAgXS5maWx0ZXIoc3RhdHVzID0+IHNxdWFyZVN0YXR1c2VzLmV2ZXJ5KHMgPT4gcy5pbmNsdWRlcyhzdGF0dXMpKSlcblxuICAgICAgICByZXR1cm4gc2hhcmVkU3RhdHVzZXMubGVuZ3RoID4gMCA/IHNoYXJlZFN0YXR1c2VzIDogWydwb3NzaWJsZSddXG4gICAgICB9LFxuICAgICAgZmlsdGVyTm9Ib3Zlckljb25zKHZhbCkge1xuICAgICAgICByZXR1cm4gc2VsZi5zaG91bGRTaG93Q29sbGVjdGlvblxuICAgICAgICAgID8gc2VsZi5jdXJDYWdlLmZpbHRlci5ub0hvdmVySWNvbnModmFsKVxuICAgICAgICAgIDogYmFzZUljb25zKClcbiAgICAgIH0sXG4gICAgICBmaWx0ZXJIb3Zlckljb25zKHZhbCkge1xuICAgICAgICByZXR1cm4gc2VsZi5zaG91bGRTaG93Q29sbGVjdGlvblxuICAgICAgICAgID8gc2VsZi5jdXJDYWdlLmZpbHRlci5ob3Zlckljb25zKHZhbCwgc2VsZi5maWx0ZXJNb2RlKVxuICAgICAgICAgIDogYmFzZUljb25zKClcbiAgICAgIH0sXG4gICAgICBmaWx0ZXJQb3NzaWJpbGl0eUNsYXNzTmFtZSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc2hvdWxkU2hvd0NvbGxlY3Rpb25cbiAgICAgICAgICA/IHNlbGYuY3VyQ2FnZS5maWx0ZXIuY2xhc3NOYW1lKHZhbCwgc2VsZi5maWx0ZXJNb2RlKVxuICAgICAgICAgIDogZ2VuZXJhdGVDbGFzc05hbWUoJ2ZpbHRlci1wb3NzaWJpbGl0eScsIFsnbm9uZScsICdkaXNhYmxlZCddKVxuICAgICAgfSxcbiAgICAgIHNxdWFyZUluZm9Qb3NzaWJpbGl0eUNsYXNzTmFtZSh2YWwpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGdlbmVyYXRlQ2xhc3NOYW1lKFxuICAgICAgICAgICAgJ3NxdWFyZS1pbmZvX3Bvc3NpYmlsaXR5JyxcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0aW9uUG9zc2liaWxpdHlTdGF0dXNlcyh2YWwpXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZWxmLmN1clNxdWFyZVxuICAgICAgICAgICAgPyBzZWxmLmN1clNxdWFyZS5pbmZvUG9zc2liaWxpdHlDbGFzc05hbWUodmFsKVxuICAgICAgICAgICAgOiBnZW5lcmF0ZUNsYXNzTmFtZSgnc3F1YXJlLWluZm9fcG9zc2liaWxpdHknLCBbJ2Rpc2FibGVkJ10pXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzcXVhcmVJbmZvUG9zc2liaWxpdHlJY29uQ2xhc3NOYW1lcyh2YWwpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuaXNTZWxlY3Rpb25FbGltaW5hdGVkVmFsdWUodmFsKVxuICAgICAgICAgICAgPyB7IGhvdmVyOiBJQ09OUy5iYW4sIG5vSG92ZXI6IElDT05TLmJhbiB9XG4gICAgICAgICAgICA6IHsgaG92ZXI6IElDT05TLmJhbiwgbm9Ib3ZlcjogSUNPTlMuY2lyY2xlIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5jdXJTcXVhcmVcbiAgICAgICAgICAgID8gc2VsZi5jdXJTcXVhcmUuaW5mb1Bvc3NpYmlsaXR5SWNvbkNsYXNzTmFtZXModmFsKVxuICAgICAgICAgICAgOiB7IGhvdmVyOiBJQ09OUy5jaXJjbGUsIG5vSG92ZXI6IElDT05TLmNpcmNsZSB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfVxuICB9KVxuICAuYWN0aW9ucyhzZWxmID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzZXQoKSB7XG4gICAgICAgIHNlbGYuY3VyU3F1YXJlID0gbnVsbFxuICAgICAgICBzZWxmLmN1ckNvbGxlY3Rpb24gPSBudWxsXG4gICAgICAgIHNlbGYuaXNTdGFnaW5nID0gZmFsc2VcbiAgICAgICAgc2VsZi5zdGFnZWRQb3NzaWJpbGl0aWVzID0gW11cbiAgICAgICAgc2VsZi5maWx0ZXJNb2RlID0gJ2FuZCdcbiAgICAgICAgc2VsZi5zZWxlY3RlZFNxdWFyZXMgPSBbXVxuICAgICAgfSxcbiAgICAgIHNlbGVjdFNxdWFyZUJ5RGlyKGRpcikge1xuICAgICAgICBjb25zdCBbY3VyUm93LCBjdXJDb2xdID0gc2VsZi5jdXJQb3NpdGlvblxuICAgICAgICBjb25zdCBuZXdQb3MgPSBzdHJpbmdTd2l0Y2goZGlyLCAoeyBfY2FzZSB9KSA9PiB7XG4gICAgICAgICAgX2Nhc2UoJ1VwJywgKCkgPT4gW2N1clJvdyAtIDEsIGN1ckNvbF0pXG4gICAgICAgICAgX2Nhc2UoJ1JpZ2h0JywgKCkgPT4gW2N1clJvdywgY3VyQ29sICsgMV0pXG4gICAgICAgICAgX2Nhc2UoJ0Rvd24nLCAoKSA9PiBbY3VyUm93ICsgMSwgY3VyQ29sXSlcbiAgICAgICAgICBfY2FzZSgnTGVmdCcsICgpID0+IFtjdXJSb3csIGN1ckNvbCAtIDFdKVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChzZWxmLmlzVmFsaWRQb3MobmV3UG9zKSkgc2VsZi5zZWxlY3RTcXVhcmVCeVBvcyhuZXdQb3MpXG4gICAgICB9LFxuICAgICAgc2VsZWN0U3F1YXJlQnlQb3MocG9zKSB7XG4gICAgICAgIHNlbGYuc2VsZWN0U3F1YXJlKHNlbGYucm9vdFB1enpsZS5nZXRTcXVhcmVCeVBvcyhwb3MpKVxuICAgICAgfSxcbiAgICAgIHNlbGVjdFNxdWFyZUJ5SWQoaWQpIHtcbiAgICAgICAgc2VsZi5zZWxlY3RTcXVhcmUoc2VsZi5yb290UHV6emxlLnNxdWFyZXMuZ2V0KGlkKSlcbiAgICAgIH0sXG4gICAgICBzZWxlY3RTcXVhcmUoc3F1YXJlKSB7XG4gICAgICAgIHNlbGYuY3VyU3F1YXJlID0gc3F1YXJlXG4gICAgICAgIHNlbGYuc2VsZWN0ZWRTcXVhcmVzID0gW3NxdWFyZV1cbiAgICAgICAgc2VsZi5pc1N0YWdpbmcgPSBmYWxzZVxuICAgICAgfSxcbiAgICAgIHNlbGVjdFRocm91Z2hTcXVhcmUoc3F1YXJlSWQpIHtcbiAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWRTcXVhcmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBuZXh0U3F1YXJlUG9zID0gc2VsZi5yb290UHV6emxlLnNxdWFyZXMuZ2V0KHNxdWFyZUlkKS5wb3NpdGlvblxuICAgICAgICAgIGNvbnN0IHByZXZTcXVhcmVQb3MgPSBzZWxmLmxhc3RTZWxlY3RlZFNxdWFyZS5wb3NpdGlvblxuXG4gICAgICAgICAgc2VsZi5zZWxlY3RlZFNxdWFyZXMucHVzaChcbiAgICAgICAgICAgIC4uLmdldEludGVydmVuaW5nUG9zaXRpb25zKHByZXZTcXVhcmVQb3MsIG5leHRTcXVhcmVQb3MpXG4gICAgICAgICAgICAgIC5tYXAocG9zID0+IHNlbGYucm9vdFB1enpsZS5nZXRTcXVhcmVCeVBvcyhwb3MpKVxuICAgICAgICAgICAgICAuZmlsdGVyKHNxdWFyZSA9PiAhc2VsZi5zZWxlY3RlZFNxdWFyZXMuaW5jbHVkZXMoc3F1YXJlKSlcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2dnbGVTZWxlY3RlZFNxdWFyZShzcXVhcmVJZCkge1xuICAgICAgICB0b2dnbGVQcmVzZW5jZUluQXJyYXkoXG4gICAgICAgICAgc2VsZi5zZWxlY3RlZFNxdWFyZXMsXG4gICAgICAgICAgc3F1YXJlSWQsXG4gICAgICAgICAgKCkgPT4gc2VsZi5zZWxlY3RlZFNxdWFyZXMuZmluZEluZGV4KHMgPT4gcy5pZCA9PT0gc3F1YXJlSWQpXG4gICAgICAgIClcbiAgICAgICAgaWYgKHNlbGYuY3VyU3F1YXJlLmlkID09PSBzcXVhcmVJZCkgc2VsZi5jdXJTcXVhcmUgPSBudWxsXG4gICAgICB9LFxuICAgICAgY2xlYXJTdGFnZWRQb3NzaWJpbGl0aWVzKCkge1xuICAgICAgICBzZWxmLnN0YWdlZFBvc3NpYmlsaXRpZXMgPSBbXVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZVN0YWdlZFBvc3NpYmlsaXR5KHZhbCkge1xuICAgICAgICBjb25zdCB2YWxJbmRleCA9IHNlbGYuc3RhZ2VkUG9zc2liaWxpdGllcy5pbmRleE9mKHZhbClcblxuICAgICAgICBpZiAodmFsSW5kZXggPj0gMCkge1xuICAgICAgICAgIHNlbGYuc3RhZ2VkUG9zc2liaWxpdGllcy5zcGxpY2UodmFsSW5kZXgsIDEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5zdGFnZWRQb3NzaWJpbGl0aWVzLnB1c2godmFsKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9nZ2xlU2VsZWN0aW9uUG9zc2liaWxpdHkodmFsKSB7XG4gICAgICAgIGlmIChzZWxmLmlzU2VsZWN0aW9uRWxpbWluYXRlZFZhbHVlKHZhbCkpIHtcbiAgICAgICAgICBzZWxmLnNlbGVjdGVkU3F1YXJlcy5mb3JFYWNoKHNxdWFyZSA9PlxuICAgICAgICAgICAgc3F1YXJlLnVuZWxpbWluYXRlUG9zc2liaWxpdHkodmFsKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLnNlbGVjdGVkU3F1YXJlcy5mb3JFYWNoKHNxdWFyZSA9PlxuICAgICAgICAgICAgc3F1YXJlLmVsaW1pbmF0ZVBvc3NpYmlsaXR5KHZhbCkpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbGVhclNlbGVjdGVkU3F1YXJlcygpIHtcbiAgICAgICAgc2VsZi5zZWxlY3RlZFNxdWFyZXMgPSBbXVxuICAgICAgfSxcbiAgICAgIHRvZ2dsZUZpbHRlclBvc3NpYmlsaXR5KHZhbCkge1xuICAgICAgICBzZWxmLmN1ckNhZ2UuZmlsdGVyLnRvZ2dsZSh2YWwsIHNlbGYuZmlsdGVyTW9kZSlcbiAgICAgIH0sXG4gICAgICBjbGVhckZpbHRlck1vZGUoKSB7XG4gICAgICAgIGlmIChzZWxmLmN1ckNhZ2UpIHtcbiAgICAgICAgICBzZWxmLmN1ckNhZ2UuZmlsdGVyLmNsZWFyTW9kZShzZWxmLmZpbHRlck1vZGUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbGVhckZpbHRlcigpIHtcbiAgICAgICAgaWYgKHNlbGYuY3VyQ2FnZSkge1xuICAgICAgICAgIHNlbGYuY3VyQ2FnZS5maWx0ZXIuaW5pdGlhbGl6ZShzZWxmLmVudi5nbG9iYWxzLnNpemUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRGaWx0ZXJNb2RlKG1vZGUpIHtcbiAgICAgICAgc2VsZi5maWx0ZXJNb2RlID0gbW9kZVxuICAgICAgfSxcbiAgICAgIGNoYW5nZUZpbHRlck1vZGVCeURpcihkaXIpIHtcbiAgICAgICAgY29uc3QgbW9kZXMgPSBbJ2FuZCcsICdub3QnLCAnb3InXVxuICAgICAgICBjb25zdCBpZHhEaWZmID0gZGlyID09PSAnTGVmdCcgPyAtMSA6IDFcbiAgICAgICAgY29uc3QgbmV3SWR4ID0gKG1vZGVzLmluZGV4T2Yoc2VsZi5maWx0ZXJNb2RlKSArIGlkeERpZmYgKyAzKSAlIDNcbiAgICAgICAgc2VsZi5maWx0ZXJNb2RlID0gbW9kZXNbbmV3SWR4XVxuICAgICAgfSxcbiAgICB9XG4gIH0pXG5cbmV4cG9ydCBkZWZhdWx0IFVJIiwiaW1wb3J0IHsgbmV3UHV6emxlLCByZXNldFB1enpsZSB9IGZyb20gXCIuLi9zZXR1cC9zZXR1cF9wdXp6bGVcIlxuaW1wb3J0IHsgYWRkTm9Gb2N1c0NsaWNrTGlzdGVuZXIsIG1vdW50RHJvcGRvd24gfSBmcm9tIFwiLi4vc2hhcmVkL2RvbV91dGlsXCJcblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwSGVhZGVyKHtcbiAgZ2FtZVN0b3JlLFxuICBlbnYsXG4gIGVsZW1lbnRzLFxuICBlbGVtZW50czoge1xuICAgIGhlYWRlckVsZXM6IHtcbiAgICAgIGFib3V0QnV0dG9uLFxuICAgICAgYWJvdXREcm9wZG93bixcblxuICAgICAgaW5zdHJ1Y3Rpb25zQnV0dG9uLFxuICAgICAgaW5zdHJ1Y3Rpb25zRHJvcGRvd24sXG5cbiAgICAgIG9wdGlvbnNCdXR0b24sXG4gICAgICBvcHRpb25zRHJvcGRvd24sXG5cbiAgICAgIHVuZG9CdXR0b24sXG4gICAgICByZWRvQnV0dG9uLFxuICAgICAgbmV3QnV0dG9uLFxuICAgICAgcmVzZXRCdXR0b24sXG4gICAgfVxuICB9XG59KSB7XG4gIG1vdW50RHJvcGRvd24oYWJvdXRCdXR0b24sIGFib3V0RHJvcGRvd24sICdzaG93JylcbiAgbW91bnREcm9wZG93bihpbnN0cnVjdGlvbnNCdXR0b24sIGluc3RydWN0aW9uc0Ryb3Bkb3duLCAnc2hvdycpXG4gIG1vdW50RHJvcGRvd24ob3B0aW9uc0J1dHRvbiwgb3B0aW9uc0Ryb3Bkb3duLCAnc2hvdycpXG5cbiAgYWRkTm9Gb2N1c0NsaWNrTGlzdGVuZXIodW5kb0J1dHRvbiwgZ2FtZVN0b3JlLnVuZG8pXG4gIGFkZE5vRm9jdXNDbGlja0xpc3RlbmVyKHJlZG9CdXR0b24sIGdhbWVTdG9yZS5yZWRvKVxuICBhZGROb0ZvY3VzQ2xpY2tMaXN0ZW5lcihuZXdCdXR0b24sICgpID0+IG5ld1B1enpsZSh7IGdhbWVTdG9yZSwgZW52LCBlbGVtZW50cyB9KSlcbiAgYWRkTm9Gb2N1c0NsaWNrTGlzdGVuZXIocmVzZXRCdXR0b24sICgpID0+IHJlc2V0UHV6emxlKHsgZ2FtZVN0b3JlLCBlbnYsIGVsZW1lbnRzIH0pKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGVhZGVyRWxlbWVudHMoKSB7XG4gIHJldHVybiB7XG4gICAgYWJvdXRCdXR0b246IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNoZWFkZXItYWJvdXQnKSxcbiAgICBhYm91dERyb3Bkb3duOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaGVhZGVyLWFib3V0IC5oZWFkZXJfZHJvcGRvd24nKSxcbiAgICBpbnN0cnVjdGlvbnNCdXR0b246IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNoZWFkZXItaW5zdHJ1Y3Rpb25zJyksXG4gICAgaW5zdHJ1Y3Rpb25zRHJvcGRvd246IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNoZWFkZXItaW5zdHJ1Y3Rpb25zIC5oZWFkZXJfZHJvcGRvd24nKSxcbiAgICBvcHRpb25zQnV0dG9uOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaGVhZGVyLW9wdGlvbnMnKSxcbiAgICBvcHRpb25zRHJvcGRvd246IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNoZWFkZXItb3B0aW9ucyAuaGVhZGVyX2Ryb3Bkb3duJyksXG4gICAgdW5kb0J1dHRvbjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2hlYWRlci11bmRvJyksXG4gICAgcmVkb0J1dHRvbjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2hlYWRlci1yZWRvJyksXG4gICAgbmV3QnV0dG9uOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaGVhZGVyLW5ldycpLFxuICAgIHJlc2V0QnV0dG9uOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjaGVhZGVyLXJlc2V0JyksXG4gIH1cbn0iLCJpbXBvcnQgeyBhdXRvcnVuIH0gZnJvbSAnbW9ieCdcbmltcG9ydCB7IGhhdmVFcXVpdmFsZW50Q2hpbGRyZW4sIHVwZGF0ZUNoaWxkcmVuVG9NYXRjaCB9IGZyb20gJy4uL3NoYXJlZC9kb21fdXRpbCdcblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQ29sbGVjdGlvbkluZm8oZ2FtZSkge1xuICBzZXR1cExpc3RlbmVycyhnYW1lKVxuICBtYWtlUmVhY3RpdmUoZ2FtZSlcbn1cblxuZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMoe1xuICBnYW1lU3RvcmUsXG4gIGVsZW1lbnRzOiB7XG4gICAgY29sbGVjdGlvbkluZm9FbGVzOiB7XG4gICAgICBjb21ib0xpc3RFbGUsXG4gICAgICBwb3NzaWJpbGl0eUVsZXMsXG4gICAgICBhbmRNb2RlQnV0dG9uLFxuICAgICAgbm90TW9kZUJ1dHRvbixcbiAgICAgIG9yTW9kZUJ1dHRvbixcbiAgICAgIGNsZWFyTW9kZUJ1dHRvbixcbiAgICAgIGNsZWFyQWxsQnV0dG9uLFxuICAgIH1cbiAgfVxufSkge1xuICBjb21ib0xpc3RFbGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcbiAgICBpZiAoIWdhbWVTdG9yZS51aS5jdXJDYWdlKSByZXR1cm5cbiAgICBjb25zdCBjb21ib0VsZSA9IGUudGFyZ2V0LmNsb3Nlc3QoJy5jb21ibycpXG4gICAgaWYgKGNvbWJvRWxlKSB7XG4gICAgICBjb25zdCBjb21ibyA9IGNvbWJvRWxlLmRhdGFzZXQuY29tYm8uc3BsaXQoJywnKVxuICAgICAgICAubWFwKHZhbFN0ciA9PiBwYXJzZUludCh2YWxTdHIpKVxuXG4gICAgICBnYW1lU3RvcmUudG9nZ2xlQ3VyQ2FnZUNvbWJvKGNvbWJvKVxuICAgIH1cbiAgfSlcblxuICBBcnJheS5mcm9tKHBvc3NpYmlsaXR5RWxlcykubWFwKHBvc3NpYmlsaXR5RWxlID0+IHtcbiAgICBjb25zdCB2YWwgPSBwYXJzZUludChwb3NzaWJpbGl0eUVsZS5kYXRhc2V0LnZhbClcblxuICAgIGZ1bmN0aW9uIHJlc3RvcmVIb3ZlcigpIHtcbiAgICAgIHBvc3NpYmlsaXR5RWxlLmNsYXNzTGlzdC5yZW1vdmUoJ3ByZXZlbnQtaG92ZXInKVxuICAgICAgcG9zc2liaWxpdHlFbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHJlc3RvcmVIb3ZlcilcbiAgICB9XG5cbiAgICBwb3NzaWJpbGl0eUVsZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGlmICghZ2FtZVN0b3JlLnVpLmN1ckNhZ2UpIHJldHVyblxuICAgICAgZ2FtZVN0b3JlLnRvZ2dsZUZpbHRlclBvc3NpYmlsaXR5KHZhbClcblxuICAgICAgcG9zc2liaWxpdHlFbGUuY2xhc3NMaXN0LmFkZCgncHJldmVudC1ob3ZlcicpXG4gICAgICBwb3NzaWJpbGl0eUVsZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVzdG9yZUhvdmVyKVxuICAgIH0pXG4gIH0pXG5cbiAgY29uc3QgYWRkRmlsdGVyQnRuTGlzdGVuZXIgPSAoYnRuLCBtb2RlKSA9PiB7XG4gICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgaWYgKGdhbWVTdG9yZS51aS5zaG91bGRTaG93Q29sbGVjdGlvbikge1xuICAgICAgICBnYW1lU3RvcmUudWkuc2V0RmlsdGVyTW9kZShtb2RlKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBhZGRGaWx0ZXJCdG5MaXN0ZW5lcihhbmRNb2RlQnV0dG9uLCAnYW5kJylcbiAgYWRkRmlsdGVyQnRuTGlzdGVuZXIobm90TW9kZUJ1dHRvbiwgJ25vdCcpXG4gIGFkZEZpbHRlckJ0bkxpc3RlbmVyKG9yTW9kZUJ1dHRvbiwgJ29yJylcblxuICBjbGVhck1vZGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgaWYgKGdhbWVTdG9yZS51aS5zaG91bGRTaG93Q29sbGVjdGlvbikgZ2FtZVN0b3JlLmNsZWFyRmlsdGVyTW9kZSgpXG4gIH0pXG4gIGNsZWFyQWxsQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIGlmIChnYW1lU3RvcmUudWkuc2hvdWxkU2hvd0NvbGxlY3Rpb24pIGdhbWVTdG9yZS5jbGVhckZpbHRlcigpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1ha2VSZWFjdGl2ZSh7XG4gIGdhbWVTdG9yZSxcbiAgZWxlbWVudHM6IHtcbiAgICBjb2xsZWN0aW9uSW5mb0VsZSxcbiAgICBjb2xsZWN0aW9uSW5mb0VsZXM6IHtcbiAgICAgIGNvbWJvTGlzdEVsZSxcbiAgICAgIHBvc3NpYmlsaXR5RWxlcyxcbiAgICB9XG4gIH1cbn0pIHtcbiAgY29uc3QgcG9zc2liaWxpdHlSZWFjdGlvbnMgPSBBcnJheS5mcm9tKHBvc3NpYmlsaXR5RWxlcykubWFwKHBvc3NpYmlsaXR5RWxlID0+IHtcbiAgICBjb25zdCB2YWwgPSBwYXJzZUludChwb3NzaWJpbGl0eUVsZS5kYXRhc2V0LnZhbClcblxuICAgIGNvbnN0IG5vSG92ZXJJY29uc0RpdiA9IHBvc3NpYmlsaXR5RWxlXG4gICAgICAucXVlcnlTZWxlY3RvcignLnBvc3NpYmlsaXR5LWljb25zLS1uby1ob3ZlcicpXG4gICAgY29uc3QgaG92ZXJJY29uc0RpdiA9IHBvc3NpYmlsaXR5RWxlXG4gICAgICAucXVlcnlTZWxlY3RvcignLnBvc3NpYmlsaXR5LWljb25zLS1ob3ZlcicpXG5cbiAgICBjb25zdCB1cGRhdGVJY29ucyA9IChpY29uc0RpdiwgbmV3SWNvbnMpID0+IHtcbiAgICAgIGlmICghaGF2ZUVxdWl2YWxlbnRDaGlsZHJlbihpY29uc0RpdiwgbmV3SWNvbnMsIHtcbiAgICAgICAgYXR0cmlidXRlczogWydjbGFzcyddXG4gICAgICB9KSkge1xuICAgICAgICBpY29uc0Rpdi5yZXBsYWNlQ2hpbGRyZW4oLi4ubmV3SWNvbnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvc3NpYmlsaXR5RWxlLmNsYXNzTmFtZSA9IGdhbWVTdG9yZS51aS5maWx0ZXJQb3NzaWJpbGl0eUNsYXNzTmFtZSh2YWwpXG4gICAgICB1cGRhdGVJY29ucyhub0hvdmVySWNvbnNEaXYsIGdhbWVTdG9yZS51aS5maWx0ZXJOb0hvdmVySWNvbnModmFsKSlcbiAgICAgIHVwZGF0ZUljb25zKGhvdmVySWNvbnNEaXYsIGdhbWVTdG9yZS51aS5maWx0ZXJIb3Zlckljb25zKHZhbCkpXG4gICAgfVxuICB9KVxuXG4gIGNvbnN0IHJlYWN0aW9ucyA9IFtcbiAgICBmdW5jdGlvbiByZW5kZXJDb21ib3MoKSB7XG4gICAgICBpZiAoZ2FtZVN0b3JlLnVpLnNob3VsZFNob3dDb2xsZWN0aW9uKSB7XG4gICAgICAgIHVwZGF0ZUNoaWxkcmVuVG9NYXRjaChcbiAgICAgICAgICBjb21ib0xpc3RFbGUsXG4gICAgICAgICAgZ2FtZVN0b3JlLnVpLmN1ckNhZ2UuY29tYm9FbGVzLFxuICAgICAgICAgIGdhbWVTdG9yZS51aS5jdXJDYWdlLmNvbXBhcmVDb21ib0VsZXNcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVuZGVyRmlsdGVyTW9kZUNsYXNzTmFtZSgpIHtcbiAgICAgIGNvbGxlY3Rpb25JbmZvRWxlLmNsYXNzTmFtZSA9IGdhbWVTdG9yZS51aS5jb2xsZWN0aW9uQ2xhc3NOYW1lXG4gICAgfSxcbiAgICAuLi5wb3NzaWJpbGl0eVJlYWN0aW9uc1xuICBdXG5cbiAgY29uc3QgZGlzcG9zZXJzID0gcmVhY3Rpb25zLm1hcChmbiA9PiBhdXRvcnVuKGZuKSlcbiAgcmV0dXJuIGRpc3Bvc2Vyc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sbGVjdGlvbkluZm9FbGVtZW50cygpIHtcbiAgcmV0dXJuIHtcbiAgICBjb21ib0xpc3RFbGU6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb21ib3NfbGlzdCcpLFxuICAgIGZpbHRlckVsZTogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbGxlY3Rpb24tZmlsdGVyJyksXG4gICAgcG9zc2liaWxpdHlFbGVzOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZmlsdGVyLXBvc3NpYmlsaXR5JyksXG4gICAgYW5kTW9kZUJ1dHRvbjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2ZpbHRlci1hbmQnKSxcbiAgICBub3RNb2RlQnV0dG9uOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZmlsdGVyLW5vdCcpLFxuICAgIG9yTW9kZUJ1dHRvbjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2ZpbHRlci1vcicpLFxuICAgIGNsZWFyTW9kZUJ1dHRvbjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2ZpbHRlci1jbGVhci1tb2RlJyksXG4gICAgY2xlYXJBbGxCdXR0b246IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNmaWx0ZXItY2xlYXItYWxsJyksXG4gIH1cbn0iLCJpbXBvcnQgeyBhdXRvcnVuIH0gZnJvbSAnbW9ieCdcblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwU3F1YXJlSW5mbyhnYW1lKSB7XG4gIHNldHVwTGlzdGVuZXJzKGdhbWUpXG4gIG1ha2VSZWFjdGl2ZShnYW1lKVxufVxuXG5mdW5jdGlvbiBzZXR1cExpc3RlbmVycyh7XG4gIGdhbWVTdG9yZSxcbiAgZWxlbWVudHM6IHtcbiAgICBzcXVhcmVJbmZvRWxlczoge1xuICAgICAgcG9zc2liaWxpdHlFbGVzLFxuICAgICAgc2VsZWN0LFxuICAgICAgY2xlYXIsXG4gICAgfVxuICB9XG59KSB7XG4gIHBvc3NpYmlsaXR5RWxlcy5mb3JFYWNoKHBvc3NpYmlsaXR5RWxlID0+IHtcbiAgICBjb25zdCB2YWwgPSBwYXJzZUludChwb3NzaWJpbGl0eUVsZS5kYXRhc2V0LnZhbClcblxuICAgIGZ1bmN0aW9uIHJlc3RvcmVIb3ZlcigpIHtcbiAgICAgIHBvc3NpYmlsaXR5RWxlLmNsYXNzTGlzdC5yZW1vdmUoJ3ByZXZlbnQtaG92ZXInKVxuICAgICAgcG9zc2liaWxpdHlFbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHJlc3RvcmVIb3ZlcilcbiAgICB9XG5cbiAgICBwb3NzaWJpbGl0eUVsZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGlmICghZ2FtZVN0b3JlLnVpLmN1clNxdWFyZSB8fCBnYW1lU3RvcmUudWkuaGFzRm9jdXNlZFNxdWFyZVZhbHVlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoZ2FtZVN0b3JlLnVpLmlzU3RhZ2luZykge1xuICAgICAgICBnYW1lU3RvcmUudG9nZ2xlU3RhZ2VkUG9zc2liaWxpdHkodmFsKVxuICAgICAgfSBlbHNlIGlmIChnYW1lU3RvcmUudWkuaGFzU2VsZWN0aW9uKSB7XG4gICAgICAgIGdhbWVTdG9yZS50b2dnbGVTZWxlY3Rpb25Qb3NzaWJpbGl0eSh2YWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnYW1lU3RvcmUudG9nZ2xlRm9jdXNlZFNxdWFyZVBvc3NpYmlsaXR5KHZhbClcbiAgICAgIH1cblxuICAgICAgcG9zc2liaWxpdHlFbGUuY2xhc3NMaXN0LmFkZCgncHJldmVudC1ob3ZlcicpXG4gICAgICBwb3NzaWJpbGl0eUVsZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVzdG9yZUhvdmVyKVxuICAgIH0pXG4gIH0pXG5cbiAgc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIGlmICghZ2FtZVN0b3JlLnVpLmN1clNxdWFyZSB8fCBnYW1lU3RvcmUudWkuY3VyU3F1YXJlLmhhc1ZhbHVlKSB7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2UgaWYgKGdhbWVTdG9yZS51aS5pc1N0YWdpbmcpIHtcbiAgICAgIGdhbWVTdG9yZS5zdG9wU3RhZ2luZygpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdhbWVTdG9yZS5iZWdpblN0YWdpbmcoKVxuICAgIH1cbiAgfSlcblxuICBjbGVhci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBpZiAoIWdhbWVTdG9yZS51aS5jdXJTcXVhcmUpIHtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZiAoZ2FtZVN0b3JlLnVpLmlzU3RhZ2luZykge1xuICAgICAgZ2FtZVN0b3JlLmNsZWFyU3RhZ2VkUG9zc2liaWxpdGllcygpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdhbWVTdG9yZS5yZXNldEZvY3VzZWRTcXVhcmVQb3NzaWJpbGl0aWVzKClcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1ha2VSZWFjdGl2ZSh7XG4gIGdhbWVTdG9yZSxcbiAgZWxlbWVudHM6IHtcbiAgICBzcXVhcmVJbmZvRWxlczoge1xuICAgICAgc3F1YXJlTGFiZWxUZXh0LFxuICAgICAgcG9zc2liaWxpdHlFbGVzLFxuICAgICAgc2VsZWN0SWNvbixcbiAgICAgIGNsZWFySWNvbixcbiAgICAgIHNlbGVjdCxcbiAgICAgIGNsZWFyLFxuICAgIH1cbiAgfVxufSkge1xuICBjb25zdCBwb3NzaWJpbGl0eVJlYWN0aW9ucyA9IEFycmF5LmZyb20ocG9zc2liaWxpdHlFbGVzKS5tYXAocG9zc2liaWxpdHlFbGUgPT4ge1xuICAgIGNvbnN0IHZhbCA9IHBhcnNlSW50KHBvc3NpYmlsaXR5RWxlLmRhdGFzZXQudmFsKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb3NzaWJpbGl0eUVsZS5jbGFzc05hbWUgPSBnYW1lU3RvcmUudWkuc3F1YXJlSW5mb1Bvc3NpYmlsaXR5Q2xhc3NOYW1lKHZhbClcbiAgICAgIGNvbnN0IGljb25DbGFzc05hbWVzID0gZ2FtZVN0b3JlLnVpLnNxdWFyZUluZm9Qb3NzaWJpbGl0eUljb25DbGFzc05hbWVzKHZhbClcbiAgICAgIGNvbnN0IHsgbm9Ib3ZlciwgaG92ZXIgfSA9IGdldFBvc3NpYmlsaXR5SWNvbnMocG9zc2liaWxpdHlFbGUpXG4gICAgICBub0hvdmVyLmNsYXNzTmFtZSA9IGljb25DbGFzc05hbWVzLm5vSG92ZXJcbiAgICAgIGhvdmVyLmNsYXNzTmFtZSA9IGljb25DbGFzc05hbWVzLmhvdmVyXG4gICAgfVxuICB9KVxuXG4gIGNvbnN0IHJlYWN0aW9ucyA9IFtcbiAgICBmdW5jdGlvbiByZW5kZXJJY29uQ2xhc3NOYW1lcygpIHtcbiAgICAgIHNlbGVjdEljb24uY2xhc3NOYW1lID0gZ2FtZVN0b3JlLnVpLnNxdWFyZUluZm9TZWxlY3RJY29uQ2xhc3NOYW1lXG4gICAgICBjbGVhckljb24uY2xhc3NOYW1lID0gZ2FtZVN0b3JlLnVpLnNxdWFyZUluZm9DbGVhckljb25DbGFzc05hbWVcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHJlbmRlckJ1dHRvbnNDbGFzc05hbWUoKSB7XG4gICAgICBzZWxlY3QuY2xhc3NOYW1lID0gZ2FtZVN0b3JlLnVpLnNxdWFyZUluZm9TZWxlY3RDbGFzc05hbWVcbiAgICAgIGNsZWFyLmNsYXNzTmFtZSA9IGdhbWVTdG9yZS51aS5zcXVhcmVJbmZvQ2xlYXJDbGFzc05hbWVcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHJlbmRlckRpc2FibGVkU2VsZWN0KCkge1xuICAgICAgaWYgKGdhbWVTdG9yZS51aS5zcXVhcmVJbmZvU2VsZWN0SXNEaXNhYmxlZCkge1xuICAgICAgICBzZWxlY3QuZGlzYWJsZWQgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3QuZGlzYWJsZWQgPSBmYWxzZVxuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVuZGVyRGlzYWJsZWRDbGVhcigpIHtcbiAgICAgIGlmIChnYW1lU3RvcmUudWkuc3F1YXJlSW5mb0NsZWFySXNEaXNhYmxlZCkge1xuICAgICAgICBjbGVhci5kaXNhYmxlZCA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFyLmRpc2FibGVkID0gZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uIHJlbmRlckxhYmVsVGV4dCgpIHtcbiAgICAgIGlmIChnYW1lU3RvcmUudWkuaGFzU2VsZWN0aW9uKSB7XG4gICAgICAgIHNxdWFyZUxhYmVsVGV4dC5pbm5lckhUTUwgPSAnU2VsZWN0aW9uJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3F1YXJlTGFiZWxUZXh0LmlubmVySFRNTCA9ICdTcXVhcmUnXG4gICAgICB9XG4gICAgfSxcbiAgICAuLi5wb3NzaWJpbGl0eVJlYWN0aW9uc1xuICBdXG5cbiAgY29uc3QgZGlzcG9zZXJzID0gcmVhY3Rpb25zLm1hcChmbiA9PiBhdXRvcnVuKGZuKSlcbiAgcmV0dXJuIGRpc3Bvc2Vyc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3F1YXJlSW5mb0VsZW1lbnRzKCkge1xuICByZXR1cm4ge1xuICAgIHNxdWFyZUxhYmVsVGV4dDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NxdWFyZS1sYWJlbCB0ZXh0JyksXG4gICAgcG9zc2liaWxpdHlFbGVzOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc3F1YXJlLWluZm9fcG9zc2liaWxpdHknKSxcbiAgICBzZWxlY3Q6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzcXVhcmUtaW5mb19zZWxlY3Qtb25seScpLFxuICAgIHNlbGVjdEljb246IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzcXVhcmUtaW5mb19zZWxlY3Qtb25seSBpJyksXG4gICAgY2xlYXI6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzcXVhcmUtaW5mb19jbGVhcicpLFxuICAgIGNsZWFySWNvbjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NxdWFyZS1pbmZvX2NsZWFyIGknKSxcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb3NzaWJpbGl0eUljb25zKHBvc3NpYmlsaXR5RWxlKSB7XG4gIHJldHVybiB7XG4gICAgbm9Ib3ZlcjogcG9zc2liaWxpdHlFbGUucXVlcnlTZWxlY3RvcignLm5vLWhvdmVyIGknKSxcbiAgICBob3ZlcjogcG9zc2liaWxpdHlFbGUucXVlcnlTZWxlY3RvcignLmhvdmVyIGknKSxcbiAgfVxufSIsImltcG9ydCB7IGF1dG9ydW4gfSBmcm9tICdtb2J4J1xuaW1wb3J0IHsgZGV2TG9nIH0gZnJvbSAnLi4vZGV2J1xuaW1wb3J0IHdhbGt0aHJvdWdoIGZyb20gJy4uL3NldHVwL3dhbGt0aHJvdWdoJ1xuaW1wb3J0IHsgVVBfT1JfRE9XTl9SRUdFWCwgTlVNX1JFR0VYLCBBUlJPV19SRUdFWCB9IGZyb20gXCIuLi9zaGFyZWQvY29uc3RhbnRzXCJcbmltcG9ydCB7IGdldERpckZyb21Db2RlLCBnZXROdW1Gcm9tQ29kZSwgc3RyaW5nU3dpdGNoIH0gZnJvbSAnLi4vc2hhcmVkL2dlbmVyYWxfdXRpbCdcblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwT3B0aW9ucyhnYW1lKSB7XG4gIHNldHVwTGlzdGVuZXJzKGdhbWUpXG4gIG1ha2VPcHRpb25zUmVhY3RpdmUoZ2FtZSlcbn1cblxuZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMoe1xuICBnYW1lU3RvcmU6IHtcbiAgICBvcHRpb25zXG4gIH0sXG4gIGVsZW1lbnRzOiB7XG4gICAgb3B0aW9uc0VsZXM6IHtcbiAgICAgIGF1dG9CbG9jayxcbiAgICAgIGF1dG9FbGltLFxuICAgICAgYXV0b0VsaW1NYXRoSW1wb3NzaWJpbGl0aWVzLFxuICAgICAgd2Fsa3Rocm91Z2gsXG4gICAgICBtYXhQb3NzaWJpbGl0aWVzSW5wdXQsXG4gICAgfVxuICB9XG59KSB7XG4gIGF1dG9CbG9jay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9wdGlvbnMudG9nZ2xlQXV0b0Jsb2NrKVxuICBhdXRvRWxpbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9wdGlvbnMudG9nZ2xlQXV0b0VsaW1pbmF0ZSlcbiAgd2Fsa3Rocm91Z2guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvcHRpb25zLnRvZ2dsZVdhbGt0aHJvdWdoKVxuICBhdXRvRWxpbU1hdGhJbXBvc3NpYmlsaXRpZXMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAnY2xpY2snLFxuICAgIG9wdGlvbnMudG9nZ2xlQXV0b0VsaW1NYXRoSW1wb3NzaWJpbGl0aWVzXG4gIClcblxuICBtYXhQb3NzaWJpbGl0aWVzSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGUgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgY29uc3QgbnVtID0gc3RyaW5nU3dpdGNoKGUuY29kZSwgKHsgX2Nhc2UgfSkgPT4ge1xuICAgICAgX2Nhc2UoTlVNX1JFR0VYLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBnZXROdW1Gcm9tQ29kZShlLmNvZGUpXG4gICAgICB9KVxuICAgICAgX2Nhc2UoQVJST1dfUkVHRVgsICgpID0+IHtcbiAgICAgICAgY29uc3QgZGlyID0gZ2V0RGlyRnJvbUNvZGUoZS5jb2RlKVxuICAgICAgICBsZXQgbnVtID0gb3B0aW9ucy5tYXhEaXNwbGF5ZWRQb3NzaWJpbGl0aWVzXG4gICAgICAgIHJldHVybiBkaXIgPT09ICdVcCcgfHwgZGlyID09PSAnUmlnaHQnID8gbnVtICsgMSA6IG51bSAtIDFcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmIChudW0pIHtcbiAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBvcHRpb25zLnNldE1heERpc3BsYXllZFBvc3NpYmlsaXRpZXMobnVtKVxuICAgICAgaWYgKCFzdWNjZXNzKSBkZXZMb2coJ0JhZCBJbnB1dCEnKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gbWFrZU9wdGlvbnNSZWFjdGl2ZSh7XG4gIGdhbWVTdG9yZToge1xuICAgIG9wdGlvbnNcbiAgfSxcbiAgZWxlbWVudHM6IHtcbiAgICBvcHRpb25zRWxlczoge1xuICAgICAgYXV0b0Jsb2NrLFxuICAgICAgYXV0b0VsaW0sXG4gICAgICBhdXRvRWxpbU1hdGhJbXBvc3NpYmlsaXRpZXMsXG4gICAgICBtYXhQb3NzaWJpbGl0aWVzSW5wdXQsXG4gICAgICB3YWxrdGhyb3VnaCxcbiAgICB9XG4gIH1cbn0pIHtcbiAgY29uc3QgcmVhY3Rpb25zID0gW1xuICAgIGZ1bmN0aW9uIHJlbmRlckF1dG9CbG9jaygpIHtcbiAgICAgIGF1dG9CbG9jay5jbGFzc05hbWUgPSBvcHRpb25zLmF1dG9CbG9ja0NsYXNzTmFtZVxuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVuZGVyQXV0b0VsaW0oKSB7XG4gICAgICBhdXRvRWxpbS5jbGFzc05hbWUgPSBvcHRpb25zLmF1dG9FbGltQ2xhc3NOYW1lXG4gICAgfSxcbiAgICBmdW5jdGlvbiByZW5kZXJBdXRvRWxpbU1hdGhJbXBvc3NpYmlsaXRpZXMoKSB7XG4gICAgICBhdXRvRWxpbU1hdGhJbXBvc3NpYmlsaXRpZXMuY2xhc3NOYW1lID1cbiAgICAgICAgb3B0aW9ucy5hdXRvRWxpbU1hdGhJbXBvc3NpYmlsaXRpZXNDbGFzc05hbWVcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHJlbmRlcldhbGt0aHJvdWdoKCkge1xuICAgICAgd2Fsa3Rocm91Z2guY2xhc3NOYW1lID0gb3B0aW9ucy53YWxrdGhyb3VnaENsYXNzTmFtZVxuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVuZGVyTWF4UG9zc2liaWxpdGllc0lucHV0KCkge1xuICAgICAgbWF4UG9zc2liaWxpdGllc0lucHV0LnZhbHVlID0gb3B0aW9ucy5tYXhEaXNwbGF5ZWRQb3NzaWJpbGl0aWVzXG4gICAgfSxcbiAgXVxuXG4gIGNvbnN0IGRpc3Bvc2VycyA9IHJlYWN0aW9ucy5tYXAoZm4gPT4gYXV0b3J1bihmbikpXG4gIHJldHVybiBkaXNwb3NlcnNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wdGlvbnNFbGVtZW50cygpIHtcbiAgcmV0dXJuIHtcbiAgICBhdXRvQmxvY2s6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNvcHRpb24tYXV0by1ibG9jaycpLFxuICAgIGF1dG9FbGltOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3B0aW9uLWF1dG8tZWxpbScpLFxuICAgIHdhbGt0aHJvdWdoOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3B0aW9uLXdhbGt0aHJvdWdoJyksXG4gICAgYXV0b0VsaW1NYXRoSW1wb3NzaWJpbGl0aWVzOiBkb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoJyNvcHRpb24tYXV0by1lbGltLW1hdGgtaW1wb3NzaWJpbGl0aWVzJyksXG4gICAgbWF4UG9zc2liaWxpdGllc0lucHV0OiBkb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoJyNvcHRpb24tbWF4LXBvc3NpYmlsaXRpZXMgLm9wdGlvbl9udW0taW5wdXQnKSxcbiAgICBtYXhQb3NzaWJpbGl0aWVzRXJyb3I6IGRvY3VtZW50XG4gICAgICAucXVlcnlTZWxlY3RvcignI29wdGlvbi1tYXgtcG9zc2liaWxpdGllcyAub3B0aW9uX2Vycm9yJyksXG4gIH1cbn1cbiIsImltcG9ydCB7IGF1dG9ydW4gfSBmcm9tICdtb2J4J1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBTcXVhcmVzKHtcbiAgZ2FtZVN0b3JlLFxuICBlbnY6IHtcbiAgICB0ZW1wbGF0ZXMsXG4gIH0sXG4gIGVsZW1lbnRzOiB7XG4gICAgcHV6emxlRWxlXG4gIH1cbn0pIHtcbiAgY29uc3Qgc3F1YXJlRWxlcyA9IG5ldyBEb2N1bWVudEZyYWdtZW50KClcblxuICBjb25zdCBkaXNwb3NlcnMgPSBnYW1lU3RvcmUucHV6emxlLnNxdWFyZXNBcnJheS5tYXAoc3F1YXJlID0+IHtcbiAgICBjb25zdCBzcXVhcmVFbGUgPSB0ZW1wbGF0ZXMuc3F1YXJlLmNsb25lTm9kZSh0cnVlKVxuICAgIGNvbnN0IHNxdWFyZUVsZW1lbnRzID0gZ2V0U3F1YXJlRWxlbWVudHNGcm9tU3F1YXJlKHNxdWFyZUVsZSlcblxuICAgIHNldHVwU3F1YXJlKHNxdWFyZSwgc3F1YXJlRWxlbWVudHMpXG4gICAgc3F1YXJlRWxlcy5hcHBlbmRDaGlsZChzcXVhcmVFbGUpXG5cbiAgICByZXR1cm4gbWFrZVNxdWFyZVJlYWN0aXZlKHNxdWFyZSwgc3F1YXJlRWxlbWVudHMpXG4gIH0pXG5cbiAgcHV6emxlRWxlLnJlcGxhY2VDaGlsZHJlbihzcXVhcmVFbGVzKVxuICByZXR1cm4gKCkgPT4gZGlzcG9zZXJzLmZvckVhY2goZGlzcG9zZXIgPT4gZGlzcG9zZXIoKSlcbn1cblxuZnVuY3Rpb24gc2V0dXBTcXVhcmUoc3F1YXJlLCB7XG4gIHNxdWFyZUVsZSxcbiAgbGFiZWwsXG4gIGNhZ2VUb3AsXG4gIGNhZ2VMZWZ0LFxufSkge1xuICBzcXVhcmVFbGUuZGF0YXNldC5wb3MgPSBzcXVhcmUuZGF0YVBvc1xuICBzcXVhcmVFbGUuZGF0YXNldC5pZCA9IHNxdWFyZS5pZFxuICBsYWJlbC5pbm5lclRleHQgPSBzcXVhcmUubGFiZWxcblxuICBpZiAoIXNxdWFyZS5pc0NhZ2VUb3ApIHtcbiAgICBjYWdlVG9wLnJlbW92ZSgpXG4gIH1cbiAgaWYgKCFzcXVhcmUuaXNDYWdlTGVmdCkge1xuICAgIGNhZ2VMZWZ0LnJlbW92ZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZVNxdWFyZVJlYWN0aXZlKHNxdWFyZSwge1xuICBzcXVhcmVFbGUsXG4gIHZhbHVlLFxuICBwb3NzaWJpbGl0eUVsZXNcbn0pIHtcbiAgY29uc3QgcG9zc2liaWxpdHlSZWFjdGlvbnMgPSBBcnJheS5mcm9tKHBvc3NpYmlsaXR5RWxlcykubWFwKHBvc3NpYmlsaXR5RWxlID0+XG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VJbnQocG9zc2liaWxpdHlFbGUuZGF0YXNldC52YWwpXG4gICAgICBwb3NzaWJpbGl0eUVsZS5jbGFzc05hbWUgPSBzcXVhcmUucG9zc2liaWxpdHlDbGFzc05hbWUodmFsKVxuICAgIH1cbiAgKVxuXG4gIGNvbnN0IHJlYWN0aW9ucyA9IFtcbiAgICBmdW5jdGlvbiByZW5kZXJWYWxOb2RlKCkge1xuICAgICAgdmFsdWUuaW5uZXJUZXh0ID0gc3F1YXJlLmRpc3BsYXllZFZhbHVlXG4gICAgfSxcbiAgICBmdW5jdGlvbiByZW5kZXJDbGFzc05hbWUoKSB7XG4gICAgICBzcXVhcmVFbGUuY2xhc3NOYW1lID0gc3F1YXJlLmNsYXNzTmFtZVxuICAgIH0sXG4gICAgLi4ucG9zc2liaWxpdHlSZWFjdGlvbnNcbiAgXVxuXG4gIGNvbnN0IGRpc3Bvc2VycyA9IHJlYWN0aW9ucy5tYXAoZm4gPT4gYXV0b3J1bihmbikpXG4gIHJldHVybiAoKSA9PiBkaXNwb3NlcnMuZm9yRWFjaChkaXNwb3NlciA9PiBkaXNwb3NlcigpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3F1YXJlRWxlbWVudChpZCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzcXVhcmVTZWxlY3RvcihpZCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTcXVhcmVFbGVtZW50c0Zyb21JZChpZCkge1xuICBjb25zdCB7IGdldENoaWxkLCBnZXRDaGlsZHJlbiB9ID0gY3JlYXRlU3F1YXJlQ2hpbGRTZWxlY3RvcnMoaWQpXG5cbiAgcmV0dXJuIHtcbiAgICBzcXVhcmVFbGU6IGdldFNxdWFyZUVsZW1lbnQoaWQsIHBhcmVudCksXG4gICAgY2FnZVRvcDogZ2V0Q2hpbGQoJy5zcXVhcmVfY2FnZS10b3AnKSxcbiAgICBjYWdlTGVmdDogZ2V0Q2hpbGQoJy5zcXVhcmVfY2FnZS1sZWZ0JyksXG4gICAgbGFiZWw6IGdldENoaWxkKCcuc3F1YXJlX2xhYmVsJyksXG4gICAgdmFsdWU6IGdldENoaWxkKCcuc3F1YXJlX3ZhbHVlJyksXG4gICAgcG9zc2liaWxpdHlFbGVzOiBnZXRDaGlsZHJlbignLnNxdWFyZV9wb3NzaWJpbGl0eScpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3F1YXJlQ2hpbGRTZWxlY3RvcnMoaWQpIHtcbiAgY29uc3QgZ2V0U2VsZWN0b3IgPSBzdWJTZWxlY3RvciA9PiBbc3F1YXJlU2VsZWN0b3IoaWQpLCBzdWJTZWxlY3Rvcl0uam9pbignICcpXG5cbiAgcmV0dXJuIHtcbiAgICBnZXRDaGlsZDogc3ViU2VsZWN0b3IgPT4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihnZXRTZWxlY3RvcihzdWJTZWxlY3RvcikpLFxuICAgIGdldENoaWxkcmVuOiBzdWJTZWxlY3RvciA9PiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGdldFNlbGVjdG9yKHN1YlNlbGVjdG9yKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBzcXVhcmVTZWxlY3RvcihpZCkge1xuICByZXR1cm4gYC5zcXVhcmVbZGF0YS1pZD1cIiR7aWR9XCJdYFxufVxuXG5cbmZ1bmN0aW9uIGdldFNxdWFyZUVsZW1lbnRzRnJvbVNxdWFyZShzcXVhcmVFbGUpIHtcbiAgcmV0dXJuIHtcbiAgICBzcXVhcmVFbGUsXG4gICAgY2FnZVRvcDogc3F1YXJlRWxlLnF1ZXJ5U2VsZWN0b3IoJy5zcXVhcmVfY2FnZS10b3AnKSxcbiAgICBjYWdlTGVmdDogc3F1YXJlRWxlLnF1ZXJ5U2VsZWN0b3IoJy5zcXVhcmVfY2FnZS1sZWZ0JyksXG4gICAgbGFiZWw6IHNxdWFyZUVsZS5xdWVyeVNlbGVjdG9yKCcuc3F1YXJlX2xhYmVsJyksXG4gICAgdmFsdWU6IHNxdWFyZUVsZS5xdWVyeVNlbGVjdG9yKCcuc3F1YXJlX3ZhbHVlJyksXG4gICAgcG9zc2liaWxpdHlFbGVzOiBzcXVhcmVFbGUucXVlcnlTZWxlY3RvckFsbCgnLnNxdWFyZV9wb3NzaWJpbGl0eScpXG4gIH1cbn0iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9